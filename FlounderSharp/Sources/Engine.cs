// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>A engine used for simplifying the creation of complicated applications. By using flexible Module loading and Extension injecting, it allows the engine to be used for Networking, Imaging, AIs, Games, and many more applications. Start off by creating a new Engine object in your main thread, using Extensions in the constructor. By using Extensions: Modules can be required and therefor loaded into the engine. Implementing interfaces like  with your extension can allow you do task specific things with your Extensions. After creating your Engine object call  to start.</summary>
    public unsafe partial class Engine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Chrono.TimePoint.__Internalc__N_std_N_chrono_S_time_point____N_std_N_chrono_S_steady_clock___N_std_N_chrono_S_duration__K___N_std_S_ratio__VK1_VK1000000000 m_start;

            [FieldOffset(8)]
            internal float m_timeOffset;

            [FieldOffset(16)]
            internal global::System.IntPtr m_moduleRegister;

            [FieldOffset(24)]
            internal global::System.IntPtr m_updater;

            [FieldOffset(32)]
            internal float m_fpsLimit;

            [FieldOffset(36)]
            internal byte m_initialized;

            [FieldOffset(37)]
            internal byte m_running;

            [FieldOffset(38)]
            internal byte m_error;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Engine@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Engine@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Run@Engine@fl@@QEBAHXZ")]
            internal static extern int Run(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUpdater@Engine@fl@@QEAAXPEAVIUpdater@2@@Z")]
            internal static extern void SetUpdater(global::System.IntPtr instance, global::System.IntPtr updater);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@Engine@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeregisterModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModule@Engine@fl@@QEBAPEAVIModule@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInitialized@Engine@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetInitialized(global::System.IntPtr instance, bool* initialized);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RequestClose@Engine@fl@@QEAAXAEB_N@Z")]
            internal static extern void RequestClose(global::System.IntPtr instance, bool* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeOffset@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTimeOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeOffset@Engine@fl@@QEAAXAEBM@Z")]
            internal static extern void SetTimeOffset(global::System.IntPtr instance, float* timeOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFpsLimit@Engine@fl@@QEBAMXZ")]
            internal static extern float GetFpsLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFpsLimit@Engine@fl@@QEAAXAEBM@Z")]
            internal static extern void SetFpsLimit(global::System.IntPtr instance, float* fpsLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@Engine@fl@@QEAAMXZ")]
            internal static extern float GetDelta(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@Engine@fl@@QEAAMXZ")]
            internal static extern float GetDeltaRender(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeMs@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTimeMs(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInitialized@Engine@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInitialized(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@Engine@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRunning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDateTime@Engine@fl@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetDateTime(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Engine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Engine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Engine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Engine(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Engine __CreateInstance(global::FlounderSharp.Engine.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Engine(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Engine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            *(global::FlounderSharp.Engine.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Engine(global::FlounderSharp.Engine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Engine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Carries out the setup for basic engine components and the engine. Call  after creating a instance.</summary>
        public Engine()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        ~Engine()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Engine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the updater.</summary>
        public int Run()
        {
            var __ret = __Internal.Run((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Loads the updater into the engine.</summary>
        /// <param name="updater">The updater.</param>
        public void SetUpdater(global::FlounderSharp.IUpdater updater)
        {
            var __arg0 = ReferenceEquals(updater, null) ? global::System.IntPtr.Zero : updater.__Instance;
            __Internal.SetUpdater((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="name">The modules name.</param>
        public void DeregisterModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Gets a module instance by name.</summary>
        /// <param name="name">The module name to find.</param>
        public global::FlounderSharp.IModule GetModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.NativeToManagedMap[__ret];
            else global::FlounderSharp.IModule.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets if the engine has been initialized.</summary>
        /// <param name="initialized">If the engine has been initialized.</param>
        public void SetInitialized(ref bool initialized)
        {
            fixed (bool* __refParamPtr0 = &initialized)
            {
                var __arg0 = __refParamPtr0;
                __Internal.SetInitialized((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Requests the engine to delete and stop the gameloop.</summary>
        /// <param name="error">If a bad error occured.</param>
        public void RequestClose(ref bool error)
        {
            fixed (bool* __refParamPtr0 = &error)
            {
                var __arg0 = __refParamPtr0;
                __Internal.RequestClose((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Engine Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Engine __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Engine.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Engine) global::FlounderSharp.Engine.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Engine.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the added/removed time for the engine (seconds).</summary>
        /// <param name="timeOffset">The new time offset.</param>
        /// <remarks>Sets the time offset for the engine (seconds).</remarks>
        public float TimeOffset
        {
            get
            {
                var __ret = __Internal.GetTimeOffset((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetTimeOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the fps limit.</summary>
        /// <param name="fpsLimit">The new fps limit.</param>
        /// <remarks>Sets the fps limit. -1 disables limits.</remarks>
        public float FpsLimit
        {
            get
            {
                var __ret = __Internal.GetFpsLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFpsLimit((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public float Delta
        {
            get
            {
                var __ret = __Internal.GetDelta((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public float DeltaRender
        {
            get
            {
                var __ret = __Internal.GetDeltaRender((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float TimeMs
        {
            get
            {
                var __ret = __Internal.GetTimeMs((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine has been initialized.</summary>
        public bool IsInitialized
        {
            get
            {
                var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine is running.</summary>
        public bool IsRunning
        {
            get
            {
                var __ret = __Internal.IsRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current date time as a string. &quot;%d-%m-%Y %I:%M:%S&quot;</summary>
        public string DateTime
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetDateTime((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            internal global::System.IntPtr first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I____N_fl_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_fl_S_ConfigKey
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::FlounderSharp.ConfigKey.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
