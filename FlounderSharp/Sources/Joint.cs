// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>Represents a joint in a &quot;skeleton&quot;. It contains the index of the joint which determines where in the vertex shader uniform array the joint matrix for this joint is loaded up to. It also contains the name of the bone, and a list of all the child joints.  The &quot;animatedTransform&quot; matrix is the joint transform. This is the transform that gets loaded up to the vertex shader and is used to transform vertices. It is a model-space transform that transforms the joint from it's bind (original position, no animation applied) position to it's current position in the current pose. Changing this transform changes the position/rotation of the joint in the animated entity.  The two other matrices are transforms that are required to calculate the &quot;animatedTransform&quot; in the  class. It also has the local bind transform which is the original (no pose/animation applied) transform of the joint relative to the parent joint (in bone-space).  The &quot;localBindTransform&quot; is the original (bind) transform of the joint relative to its parent (in bone-space). The inverseBindTransform is that bind transform in model-space, but inversed.</summary>
    public unsafe partial class Joint : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_index;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_children;

            [FieldOffset(48)]
            internal global::System.IntPtr m_localBindTransform;

            [FieldOffset(56)]
            internal global::System.IntPtr m_animatedTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_inverseBindTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@fl@@QEAA@AEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int* index, global::System.IntPtr name, global::System.IntPtr bindLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joint@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateInverseBindTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void CalculateInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr parentBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@Joint@fl@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@Joint@fl@@QEBAHXZ")]
            internal static extern int GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIndex@Joint@fl@@QEAAXAEBH@Z")]
            internal static extern void SetIndex(global::System.IntPtr instance, int* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Joint@fl@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern global::System.IntPtr GetName(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Joint@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalBindTransform@Joint@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetLocalBindTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLocalBindTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetLocalBindTransform(global::System.IntPtr instance, global::System.IntPtr localBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAnimatedTransform@Joint@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetAnimatedTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAnimatedTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetAnimatedTransform(global::System.IntPtr instance, global::System.IntPtr animatedTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInverseBindTransform@Joint@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetInverseBindTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInverseBindTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr inverseBindTransform);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Joint> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Joint>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Joint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joint(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Joint __CreateInstance(global::FlounderSharp.Joint.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joint(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Joint.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joint.__Internal));
            global::FlounderSharp.Joint.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joint(global::FlounderSharp.Joint.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new joint.</summary>
        /// <param name="index">The joint's index (ID).</param>
        /// <param name="name">The name of the joint. This is how the joint is named in the collada file, and so is used to identify which joint a joint transform in an animation keyframe refers to.</param>
        /// <param name="bindLocalTransform">The bone-space transform of the joint in the bind position.</param>
        public Joint(ref int index, string name, global::FlounderSharp.Matrix4 bindLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            fixed (int* __refParamPtr0 = &index)
            {
                var __arg0 = __refParamPtr0;
                var __allocator1 = new global::Std.Allocator<char>();
                var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
                var __arg1 = __basicString1.__Instance;
                if (ReferenceEquals(bindLocalTransform, null))
                    throw new global::System.ArgumentNullException("bindLocalTransform", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = bindLocalTransform.__Instance;
                __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                __basicString1.Dispose(false);
                __allocator1.Dispose();
            }
        }

        public Joint(global::FlounderSharp.Joint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        ~Joint()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Joint __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>This is called during set-up, after the joints hierarchy has been created. This calculates the model-space bind transform of this joint like so:</para>
        /// <para></para>
        /// <para></para>
        /// <para>{</para>
        /// </summary>
        public void CalculateInverseBindTransform(global::FlounderSharp.Matrix4 parentBindTransform)
        {
            if (ReferenceEquals(parentBindTransform, null))
                throw new global::System.ArgumentNullException("parentBindTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = parentBindTransform.__Instance;
            __Internal.CalculateInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Adds a child joint to this joint. Used during the creation of the joint hierarchy. Joints can have multiple children, which is why they are stored in a list (e.g. a &quot;hand&quot; joint may have multiple &quot;finger&quot; children joints).</summary>
        /// <param name="child">The new child joint of this joint.</param>
        public void AddChild(global::FlounderSharp.Joint child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public int Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetIndex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public string Name
        {
            get
            {
                var __ret = __Internal.GetName((__Instance + __PointerAdjustment));
                var __basicStringRet = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.CStr(__basicStringRet);
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.Matrix4 LocalBindTransform
        {
            get
            {
                var __ret = __Internal.GetLocalBindTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLocalBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>The animated transform is the transform that gets loaded up to the shader and is used to deform the vertices of the &quot;skin&quot;. It represents the transformation from the joint's bind position (in model-space) to the joint's desired animation pose (also in model-space). This matrix is calculated by taking the desired model-space transform of the joint and multiplying it by the inverse of the starting model-space transform of the joint.</summary>
        public global::FlounderSharp.Matrix4 AnimatedTransform
        {
            get
            {
                var __ret = __Internal.GetAnimatedTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAnimatedTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>This returns the inverted model-space bind transform. The bind transform is the original model-space transform of the joint (when no animation is applied). This returns the inverse of that, which is used to calculate the animated transform matrix which gets used to transform vertices in the shader.</summary>
        public global::FlounderSharp.Matrix4 InverseBindTransform
        {
            get
            {
                var __ret = __Internal.GetInverseBindTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            internal global::System.IntPtr first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I____N_fl_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_fl_S_ConfigKey
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::FlounderSharp.ConfigKey.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
