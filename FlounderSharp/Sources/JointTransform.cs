// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>Represents the local bone-space transform of a joint at a certain keyframe during an animation. This includes the position and rotation of the joint, relative to the parent joint (or relative to the model's origin if it's the root joint). The transform is stored as a position vector and a quaternion (rotation) so that these values can  be easily interpolated, a functionality that this class also provides.</summary>
    public unsafe partial class JointTransform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_position;

            [FieldOffset(8)]
            internal global::System.IntPtr m_rotation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@fl@@QEAA@AEBVVector3@1@AEBVQuaternion@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@fl@@QEAA@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@fl@@QEAA@AEBVJointTransformData@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointTransform@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@fl@@SAPEAV12@AEBV12@0AEBM@Z")]
            internal static extern global::System.IntPtr Interpolate(global::System.IntPtr frameA, global::System.IntPtr frameB, float* progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@fl@@SA?AVVector3@2@AEBV32@0AEBM@Z")]
            internal static extern void Interpolate(global::System.IntPtr @return, global::System.IntPtr start, global::System.IntPtr end, float* progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@JointTransform@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@JointTransform@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@JointTransform@fl@@QEBAPEAVQuaternion@2@XZ")]
            internal static extern global::System.IntPtr GetRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRotation@JointTransform@fl@@QEAAXAEBVQuaternion@2@@Z")]
            internal static extern void SetRotation(global::System.IntPtr instance, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalTransform@JointTransform@fl@@QEAAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetLocalTransform(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointTransform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointTransform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.JointTransform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointTransform(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.JointTransform __CreateInstance(global::FlounderSharp.JointTransform.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointTransform(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.JointTransform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            *(global::FlounderSharp.JointTransform.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JointTransform(global::FlounderSharp.JointTransform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointTransform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="position">The position of the joint relative to the parent joint (local-space) at a certain keyframe.</param>
        /// <param name="rotation">The rotation of the joint relative to te parent joint (local-space) at a certain keyframe.</param>
        public JointTransform(global::FlounderSharp.Vector3 position, global::FlounderSharp.Quaternion rotation)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="localTransform">The joint's local-transform at a certain keyframe of an animation.</param>
        public JointTransform(global::FlounderSharp.Matrix4 localTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public JointTransform(global::FlounderSharp.JointTransformData data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        ~JointTransform()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.JointTransform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::FlounderSharp.JointTransform(global::FlounderSharp.Matrix4 localTransform)
        {
            return new global::FlounderSharp.JointTransform(localTransform);
        }

        public static implicit operator global::FlounderSharp.JointTransform(global::FlounderSharp.JointTransformData data)
        {
            return new global::FlounderSharp.JointTransform(data);
        }

        /// <summary>Interpolates between two transforms based on the progression value. The result is a new transform which is part way between the two original transforms. The translation can simply be linearly interpolated, but the rotation interpolation is slightly more complex, using a method called &quot;SLERP&quot; to spherically-linearly interpolate between 2 quaternions (rotations). This gives a much much better result than trying to linearly interpolate between Euler rotations.</summary>
        /// <param name="frameA">The previous transform</param>
        /// <param name="frameB">The next transform</param>
        /// <param name="progression">A number between 0 and 1 indicating how far between the two transforms to interpolate. A progression value of 0 would return a transform equal to &quot;frameA&quot;, a value of 1 would return a transform equal to &quot;frameB&quot;. Everything else gives a transform somewhere in-between the two.</param>
        public static global::FlounderSharp.JointTransform Interpolate(global::FlounderSharp.JointTransform frameA, global::FlounderSharp.JointTransform frameB, ref float progression)
        {
            if (ReferenceEquals(frameA, null))
                throw new global::System.ArgumentNullException("frameA", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frameA.__Instance;
            if (ReferenceEquals(frameB, null))
                throw new global::System.ArgumentNullException("frameB", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = frameB.__Instance;
            fixed (float* __refParamPtr2 = &progression)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.Interpolate(__arg0, __arg1, __arg2);
                global::FlounderSharp.JointTransform __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.JointTransform.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.JointTransform) global::FlounderSharp.JointTransform.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.JointTransform.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Linearly interpolates between two translations based on a &quot;progression&quot; value.</summary>
        /// <param name="start">The start translation.</param>
        /// <param name="end">The end translation.</param>
        /// <param name="progression">A value between 0 and 1 indicating how far to interpolate between the two translations.</param>
        public static global::FlounderSharp.Vector3 Interpolate(global::FlounderSharp.Vector3 start, global::FlounderSharp.Vector3 end, ref float progression)
        {
            if (ReferenceEquals(start, null))
                throw new global::System.ArgumentNullException("start", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = start.__Instance;
            if (ReferenceEquals(end, null))
                throw new global::System.ArgumentNullException("end", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = end.__Instance;
            fixed (float* __refParamPtr2 = &progression)
            {
                var __arg2 = __refParamPtr2;
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.Interpolate(new IntPtr(&__ret), __arg0, __arg1, __arg2);
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Quaternion Rotation
        {
            get
            {
                var __ret = __Internal.GetRotation((__Instance + __PointerAdjustment));
                global::FlounderSharp.Quaternion __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Quaternion.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Quaternion) global::FlounderSharp.Quaternion.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Quaternion.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>In this method the local-space transform matrix is constructed by translating an identity matrix using the position variable and then applying the rotation. The rotation is applied by first converting the quaternion into a rotation matrix, which is then multiplied with the transform matrix.</summary>
        public global::FlounderSharp.Matrix4 LocalTransform
        {
            get
            {
                var __ret = __Internal.GetLocalTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            internal global::System.IntPtr first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I____N_fl_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_fl_S_ConfigKey
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::FlounderSharp.ConfigKey.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
