// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>This class contains all the functionality to apply an animation to an animated entity. An Animator instance is associated with just one animated entity. It also keeps track of the running time (in seconds) of the current animation, along with a reference to the currently playing animation for the corresponding entity.  An Animator instance needs to be updated every frame, in order for it to keep updating the animation pose of the associated entity. The currently playing animation can be changed at any time using the doAnimation() method. The Animator will keep looping the current animation until a new animation is chosen.  The Animator calculates the desired current animation pose by interpolating between the previous and next keyframes of the animation (based on the current animation time). The Animator then updates the transforms all of the joints each frame to match the current desired animation pose.</summary>
    public unsafe partial class Animator : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_rootJoint;

            [FieldOffset(8)]
            internal float m_animationTime;

            [FieldOffset(16)]
            internal global::System.IntPtr m_currentAnimation;

            [FieldOffset(24)]
            internal global::System.IntPtr m_animatorTransformation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animator@fl@@QEAA@PEAVJoint@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr rootJoint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Animator@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Animator@fl@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IncreaseAnimationTime@Animator@fl@@QEAAXXZ")]
            internal static extern void IncreaseAnimationTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateProgression@Animator@fl@@QEAAMAEBVKeyframe@2@0@Z")]
            internal static extern float CalculateProgression(global::System.IntPtr instance, global::System.IntPtr previousFrame, global::System.IntPtr nextFrame);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DoAnimation@Animator@fl@@QEAAXPEAVAnimation@2@@Z")]
            internal static extern void DoAnimation(global::System.IntPtr instance, global::System.IntPtr animation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentAnimation@Animator@fl@@QEBAPEAVAnimation@2@XZ")]
            internal static extern global::System.IntPtr GetCurrentAnimation(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Animator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Animator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Animator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Animator(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Animator __CreateInstance(global::FlounderSharp.Animator.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Animator(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Animator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Animator.__Internal));
            *(global::FlounderSharp.Animator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Animator(global::FlounderSharp.Animator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Animator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new animator.</summary>
        /// <param name="rootJoint">The root joint of the joint hierarchy which makes up the &quot;skeleton&quot; of the entity.</param>
        public Animator(global::FlounderSharp.Joint rootJoint)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Animator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(rootJoint, null) ? global::System.IntPtr.Zero : rootJoint.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        ~Animator()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Animator __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>This method should be called each frame to update the animation currently being played. This increases the animation time (and loops it back to zero if necessary), finds the pose that the entity should be in at that time of the animation, and then applied that pose to all the entity's joints.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        /// <summary>Increases the current animation time which allows the animation to progress. If the current animation has reached the end then the timer is reset, causing the animation to loop.</summary>
        public void IncreaseAnimationTime()
        {
            __Internal.IncreaseAnimationTime((__Instance + __PointerAdjustment));
        }

        /// <summary>Calculates how far between the previous and next keyframe the current animation time is, and returns it as a value between 0 and 1.</summary>
        /// <param name="previousFrame">The previous keyframe in the animation.</param>
        /// <param name="nextFrame">The next keyframe in the animation.</param>
        public float CalculateProgression(global::FlounderSharp.Keyframe previousFrame, global::FlounderSharp.Keyframe nextFrame)
        {
            if (ReferenceEquals(previousFrame, null))
                throw new global::System.ArgumentNullException("previousFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = previousFrame.__Instance;
            if (ReferenceEquals(nextFrame, null))
                throw new global::System.ArgumentNullException("nextFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = nextFrame.__Instance;
            var __ret = __Internal.CalculateProgression((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Indicates that the entity should carry out the given animation. Resets the animation time so that the new animation starts from the beginning.</summary>
        /// <param name="animation">The new animation to carry out.</param>
        public void DoAnimation(global::FlounderSharp.Animation animation)
        {
            var __arg0 = ReferenceEquals(animation, null) ? global::System.IntPtr.Zero : animation.__Instance;
            __Internal.DoAnimation((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::FlounderSharp.Animator(global::FlounderSharp.Joint rootJoint)
        {
            return new global::FlounderSharp.Animator(rootJoint);
        }

        public global::FlounderSharp.Animation CurrentAnimation
        {
            get
            {
                var __ret = __Internal.GetCurrentAnimation((__Instance + __PointerAdjustment));
                global::FlounderSharp.Animation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Animation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Animation) global::FlounderSharp.Animation.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Animation.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            internal global::System.IntPtr first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I____N_fl_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_fl_S_ConfigKey
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::FlounderSharp.ConfigKey.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
