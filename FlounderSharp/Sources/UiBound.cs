// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>A rectangle made of a position and dimension.</summary>
    public unsafe partial class UiBound : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_position;

            [FieldOffset(8)]
            internal global::System.IntPtr m_reference;

            [FieldOffset(16)]
            internal byte m_aspectPosition;

            [FieldOffset(17)]
            internal byte m_aspectSize;

            [FieldOffset(24)]
            internal global::System.IntPtr m_dimensions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@fl@@QEAA@AEBVVector2@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N20@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr reference, bool* aspectPosition, bool* aspectSize, global::System.IntPtr dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiBound@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Set@UiBound@fl@@QEAAPEAV12@AEBV12@@Z")]
            internal static extern global::System.IntPtr Set(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectPosition@UiBound@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectPosition(global::System.IntPtr instance, bool* aspectPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectSize@UiBound@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectSize(global::System.IntPtr instance, bool* aspectSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindPivot@UiBound@fl@@SA?AVVector2@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void FindPivot(global::System.IntPtr @return, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@UiBound@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@UiBound@fl@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetReference@UiBound@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetReference(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetReference@UiBound@fl@@QEAAXPEAVVector2@2@@Z")]
            internal static extern void SetReference(global::System.IntPtr instance, global::System.IntPtr reference);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDimensions@UiBound@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetDimensions(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@UiBound@fl@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, global::System.IntPtr dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectPosition@UiBound@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAspectPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectSize@UiBound@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAspectSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiBound> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiBound>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.UiBound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiBound(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiBound __CreateInstance(global::FlounderSharp.UiBound.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiBound(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiBound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiBound.__Internal));
            global::FlounderSharp.UiBound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiBound(global::FlounderSharp.UiBound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiBound(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for rectangle.</summary>
        /// <param name="position">The object screen position.</param>
        /// <param name="reference">The reference pivot vertex (TopLeft, TopCentre, TopRight, CentreLeft, Centre, CentreRight, BottomLeft, BottomCentre, BottomRight).</param>
        /// <param name="aspectPosition">The if the x position will change with display width.</param>
        /// <param name="aspectSize">The if the width will scale with display width.</param>
        /// <param name="dimensions">The object dimensions.</param>
        public UiBound(global::FlounderSharp.Vector2 position, string reference, ref bool aspectPosition, ref bool aspectSize, global::FlounderSharp.Vector2 dimensions)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(reference, __allocator1);
            var __arg1 = __basicString1.__Instance;
            fixed (bool* __refParamPtr2 = &aspectPosition)
            {
                var __arg2 = __refParamPtr2;
                fixed (bool* __refParamPtr3 = &aspectSize)
                {
                    var __arg3 = __refParamPtr3;
                    if (ReferenceEquals(dimensions, null))
                        throw new global::System.ArgumentNullException("dimensions", "Cannot be null because it is a C++ reference (&).");
                    var __arg4 = dimensions.__Instance;
                    __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
                    __basicString1.Dispose(false);
                    __allocator1.Dispose();
                }
            }
        }

        /// <summary>Creates a new rectangle.</summary>
        /// <param name="source">Creates this rectangle out of a existing one.</param>
        public UiBound(global::FlounderSharp.UiBound source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        ~UiBound()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.UiBound __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Loads from another Rectangle.</summary>
        /// <param name="source">The source rectangle.</param>
        public global::FlounderSharp.UiBound Set(global::FlounderSharp.UiBound source)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __ret = __Internal.Set((__Instance + __PointerAdjustment), __arg0);
            global::FlounderSharp.UiBound __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UiBound.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.UiBound) global::FlounderSharp.UiBound.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.UiBound.__CreateInstance(__ret);
            return __result0;
        }

        public void SetAspectPosition(ref bool aspectPosition)
        {
            fixed (bool* __refParamPtr0 = &aspectPosition)
            {
                var __arg0 = __refParamPtr0;
                __Internal.SetAspectPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public void SetAspectSize(ref bool aspectSize)
        {
            fixed (bool* __refParamPtr0 = &aspectSize)
            {
                var __arg0 = __refParamPtr0;
                __Internal.SetAspectSize((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public static global::FlounderSharp.Vector2 FindPivot(string key)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.FindPivot(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public global::FlounderSharp.Vector2 MPosition
        {
            get
            {
                global::FlounderSharp.Vector2 __result0;
                if (((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_position = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.Vector2 MReference
        {
            get
            {
                global::FlounderSharp.Vector2 __result0;
                if (((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_reference = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public bool MAspectPosition
        {
            get
            {
                return ((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_aspectPosition != 0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_aspectPosition = (byte) (value ? 1 : 0);
            }
        }

        public bool MAspectSize
        {
            get
            {
                return ((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_aspectSize != 0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_aspectSize = (byte) (value ? 1 : 0);
            }
        }

        public global::FlounderSharp.Vector2 MDimensions
        {
            get
            {
                global::FlounderSharp.Vector2 __result0;
                if (((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_dimensions = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.Vector2 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector2 Reference
        {
            get
            {
                var __ret = __Internal.GetReference((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetReference((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector2 Dimensions
        {
            get
            {
                var __ret = __Internal.GetDimensions((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsAspectPosition
        {
            get
            {
                var __ret = __Internal.IsAspectPosition((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsAspectSize
        {
            get
            {
                var __ret = __Internal.IsAspectSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            internal global::System.IntPtr first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I____N_fl_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_fl_S_ConfigKey
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::FlounderSharp.ConfigKey.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
