// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>Represents the 3D area of the world in which engine.shadows will be cast (basically represents the orthographic projection area for the shadow render pass). It can be updated each frame to optimise the area, making it as small as possible (to allow for optimal shadow map resolution) while not being too small to avoid objects not having shadows when they should. This class also provides functionality to test whether an object is inside this shadow box. Everything inside the box will be rendered to the shadow map in the shadow render pass.</summary>
    public unsafe partial class ShadowBox : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_lightDirection;

            [FieldOffset(8)]
            internal float m_shadowOffset;

            [FieldOffset(12)]
            internal float m_shadowDistance;

            [FieldOffset(16)]
            internal global::System.IntPtr m_projectionMatrix;

            [FieldOffset(24)]
            internal global::System.IntPtr m_lightViewMatrix;

            [FieldOffset(32)]
            internal global::System.IntPtr m_projectionViewMatrix;

            [FieldOffset(40)]
            internal global::System.IntPtr m_shadowMapSpaceMatrix;

            [FieldOffset(48)]
            internal global::System.IntPtr m_offset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_centre;

            [FieldOffset(64)]
            internal float m_farHeight;

            [FieldOffset(68)]
            internal float m_farWidth;

            [FieldOffset(72)]
            internal float m_nearHeight;

            [FieldOffset(76)]
            internal float m_nearWidth;

            [FieldOffset(80)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowBox@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ShadowBox@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ShadowBox@fl@@QEAAXAEBVICamera@2@AEBVVector3@2@AEBM2@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr camera, global::System.IntPtr lightPosition, float* shadowOffset, float* shadowDistance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInBox@ShadowBox@fl@@QEBA_NAEBVVector3@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInBox(global::System.IntPtr instance, global::System.IntPtr position, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProjectionViewMatrix@ShadowBox@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetProjectionViewMatrix(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetToShadowMapSpaceMatrix@ShadowBox@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetToShadowMapSpaceMatrix(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLightSpaceTransform@ShadowBox@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetLightSpaceTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAabb@ShadowBox@fl@@QEBAPEAVColliderAabb@2@XZ")]
            internal static extern global::System.IntPtr GetAabb(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ShadowBox> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ShadowBox>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ShadowBox __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShadowBox(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShadowBox __CreateInstance(global::FlounderSharp.ShadowBox.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShadowBox(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShadowBox.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowBox.__Internal));
            *(global::FlounderSharp.ShadowBox.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ShadowBox(global::FlounderSharp.ShadowBox.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShadowBox(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new shadow box and calculates some initial values relating to the camera's view frustum.</summary>
        public ShadowBox()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowBox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        ~ShadowBox()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ShadowBox __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the bounds of the shadow box based on the light direction and the camera's view frustum. Will make sure that the box covers the smallest area possible while still ensuring that everything. Objects inside the camera's view (and in range) will be shadowed.</summary>
        /// <param name="camera">The camera object to be used when calculating the shadow boxes size.</param>
        /// <param name="lightPosition">The lights position.</param>
        /// <param name="shadowOffset">The shadows offset.</param>
        /// <param name="shadowDistance">The shadows distance.</param>
        public void Update(global::FlounderSharp.ICamera camera, global::FlounderSharp.Vector3 lightPosition, ref float shadowOffset, ref float shadowDistance)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = camera.__Instance;
            if (ReferenceEquals(lightPosition, null))
                throw new global::System.ArgumentNullException("lightPosition", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = lightPosition.__Instance;
            fixed (float* __refParamPtr2 = &shadowOffset)
            {
                var __arg2 = __refParamPtr2;
                fixed (float* __refParamPtr3 = &shadowDistance)
                {
                    var __arg3 = __refParamPtr3;
                    __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
                }
            }
        }

        /// <summary>Test if a bounding sphere intersects the shadow box. Can be used to decide which engine.entities should be rendered in the shadow render pass.</summary>
        /// <param name="position">The centre of the bounding sphere in world space.</param>
        /// <param name="radius">The radius of the bounding sphere.</param>
        public bool IsInBox(global::FlounderSharp.Vector3 position, ref float radius)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            fixed (float* __refParamPtr1 = &radius)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.IsInBox((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }
        }

        public global::FlounderSharp.Matrix4 ProjectionViewMatrix
        {
            get
            {
                var __ret = __Internal.GetProjectionViewMatrix((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>This biased projection-view matrix is used to convert fragments into &quot;shadow map space&quot; when rendering the main render pass.</summary>
        public global::FlounderSharp.Matrix4 ToShadowMapSpaceMatrix
        {
            get
            {
                var __ret = __Internal.GetToShadowMapSpaceMatrix((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the light's &quot;view&quot; matrix</summary>
        public global::FlounderSharp.Matrix4 LightSpaceTransform
        {
            get
            {
                var __ret = __Internal.GetLightSpaceTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.ColliderAabb Aabb
        {
            get
            {
                var __ret = __Internal.GetAabb((__Instance + __PointerAdjustment));
                global::FlounderSharp.ColliderAabb __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
                else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            internal global::System.IntPtr first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I____N_fl_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_fl_S_ConfigKey
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::FlounderSharp.ConfigKey.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
