// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>A helper for C++ strings.</summary>
    public unsafe partial class FormatString : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FormatString@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StartsWith@FormatString@fl@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool StartsWith(global::System.IntPtr str, global::System.IntPtr token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Contains@FormatString@fl@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(global::System.IntPtr str, global::System.IntPtr token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInteger@FormatString@fl@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInteger(global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindCharPos@FormatString@fl@@SAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBD@Z")]
            internal static extern int FindCharPos(global::System.IntPtr str, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Trim@FormatString@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z")]
            internal static extern void Trim(global::System.IntPtr @return, global::System.IntPtr str, global::System.IntPtr whitespace);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Substring@FormatString@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBI1@Z")]
            internal static extern void Substring(global::System.IntPtr @return, global::System.IntPtr str, uint start, uint end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveAll@FormatString@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBD@Z")]
            internal static extern void RemoveAll(global::System.IntPtr @return, global::System.IntPtr str, sbyte token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Replace@FormatString@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@00@Z")]
            internal static extern void Replace(global::System.IntPtr @return, global::System.IntPtr str, global::System.IntPtr token, global::System.IntPtr to);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Lowercase@FormatString@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void Lowercase(global::System.IntPtr @return, global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Uppercase@FormatString@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void Uppercase(global::System.IntPtr @return, global::System.IntPtr str);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FormatString> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FormatString>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.FormatString __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FormatString(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FormatString __CreateInstance(global::FlounderSharp.FormatString.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FormatString(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FormatString.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FormatString.__Internal));
            *(global::FlounderSharp.FormatString.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FormatString(global::FlounderSharp.FormatString.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FormatString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FormatString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FormatString.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FormatString(global::FlounderSharp.FormatString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FormatString.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.FormatString.__Internal*) __Instance) = *((global::FlounderSharp.FormatString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.FormatString __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if a string starts with a token.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static bool StartsWith(string str, string token)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.StartsWith(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Gets if a string contains a token.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static bool Contains(string str, string token)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.Contains(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Gets if a string is a integer.</summary>
        /// <param name="str">The string.</param>
        public static bool IsInteger(string str)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.IsInteger(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets the first char index in the string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="c">The char to look for.</param>
        public static int FindCharPos(string str, sbyte c)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.FindCharPos(__arg0, c);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Trims the left and right side of a string of whitespace.</summary>
        /// <param name="str">The string.</param>
        /// <param name="whitespace">The whitespace type.</param>
        public static string Trim(string str, string whitespace)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(whitespace, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Trim(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>Takes a substring of a string between two bounds.</summary>
        /// <param name="str">The string.</param>
        /// <param name="start">The left bound.</param>
        /// <param name="end">The right bound.</param>
        public static string Substring(string str, uint start, uint end)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Substring(new IntPtr(&__ret), __arg0, start, end);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>Removes all tokens from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static string RemoveAll(string str, sbyte token)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.RemoveAll(new IntPtr(&__ret), __arg0, token);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>Replaces all tokens from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        /// <param name="to">The string to replace the tokens with.</param>
        public static string Replace(string str, string token, string to)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(to, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Replace(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>Lowercases a string.</summary>
        /// <param name="str">The string.</param>
        public static string Lowercase(string str)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Lowercase(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>uppercased a string.</summary>
        /// <param name="str">The string.</param>
        public static string Uppercase(string str)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Uppercase(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr _0, int _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1, global::System.IntPtr _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1, global::System.IntPtr _2, global::System.IntPtr _3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1, global::System.IntPtr _2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate ulong Func_ulong_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_float(global::System.IntPtr _0, float _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1, global::System.IntPtr _2, global::System.IntPtr _3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float_IntPtr_float(global::System.IntPtr _0, float _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr_float_float(global::System.IntPtr _0, global::System.IntPtr _1, float _2, float _3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate int Func_int_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr_int(global::System.IntPtr _0, global::System.IntPtr _1, int _2);
    }
}

namespace FlounderSharp
{
    public unsafe partial class LoadedValue : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_children;

            [FieldOffset(16)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(48)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0LoadedValue@fl@@QEAA@PEAV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0LoadedValue@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1LoadedValue@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChild@LoadedValue@fl@@QEAAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N@Z")]
            internal static extern global::System.IntPtr GetChild(global::System.IntPtr instance, global::System.IntPtr name, bool addIfNull);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChild@LoadedValue@fl@@QEAAPEAV12@AEBIAEB_N@Z")]
            internal static extern global::System.IntPtr GetChild(global::System.IntPtr instance, uint index, bool addIfNull);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChildWithAttribute@LoadedValue@fl@@QEAAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00@Z")]
            internal static extern global::System.IntPtr GetChildWithAttribute(global::System.IntPtr instance, global::System.IntPtr childName, global::System.IntPtr attribute, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@LoadedValue@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@LoadedValue@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@LoadedValue@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@LoadedValue@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetString@LoadedValue@fl@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetString@LoadedValue@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetString(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ChildrenCount@LoadedValue@fl@@QEBAIXZ")]
            internal static extern uint ChildrenCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.LoadedValue> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.LoadedValue>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.LoadedValue __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.LoadedValue(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.LoadedValue __CreateInstance(global::FlounderSharp.LoadedValue.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.LoadedValue(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.LoadedValue.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.LoadedValue.__Internal));
            global::FlounderSharp.LoadedValue.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private LoadedValue(global::FlounderSharp.LoadedValue.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LoadedValue(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public LoadedValue(global::FlounderSharp.LoadedValue parent, string name, string value)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.LoadedValue.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(value, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public LoadedValue(global::FlounderSharp.LoadedValue _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.LoadedValue.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.LoadedValue __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::FlounderSharp.LoadedValue GetChild(string name, bool addIfNull)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetChild((__Instance + __PointerAdjustment), __arg0, addIfNull);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.LoadedValue __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.LoadedValue GetChild(uint index, bool addIfNull)
        {
            var __ret = __Internal.GetChild((__Instance + __PointerAdjustment), index, addIfNull);
            global::FlounderSharp.LoadedValue __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.LoadedValue GetChildWithAttribute(string childName, string attribute, string value)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(childName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(value, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.GetChildWithAttribute((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            global::FlounderSharp.LoadedValue __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(__ret);
            return __result0;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string String
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetString((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public uint ChildrenCount
        {
            get
            {
                var __ret = __Internal.ChildrenCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 3-tuple vector.</summary>
    public unsafe partial class Vector3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Vector3._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@fl@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@fl@@QEAA@AEBVVector2@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@fl@@QEAA@AEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@fl@@QEAA@AEBVColour@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Vector3@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector3@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector3@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Cross@Vector3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Cross(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector3@fl@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector3@fl@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector3@fl@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector3@fl@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector3@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector3@fl@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProjectCubeToSphere@Vector3@fl@@QEAA?AV12@AEBM@Z")]
            internal static extern void ProjectCubeToSphere(global::System.IntPtr instance, global::System.IntPtr @return, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BaryCentric@Vector3@fl@@QEAAMAEBV12@00@Z")]
            internal static extern float BaryCentric(global::System.IntPtr instance, global::System.IntPtr p1, global::System.IntPtr p2, global::System.IntPtr p3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinVector@Vector3@fl@@SA?AV12@AEBV12@0@Z")]
            internal static extern void MinVector(global::System.IntPtr @return, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxVector@Vector3@fl@@SA?AV12@AEBV12@0@Z")]
            internal static extern void MaxVector(global::System.IntPtr @return, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomPointOnCircle@Vector3@fl@@SA?AV12@AEBV12@AEBM@Z")]
            internal static extern void RandomPointOnCircle(global::System.IntPtr @return, global::System.IntPtr normal, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomUnitVectorWithinCone@Vector3@fl@@SA?AV12@AEBV12@AEBM@Z")]
            internal static extern void RandomUnitVectorWithinCone(global::System.IntPtr @return, global::System.IntPtr coneDirection, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Vector3@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector3@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector3@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector3@fl@@QEAA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector3@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector3@0@V10@M@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector3@0@V10@M@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector3@0@V10@M@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector3@0@V10@M@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Vector3.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector3@0@MV10@@Z")]
            internal static extern void OperatorPlus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector3.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector3@0@MV10@@Z")]
            internal static extern void OperatorMinus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector3.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector3@0@MV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector3.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector3@0@MV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector3.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector3@fl@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector3@fl@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector3@fl@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector3@fl@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Vector3@fl@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Vector3@fl@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector3@fl@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector3@fl@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector3@fl@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector3@fl@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CartesianToPolar@Vector3@fl@@QEBA?AV12@XZ")]
            internal static extern void CartesianToPolar(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PolarToCartesian@Vector3@fl@@QEBA?AV12@XZ")]
            internal static extern void PolarToCartesian(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomUnitVector@Vector3@fl@@SA?AV12@XZ")]
            internal static extern void RandomUnitVector(global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Vector3._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Vector3._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float m_x;

                    [FieldOffset(4)]
                    internal float m_y;

                    [FieldOffset(8)]
                    internal float m_z;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Vector3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Vector3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Vector3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Vector3(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Vector3 __CreateInstance(global::FlounderSharp.Vector3.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Vector3(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Vector3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector3.__Internal));
            global::FlounderSharp.Vector3.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector3(global::FlounderSharp.Vector3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector3.</summary>
        public Vector3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        public Vector3(float x, float y, float z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y, z);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        /// <param name="z">Start z.</param>
        public Vector3(global::FlounderSharp.Vector2 source, float z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, z);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector3(global::FlounderSharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector3(global::FlounderSharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing colour.</param>
        public Vector3(global::FlounderSharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Vector3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector3 Add(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector3 Subtract(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector3 Multiply(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector3 Divide(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the cross product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector3 Cross(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Cross((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::FlounderSharp.Vector3 Scale(float scalar)
        {
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around the origin.</summary>
        /// <param name="rotation">The rotation amount.</param>
        public global::FlounderSharp.Vector3 Rotate(global::FlounderSharp.Vector3 rotation)
        {
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = rotation.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::FlounderSharp.Vector3 Negate()
        {
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::FlounderSharp.Vector3 Normalize()
        {
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector3 DistanceVector(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::FlounderSharp.Vector3 SmoothDamp(global::FlounderSharp.Vector3 target, global::FlounderSharp.Vector3 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Projects this cube coordinate onto a sphere.</summary>
        /// <param name="radius">The sphere radius.</param>
        public global::FlounderSharp.Vector3 ProjectCubeToSphere(float radius)
        {
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.ProjectCubeToSphere((__Instance + __PointerAdjustment), new IntPtr(&__ret), radius);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets the height of this vector on a point off of a 3d triangle.</summary>
        /// <param name="p1">Point 1 on the triangle.</param>
        /// <param name="p2">Point 2 on the triangle.</param>
        /// <param name="p3">Point 3 on the triangle.</param>
        public float BaryCentric(global::FlounderSharp.Vector3 p1, global::FlounderSharp.Vector3 p2, global::FlounderSharp.Vector3 p3)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            var __ret = __Internal.BaryCentric((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Saves this vector into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Vector3 __op, global::FlounderSharp.Vector3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Vector3;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Vector3.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Vector3 __op, global::FlounderSharp.Vector3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::FlounderSharp.Vector3 __op, global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::FlounderSharp.Vector3 __op, global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::FlounderSharp.Vector3 __op, global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::FlounderSharp.Vector3 __op, global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::FlounderSharp.Vector3 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::FlounderSharp.Vector3 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::FlounderSharp.Vector3 operator -(global::FlounderSharp.Vector3 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Vector3(global::FlounderSharp.Vector4 source)
        {
            return new global::FlounderSharp.Vector3(source);
        }

        public static implicit operator global::FlounderSharp.Vector3(global::FlounderSharp.Colour source)
        {
            return new global::FlounderSharp.Vector3(source);
        }

        /// <summary>Gets the lowest vector size.</summary>
        /// <param name="a">The first vector to get values from.</param>
        /// <param name="b">The second vector to get values from.</param>
        public static global::FlounderSharp.Vector3 MinVector(global::FlounderSharp.Vector3 a, global::FlounderSharp.Vector3 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.MinVector(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets the maximum vector size.</summary>
        /// <param name="a">The first vector to get values from.</param>
        /// <param name="b">The second vector to get values from.</param>
        public static global::FlounderSharp.Vector3 MaxVector(global::FlounderSharp.Vector3 a, global::FlounderSharp.Vector3 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.MaxVector(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets a random point from on a circle.</summary>
        /// <param name="normal">The circles normal.</param>
        /// <param name="radius">The circles radius.</param>
        public static global::FlounderSharp.Vector3 RandomPointOnCircle(global::FlounderSharp.Vector3 normal, float radius)
        {
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = normal.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.RandomPointOnCircle(new IntPtr(&__ret), __arg0, radius);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Generates a random unit vector from within a cone.</summary>
        /// <param name="coneDirection">The cones direction.</param>
        /// <param name="angle">The cones major angle.</param>
        public static global::FlounderSharp.Vector3 RandomUnitVectorWithinCone(global::FlounderSharp.Vector3 coneDirection, float angle)
        {
            if (ReferenceEquals(coneDirection, null))
                throw new global::System.ArgumentNullException("coneDirection", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = coneDirection.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.RandomUnitVectorWithinCone(new IntPtr(&__ret), __arg0, angle);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator +(global::FlounderSharp.Vector3 left, global::FlounderSharp.Vector3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator -(global::FlounderSharp.Vector3 left, global::FlounderSharp.Vector3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator *(global::FlounderSharp.Vector3 left, global::FlounderSharp.Vector3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator /(global::FlounderSharp.Vector3 left, global::FlounderSharp.Vector3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator +(global::FlounderSharp.Vector3 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator -(global::FlounderSharp.Vector3 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator *(global::FlounderSharp.Vector3 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator /(global::FlounderSharp.Vector3 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator +(float value, global::FlounderSharp.Vector3 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorPlus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator -(float value, global::FlounderSharp.Vector3 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorMinus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator *(float value, global::FlounderSharp.Vector3 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 operator /(float value, global::FlounderSharp.Vector3 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector3 Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 One
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ONE@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 Left
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?LEFT@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 Right
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?RIGHT@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 Up
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?UP@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 Down
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?DOWN@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 Front
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?FRONT@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 Back
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?BACK@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 PositiveInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?POSITIVE_INFINITY@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector3 NegativeInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?NEGATIVE_INFINITY@Vector3@fl@@2V12@B");
                return global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetZ((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Converts from rectangular to spherical coordinates, this vector is in cartesian (x, y, z).</summary>
        public global::FlounderSharp.Vector3 CartesianToPolar
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.CartesianToPolar((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Converts from spherical to rectangular coordinates, this vector is in polar (radius, theta, phi).</summary>
        public global::FlounderSharp.Vector3 PolarToCartesian
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.PolarToCartesian((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Generates a random unit vector.</summary>
        public static global::FlounderSharp.Vector3 RandomUnitVector
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.RandomUnitVector(new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 4-tuple vector.</summary>
    public unsafe partial class Vector4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Vector4._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@fl@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@fl@@QEAA@AEBVVector3@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@fl@@QEAA@AEBVColour@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Vector4@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector4@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector4@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector4@fl@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector4@fl@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector4@fl@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector4@fl@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector4@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector4@fl@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Vector4@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector4@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector4@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector4@fl@@QEAA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector4@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector4@0@V10@M@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector4@0@V10@M@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector4@0@V10@M@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector4@0@V10@M@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Vector4.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector4@0@MV10@@Z")]
            internal static extern void OperatorPlus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector4.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector4@0@MV10@@Z")]
            internal static extern void OperatorMinus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector4.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector4@0@MV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector4.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector4@0@MV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector4.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector4@fl@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector4@fl@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector4@fl@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector4@fl@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Vector4@fl@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Vector4@fl@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetW@Vector4@fl@@QEBAMXZ")]
            internal static extern float GetW(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetW@Vector4@fl@@QEAAXAEBM@Z")]
            internal static extern void SetW(global::System.IntPtr instance, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector4@fl@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector4@fl@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector4@fl@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector4@fl@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Vector4._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Vector4._.__.__Internal __1;

                [FieldOffset(0)]
                internal global::FlounderSharp.Vector4._.__.__Internal __2;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float m_x;

                    [FieldOffset(4)]
                    internal float m_y;

                    [FieldOffset(8)]
                    internal float m_z;

                    [FieldOffset(12)]
                    internal float m_w;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Vector4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Vector4>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Vector4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Vector4(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Vector4 __CreateInstance(global::FlounderSharp.Vector4.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Vector4(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Vector4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector4.__Internal));
            global::FlounderSharp.Vector4.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector4(global::FlounderSharp.Vector4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector4.</summary>
        public Vector4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        /// <param name="w">Start w.</param>
        public Vector4(float x, float y, float z, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y, z, w);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        /// <param name="w">Start w.</param>
        public Vector4(global::FlounderSharp.Vector3 source, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, w);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector4(global::FlounderSharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing colour.</param>
        public Vector4(global::FlounderSharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Vector4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector4 Add(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector4 Subtract(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector4 Multiply(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector4 Divide(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::FlounderSharp.Vector4 Scale(float scalar)
        {
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::FlounderSharp.Vector4 Negate()
        {
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::FlounderSharp.Vector4 Normalize()
        {
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector4 DistanceVector(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::FlounderSharp.Vector4 SmoothDamp(global::FlounderSharp.Vector4 target, global::FlounderSharp.Vector4 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Saves this vector into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Vector4 __op, global::FlounderSharp.Vector4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Vector4;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Vector4.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Vector4 __op, global::FlounderSharp.Vector4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::FlounderSharp.Vector4 __op, global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::FlounderSharp.Vector4 __op, global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::FlounderSharp.Vector4 __op, global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::FlounderSharp.Vector4 __op, global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::FlounderSharp.Vector4 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::FlounderSharp.Vector4 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::FlounderSharp.Vector4 operator -(global::FlounderSharp.Vector4 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Vector4(global::FlounderSharp.Colour source)
        {
            return new global::FlounderSharp.Vector4(source);
        }

        public static global::FlounderSharp.Vector4 operator +(global::FlounderSharp.Vector4 left, global::FlounderSharp.Vector4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator -(global::FlounderSharp.Vector4 left, global::FlounderSharp.Vector4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator *(global::FlounderSharp.Vector4 left, global::FlounderSharp.Vector4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator /(global::FlounderSharp.Vector4 left, global::FlounderSharp.Vector4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator +(global::FlounderSharp.Vector4 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator -(global::FlounderSharp.Vector4 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator *(global::FlounderSharp.Vector4 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator /(global::FlounderSharp.Vector4 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator +(float value, global::FlounderSharp.Vector4 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorPlus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator -(float value, global::FlounderSharp.Vector4 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorMinus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator *(float value, global::FlounderSharp.Vector4 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 operator /(float value, global::FlounderSharp.Vector4 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector4 Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Vector4@fl@@2V12@B");
                return global::FlounderSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector4 One
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ONE@Vector4@fl@@2V12@B");
                return global::FlounderSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector4 PositiveInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?POSITIVE_INFINITY@Vector4@fl@@2V12@B");
                return global::FlounderSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector4 NegativeInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?NEGATIVE_INFINITY@Vector4@fl@@2V12@B");
                return global::FlounderSharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetZ((__Instance + __PointerAdjustment), value);
            }
        }

        public float W
        {
            get
            {
                var __ret = __Internal.GetW((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetW((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 4x4 matrix.</summary>
    public unsafe partial class Matrix4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Matrix4._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@fl@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Matrix4@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix4@fl@@QEBA?AVVector4@2@AEBV32@@Z")]
            internal static extern void Multiply_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix4@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix4@fl@@QEBA?AVVector4@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Translate@Matrix4@fl@@QEBA?AV12@AEBVVector2@2@@Z")]
            internal static extern void Translate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Translate@Matrix4@fl@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Translate_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix4@fl@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix4@fl@@QEBA?AV12@AEBVVector4@2@@Z")]
            internal static extern void Scale_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Matrix4@fl@@QEBA?AV12@AEBMAEBVVector3@2@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float angle, global::System.IntPtr axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix4@fl@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@fl@@SA?AV12@AEBVVector3@2@00@Z")]
            internal static extern void TransformationMatrix(global::System.IntPtr @return, global::System.IntPtr translation, global::System.IntPtr rotation, global::System.IntPtr scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@fl@@SA?AV12@AEBVVector2@2@AEBM@Z")]
            internal static extern void TransformationMatrix(global::System.IntPtr @return, global::System.IntPtr translation, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@fl@@SA?AV12@AEBVVector2@2@AEBVVector3@2@@Z")]
            internal static extern void TransformationMatrix(global::System.IntPtr @return, global::System.IntPtr translation, global::System.IntPtr scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@fl@@SA?AV12@AEBVVector3@2@0AEBM@Z")]
            internal static extern void TransformationMatrix(global::System.IntPtr @return, global::System.IntPtr translation, global::System.IntPtr rotation, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PerspectiveMatrix@Matrix4@fl@@SA?AV12@AEBM000@Z")]
            internal static extern void PerspectiveMatrix(global::System.IntPtr @return, float fov, float aspectRatio, float zNear, float zFar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?OrthographicMatrix@Matrix4@fl@@SA?AV12@AEBM00000@Z")]
            internal static extern void OrthographicMatrix(global::System.IntPtr @return, float left, float right, float bottom, float top, float near, float far);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ViewMatrix@Matrix4@fl@@SA?AV12@AEBVVector3@2@0@Z")]
            internal static extern void ViewMatrix(global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WorldToScreenSpace@Matrix4@fl@@SA?AVVector3@2@AEBV32@AEBV12@1@Z")]
            internal static extern void WorldToScreenSpace(global::System.IntPtr @return, global::System.IntPtr worldSpace, global::System.IntPtr viewMatrix, global::System.IntPtr projectionMatrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZero@Matrix4@fl@@QEAA?AV12@XZ")]
            internal static extern void SetZero(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIdentity@Matrix4@fl@@QEAA?AV12@XZ")]
            internal static extern void SetIdentity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToArray@Matrix4@fl@@QEBAPEAMXZ")]
            internal static extern float* ToArray(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Matrix4@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix4@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix4@fl@@QEAA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix4@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVMatrix4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVMatrix4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix4@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix4@0@V10@VVector4@0@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, global::FlounderSharp.Vector4.__Internal value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix4@0@V10@VVector4@0@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, global::FlounderSharp.Vector4.__Internal value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix4@0@V10@M@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix4@0@V10@M@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::FlounderSharp.Matrix4.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix4@0@MV10@@Z")]
            internal static extern void OperatorStar_2(global::System.IntPtr @return, float value, global::FlounderSharp.Matrix4.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix4@0@MV10@@Z")]
            internal static extern void OperatorSlash_2(global::System.IntPtr @return, float value, global::FlounderSharp.Matrix4.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix4@fl@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix4@fl@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix4@fl@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix4._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix4._.__.__Internal __1;

                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix4._.__.__Internal __2;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr m_0;

                    [FieldOffset(8)]
                    internal global::System.IntPtr m_1;

                    [FieldOffset(16)]
                    internal global::System.IntPtr m_2;

                    [FieldOffset(24)]
                    internal global::System.IntPtr m_3;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Matrix4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Matrix4>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Matrix4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Matrix4(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Matrix4 __CreateInstance(global::FlounderSharp.Matrix4.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Matrix4(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Matrix4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix4.__Internal));
            global::FlounderSharp.Matrix4.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix4(global::FlounderSharp.Matrix4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix4. The matrix is initialised to the identity.</summary>
        public Matrix4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix4(global::FlounderSharp.Matrix4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a 16 element array.</param>
        public Matrix4(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 16)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor((__Instance + __PointerAdjustment), source);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Matrix4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix4 Add(global::FlounderSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix4 Subtract(global::FlounderSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix4 Multiply(global::FlounderSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector4 Multiply(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Multiply_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix4 Divide(global::FlounderSharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector4 Transform(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector4.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Translates this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::FlounderSharp.Matrix4 Translate(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Translate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Translates this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::FlounderSharp.Matrix4 Translate(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Translate_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Matrix4 Scale(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Matrix4 Scale(global::FlounderSharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Scale_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Rotates this matrix around the given axis the specified angle.</summary>
        /// <param name="angle">the angle, in radians.</param>
        /// <param name="axis">The vector representing the rotation axis.</param>
        public global::FlounderSharp.Matrix4 Rotate(float angle, global::FlounderSharp.Vector3 axis)
        {
            if (ReferenceEquals(axis, null))
                throw new global::System.ArgumentNullException("axis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = axis.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), angle, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::FlounderSharp.Matrix4 Negate()
        {
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Sets this matrix to 0.</summary>
        public global::FlounderSharp.Matrix4 SetZero()
        {
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.SetZero((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Sets this matrix to be the identity matrix.</summary>
        public global::FlounderSharp.Matrix4 SetIdentity()
        {
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.SetIdentity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Turns this 4x4 matrix into an array.</summary>
        public float* ToArray()
        {
            var __ret = __Internal.ToArray((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Saves this matrix into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Matrix4 __op, global::FlounderSharp.Matrix4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Matrix4;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Matrix4.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Matrix4 __op, global::FlounderSharp.Matrix4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::FlounderSharp.Matrix4 operator -(global::FlounderSharp.Matrix4 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Matrix4(float[] source)
        {
            return new global::FlounderSharp.Matrix4(source);
        }

        /// <summary>Creates a new transformation matrix for a object in 3d space.</summary>
        /// <param name="translation">Translation amount the XYZ.</param>
        /// <param name="rotation">Rotation amount the XYZ.</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::FlounderSharp.Matrix4 TransformationMatrix(global::FlounderSharp.Vector3 translation, global::FlounderSharp.Vector3 rotation, global::FlounderSharp.Vector3 scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scale.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.TransformationMatrix(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix for a object in 2d space.</summary>
        /// <param name="translation">Translation amount the XY.</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::FlounderSharp.Matrix4 TransformationMatrix(global::FlounderSharp.Vector2 translation, float scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.TransformationMatrix(new IntPtr(&__ret), __arg0, scale);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix for a object in 2d space.</summary>
        /// <param name="translation">Translation amount the XY.</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::FlounderSharp.Matrix4 TransformationMatrix(global::FlounderSharp.Vector2 translation, global::FlounderSharp.Vector3 scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = scale.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.TransformationMatrix(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix for a object in 3d space.</summary>
        /// <param name="translation">Translation amount the XYZ.</param>
        /// <param name="rotation">Rotation amount the XYZ.</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::FlounderSharp.Matrix4 TransformationMatrix(global::FlounderSharp.Vector3 translation, global::FlounderSharp.Vector3 rotation, float scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.TransformationMatrix(new IntPtr(&__ret), __arg0, __arg1, scale);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new perspective matrix.</summary>
        /// <param name="fov">The cameras FOV.</param>
        /// <param name="aspectRatio">The cameras aspect ratio.</param>
        /// <param name="zNear">The cameras near plane.</param>
        /// <param name="zFar">The cameras far plane.</param>
        public static global::FlounderSharp.Matrix4 PerspectiveMatrix(float fov, float aspectRatio, float zNear, float zFar)
        {
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.PerspectiveMatrix(new IntPtr(&__ret), fov, aspectRatio, zNear, zFar);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new orthographic matrix.</summary>
        /// <param name="left">The left plane.</param>
        /// <param name="right">The right plane.</param>
        /// <param name="bottom">The bottom plane.</param>
        /// <param name="top">The top plane.</param>
        /// <param name="near">The near plane.</param>
        /// <param name="far">The far plane.</param>
        /// <param name="destination">The destination matrix or nullptr if a new matrix is to be created.</param>
        public static global::FlounderSharp.Matrix4 OrthographicMatrix(float left, float right, float bottom, float top, float near, float far)
        {
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OrthographicMatrix(new IntPtr(&__ret), left, right, bottom, top, near, far);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new view matrix.</summary>
        /// <param name="position">The cameras position.</param>
        /// <param name="rotation">The cameras rotation.</param>
        public static global::FlounderSharp.Matrix4 ViewMatrix(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 rotation)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.ViewMatrix(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Transforms a 3D world point into screen space.</summary>
        /// <param name="worldSpace">The point to get into screen space.</param>
        /// <param name="viewMatrix">The cameras view matrix.</param>
        /// <param name="projectionMatrix">The cameras projection matrix.</param>
        public static global::FlounderSharp.Vector3 WorldToScreenSpace(global::FlounderSharp.Vector3 worldSpace, global::FlounderSharp.Matrix4 viewMatrix, global::FlounderSharp.Matrix4 projectionMatrix)
        {
            if (ReferenceEquals(worldSpace, null))
                throw new global::System.ArgumentNullException("worldSpace", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = worldSpace.__Instance;
            if (ReferenceEquals(viewMatrix, null))
                throw new global::System.ArgumentNullException("viewMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = viewMatrix.__Instance;
            if (ReferenceEquals(projectionMatrix, null))
                throw new global::System.ArgumentNullException("projectionMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = projectionMatrix.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.WorldToScreenSpace(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator +(global::FlounderSharp.Matrix4 left, global::FlounderSharp.Matrix4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator -(global::FlounderSharp.Matrix4 left, global::FlounderSharp.Matrix4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator *(global::FlounderSharp.Matrix4 left, global::FlounderSharp.Matrix4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator /(global::FlounderSharp.Matrix4 left, global::FlounderSharp.Matrix4 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator *(global::FlounderSharp.Matrix4 left, global::FlounderSharp.Vector4 value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) value.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator /(global::FlounderSharp.Matrix4 left, global::FlounderSharp.Vector4 value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector4.__Internal() : *(global::FlounderSharp.Vector4.__Internal*) value.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator *(global::FlounderSharp.Matrix4 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator /(global::FlounderSharp.Matrix4 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator *(float value, global::FlounderSharp.Matrix4 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorStar_2(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 operator /(float value, global::FlounderSharp.Matrix4 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix4.__Internal() : *(global::FlounderSharp.Matrix4.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.OperatorSlash_2(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix4 Identity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?IDENTITY@Matrix4@fl@@2V12@B");
                return global::FlounderSharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Matrix4 Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Matrix4@fl@@2V12@B");
                return global::FlounderSharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::FlounderSharp.Matrix4 Invert
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix4.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::FlounderSharp.Matrix4 Transpose
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix4.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A vector like object of the form w + xi + yj + zk, where w, x, y, z are real numbers and i, j, k are imaginary units.</summary>
    public unsafe partial class Quaternion : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Quaternion._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@fl@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@fl@@QEAA@AEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@fl@@QEAA@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Quaternion@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Quaternion@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MultiplyInverse@Quaternion@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void MultiplyInverse(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Quaternion@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Slerp@Quaternion@fl@@QEAA?AV12@AEBV12@AEBM@Z")]
            internal static extern void Slerp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other, float progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Quaternion@fl@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Quaternion@fl@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Quaternion@fl@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToMatrix@Quaternion@fl@@QEAA?AVMatrix4@2@XZ")]
            internal static extern void ToMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToRotationMatrix@Quaternion@fl@@QEAA?AVMatrix4@2@XZ")]
            internal static extern void ToRotationMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Quaternion@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Quaternion@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Quaternion@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MQuaternion@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NQuaternion@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OQuaternion@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PQuaternion@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Quaternion@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Quaternion@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GQuaternion@fl@@QEAA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Quaternion@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVQuaternion@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Quaternion.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVQuaternion@0@MV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float value, global::FlounderSharp.Quaternion.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Quaternion@fl@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Quaternion@fl@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Quaternion@fl@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Quaternion@fl@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Quaternion@fl@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Quaternion@fl@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetW@Quaternion@fl@@QEBAMXZ")]
            internal static extern float GetW(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetW@Quaternion@fl@@QEAAXAEBM@Z")]
            internal static extern void SetW(global::System.IntPtr instance, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Quaternion@fl@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Quaternion@fl@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Quaternion@fl@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Quaternion@fl@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Quaternion._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Quaternion._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float m_x;

                    [FieldOffset(4)]
                    internal float m_y;

                    [FieldOffset(8)]
                    internal float m_z;

                    [FieldOffset(12)]
                    internal float m_w;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Quaternion> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Quaternion>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Quaternion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Quaternion(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Quaternion __CreateInstance(global::FlounderSharp.Quaternion.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Quaternion(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Quaternion.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Quaternion.__Internal));
            global::FlounderSharp.Quaternion.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Quaternion(global::FlounderSharp.Quaternion.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Quaternion(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Quaternion.</summary>
        public Quaternion()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        /// <param name="w">Start w.</param>
        public Quaternion(float x, float y, float z, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y, z, w);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this quaternion out of a existing vector.</param>
        public Quaternion(global::FlounderSharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Quaternion(global::FlounderSharp.Quaternion source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this vector out of a existing matrix.</param>
        public Quaternion(global::FlounderSharp.Matrix4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Quaternion __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Sets the value of this quaternion to the quaternion product of quaternions left and right (this = left * right). Note that this is safe for aliasing (e.g. this can be left or right).</summary>
        /// <param name="other">The other quaternion.</param>
        public global::FlounderSharp.Quaternion Multiply(global::FlounderSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Multiplies quaternion left by the inverse of quaternion right and places the value into this quaternion. The value of both argument quaternions is persevered (this = left * right^-1).</summary>
        /// <param name="other">The other quaternion.</param>
        public global::FlounderSharp.Quaternion MultiplyInverse(global::FlounderSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.MultiplyInverse((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Calculates the dot product of the this quaternion and another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public float Dot(global::FlounderSharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the slerp between this quaternion and another quaternion, they must be normalized!</summary>
        /// <param name="other">The other quaternion.</param>
        /// <param name="progression">The progression.</param>
        public global::FlounderSharp.Quaternion Slerp(global::FlounderSharp.Quaternion other, float progression)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.Slerp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, progression);
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Scales this quaternion by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::FlounderSharp.Quaternion Scale(float scalar)
        {
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Negates this quaternion.</summary>
        public global::FlounderSharp.Quaternion Negate()
        {
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this quaternion.</summary>
        public global::FlounderSharp.Quaternion Normalize()
        {
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to a 4x4 matrix.</summary>
        public global::FlounderSharp.Matrix4 ToMatrix()
        {
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.ToMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to a 4x4 matrix representing the exact same rotation as this quaternion. (The rotation is only contained in the top-left 3x3 part, but a 4x4 matrix is returned here for convenience seeing as it will be multiplied with other 4x4 matrices).</summary>
        public global::FlounderSharp.Matrix4 ToRotationMatrix()
        {
            var __ret = new global::FlounderSharp.Matrix4.__Internal();
            __Internal.ToRotationMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Saves this quaternion into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Quaternion __op, global::FlounderSharp.Quaternion other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Quaternion;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Quaternion.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Quaternion __op, global::FlounderSharp.Quaternion other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::FlounderSharp.Quaternion __op, global::FlounderSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::FlounderSharp.Quaternion __op, global::FlounderSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::FlounderSharp.Quaternion __op, global::FlounderSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::FlounderSharp.Quaternion __op, global::FlounderSharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::FlounderSharp.Quaternion __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::FlounderSharp.Quaternion __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::FlounderSharp.Quaternion operator -(global::FlounderSharp.Quaternion __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Quaternion(global::FlounderSharp.Vector4 source)
        {
            return new global::FlounderSharp.Quaternion(source);
        }

        public static implicit operator global::FlounderSharp.Quaternion(global::FlounderSharp.Matrix4 source)
        {
            return new global::FlounderSharp.Quaternion(source);
        }

        public static global::FlounderSharp.Quaternion operator *(global::FlounderSharp.Quaternion left, global::FlounderSharp.Quaternion right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Quaternion.__Internal() : *(global::FlounderSharp.Quaternion.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Quaternion operator *(float value, global::FlounderSharp.Quaternion left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Quaternion.__Internal() : *(global::FlounderSharp.Quaternion.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Quaternion Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Quaternion@fl@@2V12@B");
                return global::FlounderSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Quaternion One
        {
            get
            {
                var __ptr = (global::FlounderSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ONE@Quaternion@fl@@2V12@B");
                return global::FlounderSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Quaternion PositiveInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?POSITIVE_INFINITY@Quaternion@fl@@2V12@B");
                return global::FlounderSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Quaternion NegativeInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?NEGATIVE_INFINITY@Quaternion@fl@@2V12@B");
                return global::FlounderSharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetZ((__Instance + __PointerAdjustment), value);
            }
        }

        public float W
        {
            get
            {
                var __ret = __Internal.GetW((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetW((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this quaternion.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this quaternion.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this quaternion.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this quaternion.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class JointTransformData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_jointNameId;

            [FieldOffset(32)]
            internal global::FlounderSharp.Matrix4.__Internal m_jointLocalTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransformData@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr jointNameId, global::System.IntPtr jointLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransformData@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointTransformData@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointNameId@JointTransformData@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetJointNameId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointLocalTransform@JointTransformData@fl@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetJointLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointTransformData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointTransformData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.JointTransformData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointTransformData(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.JointTransformData __CreateInstance(global::FlounderSharp.JointTransformData.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointTransformData(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.JointTransformData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransformData.__Internal));
            global::FlounderSharp.JointTransformData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointTransformData(global::FlounderSharp.JointTransformData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointTransformData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JointTransformData(string jointNameId, global::FlounderSharp.Matrix4 jointLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransformData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(jointNameId, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(jointLocalTransform, null))
                throw new global::System.ArgumentNullException("jointLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = jointLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public JointTransformData(global::FlounderSharp.JointTransformData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransformData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.JointTransformData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string JointNameId
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetJointNameId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public global::FlounderSharp.Matrix4 JointLocalTransform
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix4.__Internal();
                __Internal.GetJointLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents the local bone-space transform of a joint at a certain keyframe during an animation. This includes the position and rotation of the joint, relative to the parent joint (or relative to the model's origin if it's the root joint). The transform is stored as a position vector and a quaternion (rotation) so that these values can  be easily interpolated, a functionality that this class also provides.</summary>
    public unsafe partial class JointTransform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_position;

            [FieldOffset(8)]
            internal global::System.IntPtr m_rotation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@fl@@QEAA@AEBVVector3@1@AEBVQuaternion@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@fl@@QEAA@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@fl@@QEAA@AEBVJointTransformData@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointTransform@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@fl@@SAPEAV12@AEBV12@0AEBM@Z")]
            internal static extern global::System.IntPtr Interpolate(global::System.IntPtr frameA, global::System.IntPtr frameB, float progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@fl@@SA?AVVector3@2@AEBV32@0AEBM@Z")]
            internal static extern void Interpolate(global::System.IntPtr @return, global::System.IntPtr start, global::System.IntPtr end, float progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@JointTransform@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@JointTransform@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@JointTransform@fl@@QEBAPEAVQuaternion@2@XZ")]
            internal static extern global::System.IntPtr GetRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRotation@JointTransform@fl@@QEAAXAEBVQuaternion@2@@Z")]
            internal static extern void SetRotation(global::System.IntPtr instance, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalTransform@JointTransform@fl@@QEAAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetLocalTransform(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointTransform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointTransform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.JointTransform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointTransform(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.JointTransform __CreateInstance(global::FlounderSharp.JointTransform.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointTransform(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.JointTransform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            *(global::FlounderSharp.JointTransform.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JointTransform(global::FlounderSharp.JointTransform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointTransform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="position">The position of the joint relative to the parent joint (local-space) at a certain keyframe.</param>
        /// <param name="rotation">The rotation of the joint relative to te parent joint (local-space) at a certain keyframe.</param>
        public JointTransform(global::FlounderSharp.Vector3 position, global::FlounderSharp.Quaternion rotation)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="localTransform">The joint's local-transform at a certain keyframe of an animation.</param>
        public JointTransform(global::FlounderSharp.Matrix4 localTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public JointTransform(global::FlounderSharp.JointTransformData data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public JointTransform(global::FlounderSharp.JointTransform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.JointTransform.__Internal*) __Instance) = *((global::FlounderSharp.JointTransform.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.JointTransform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::FlounderSharp.JointTransform(global::FlounderSharp.Matrix4 localTransform)
        {
            return new global::FlounderSharp.JointTransform(localTransform);
        }

        public static implicit operator global::FlounderSharp.JointTransform(global::FlounderSharp.JointTransformData data)
        {
            return new global::FlounderSharp.JointTransform(data);
        }

        /// <summary>Interpolates between two transforms based on the progression value. The result is a new transform which is part way between the two original transforms. The translation can simply be linearly interpolated, but the rotation interpolation is slightly more complex, using a method called &quot;SLERP&quot; to spherically-linearly interpolate between 2 quaternions (rotations). This gives a much much better result than trying to linearly interpolate between Euler rotations.</summary>
        /// <param name="frameA">The previous transform</param>
        /// <param name="frameB">The next transform</param>
        /// <param name="progression">A number between 0 and 1 indicating how far between the two transforms to interpolate. A progression value of 0 would return a transform equal to &quot;frameA&quot;, a value of 1 would return a transform equal to &quot;frameB&quot;. Everything else gives a transform somewhere in-between the two.</param>
        public static global::FlounderSharp.JointTransform Interpolate(global::FlounderSharp.JointTransform frameA, global::FlounderSharp.JointTransform frameB, float progression)
        {
            if (ReferenceEquals(frameA, null))
                throw new global::System.ArgumentNullException("frameA", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frameA.__Instance;
            if (ReferenceEquals(frameB, null))
                throw new global::System.ArgumentNullException("frameB", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = frameB.__Instance;
            var __ret = __Internal.Interpolate(__arg0, __arg1, progression);
            global::FlounderSharp.JointTransform __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.JointTransform.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.JointTransform) global::FlounderSharp.JointTransform.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.JointTransform.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Linearly interpolates between two translations based on a &quot;progression&quot; value.</summary>
        /// <param name="start">The start translation.</param>
        /// <param name="end">The end translation.</param>
        /// <param name="progression">A value between 0 and 1 indicating how far to interpolate between the two translations.</param>
        public static global::FlounderSharp.Vector3 Interpolate(global::FlounderSharp.Vector3 start, global::FlounderSharp.Vector3 end, float progression)
        {
            if (ReferenceEquals(start, null))
                throw new global::System.ArgumentNullException("start", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = start.__Instance;
            if (ReferenceEquals(end, null))
                throw new global::System.ArgumentNullException("end", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = end.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Interpolate(new IntPtr(&__ret), __arg0, __arg1, progression);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Quaternion Rotation
        {
            get
            {
                var __ret = __Internal.GetRotation((__Instance + __PointerAdjustment));
                global::FlounderSharp.Quaternion __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Quaternion.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Quaternion) global::FlounderSharp.Quaternion.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Quaternion.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>In this method the local-space transform matrix is constructed by translating an identity matrix using the position variable and then applying the rotation. The rotation is applied by first converting the quaternion into a rotation matrix, which is then multiplied with the transform matrix.</summary>
        public global::FlounderSharp.Matrix4 LocalTransform
        {
            get
            {
                var __ret = __Internal.GetLocalTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class KeyframeData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_time;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_JointTransformData___N_std_S_allocator__S0_ m_jointTransforms;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0KeyframeData@fl@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0KeyframeData@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1KeyframeData@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddJointTransform@KeyframeData@fl@@QEAAXPEAVJointTransformData@2@@Z")]
            internal static extern void AddJointTransform(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@KeyframeData@fl@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.KeyframeData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.KeyframeData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.KeyframeData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.KeyframeData(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.KeyframeData __CreateInstance(global::FlounderSharp.KeyframeData.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.KeyframeData(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.KeyframeData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.KeyframeData.__Internal));
            global::FlounderSharp.KeyframeData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private KeyframeData(global::FlounderSharp.KeyframeData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected KeyframeData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public KeyframeData(float time)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.KeyframeData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), time);
        }

        public KeyframeData(global::FlounderSharp.KeyframeData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.KeyframeData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.KeyframeData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddJointTransform(global::FlounderSharp.JointTransformData transform)
        {
            var __arg0 = ReferenceEquals(transform, null) ? global::System.IntPtr.Zero : transform.__Instance;
            __Internal.AddJointTransform((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::FlounderSharp.KeyframeData(float time)
        {
            return new global::FlounderSharp.KeyframeData(time);
        }

        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents one keyframe of an animation. This contains the timestamp of the keyframe, which is the time (in seconds) from the start of the animation when this keyframe occurs.  It also contains the desired local-space transforms of all of the joints in the animated entity at this keyframe in the animation. The joint transforms are stored in a map, indexed by the name of the joint that they should be applied to.</summary>
    public unsafe partial class Keyframe : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_timeStamp;

            [FieldOffset(8)]
            internal global::System.IntPtr m_pose;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyframe@fl@@QEAA@AEBVKeyframeData@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyframe@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Keyframe@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeStamp@Keyframe@fl@@QEBAMXZ")]
            internal static extern float GetTimeStamp(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Keyframe> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Keyframe>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Keyframe __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Keyframe(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Keyframe __CreateInstance(global::FlounderSharp.Keyframe.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Keyframe(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Keyframe.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Keyframe.__Internal));
            *(global::FlounderSharp.Keyframe.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Keyframe(global::FlounderSharp.Keyframe.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Keyframe(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Keyframe(global::FlounderSharp.KeyframeData data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Keyframe.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Keyframe(global::FlounderSharp.Keyframe _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Keyframe.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Keyframe.__Internal*) __Instance) = *((global::FlounderSharp.Keyframe.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Keyframe __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::FlounderSharp.Keyframe(global::FlounderSharp.KeyframeData data)
        {
            return new global::FlounderSharp.Keyframe(data);
        }

        /// <summary>Gets the time in seconds of the keyframe in the animation.</summary>
        public float TimeStamp
        {
            get
            {
                var __ret = __Internal.GetTimeStamp((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents an animation that can be carried out by an animated entity. It contains the length of the animation in seconds, and a list of s.</summary>
    public unsafe partial class Animation : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_length;

            [FieldOffset(8)]
            internal global::System.IntPtr m_keyframes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animation@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Animation@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@Animation@fl@@QEBAMXZ")]
            internal static extern float GetLength(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Animation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Animation>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Animation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Animation(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Animation __CreateInstance(global::FlounderSharp.Animation.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Animation(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Animation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Animation.__Internal));
            *(global::FlounderSharp.Animation.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Animation(global::FlounderSharp.Animation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Animation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Animation(global::FlounderSharp.Animation _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Animation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Animation.__Internal*) __Instance) = *((global::FlounderSharp.Animation.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Animation __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the length of the animation in seconds.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class AnimationLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_libraryAnimations;

            [FieldOffset(8)]
            internal global::System.IntPtr m_libraryVisualScenes;

            [FieldOffset(16)]
            internal float m_lengthSeconds;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_KeyframeData___N_std_S_allocator__S0_ m_keyframeData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AnimationLoader@fl@@QEAA@PEAVLoadedValue@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr libraryAnimations, global::System.IntPtr libraryVisualScenes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AnimationLoader@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AnimationLoader@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLengthSeconds@AnimationLoader@fl@@QEBAMXZ")]
            internal static extern float GetLengthSeconds(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.AnimationLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.AnimationLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.AnimationLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AnimationLoader(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.AnimationLoader __CreateInstance(global::FlounderSharp.AnimationLoader.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AnimationLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.AnimationLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AnimationLoader.__Internal));
            global::FlounderSharp.AnimationLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AnimationLoader(global::FlounderSharp.AnimationLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AnimationLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AnimationLoader(global::FlounderSharp.LoadedValue libraryAnimations, global::FlounderSharp.LoadedValue libraryVisualScenes)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AnimationLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(libraryAnimations, null) ? global::System.IntPtr.Zero : libraryAnimations.__Instance;
            var __arg1 = ReferenceEquals(libraryVisualScenes, null) ? global::System.IntPtr.Zero : libraryVisualScenes.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public AnimationLoader(global::FlounderSharp.AnimationLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AnimationLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.AnimationLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float LengthSeconds
        {
            get
            {
                var __ret = __Internal.GetLengthSeconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class JointData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_index;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_nameId;

            [FieldOffset(40)]
            internal global::FlounderSharp.Matrix4.__Internal m_bindLocalTransform;

            [FieldOffset(104)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_JointData___N_std_S_allocator__S0_ m_children;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointData@fl@@QEAA@AEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int index, global::System.IntPtr nameId, global::System.IntPtr bindLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointData@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointData@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@JointData@fl@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@JointData@fl@@QEBAHXZ")]
            internal static extern int GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNameId@JointData@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetNameId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBindLocalTransform@JointData@fl@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetBindLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JointData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.JointData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointData(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.JointData __CreateInstance(global::FlounderSharp.JointData.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JointData(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.JointData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointData.__Internal));
            global::FlounderSharp.JointData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointData(global::FlounderSharp.JointData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JointData(int index, string nameId, global::FlounderSharp.Matrix4 bindLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(nameId, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(bindLocalTransform, null))
                throw new global::System.ArgumentNullException("bindLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = bindLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), index, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public JointData(global::FlounderSharp.JointData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JointData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.JointData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddChild(global::FlounderSharp.JointData child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public int Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string NameId
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetNameId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public global::FlounderSharp.Matrix4 BindLocalTransform
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix4.__Internal();
                __Internal.GetBindLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a joint in a &quot;skeleton&quot;. It contains the index of the joint which determines where in the vertex shader uniform array the joint matrix for this joint is loaded up to. It also contains the name of the bone, and a list of all the child joints.  The &quot;animatedTransform&quot; matrix is the joint transform. This is the transform that gets loaded up to the vertex shader and is used to transform vertices. It is a model-space transform that transforms the joint from it's bind (original position, no animation applied) position to it's current position in the current pose. Changing this transform changes the position/rotation of the joint in the animated entity.  The two other matrices are transforms that are required to calculate the &quot;animatedTransform&quot; in the  class. It also has the local bind transform which is the original (no pose/animation applied) transform of the joint relative to the parent joint (in bone-space).  The &quot;localBindTransform&quot; is the original (bind) transform of the joint relative to its parent (in bone-space). The inverseBindTransform is that bind transform in model-space, but inversed.</summary>
    public unsafe partial class Joint : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_index;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_children;

            [FieldOffset(48)]
            internal global::System.IntPtr m_localBindTransform;

            [FieldOffset(56)]
            internal global::System.IntPtr m_animatedTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_inverseBindTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@fl@@QEAA@AEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int index, global::System.IntPtr name, global::System.IntPtr bindLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joint@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateInverseBindTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void CalculateInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr parentBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@Joint@fl@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@Joint@fl@@QEBAHXZ")]
            internal static extern int GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIndex@Joint@fl@@QEAAXAEBH@Z")]
            internal static extern void SetIndex(global::System.IntPtr instance, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Joint@fl@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern global::System.IntPtr GetName(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Joint@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalBindTransform@Joint@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetLocalBindTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLocalBindTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetLocalBindTransform(global::System.IntPtr instance, global::System.IntPtr localBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAnimatedTransform@Joint@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetAnimatedTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAnimatedTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetAnimatedTransform(global::System.IntPtr instance, global::System.IntPtr animatedTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInverseBindTransform@Joint@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetInverseBindTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInverseBindTransform@Joint@fl@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr inverseBindTransform);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Joint> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Joint>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Joint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joint(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Joint __CreateInstance(global::FlounderSharp.Joint.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joint(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Joint.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joint.__Internal));
            global::FlounderSharp.Joint.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joint(global::FlounderSharp.Joint.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new joint.</summary>
        /// <param name="index">The joint's index (ID).</param>
        /// <param name="name">The name of the joint. This is how the joint is named in the collada file, and so is used to identify which joint a joint transform in an animation keyframe refers to.</param>
        /// <param name="bindLocalTransform">The bone-space transform of the joint in the bind position.</param>
        public Joint(int index, string name, global::FlounderSharp.Matrix4 bindLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(bindLocalTransform, null))
                throw new global::System.ArgumentNullException("bindLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = bindLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), index, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public Joint(global::FlounderSharp.Joint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Joint __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>This is called during set-up, after the joints hierarchy has been created. This calculates the model-space bind transform of this joint like so:</para>
        /// <para></para>
        /// <para></para>
        /// <para>{</para>
        /// </summary>
        public void CalculateInverseBindTransform(global::FlounderSharp.Matrix4 parentBindTransform)
        {
            if (ReferenceEquals(parentBindTransform, null))
                throw new global::System.ArgumentNullException("parentBindTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = parentBindTransform.__Instance;
            __Internal.CalculateInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Adds a child joint to this joint. Used during the creation of the joint hierarchy. Joints can have multiple children, which is why they are stored in a list (e.g. a &quot;hand&quot; joint may have multiple &quot;finger&quot; children joints).</summary>
        /// <param name="child">The new child joint of this joint.</param>
        public void AddChild(global::FlounderSharp.Joint child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public int Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public string Name
        {
            get
            {
                var __ret = __Internal.GetName((__Instance + __PointerAdjustment));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.CStr(__basicStringRet);
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.Matrix4 LocalBindTransform
        {
            get
            {
                var __ret = __Internal.GetLocalBindTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLocalBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>The animated transform is the transform that gets loaded up to the shader and is used to deform the vertices of the &quot;skin&quot;. It represents the transformation from the joint's bind position (in model-space) to the joint's desired animation pose (also in model-space). This matrix is calculated by taking the desired model-space transform of the joint and multiplying it by the inverse of the starting model-space transform of the joint.</summary>
        public global::FlounderSharp.Matrix4 AnimatedTransform
        {
            get
            {
                var __ret = __Internal.GetAnimatedTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAnimatedTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>This returns the inverted model-space bind transform. The bind transform is the original model-space transform of the joint (when no animation is applied). This returns the inverse of that, which is used to calculate the animated transform matrix which gets used to transform vertices in the shader.</summary>
        public global::FlounderSharp.Matrix4 InverseBindTransform
        {
            get
            {
                var __ret = __Internal.GetInverseBindTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>This class contains all the functionality to apply an animation to an animated entity. An Animator instance is associated with just one animated entity. It also keeps track of the running time (in seconds) of the current animation, along with a reference to the currently playing animation for the corresponding entity.  An Animator instance needs to be updated every frame, in order for it to keep updating the animation pose of the associated entity. The currently playing animation can be changed at any time using the doAnimation() method. The Animator will keep looping the current animation until a new animation is chosen.  The Animator calculates the desired current animation pose by interpolating between the previous and next keyframes of the animation (based on the current animation time). The Animator then updates the transforms all of the joints each frame to match the current desired animation pose.</summary>
    public unsafe partial class Animator : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_rootJoint;

            [FieldOffset(8)]
            internal float m_animationTime;

            [FieldOffset(16)]
            internal global::System.IntPtr m_currentAnimation;

            [FieldOffset(24)]
            internal global::System.IntPtr m_animatorTransformation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animator@fl@@QEAA@PEAVJoint@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr rootJoint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animator@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Animator@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Animator@fl@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IncreaseAnimationTime@Animator@fl@@QEAAXXZ")]
            internal static extern void IncreaseAnimationTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateProgression@Animator@fl@@QEAAMAEBVKeyframe@2@0@Z")]
            internal static extern float CalculateProgression(global::System.IntPtr instance, global::System.IntPtr previousFrame, global::System.IntPtr nextFrame);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DoAnimation@Animator@fl@@QEAAXPEAVAnimation@2@@Z")]
            internal static extern void DoAnimation(global::System.IntPtr instance, global::System.IntPtr animation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentAnimation@Animator@fl@@QEBAPEAVAnimation@2@XZ")]
            internal static extern global::System.IntPtr GetCurrentAnimation(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Animator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Animator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Animator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Animator(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Animator __CreateInstance(global::FlounderSharp.Animator.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Animator(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Animator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Animator.__Internal));
            *(global::FlounderSharp.Animator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Animator(global::FlounderSharp.Animator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Animator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new animator.</summary>
        /// <param name="rootJoint">The root joint of the joint hierarchy which makes up the &quot;skeleton&quot; of the entity.</param>
        public Animator(global::FlounderSharp.Joint rootJoint)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Animator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(rootJoint, null) ? global::System.IntPtr.Zero : rootJoint.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Animator(global::FlounderSharp.Animator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Animator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Animator.__Internal*) __Instance) = *((global::FlounderSharp.Animator.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Animator __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>This method should be called each frame to update the animation currently being played. This increases the animation time (and loops it back to zero if necessary), finds the pose that the entity should be in at that time of the animation, and then applied that pose to all the entity's joints.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        /// <summary>Increases the current animation time which allows the animation to progress. If the current animation has reached the end then the timer is reset, causing the animation to loop.</summary>
        public void IncreaseAnimationTime()
        {
            __Internal.IncreaseAnimationTime((__Instance + __PointerAdjustment));
        }

        /// <summary>Calculates how far between the previous and next keyframe the current animation time is, and returns it as a value between 0 and 1.</summary>
        /// <param name="previousFrame">The previous keyframe in the animation.</param>
        /// <param name="nextFrame">The next keyframe in the animation.</param>
        public float CalculateProgression(global::FlounderSharp.Keyframe previousFrame, global::FlounderSharp.Keyframe nextFrame)
        {
            if (ReferenceEquals(previousFrame, null))
                throw new global::System.ArgumentNullException("previousFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = previousFrame.__Instance;
            if (ReferenceEquals(nextFrame, null))
                throw new global::System.ArgumentNullException("nextFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = nextFrame.__Instance;
            var __ret = __Internal.CalculateProgression((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Indicates that the entity should carry out the given animation. Resets the animation time so that the new animation starts from the beginning.</summary>
        /// <param name="animation">The new animation to carry out.</param>
        public void DoAnimation(global::FlounderSharp.Animation animation)
        {
            var __arg0 = ReferenceEquals(animation, null) ? global::System.IntPtr.Zero : animation.__Instance;
            __Internal.DoAnimation((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::FlounderSharp.Animator(global::FlounderSharp.Joint rootJoint)
        {
            return new global::FlounderSharp.Animator(rootJoint);
        }

        public global::FlounderSharp.Animation CurrentAnimation
        {
            get
            {
                var __ret = __Internal.GetCurrentAnimation((__Instance + __PointerAdjustment));
                global::FlounderSharp.Animation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Animation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Animation) global::FlounderSharp.Animation.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Animation.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 2-tuple vector.</summary>
    public unsafe partial class Vector2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Vector2._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@fl@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@fl@@QEAA@AEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Vector2@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector2@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector2@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector2@fl@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@fl@@QEBA?AV12@AEBM@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@fl@@QEBA?AV12@AEBMAEBV12@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float angle, global::System.IntPtr rotationAxis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector2@fl@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector2@fl@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector2@fl@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector2@fl@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InTriangle@Vector2@fl@@QEBA_NAEBV12@00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InTriangle(global::System.IntPtr instance, global::System.IntPtr v1, global::System.IntPtr v2, global::System.IntPtr v3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector2@fl@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Vector2@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector2@fl@@QEAA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector2@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector2@0@V10@M@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector2@0@V10@M@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector2@0@V10@M@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector2@0@V10@M@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Vector2.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVVector2@0@MV10@@Z")]
            internal static extern void OperatorPlus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector2.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVVector2@0@MV10@@Z")]
            internal static extern void OperatorMinus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector2.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVVector2@0@MV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector2.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVVector2@0@MV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, float value, global::FlounderSharp.Vector2.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector2@fl@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector2@fl@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector2@fl@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector2@fl@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector2@fl@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector2@fl@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector2@fl@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector2@fl@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CartesianToPolar@Vector2@fl@@QEBA?AV12@XZ")]
            internal static extern void CartesianToPolar(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PolarToCartesian@Vector2@fl@@QEBA?AV12@XZ")]
            internal static extern void PolarToCartesian(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Vector2._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Vector2._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float m_x;

                    [FieldOffset(4)]
                    internal float m_y;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Vector2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Vector2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Vector2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Vector2(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Vector2 __CreateInstance(global::FlounderSharp.Vector2.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Vector2(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Vector2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector2.__Internal));
            global::FlounderSharp.Vector2.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector2(global::FlounderSharp.Vector2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector2.</summary>
        public Vector2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        public Vector2(float x, float y)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::FlounderSharp.Vector2 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::FlounderSharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Vector2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector2 Add(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector2 Subtract(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector2 Multiply(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector2 Divide(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::FlounderSharp.Vector2 Scale(float scalar)
        {
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around the origin.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        public global::FlounderSharp.Vector2 Rotate(float angle)
        {
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), angle);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around a rotation axis.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        /// <param name="rotationAxis">The point to rotate the vector around.</param>
        public global::FlounderSharp.Vector2 Rotate(float angle, global::FlounderSharp.Vector2 rotationAxis)
        {
            if (ReferenceEquals(rotationAxis, null))
                throw new global::System.ArgumentNullException("rotationAxis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotationAxis.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), angle, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::FlounderSharp.Vector2 Negate()
        {
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::FlounderSharp.Vector2 Normalize()
        {
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector2 DistanceVector(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets if this vector is in a triangle.</summary>
        /// <param name="v1">The first triangle vertex.</param>
        /// <param name="v2">The second triangle vertex.</param>
        /// <param name="v3">The third triangle vertex.</param>
        public bool InTriangle(global::FlounderSharp.Vector2 v1, global::FlounderSharp.Vector2 v2, global::FlounderSharp.Vector2 v3)
        {
            if (ReferenceEquals(v1, null))
                throw new global::System.ArgumentNullException("v1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = v1.__Instance;
            if (ReferenceEquals(v2, null))
                throw new global::System.ArgumentNullException("v2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = v2.__Instance;
            if (ReferenceEquals(v3, null))
                throw new global::System.ArgumentNullException("v3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = v3.__Instance;
            var __ret = __Internal.InTriangle((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::FlounderSharp.Vector2 SmoothDamp(global::FlounderSharp.Vector2 target, global::FlounderSharp.Vector2 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Saves this vector into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Vector2 __op, global::FlounderSharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Vector2;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Vector2.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Vector2 __op, global::FlounderSharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::FlounderSharp.Vector2 __op, global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::FlounderSharp.Vector2 __op, global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::FlounderSharp.Vector2 __op, global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::FlounderSharp.Vector2 __op, global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::FlounderSharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::FlounderSharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public static global::FlounderSharp.Vector2 operator -(global::FlounderSharp.Vector2 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Vector2(global::FlounderSharp.Vector3 source)
        {
            return new global::FlounderSharp.Vector2(source);
        }

        public static global::FlounderSharp.Vector2 operator +(global::FlounderSharp.Vector2 left, global::FlounderSharp.Vector2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator -(global::FlounderSharp.Vector2 left, global::FlounderSharp.Vector2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator *(global::FlounderSharp.Vector2 left, global::FlounderSharp.Vector2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator /(global::FlounderSharp.Vector2 left, global::FlounderSharp.Vector2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator +(global::FlounderSharp.Vector2 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator -(global::FlounderSharp.Vector2 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator *(global::FlounderSharp.Vector2 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator /(global::FlounderSharp.Vector2 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator +(float value, global::FlounderSharp.Vector2 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorPlus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator -(float value, global::FlounderSharp.Vector2 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorMinus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator *(float value, global::FlounderSharp.Vector2 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 operator /(float value, global::FlounderSharp.Vector2 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Vector2 Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector2 One
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ONE@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector2 Left
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?LEFT@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector2 Right
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?RIGHT@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector2 Up
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?UP@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector2 Down
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?DOWN@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector2 PositiveInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?POSITIVE_INFINITY@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Vector2 NegativeInfinity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?NEGATIVE_INFINITY@Vector2@fl@@2V12@B");
                return global::FlounderSharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Converts from rectangular to spherical coordinates, this vector is in cartesian (x, y).</summary>
        public global::FlounderSharp.Vector2 CartesianToPolar
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector2.__Internal();
                __Internal.CartesianToPolar((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector2.__CreateInstance(__ret);
            }
        }

        /// <summary>Converts from spherical to rectangular coordinates, this vector is in polar (radius, theta).</summary>
        public global::FlounderSharp.Vector2 PolarToCartesian
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector2.__Internal();
                __Internal.PolarToCartesian((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector2.__CreateInstance(__ret);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds position, rotation, and scale components.</summary>
    public unsafe partial class Transform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_position;

            [FieldOffset(8)]
            internal global::System.IntPtr m_rotation;

            [FieldOffset(16)]
            internal global::System.IntPtr m_scaling;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@fl@@QEAA@AEBVVector3@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation, global::System.IntPtr scaling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@fl@@QEAA@AEBVVector3@1@0AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Transform@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Transform@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Transform@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Transform@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Transform@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Transform@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@Transform@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRotation@Transform@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetRotation(global::System.IntPtr instance, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScaling@Transform@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetScaling(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaling@Transform@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetScaling(global::System.IntPtr instance, global::System.IntPtr scaling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorldMatrix@Transform@fl@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetWorldMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModelMatrix@Transform@fl@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetModelMatrix(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Transform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Transform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Transform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Transform(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Transform __CreateInstance(global::FlounderSharp.Transform.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Transform(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Transform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Transform.__Internal));
            global::FlounderSharp.Transform.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Transform(global::FlounderSharp.Transform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Transform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Transform.</summary>
        public Transform()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="source">Creates this vector out of a transform.</param>
        public Transform(global::FlounderSharp.Transform source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scaling">The scaling.</param>
        public Transform(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 rotation, global::FlounderSharp.Vector3 scaling)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scaling, null))
                throw new global::System.ArgumentNullException("scaling", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scaling.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scale">The scale.</param>
        public Transform(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 rotation, float scale)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, scale);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Transform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Saves this transform into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Transform __op, global::FlounderSharp.Transform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Transform;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Transform.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Transform __op, global::FlounderSharp.Transform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector3 Rotation
        {
            get
            {
                var __ret = __Internal.GetRotation((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector3 Scaling
        {
            get
            {
                var __ret = __Internal.GetScaling((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScaling((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Matrix4 WorldMatrix
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix4.__Internal();
                __Internal.GetWorldMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
            }
        }

        public global::FlounderSharp.Matrix4 ModelMatrix
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix4.__Internal();
                __Internal.GetModelMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe abstract partial class Component : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Component@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Component@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Component@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnabled@Component@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetEnabled(global::System.IntPtr instance, bool enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGameObject@Component@fl@@QEBAPEAVGameObject@2@XZ")]
            internal static extern global::System.IntPtr GetGameObject(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGameObject@Component@fl@@QEAAXPEAVGameObject@2@@Z")]
            internal static extern void SetGameObject(global::System.IntPtr instance, global::System.IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsEnabled@Component@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsEnabled(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Component> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Component>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Component __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ComponentInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Component __CreateInstance(global::FlounderSharp.Component.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ComponentInternal(native, skipVTables);
        }

        protected Component(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected Component()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Component.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Component");
        }

        protected Component(global::FlounderSharp.Component _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Component.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Component");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Component __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.Component.__Internal*) __Instance)->vfptr_Component = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Update();

        public abstract void Load(global::FlounderSharp.LoadedValue value);

        public abstract void Write(global::FlounderSharp.LoadedValue value);

        public void SetEnabled(bool enable)
        {
            __Internal.SetEnabled((__Instance + __PointerAdjustment), enable);
        }

        public abstract string Name
        {
            get;

            set;
        }

        public global::FlounderSharp.GameObject GameObject
        {
            get
            {
                var __ret = __Internal.GetGameObject((__Instance + __PointerAdjustment));
                global::FlounderSharp.GameObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.GameObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.NativeToManagedMap[__ret];
                else global::FlounderSharp.GameObject.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetGameObject((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsEnabled
        {
            get
            {
                var __ret = __Internal.IsEnabled((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~Component()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Component) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Component) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Component) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Component) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Component) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class ComponentInternal : global::FlounderSharp.Component, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.Component.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Component.__Internal));
            *(global::FlounderSharp.Component.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ComponentInternal(global::FlounderSharp.Component.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ComponentInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }
    }
}

namespace FlounderSharp
{
    public enum FrustumPlanes
    {
        FrustumRight = 0,
        FrustumLeft = 1,
        FrustumBottom = 2,
        FrustumTop = 3,
        FrustumBack = 4,
        FrustumFront = 5
    }

    public enum FrustumFace
    {
        FrustumA = 0,
        FrustumB = 1,
        FrustumC = 2,
        FrustumD = 3
    }

    /// <summary>Represents the region of flounder.space in the modeled world that may appear on the screen.</summary>
    public unsafe partial class Frustum : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_frustumArray;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Frustum@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Frustum@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Frustum@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Frustum@fl@@QEBAXAEBVMatrix4@2@0@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr viewMatrix, global::System.IntPtr projectionMatrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PointInFrustum@Frustum@fl@@QEBA_NAEBVVector3@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PointInFrustum(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SphereInFrustum@Frustum@fl@@QEBA_NAEBVVector3@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SphereInFrustum(global::System.IntPtr instance, global::System.IntPtr position, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CubeInFrustum@Frustum@fl@@QEBA_NAEBVVector3@2@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CubeInFrustum(global::System.IntPtr instance, global::System.IntPtr min, global::System.IntPtr max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFrustumArray@Frustum@fl@@QEBAPEAPEAMXZ")]
            internal static extern float** GetFrustumArray(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Frustum> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Frustum>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Frustum __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Frustum(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Frustum __CreateInstance(global::FlounderSharp.Frustum.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Frustum(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Frustum.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Frustum.__Internal));
            *(global::FlounderSharp.Frustum.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Frustum(global::FlounderSharp.Frustum.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Frustum(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new frustum.</summary>
        public Frustum()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Frustum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Frustum(global::FlounderSharp.Frustum _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Frustum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Frustum.__Internal*) __Instance) = *((global::FlounderSharp.Frustum.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Frustum __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates a frustum from the view and projection matrix.</summary>
        /// <param name="viewMatrix">The view matrix.</param>
        /// <param name="projectionMatrix">The projection matrix.</param>
        public void Update(global::FlounderSharp.Matrix4 viewMatrix, global::FlounderSharp.Matrix4 projectionMatrix)
        {
            if (ReferenceEquals(viewMatrix, null))
                throw new global::System.ArgumentNullException("viewMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = viewMatrix.__Instance;
            if (ReferenceEquals(projectionMatrix, null))
                throw new global::System.ArgumentNullException("projectionMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = projectionMatrix.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Is the point contained in the frustum?</summary>
        /// <param name="position">The points position.</param>
        public bool PointInFrustum(global::FlounderSharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = __Internal.PointInFrustum((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Is the sphere contained in the frustum?</summary>
        /// <param name="position">The points position.</param>
        /// <param name="radius">The spheres radius.</param>
        public bool SphereInFrustum(global::FlounderSharp.Vector3 position, float radius)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = __Internal.SphereInFrustum((__Instance + __PointerAdjustment), __arg0, radius);
            return __ret;
        }

        /// <summary>Is the cube contained partially in the frustum?</summary>
        /// <param name="min">The point 1st position.</param>
        /// <param name="max">The point 2nd position.</param>
        public bool CubeInFrustum(global::FlounderSharp.Vector3 min, global::FlounderSharp.Vector3 max)
        {
            if (ReferenceEquals(min, null))
                throw new global::System.ArgumentNullException("min", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = min.__Instance;
            if (ReferenceEquals(max, null))
                throw new global::System.ArgumentNullException("max", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = max.__Instance;
            var __ret = __Internal.CubeInFrustum((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }


        public float** FrustumArray
        {
            get
            {
                var __ret = __Internal.GetFrustumArray((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A data structure that stores objects with a notion of flounder.space.</summary>
    public unsafe abstract partial class ISpatialStructure : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpatialStructure;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpatialStructure@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpatialStructure@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ISpatialStructure@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ISpatialStructure> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ISpatialStructure>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ISpatialStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ISpatialStructureInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ISpatialStructure __CreateInstance(global::FlounderSharp.ISpatialStructure.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ISpatialStructureInternal(native, skipVTables);
        }

        protected ISpatialStructure(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new spatial structure.</summary>
        protected ISpatialStructure()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ISpatialStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.ISpatialStructure");
        }

        protected ISpatialStructure(global::FlounderSharp.ISpatialStructure _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ISpatialStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ISpatialStructure");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ISpatialStructure __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.ISpatialStructure.__Internal*) __Instance)->vfptr_ISpatialStructure = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds a new object to the spatial structure.</summary>
        /// <param name="object">The object to add.</param>
        public abstract void Add(global::FlounderSharp.GameObject targetObject);

        /// <summary>Removes an object from the spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        public abstract void Remove(global::FlounderSharp.GameObject targetObject);

        /// <summary>Removes all objects from the spatial structure..</summary>
        public abstract void Clear();

        /// <summary>If the structure contains the object.</summary>
        /// <param name="object">The object to check for.</param>
        public abstract bool Contains(global::FlounderSharp.GameObject targetObject);

        /// <summary>Gets the size of this structure.</summary>
        public abstract uint Size
        {
            get;
        }

        #region Virtual table interop

        // virtual ~ISpatialStructure() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Add(GameObject *object) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _AddDelegateInstance;

        private static void _AddDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.__CreateInstance(targetObject, skipVTables: true);
            __target.Add(__result0);
        }

        // void Remove(GameObject *object) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RemoveDelegateInstance;

        private static void _RemoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.__CreateInstance(targetObject, skipVTables: true);
            __target.Remove(__result0);
        }

        // void Clear() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // unsigned int GetSize() = 0
        private static global::FlounderSharp.Delegates.Func_uint_IntPtr _GetSizeDelegateInstance;

        private static uint _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        // bool Contains(GameObject *object) = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.__CreateInstance(targetObject, skipVTables: true);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _AddDelegateInstance += _AddDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                _RemoveDelegateInstance += _RemoveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = _Thunks[5];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class ISpatialStructureInternal : global::FlounderSharp.ISpatialStructure, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.ISpatialStructure.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ISpatialStructure.__Internal));
            *(global::FlounderSharp.ISpatialStructure.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ISpatialStructureInternal(global::FlounderSharp.ISpatialStructure.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ISpatialStructureInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Adds a new object to the spatial structure.</summary>
        /// <param name="object">The object to add.</param>
        public override void Add(global::FlounderSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___AddDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            ___AddDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Removes an object from the spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        public override void Remove(global::FlounderSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___RemoveDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            ___RemoveDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Removes all objects from the spatial structure..</summary>
        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___ClearDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>If the structure contains the object.</summary>
        /// <param name="object">The object to check for.</param>
        public override bool Contains(global::FlounderSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
            var ___ContainsDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the size of this structure.</summary>
        public override uint Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetSizeDelegate = (global::FlounderSharp.Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_uint_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class GameObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_GameObject;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_transform;

            [FieldOffset(48)]
            internal global::System.IntPtr m_components;

            [FieldOffset(56)]
            internal global::System.IntPtr m_structure;

            [FieldOffset(64)]
            internal byte m_removed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@fl@@QEAA@AEBVTransform@1@PEAVISpatialStructure@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr transform, global::System.IntPtr structure, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVTransform@1@PEAVISpatialStructure@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr prefabName, global::System.IntPtr transform, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddComponent@GameObject@fl@@QEAAPEAVComponent@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddComponent(global::System.IntPtr instance, global::System.IntPtr component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveComponent@GameObject@fl@@QEAAPEAVComponent@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr RemoveComponent(global::System.IntPtr instance, global::System.IntPtr component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StructureSwitch@GameObject@fl@@QEAAXPEAVISpatialStructure@2@@Z")]
            internal static extern void StructureSwitch(global::System.IntPtr instance, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StructureRemove@GameObject@fl@@QEAAXXZ")]
            internal static extern void StructureRemove(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@GameObject@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@GameObject@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransform@GameObject@fl@@QEBAPEAVTransform@2@XZ")]
            internal static extern global::System.IntPtr GetTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTransform@GameObject@fl@@QEBAXAEBVTransform@2@@Z")]
            internal static extern void SetTransform(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@GameObject@fl@@QEBAPEAVISpatialStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRemoved@GameObject@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRemoved(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.GameObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.GameObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.GameObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.GameObject(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.GameObject __CreateInstance(global::FlounderSharp.GameObject.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.GameObject(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.GameObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GameObject.__Internal));
            global::FlounderSharp.GameObject.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private GameObject(global::FlounderSharp.GameObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GameObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public GameObject(global::FlounderSharp.Transform transform, global::FlounderSharp.ISpatialStructure structure, string name)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            var __arg1 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(name, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.GameObject");
        }

        public GameObject(string prefabName, global::FlounderSharp.Transform transform, global::FlounderSharp.ISpatialStructure structure)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(prefabName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = transform.__Instance;
            var __arg2 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.GameObject");
        }

        public GameObject(global::FlounderSharp.GameObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.GameObject");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.GameObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.GameObject.__Internal*) __Instance)->vfptr_GameObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public virtual void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public global::FlounderSharp.Component AddComponent(global::FlounderSharp.Component component)
        {
            var __arg0 = ReferenceEquals(component, null) ? global::System.IntPtr.Zero : component.__Instance;
            var __ret = __Internal.AddComponent((__Instance + __PointerAdjustment), __arg0);
            global::FlounderSharp.Component __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Component.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.NativeToManagedMap[__ret];
            else global::FlounderSharp.Component.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.Component RemoveComponent(global::FlounderSharp.Component component)
        {
            var __arg0 = ReferenceEquals(component, null) ? global::System.IntPtr.Zero : component.__Instance;
            var __ret = __Internal.RemoveComponent((__Instance + __PointerAdjustment), __arg0);
            global::FlounderSharp.Component __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Component.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.NativeToManagedMap[__ret];
            else global::FlounderSharp.Component.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.__CreateInstance(__ret);
            return __result0;
        }

        public void StructureSwitch(global::FlounderSharp.ISpatialStructure structure)
        {
            var __arg0 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            __Internal.StructureSwitch((__Instance + __PointerAdjustment), __arg0);
        }

        public void StructureRemove()
        {
            __Internal.StructureRemove((__Instance + __PointerAdjustment));
        }

        protected string MName
        {
            get
            {
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.GameObject.__Internal*) __Instance)->m_name));
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                ((global::FlounderSharp.GameObject.__Internal*)__Instance)->m_name = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }
        }

        protected global::FlounderSharp.Transform MTransform
        {
            get
            {
                global::FlounderSharp.Transform __result0;
                if (((global::FlounderSharp.GameObject.__Internal*) __Instance)->m_transform == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Transform.NativeToManagedMap.ContainsKey(((global::FlounderSharp.GameObject.__Internal*) __Instance)->m_transform))
                    __result0 = (global::FlounderSharp.Transform) global::FlounderSharp.Transform.NativeToManagedMap[((global::FlounderSharp.GameObject.__Internal*) __Instance)->m_transform];
                else __result0 = global::FlounderSharp.Transform.__CreateInstance(((global::FlounderSharp.GameObject.__Internal*) __Instance)->m_transform);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.GameObject.__Internal*)__Instance)->m_transform = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.Transform Transform
        {
            get
            {
                var __ret = __Internal.GetTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Transform __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Transform.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Transform) global::FlounderSharp.Transform.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Transform.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.ISpatialStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::FlounderSharp.ISpatialStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ISpatialStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ISpatialStructure) global::FlounderSharp.ISpatialStructure.NativeToManagedMap[__ret];
                else global::FlounderSharp.ISpatialStructure.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ISpatialStructure) global::FlounderSharp.ISpatialStructure.__CreateInstance(__ret);
                return __result0;
            }
        }

        public bool Removed
        {
            get
            {
                var __ret = __Internal.GetRemoved((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~GameObject()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.GameObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update()
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.GameObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A class that represents bounding intersect data.</summary>
    public unsafe partial class Intersect : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_intersects;

            [FieldOffset(4)]
            internal float m_distance;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Intersect@fl@@QEAA@AEB_NAEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool intersects, float distance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Intersect@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Intersect@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIntersection@Intersect@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsIntersection(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Intersect@fl@@QEBAMXZ")]
            internal static extern float Distance(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Intersect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Intersect>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Intersect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Intersect(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Intersect __CreateInstance(global::FlounderSharp.Intersect.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Intersect(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Intersect.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Intersect.__Internal));
            *(global::FlounderSharp.Intersect.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Intersect(global::FlounderSharp.Intersect.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Intersect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new bounding intersect data.</summary>
        /// <param name="intersects">If there is a collision.</param>
        /// <param name="distance">What distance that collision is at.</param>
        public Intersect(bool intersects, float distance)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Intersect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), intersects, distance);
        }

        public Intersect(global::FlounderSharp.Intersect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Intersect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Intersect.__Internal*) __Instance) = *((global::FlounderSharp.Intersect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Intersect __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if there is a intersection.</summary>
        public bool IsIntersection
        {
            get
            {
                var __ret = __Internal.IsIntersection((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the distance that intersection is at.</summary>
        public float Distance
        {
            get
            {
                var __ret = __Internal.Distance((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 3 dimensional ray.</summary>
    public unsafe partial class Ray : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_useMouse;

            [FieldOffset(8)]
            internal global::System.IntPtr m_screenStart;

            [FieldOffset(16)]
            internal global::System.IntPtr m_viewMatrix;

            [FieldOffset(24)]
            internal global::System.IntPtr m_projectionMatrix;

            [FieldOffset(32)]
            internal global::System.IntPtr m_normalizedCoords;

            [FieldOffset(40)]
            internal global::System.IntPtr m_clipCoords;

            [FieldOffset(48)]
            internal global::System.IntPtr m_eyeCoords;

            [FieldOffset(56)]
            internal global::System.IntPtr m_invertedProjection;

            [FieldOffset(64)]
            internal global::System.IntPtr m_invertedView;

            [FieldOffset(72)]
            internal global::System.IntPtr m_rayWorld;

            [FieldOffset(80)]
            internal global::System.IntPtr m_origin;

            [FieldOffset(88)]
            internal global::System.IntPtr m_currentRay;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ray@fl@@QEAA@AEB_NAEBVVector2@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool useMouse, global::System.IntPtr screenStart);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ray@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Ray@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Ray@fl@@QEAAXAEBVVector3@2@AEBVVector2@2@AEBVMatrix4@2@2@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr currentPosition, global::System.IntPtr mousePosition, global::System.IntPtr viewMatrix, global::System.IntPtr projectionMatrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPointOnRay@Ray@fl@@QEBA?AVVector3@2@AEBM@Z")]
            internal static extern void GetPointOnRay(global::System.IntPtr instance, global::System.IntPtr @return, float distance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ConvertToScreenSpace@Ray@fl@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void ConvertToScreenSpace(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Ray> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Ray>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Ray __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Ray(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Ray __CreateInstance(global::FlounderSharp.Ray.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Ray(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Ray.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Ray.__Internal));
            *(global::FlounderSharp.Ray.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Ray(global::FlounderSharp.Ray.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Ray(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new 3D ray.</summary>
        /// <param name="useMouse">If the ray will use the mouse coords or to start from screenStart.</param>
        /// <param name="screenStart">If useMouse is false then this will be used as the rays start.</param>
        public Ray(bool useMouse, global::FlounderSharp.Vector2 screenStart)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(screenStart, null))
                throw new global::System.ArgumentNullException("screenStart", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = screenStart.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), useMouse, __arg1);
        }

        public Ray(global::FlounderSharp.Ray _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Ray.__Internal*) __Instance) = *((global::FlounderSharp.Ray.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Ray __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the ray to a new position.</summary>
        /// <param name="currentPosition">The new position.</param>
        /// <param name="currentPosition">The mouses xy screen space position.</param>
        /// <param name="viewMatrix">The cameras view matrix.</param>
        /// <param name="projectionMatrix">The projection view matrix.</param>
        public void Update(global::FlounderSharp.Vector3 currentPosition, global::FlounderSharp.Vector2 mousePosition, global::FlounderSharp.Matrix4 viewMatrix, global::FlounderSharp.Matrix4 projectionMatrix)
        {
            if (ReferenceEquals(currentPosition, null))
                throw new global::System.ArgumentNullException("currentPosition", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = currentPosition.__Instance;
            if (ReferenceEquals(mousePosition, null))
                throw new global::System.ArgumentNullException("mousePosition", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = mousePosition.__Instance;
            if (ReferenceEquals(viewMatrix, null))
                throw new global::System.ArgumentNullException("viewMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = viewMatrix.__Instance;
            if (ReferenceEquals(projectionMatrix, null))
                throw new global::System.ArgumentNullException("projectionMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = projectionMatrix.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Gets a point on the ray.</summary>
        /// <param name="distance">Distance down the ray to sample.</param>
        public global::FlounderSharp.Vector3 GetPointOnRay(float distance)
        {
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.GetPointOnRay((__Instance + __PointerAdjustment), new IntPtr(&__ret), distance);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Converts a position from world space to screen space.</summary>
        /// <param name="position">The position to convert.</param>
        public global::FlounderSharp.Vector3 ConvertToScreenSpace(global::FlounderSharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.ConvertToScreenSpace((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public global::FlounderSharp.Vector3 MOrigin
        {
            get
            {
                global::FlounderSharp.Vector3 __result0;
                if (((global::FlounderSharp.Ray.__Internal*) __Instance)->m_origin == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(((global::FlounderSharp.Ray.__Internal*) __Instance)->m_origin))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[((global::FlounderSharp.Ray.__Internal*) __Instance)->m_origin];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(((global::FlounderSharp.Ray.__Internal*) __Instance)->m_origin);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.Ray.__Internal*)__Instance)->m_origin = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MCurrentRay
        {
            get
            {
                global::FlounderSharp.Vector3 __result0;
                if (((global::FlounderSharp.Ray.__Internal*) __Instance)->m_currentRay == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(((global::FlounderSharp.Ray.__Internal*) __Instance)->m_currentRay))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[((global::FlounderSharp.Ray.__Internal*) __Instance)->m_currentRay];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(((global::FlounderSharp.Ray.__Internal*) __Instance)->m_currentRay);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.Ray.__Internal*)__Instance)->m_currentRay = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A simple class that represents a physical shape.</summary>
    public unsafe abstract partial class Collider : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Collider@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Collider@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Collider@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.Collider __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ColliderInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Collider __CreateInstance(global::FlounderSharp.Collider.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ColliderInternal(native, skipVTables);
        }

        protected Collider(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new collider.</summary>
        protected Collider()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Collider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Collider");
        }

        protected Collider(global::FlounderSharp.Collider _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Collider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Collider");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Component __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.Collider.__Internal*) __Instance)->vfptr_Component = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Clones this collder into the destination and updates it.</summary>
        /// <param name="transform">The amount to transform the object.</param>
        /// <param name="destination">The collider to store the new data in.</param>
        public abstract global::FlounderSharp.Collider Update(global::FlounderSharp.Transform transform, global::FlounderSharp.Collider destination);

        /// <summary>Adjusts a movement amount so that after the move is performed, the this collider will not intersect the {@code right}. This method assumes that this collider can actually intersect {@code right} after some amount of movement, even if it won't necessarily intersect it after the movement specified by {@code moveDelta}.</summary>
        /// <param name="other">The right source collider.</param>
        /// <param name="positionDelta">The delta movement for the left collider.</param>
        /// <param name="destination">Where the final resolved delta should be stored.</param>
        public abstract global::FlounderSharp.Vector3 ResolveCollision(global::FlounderSharp.Collider other, global::FlounderSharp.Vector3 positionDelta, global::FlounderSharp.Vector3 destination);

        /// <summary>Tests whether a shape is intersecting this shape.</summary>
        /// <param name="other">The other shape being tested for intersection.</param>
        public abstract global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Collider other);

        /// <summary>Tests whether a ray is intersecting this shape.</summary>
        /// <param name="ray">The ray being tested for intersection.</param>
        public abstract global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Ray ray);

        /// <summary>Gets if the shape is partially in the view frustum.</summary>
        /// <param name="frustum">The view frustum.</param>
        public abstract bool InFrustum(global::FlounderSharp.Frustum frustum);

        /// <summary>Tests whether another this shape completely contains the other.</summary>
        /// <param name="other">The shape being tested for containment.</param>
        public abstract bool Contains(global::FlounderSharp.Collider other);

        /// <summary>Gets if a point is contained in this shape.</summary>
        /// <param name="point">The point to check if it is contained.</param>
        public abstract bool Contains(global::FlounderSharp.Vector3 point);

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~Collider()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "Collider"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Collider *Update(const Transform &transform, Collider *destination) = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr _Update_1DelegateInstance;

        private static global::System.IntPtr _Update_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr transform, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Transform __result0;
            if (transform == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Transform.NativeToManagedMap.ContainsKey(transform))
                __result0 = (global::FlounderSharp.Transform) global::FlounderSharp.Transform.NativeToManagedMap[transform];
            else __result0 = global::FlounderSharp.Transform.__CreateInstance(transform);
            global::FlounderSharp.Collider __result1;
            if (destination == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(destination))
                __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[destination];
            else __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(destination, skipVTables: true);
            var __ret = __target.Update(__result0, __result1);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Vector3 *ResolveCollision(const Collider &other, const Vector3 &positionDelta, Vector3 *destination) = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _ResolveCollisionDelegateInstance;

        private static global::System.IntPtr _ResolveCollisionDelegateHook(global::System.IntPtr instance, global::System.IntPtr other, global::System.IntPtr positionDelta, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result0;
            if (other == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            global::FlounderSharp.Vector3 __result1;
            if (positionDelta == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(positionDelta))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[positionDelta];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(positionDelta);
            global::FlounderSharp.Vector3 __result2;
            if (destination == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(destination))
                __result2 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[destination];
            else __result2 = global::FlounderSharp.Vector3.__CreateInstance(destination);
            var __ret = __target.ResolveCollision(__result0, __result1, __result2);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Intersect Intersects(const Ray &ray) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _Intersects_1DelegateInstance;

        private static void _Intersects_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr ray)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Ray __result1;
            if (ray == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Ray.NativeToManagedMap.ContainsKey(ray))
                __result1 = (global::FlounderSharp.Ray) global::FlounderSharp.Ray.NativeToManagedMap[ray];
            else __result1 = global::FlounderSharp.Ray.__CreateInstance(ray);
            var __ret = __target.Intersects(__result1);
            *(global::FlounderSharp.Intersect.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Intersect.__Internal() : *(global::FlounderSharp.Intersect.__Internal*) __ret.__Instance;
        }

        // Intersect Intersects(const Collider &other) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _IntersectsDelegateInstance;

        private static void _IntersectsDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result1;
            if (other == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            var __ret = __target.Intersects(__result1);
            *(global::FlounderSharp.Intersect.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Intersect.__Internal() : *(global::FlounderSharp.Intersect.__Internal*) __ret.__Instance;
        }

        // bool InFrustum(const Frustum &frustum) = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _InFrustumDelegateInstance;

        private static bool _InFrustumDelegateHook(global::System.IntPtr instance, global::System.IntPtr frustum)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Frustum __result0;
            if (frustum == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Frustum.NativeToManagedMap.ContainsKey(frustum))
                __result0 = (global::FlounderSharp.Frustum) global::FlounderSharp.Frustum.NativeToManagedMap[frustum];
            else __result0 = global::FlounderSharp.Frustum.__CreateInstance(frustum);
            var __ret = __target.InFrustum(__result0);
            return __ret;
        }

        // bool Contains(const Vector3 &point) = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _Contains_1DelegateInstance;

        private static bool _Contains_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr point)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result0;
            if (point == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(point))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[point];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(point);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        // bool Contains(const Collider &other) = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr other)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result0;
            if (other == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[12];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _Update_1DelegateInstance += _Update_1DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Update_1DelegateInstance).ToPointer();
                _ResolveCollisionDelegateInstance += _ResolveCollisionDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ResolveCollisionDelegateInstance).ToPointer();
                _Intersects_1DelegateInstance += _Intersects_1DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_Intersects_1DelegateInstance).ToPointer();
                _IntersectsDelegateInstance += _IntersectsDelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_IntersectsDelegateInstance).ToPointer();
                _InFrustumDelegateInstance += _InFrustumDelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_InFrustumDelegateInstance).ToPointer();
                _Contains_1DelegateInstance += _Contains_1DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_Contains_1DelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                    *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                    *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                    *(void**) (vfptr0 + 72) = _Thunks[8];
                    *(void**) (vfptr0 + 80) = _Thunks[9];
                    *(void**) (vfptr0 + 88) = _Thunks[10];
                    *(void**) (vfptr0 + 96) = _Thunks[11];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class ColliderInternal : global::FlounderSharp.Collider, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.Collider.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Collider.__Internal));
            *(global::FlounderSharp.Collider.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ColliderInternal(global::FlounderSharp.Collider.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ColliderInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Clones this collder into the destination and updates it.</summary>
        /// <param name="transform">The amount to transform the object.</param>
        /// <param name="destination">The collider to store the new data in.</param>
        public override global::FlounderSharp.Collider Update(global::FlounderSharp.Transform transform, global::FlounderSharp.Collider destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___Update_1Delegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            var __arg1 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = ___Update_1Delegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            global::FlounderSharp.Collider __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[__ret];
            else global::FlounderSharp.Collider.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Adjusts a movement amount so that after the move is performed, the this collider will not intersect the {@code right}. This method assumes that this collider can actually intersect {@code right} after some amount of movement, even if it won't necessarily intersect it after the movement specified by {@code moveDelta}.</summary>
        /// <param name="other">The right source collider.</param>
        /// <param name="positionDelta">The delta movement for the left collider.</param>
        /// <param name="destination">Where the final resolved delta should be stored.</param>
        public override global::FlounderSharp.Vector3 ResolveCollision(global::FlounderSharp.Collider other, global::FlounderSharp.Vector3 positionDelta, global::FlounderSharp.Vector3 destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___ResolveCollisionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            if (ReferenceEquals(positionDelta, null))
                throw new global::System.ArgumentNullException("positionDelta", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = positionDelta.__Instance;
            var __arg2 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = ___ResolveCollisionDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            global::FlounderSharp.Vector3 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Tests whether a shape is intersecting this shape.</summary>
        /// <param name="other">The other shape being tested for intersection.</param>
        public override global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Collider other)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
            var ___IntersectsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Intersect.__Internal();
            ___IntersectsDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Intersect.__CreateInstance(__ret);
        }

        /// <summary>Tests whether a ray is intersecting this shape.</summary>
        /// <param name="ray">The ray being tested for intersection.</param>
        public override global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Ray ray)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___Intersects_1Delegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = ray.__Instance;
            var __ret = new global::FlounderSharp.Intersect.__Internal();
            ___Intersects_1Delegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Intersect.__CreateInstance(__ret);
        }

        /// <summary>Gets if the shape is partially in the view frustum.</summary>
        /// <param name="frustum">The view frustum.</param>
        public override bool InFrustum(global::FlounderSharp.Frustum frustum)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
            var ___InFrustumDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(frustum, null))
                throw new global::System.ArgumentNullException("frustum", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frustum.__Instance;
            var __ret = ___InFrustumDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Tests whether another this shape completely contains the other.</summary>
        /// <param name="other">The shape being tested for containment.</param>
        public override bool Contains(global::FlounderSharp.Collider other)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
            var ___ContainsDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets if a point is contained in this shape.</summary>
        /// <param name="point">The point to check if it is contained.</param>
        public override bool Contains(global::FlounderSharp.Vector3 point)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
            var ___Contains_1Delegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(point, null))
                throw new global::System.ArgumentNullException("point", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = point.__Instance;
            var __ret = ___Contains_1Delegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A axis-aligned bounding box.</summary>
    public unsafe partial class ColliderAabb : global::FlounderSharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_minExtents;

            [FieldOffset(64)]
            internal global::System.IntPtr m_maxExtents;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderAabb@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderAabb@fl@@QEAA@AEBVVector3@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr minExtents, global::System.IntPtr maxExtents);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderAabb@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Set@ColliderAabb@fl@@QEAAPEAV12@AEBV12@@Z")]
            internal static extern global::System.IntPtr Set(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@ColliderAabb@fl@@SAPEAV12@AEBV12@AEBVVector3@2@PEAV12@@Z")]
            internal static extern global::System.IntPtr Scale(global::System.IntPtr source, global::System.IntPtr scale, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@ColliderAabb@fl@@SAPEAV12@AEBV12@AEBM11PEAV12@@Z")]
            internal static extern global::System.IntPtr Scale(global::System.IntPtr source, float scaleX, float scaleY, float scaleZ, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Expand@ColliderAabb@fl@@SAPEAV12@AEBV12@AEBVVector3@2@PEAV12@@Z")]
            internal static extern global::System.IntPtr Expand(global::System.IntPtr source, global::System.IntPtr expand, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Expand@ColliderAabb@fl@@SAPEAV12@AEBV12@AEBM11PEAV12@@Z")]
            internal static extern global::System.IntPtr Expand(global::System.IntPtr source, float expandX, float expandY, float expandZ, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Combine@ColliderAabb@fl@@SAPEAV12@AEBV12@0PEAV12@@Z")]
            internal static extern global::System.IntPtr Combine(global::System.IntPtr left, global::System.IntPtr right, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Stretch@ColliderAabb@fl@@SAPEAV12@AEBV12@AEBVVector3@2@PEAV12@@Z")]
            internal static extern global::System.IntPtr Stretch(global::System.IntPtr source, global::System.IntPtr stretch, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Stretch@ColliderAabb@fl@@SAPEAV12@AEBV12@AEBM11PEAV12@@Z")]
            internal static extern global::System.IntPtr Stretch(global::System.IntPtr source, float stretchX, float stretchY, float stretchZ, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMinExtents@ColliderAabb@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetMinExtents(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMinExtents@ColliderAabb@fl@@QEBAXAEBVVector3@2@@Z")]
            internal static extern void SetMinExtents(global::System.IntPtr instance, global::System.IntPtr minExtents);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxExtents@ColliderAabb@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetMaxExtents(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMaxExtents@ColliderAabb@fl@@QEBAXAEBVVector3@2@@Z")]
            internal static extern void SetMaxExtents(global::System.IntPtr instance, global::System.IntPtr maxExtents);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCentreX@ColliderAabb@fl@@QEBAMXZ")]
            internal static extern float GetCentreX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCentreY@ColliderAabb@fl@@QEBAMXZ")]
            internal static extern float GetCentreY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCentreZ@ColliderAabb@fl@@QEBAMXZ")]
            internal static extern float GetCentreZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@ColliderAabb@fl@@QEBAMXZ")]
            internal static extern float GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@ColliderAabb@fl@@QEBAMXZ")]
            internal static extern float GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepth@ColliderAabb@fl@@QEBAMXZ")]
            internal static extern float GetDepth(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.ColliderAabb __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ColliderAabb(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ColliderAabb __CreateInstance(global::FlounderSharp.ColliderAabb.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ColliderAabb(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ColliderAabb.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderAabb.__Internal));
            global::FlounderSharp.ColliderAabb.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderAabb(global::FlounderSharp.ColliderAabb.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderAabb(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new unit aabb.</summary>
        public ColliderAabb()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderAabb.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.ColliderAabb");
        }

        /// <summary>Creates a new aabb</summary>
        /// <param name="minExtents">The aabbs min extents.</param>
        /// <param name="minExtents">The aabbs max extents.</param>
        public ColliderAabb(global::FlounderSharp.Vector3 minExtents, global::FlounderSharp.Vector3 maxExtents)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderAabb.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(minExtents, null))
                throw new global::System.ArgumentNullException("minExtents", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = minExtents.__Instance;
            if (ReferenceEquals(maxExtents, null))
                throw new global::System.ArgumentNullException("maxExtents", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = maxExtents.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.ColliderAabb");
        }

        /// <summary>Creates a new aabb from another aavv source.</summary>
        /// <param name="source">The source to create off of.</param>
        public ColliderAabb(global::FlounderSharp.ColliderAabb source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderAabb.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ColliderAabb");
        }

        /// <summary>Loads from another Aabb.</summary>
        /// <param name="source">The source aabb.</param>
        public global::FlounderSharp.ColliderAabb Set(global::FlounderSharp.ColliderAabb source)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __ret = __Internal.Set((__Instance + __PointerAdjustment), __arg0);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        public override global::FlounderSharp.Collider Update(global::FlounderSharp.Transform transform, global::FlounderSharp.Collider destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            var __arg1 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = ___UpdateDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            global::FlounderSharp.Collider __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[__ret];
            else global::FlounderSharp.Collider.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(__ret);
            return __result0;
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            base.Load(value);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            base.Write(value);
        }

        public override global::FlounderSharp.Vector3 ResolveCollision(global::FlounderSharp.Collider other, global::FlounderSharp.Vector3 positionDelta, global::FlounderSharp.Vector3 destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___ResolveCollisionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            if (ReferenceEquals(positionDelta, null))
                throw new global::System.ArgumentNullException("positionDelta", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = positionDelta.__Instance;
            var __arg2 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = ___ResolveCollisionDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            global::FlounderSharp.Vector3 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
            return __result0;
        }

        public override global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Collider other)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
            var ___IntersectsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Intersect.__Internal();
            ___IntersectsDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Intersect.__CreateInstance(__ret);
        }

        public override global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Ray ray)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___Intersects_1Delegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = ray.__Instance;
            var __ret = new global::FlounderSharp.Intersect.__Internal();
            ___Intersects_1Delegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Intersect.__CreateInstance(__ret);
        }

        public override bool InFrustum(global::FlounderSharp.Frustum frustum)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
            var ___InFrustumDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(frustum, null))
                throw new global::System.ArgumentNullException("frustum", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frustum.__Instance;
            var __ret = ___InFrustumDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override bool Contains(global::FlounderSharp.Collider other)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
            var ___ContainsDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override bool Contains(global::FlounderSharp.Vector3 point)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
            var ___Contains_1Delegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(point, null))
                throw new global::System.ArgumentNullException("point", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = point.__Instance;
            var __ret = ___Contains_1Delegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Creates a new aabb equivalent to this, scaled away from the centre origin.</summary>
        /// <param name="source">The source aabb.</param>
        /// <param name="scale">Amount to scale up the aabb.</param>
        /// <param name="destination">The destination aabb or null if a new aabb is to be created.</param>
        public static global::FlounderSharp.ColliderAabb Scale(global::FlounderSharp.ColliderAabb source, global::FlounderSharp.Vector3 scale, global::FlounderSharp.ColliderAabb destination)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = scale.__Instance;
            var __arg2 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = __Internal.Scale(__arg0, __arg1, __arg2);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Creates a new aabb equivalent to this, scaled away from the centre origin.</summary>
        /// <param name="source">The source aabb.</param>
        /// <param name="scaleX">Amount to scale up the aabb on X.</param>
        /// <param name="scaleY">Amount to scale up the aabb on Y.</param>
        /// <param name="scaleZ">Amount to scale up the aabb on Z.</param>
        /// <param name="destination">The destination aabb or null if a new aabb is to be created.</param>
        public static global::FlounderSharp.ColliderAabb Scale(global::FlounderSharp.ColliderAabb source, float scaleX, float scaleY, float scaleZ, global::FlounderSharp.ColliderAabb destination)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg4 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = __Internal.Scale(__arg0, scaleX, scaleY, scaleZ, __arg4);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Creates a new aabb equivalent to this, but scaled away from the origin by a certain amount.</summary>
        /// <param name="source">The source aabb.</param>
        /// <param name="expand">Amount to scale up the aabb.</param>
        /// <param name="destination">The destination aabb or null if a new aabb is to be created.</param>
        public static global::FlounderSharp.ColliderAabb Expand(global::FlounderSharp.ColliderAabb source, global::FlounderSharp.Vector3 expand, global::FlounderSharp.ColliderAabb destination)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            if (ReferenceEquals(expand, null))
                throw new global::System.ArgumentNullException("expand", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = expand.__Instance;
            var __arg2 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = __Internal.Expand(__arg0, __arg1, __arg2);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Creates a new aabb equivalent to this, but scaled away from the origin by a certain amount.</summary>
        /// <param name="source">The source aabb.</param>
        /// <param name="expandX">Amount to scale up the aabb on X.</param>
        /// <param name="expandY">Amount to scale up the aabb on Y.</param>
        /// <param name="expandZ">Amount to scale up the aabb on Z.</param>
        /// <param name="destination">The destination aabb or null if a new aabb is to be created.</param>
        public static global::FlounderSharp.ColliderAabb Expand(global::FlounderSharp.ColliderAabb source, float expandX, float expandY, float expandZ, global::FlounderSharp.ColliderAabb destination)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg4 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = __Internal.Expand(__arg0, expandX, expandY, expandZ, __arg4);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Creates an aabb that bounds both this aabb and another aabb.</summary>
        /// <param name="left">The left source aabb.</param>
        /// <param name="right">The right source aabb.</param>
        /// <param name="destination">The destination aabb or null if a new aabb is to be created.</param>
        public static global::FlounderSharp.ColliderAabb Combine(global::FlounderSharp.ColliderAabb left, global::FlounderSharp.ColliderAabb right, global::FlounderSharp.ColliderAabb destination)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __arg2 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = __Internal.Combine(__arg0, __arg1, __arg2);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Creates a new aabb equivalent to this, but stretched by a certain amount.</summary>
        /// <param name="source">The source aabb.</param>
        /// <param name="stretch">The amount to stretch.</param>
        /// <param name="destination">The destination aabb or null if a new aabb is to be created.</param>
        public static global::FlounderSharp.ColliderAabb Stretch(global::FlounderSharp.ColliderAabb source, global::FlounderSharp.Vector3 stretch, global::FlounderSharp.ColliderAabb destination)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            if (ReferenceEquals(stretch, null))
                throw new global::System.ArgumentNullException("stretch", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = stretch.__Instance;
            var __arg2 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = __Internal.Stretch(__arg0, __arg1, __arg2);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Creates a new aabb equivalent to this, but stretched by a certain amount.</summary>
        /// <param name="source">The source aabb.</param>
        /// <param name="stretchX">The amount to stretch on the X.</param>
        /// <param name="stretchY">The amount to stretch on the Y.</param>
        /// <param name="stretchZ">The amount to stretch on the Z.</param>
        /// <param name="destination">The destination aabb or null if a new aabb is to be created.</param>
        public static global::FlounderSharp.ColliderAabb Stretch(global::FlounderSharp.ColliderAabb source, float stretchX, float stretchY, float stretchZ, global::FlounderSharp.ColliderAabb destination)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg4 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = __Internal.Stretch(__arg0, stretchX, stretchY, stretchZ, __arg4);
            global::FlounderSharp.ColliderAabb __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
            else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.Vector3 MMinExtents
        {
            get
            {
                global::FlounderSharp.Vector3 __result0;
                if (((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_minExtents == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_minExtents))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_minExtents];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_minExtents);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.ColliderAabb.__Internal*)__Instance)->m_minExtents = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MMaxExtents
        {
            get
            {
                global::FlounderSharp.Vector3 __result0;
                if (((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_maxExtents == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_maxExtents))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_maxExtents];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(((global::FlounderSharp.ColliderAabb.__Internal*) __Instance)->m_maxExtents);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.ColliderAabb.__Internal*)__Instance)->m_maxExtents = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MinExtents
        {
            get
            {
                var __ret = __Internal.GetMinExtents((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetMinExtents((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector3 MaxExtents
        {
            get
            {
                var __ret = __Internal.GetMaxExtents((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetMaxExtents((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Calculates the centre of this aabb on the X axis.</summary>
        public float CentreX
        {
            get
            {
                var __ret = __Internal.GetCentreX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Calculates the centre of this aabb on the Y axis.</summary>
        public float CentreY
        {
            get
            {
                var __ret = __Internal.GetCentreY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Calculates the centre of this aabb on the Z axis.</summary>
        public float CentreZ
        {
            get
            {
                var __ret = __Internal.GetCentreZ((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the width of this aabb.</summary>
        public float Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the height of this aabb.</summary>
        public float Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the depth of this aabb.</summary>
        public float Depth
        {
            get
            {
                var __ret = __Internal.GetDepth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~ColliderAabb()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "ColliderAabb"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Collider *Update(const Transform &transform, Collider *destination) override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr _UpdateDelegateInstance;

        private static global::System.IntPtr _UpdateDelegateHook(global::System.IntPtr instance, global::System.IntPtr transform, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Transform __result0;
            if (transform == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Transform.NativeToManagedMap.ContainsKey(transform))
                __result0 = (global::FlounderSharp.Transform) global::FlounderSharp.Transform.NativeToManagedMap[transform];
            else __result0 = global::FlounderSharp.Transform.__CreateInstance(transform);
            global::FlounderSharp.Collider __result1;
            if (destination == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(destination))
                __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[destination];
            else __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(destination, skipVTables: true);
            var __ret = __target.Update(__result0, __result1);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Vector3 *ResolveCollision(const Collider &other, const Vector3 &positionDelta, Vector3 *destination) override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _ResolveCollisionDelegateInstance;

        private static global::System.IntPtr _ResolveCollisionDelegateHook(global::System.IntPtr instance, global::System.IntPtr other, global::System.IntPtr positionDelta, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result0;
            if (other == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            global::FlounderSharp.Vector3 __result1;
            if (positionDelta == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(positionDelta))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[positionDelta];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(positionDelta);
            global::FlounderSharp.Vector3 __result2;
            if (destination == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(destination))
                __result2 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[destination];
            else __result2 = global::FlounderSharp.Vector3.__CreateInstance(destination);
            var __ret = __target.ResolveCollision(__result0, __result1, __result2);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Intersect Intersects(const Ray &ray) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _Intersects_1DelegateInstance;

        private static void _Intersects_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr ray)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Ray __result1;
            if (ray == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Ray.NativeToManagedMap.ContainsKey(ray))
                __result1 = (global::FlounderSharp.Ray) global::FlounderSharp.Ray.NativeToManagedMap[ray];
            else __result1 = global::FlounderSharp.Ray.__CreateInstance(ray);
            var __ret = __target.Intersects(__result1);
            *(global::FlounderSharp.Intersect.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Intersect.__Internal() : *(global::FlounderSharp.Intersect.__Internal*) __ret.__Instance;
        }

        // Intersect Intersects(const Collider &other) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _IntersectsDelegateInstance;

        private static void _IntersectsDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result1;
            if (other == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            var __ret = __target.Intersects(__result1);
            *(global::FlounderSharp.Intersect.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Intersect.__Internal() : *(global::FlounderSharp.Intersect.__Internal*) __ret.__Instance;
        }

        // bool InFrustum(const Frustum &frustum) override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _InFrustumDelegateInstance;

        private static bool _InFrustumDelegateHook(global::System.IntPtr instance, global::System.IntPtr frustum)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Frustum __result0;
            if (frustum == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Frustum.NativeToManagedMap.ContainsKey(frustum))
                __result0 = (global::FlounderSharp.Frustum) global::FlounderSharp.Frustum.NativeToManagedMap[frustum];
            else __result0 = global::FlounderSharp.Frustum.__CreateInstance(frustum);
            var __ret = __target.InFrustum(__result0);
            return __ret;
        }

        // bool Contains(const Vector3 &point) override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _Contains_1DelegateInstance;

        private static bool _Contains_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr point)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result0;
            if (point == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(point))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[point];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(point);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        // bool Contains(const Collider &other) override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr other)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderAabb) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result0;
            if (other == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[12];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _ResolveCollisionDelegateInstance += _ResolveCollisionDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ResolveCollisionDelegateInstance).ToPointer();
                _Intersects_1DelegateInstance += _Intersects_1DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_Intersects_1DelegateInstance).ToPointer();
                _IntersectsDelegateInstance += _IntersectsDelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_IntersectsDelegateInstance).ToPointer();
                _InFrustumDelegateInstance += _InFrustumDelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_InFrustumDelegateInstance).ToPointer();
                _Contains_1DelegateInstance += _Contains_1DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_Contains_1DelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                    *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                    *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                    *(void**) (vfptr0 + 72) = _Thunks[8];
                    *(void**) (vfptr0 + 80) = _Thunks[9];
                    *(void**) (vfptr0 + 88) = _Thunks[10];
                    *(void**) (vfptr0 + 96) = _Thunks[11];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Represents when a module will update in the game loop.</summary>
    public enum ModuleUpdate
    {
        UpdateAlways = 0,
        UpdatePre = 1,
        UpdateNormal = 2,
        UpdatePost = 3,
        UpdateRender = 4
    }

    /// <summary>A interface used for defining engine modules.</summary>
    public unsafe abstract partial class IModule : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IModule@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IModule> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IModule>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IModule __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IModuleInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IModule __CreateInstance(global::FlounderSharp.IModule.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IModuleInternal(native, skipVTables);
        }

        protected IModule(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new module.</summary>
        protected IModule()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IModule");
        }

        protected IModule(global::FlounderSharp.IModule _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IModule");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IModule.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the module.</summary>
        public abstract void Update();

        #region Virtual table interop

        // virtual ~IModule() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IModule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IModule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IModuleInternal : global::FlounderSharp.IModule, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IModule.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IModule.__Internal));
            *(global::FlounderSharp.IModule.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IModuleInternal(global::FlounderSharp.IModule.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IModuleInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>The update function for the module.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace FlounderSharp
{
    /// <summary>The default updater for the engine.</summary>
    public unsafe partial class ModuleRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_modules;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModuleRegister@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@ModuleRegister@fl@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::FlounderSharp.ModuleUpdate update, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@ModuleRegister@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeregisterModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModule@ModuleRegister@fl@@QEAAPEAVIModule@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RunUpdate@ModuleRegister@fl@@QEBAXAEBW4ModuleUpdate@2@@Z")]
            internal static extern void RunUpdate(global::System.IntPtr instance, global::FlounderSharp.ModuleUpdate update);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ModuleRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ModuleRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ModuleRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ModuleRegister(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ModuleRegister __CreateInstance(global::FlounderSharp.ModuleRegister.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ModuleRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ModuleRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ModuleRegister.__Internal));
            *(global::FlounderSharp.ModuleRegister.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleRegister(global::FlounderSharp.ModuleRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new module register.</summary>
        public ModuleRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleRegister(global::FlounderSharp.ModuleRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.ModuleRegister.__Internal*) __Instance) = *((global::FlounderSharp.ModuleRegister.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ModuleRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        /// <param name="name">The modules name.</param>
        public global::FlounderSharp.IModule RegisterModule(global::FlounderSharp.IModule module, global::FlounderSharp.ModuleUpdate update, string name)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(name, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            global::FlounderSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.NativeToManagedMap[__ret];
            else global::FlounderSharp.IModule.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="name">The modules name.</param>
        public void DeregisterModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Gets a module from the register.</summary>
        /// <param name="name">The module name to get.</param>
        public global::FlounderSharp.IModule GetModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.NativeToManagedMap[__ret];
            else global::FlounderSharp.IModule.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Runs updates for all module update types.</summary>
        /// <param name="update">The modules update type.</param>
        public void RunUpdate(global::FlounderSharp.ModuleUpdate update)
        {
            __Internal.RunUpdate((__Instance + __PointerAdjustment), update);
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A class used to define how the engine will run updates and timings.</summary>
    public unsafe abstract partial class IUpdater : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUpdater;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUpdater@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUpdater@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IUpdater@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IUpdater> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IUpdater>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IUpdater __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IUpdaterInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IUpdater __CreateInstance(global::FlounderSharp.IUpdater.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IUpdaterInternal(native, skipVTables);
        }

        protected IUpdater(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new updater.</summary>
        protected IUpdater()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IUpdater");
        }

        protected IUpdater(global::FlounderSharp.IUpdater _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IUpdater");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IUpdater __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IUpdater.__Internal*) __Instance)->vfptr_IUpdater = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates all modules in order.</summary>
        public abstract void Update(global::FlounderSharp.ModuleRegister moduleRegister);

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public abstract float Delta
        {
            get;
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public abstract float DeltaRender
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IUpdater() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update(ModuleRegister *moduleRegister) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance, global::System.IntPtr moduleRegister)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.ModuleRegister __result0;
            if (moduleRegister == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ModuleRegister.NativeToManagedMap.ContainsKey(moduleRegister))
                __result0 = (global::FlounderSharp.ModuleRegister) global::FlounderSharp.ModuleRegister.NativeToManagedMap[moduleRegister];
            else __result0 = global::FlounderSharp.ModuleRegister.__CreateInstance(moduleRegister);
            __target.Update(__result0);
        }

        // float GetDelta() = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetDeltaDelegateInstance;

        private static float _GetDeltaDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Delta;
            return __ret;
        }

        // float GetDeltaRender() = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetDeltaRenderDelegateInstance;

        private static float _GetDeltaRenderDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.DeltaRender;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _GetDeltaDelegateInstance += _GetDeltaDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetDeltaDelegateInstance).ToPointer();
                _GetDeltaRenderDelegateInstance += _GetDeltaRenderDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetDeltaRenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IUpdaterInternal : global::FlounderSharp.IUpdater, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IUpdater.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUpdater.__Internal));
            *(global::FlounderSharp.IUpdater.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IUpdaterInternal(global::FlounderSharp.IUpdater.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IUpdaterInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Updates all modules in order.</summary>
        public override void Update(global::FlounderSharp.ModuleRegister moduleRegister)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(moduleRegister, null) ? global::System.IntPtr.Zero : moduleRegister.__Instance;
            ___UpdateDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public override float Delta
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetDeltaDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetDeltaDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public override float DeltaRender
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetDeltaRenderDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetDeltaRenderDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A engine used for simplifying the creation of complicated applications. By using flexible Module loading and Extension injecting, it allows the engine to be used for Networking, Imaging, AIs, Games, and many more applications. Start off by creating a new Engine object in your main thread, using Extensions in the constructor. By using Extensions: Modules can be required and therefor loaded into the engine. Implementing interfaces like  with your extension can allow you do task specific things with your Extensions. After creating your Engine object call  to start.</summary>
    public unsafe partial class Engine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Chrono.TimePoint.__Internalc__N_std_N_chrono_S_time_point____N_std_N_chrono_S_steady_clock___N_std_N_chrono_S_duration__K___N_std_S_ratio__VK1_VK1000000000 m_start;

            [FieldOffset(8)]
            internal float m_timeOffset;

            [FieldOffset(16)]
            internal global::System.IntPtr m_moduleRegister;

            [FieldOffset(24)]
            internal global::System.IntPtr m_updater;

            [FieldOffset(32)]
            internal float m_fpsLimit;

            [FieldOffset(36)]
            internal byte m_initialized;

            [FieldOffset(37)]
            internal byte m_running;

            [FieldOffset(38)]
            internal byte m_error;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Engine@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Engine@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Run@Engine@fl@@QEBAHXZ")]
            internal static extern int Run(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@Engine@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeregisterModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModule@Engine@fl@@QEBAPEAVIModule@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInitialized@Engine@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetInitialized(global::System.IntPtr instance, bool initialized);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RequestClose@Engine@fl@@QEAAXAEB_N@Z")]
            internal static extern void RequestClose(global::System.IntPtr instance, bool error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUpdater@Engine@fl@@QEBAPEAVIUpdater@2@XZ")]
            internal static extern global::System.IntPtr GetUpdater(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUpdater@Engine@fl@@QEAAXPEAVIUpdater@2@@Z")]
            internal static extern void SetUpdater(global::System.IntPtr instance, global::System.IntPtr updater);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeOffset@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTimeOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeOffset@Engine@fl@@QEAAXAEBM@Z")]
            internal static extern void SetTimeOffset(global::System.IntPtr instance, float timeOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFpsLimit@Engine@fl@@QEBAMXZ")]
            internal static extern float GetFpsLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFpsLimit@Engine@fl@@QEAAXAEBM@Z")]
            internal static extern void SetFpsLimit(global::System.IntPtr instance, float fpsLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@Engine@fl@@QEAAMXZ")]
            internal static extern float GetDelta(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@Engine@fl@@QEAAMXZ")]
            internal static extern float GetDeltaRender(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeMs@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTimeMs(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInitialized@Engine@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInitialized(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@Engine@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRunning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDateTime@Engine@fl@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetDateTime(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Engine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Engine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Engine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Engine(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Engine __CreateInstance(global::FlounderSharp.Engine.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Engine(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Engine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            *(global::FlounderSharp.Engine.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Engine(global::FlounderSharp.Engine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Engine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Carries out the setup for basic engine components and the engine. Call  after creating a instance.</summary>
        public Engine()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Engine(global::FlounderSharp.Engine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Engine.__Internal*) __Instance) = *((global::FlounderSharp.Engine.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Engine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the updater.</summary>
        public int Run()
        {
            var __ret = __Internal.Run((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="name">The modules name.</param>
        public void DeregisterModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Gets a module instance by name.</summary>
        /// <param name="name">The module name to find.</param>
        public global::FlounderSharp.IModule GetModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.NativeToManagedMap[__ret];
            else global::FlounderSharp.IModule.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets if the engine has been initialized.</summary>
        /// <param name="initialized">If the engine has been initialized.</param>
        public void SetInitialized(bool initialized)
        {
            __Internal.SetInitialized((__Instance + __PointerAdjustment), initialized);
        }

        /// <summary>Requests the engine to delete and stop the gameloop.</summary>
        /// <param name="error">If a bad error occured.</param>
        public void RequestClose(bool error)
        {
            __Internal.RequestClose((__Instance + __PointerAdjustment), error);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Engine Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Engine __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Engine.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Engine) global::FlounderSharp.Engine.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Engine.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the current updater.</summary>
        /// <param name="updater">The updater.</param>
        /// <remarks>Loads the updater into the engine.</remarks>
        public global::FlounderSharp.IUpdater Updater
        {
            get
            {
                var __ret = __Internal.GetUpdater((__Instance + __PointerAdjustment));
                global::FlounderSharp.IUpdater __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.IUpdater.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.IUpdater) global::FlounderSharp.IUpdater.NativeToManagedMap[__ret];
                else global::FlounderSharp.IUpdater.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IUpdater) global::FlounderSharp.IUpdater.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetUpdater((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the added/removed time for the engine (seconds).</summary>
        /// <param name="timeOffset">The new time offset.</param>
        /// <remarks>Sets the time offset for the engine (seconds).</remarks>
        public float TimeOffset
        {
            get
            {
                var __ret = __Internal.GetTimeOffset((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetTimeOffset((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the fps limit.</summary>
        /// <param name="fpsLimit">The new fps limit.</param>
        /// <remarks>Sets the fps limit. -1 disables limits.</remarks>
        public float FpsLimit
        {
            get
            {
                var __ret = __Internal.GetFpsLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFpsLimit((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public float Delta
        {
            get
            {
                var __ret = __Internal.GetDelta((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public float DeltaRender
        {
            get
            {
                var __ret = __Internal.GetDeltaRender((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float TimeMs
        {
            get
            {
                var __ret = __Internal.GetTimeMs((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine has been initialized.</summary>
        public bool IsInitialized
        {
            get
            {
                var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine is running.</summary>
        public bool IsRunning
        {
            get
            {
                var __ret = __Internal.IsRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current date time as a string. &quot;%d-%m-%Y %I:%M:%S&quot;</summary>
        public string DateTime
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetDateTime((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe abstract partial class IResource : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IResource@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IResource@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IResource@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IResource> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IResource>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IResource __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IResourceInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IResource __CreateInstance(global::FlounderSharp.IResource.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IResourceInternal(native, skipVTables);
        }

        protected IResource(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IResource()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IResource.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IResource");
        }

        protected IResource(global::FlounderSharp.IResource _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IResource.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IResource");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IResource.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract string Filename
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IResource() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IResource) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IResource) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IResourceInternal : global::FlounderSharp.IResource, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IResource.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IResource.__Internal));
            *(global::FlounderSharp.IResource.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IResourceInternal(global::FlounderSharp.IResource.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IResourceInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for managing resources.</summary>
    public unsafe partial class Resources : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_managed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Resources@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Resources@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Resources@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Resources@fl@@QEAAPEAVIResource@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Get(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Resources@fl@@QEAAXPEAVIResource@2@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr managed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Remove@Resources@fl@@QEAAXPEAVIResource@2@@Z")]
            internal static extern void Remove(global::System.IntPtr instance, global::System.IntPtr managed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Remove@Resources@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Remove_1(global::System.IntPtr instance, global::System.IntPtr filename);
        }

        internal static new global::FlounderSharp.Resources __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Resources(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Resources __CreateInstance(global::FlounderSharp.Resources.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Resources(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Resources.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Resources.__Internal));
            global::FlounderSharp.Resources.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Resources(global::FlounderSharp.Resources.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Resources(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new Resources module.</summary>
        public Resources()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Resources.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Resources");
        }

        public Resources(global::FlounderSharp.Resources _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Resources.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Resources");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public global::FlounderSharp.IResource Get(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Get((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.IResource __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IResource.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IResource) global::FlounderSharp.IResource.NativeToManagedMap[__ret];
            else global::FlounderSharp.IResource.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IResource) global::FlounderSharp.IResource.__CreateInstance(__ret);
            return __result0;
        }

        public void Add(global::FlounderSharp.IResource managed)
        {
            var __arg0 = ReferenceEquals(managed, null) ? global::System.IntPtr.Zero : managed.__Instance;
            __Internal.Add((__Instance + __PointerAdjustment), __arg0);
        }

        public void Remove(global::FlounderSharp.IResource managed)
        {
            var __arg0 = ReferenceEquals(managed, null) ? global::System.IntPtr.Zero : managed.__Instance;
            __Internal.Remove((__Instance + __PointerAdjustment), __arg0);
        }

        public void Remove(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.Remove_1((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Resources Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Resources __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Resources.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Resources) global::FlounderSharp.Resources.NativeToManagedMap[__ret];
            else global::FlounderSharp.Resources.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Resources) global::FlounderSharp.Resources.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~Resources()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Resources) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Resources) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

public unsafe partial class GLFWwindow
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native.ToPointer(), skipVTables);
    }

    internal static global::GLFWwindow __CreateInstance(global::GLFWwindow.__Internal native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native, skipVTables);
    }

    private static void* __CopyValue(global::GLFWwindow.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::GLFWwindow.__Internal));
        *(global::GLFWwindow.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private GLFWwindow(global::GLFWwindow.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected GLFWwindow(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for the creation, updating and destruction of the display.</summary>
    public unsafe partial class Display : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1888)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal int m_windowWidth;

            [FieldOffset(12)]
            internal int m_windowHeight;

            [FieldOffset(16)]
            internal int m_fullscreenWidth;

            [FieldOffset(20)]
            internal int m_fullscreenHeight;

            [FieldOffset(24)]
            internal float m_aspectRatio;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_icon;

            [FieldOffset(96)]
            internal byte m_antialiasing;

            [FieldOffset(97)]
            internal byte m_fullscreen;

            [FieldOffset(104)]
            internal global::System.IntPtr m_window;

            [FieldOffset(112)]
            internal byte m_closed;

            [FieldOffset(113)]
            internal byte m_focused;

            [FieldOffset(116)]
            internal int m_windowPosX;

            [FieldOffset(120)]
            internal int m_windowPosY;

            [FieldOffset(124)]
            internal byte m_iconified;

            [FieldOffset(125)]
            internal byte m_validationLayers;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceLayerList;

            [FieldOffset(152)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceExtensionList;

            [FieldOffset(176)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_deviceExtensionList;

            [FieldOffset(200)]
            internal global::System.IntPtr m_debugReport;

            [FieldOffset(208)]
            internal global::System.IntPtr m_instance;

            [FieldOffset(216)]
            internal global::System.IntPtr m_surface;

            [FieldOffset(224)]
            internal global::VkSurfaceCapabilitiesKHR.__Internal m_surfaceCapabilities;

            [FieldOffset(276)]
            internal global::VkSurfaceFormatKHR.__Internal m_surfaceFormat;

            [FieldOffset(288)]
            internal global::System.IntPtr m_logicalDevice;

            [FieldOffset(296)]
            internal global::System.IntPtr m_queue;

            [FieldOffset(304)]
            internal global::System.IntPtr m_physicalDevice;

            [FieldOffset(312)]
            internal global::VkPhysicalDeviceProperties.__Internal m_physicalDeviceProperties;

            [FieldOffset(1136)]
            internal global::VkPhysicalDeviceFeatures.__Internal m_physicalDeviceFeatures;

            [FieldOffset(1360)]
            internal global::VkPhysicalDeviceMemoryProperties.__Internal m_physicalDeviceMemoryProperties;

            [FieldOffset(1880)]
            internal uint m_graphicsFamilyIndex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Display@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWindowSize@Display@fl@@QEAAXAEBH0@Z")]
            internal static extern void SetWindowSize(global::System.IntPtr instance, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAntialiasing@Display@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetAntialiasing(global::System.IntPtr instance, bool antialiasing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFullscreen@Display@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetFullscreen(global::System.IntPtr instance, bool fullscreen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultGlfw@Display@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultGlfw(global::System.IntPtr @return, int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ErrorGlfw@Display@fl@@SAXAEBH@Z")]
            internal static extern void ErrorGlfw(int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTitle@Display@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetTitle(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTitle@Display@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetTitle(global::System.IntPtr instance, global::System.IntPtr title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIcon@Display@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetIcon(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIcon@Display@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetIcon(global::System.IntPtr instance, global::System.IntPtr icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Display@fl@@QEAAHXZ")]
            internal static extern int GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowWidth@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Display@fl@@QEAAHXZ")]
            internal static extern int GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowHeight@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAspectRatio@Display@fl@@QEBAMXZ")]
            internal static extern float GetAspectRatio(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAntialiasing@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAntialiasing(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFullscreen@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFullscreen(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlfwWindow@Display@fl@@QEBAPEAVGLFWwindow@@XZ")]
            internal static extern global::System.IntPtr GetGlfwWindow(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsClosed@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsClosed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFocused@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFocused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowXPos@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowXPos(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowYPos@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowYPos(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIconified@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsIconified(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVkGraphicsFamilyIndex@Display@fl@@QEBAIXZ")]
            internal static extern uint GetVkGraphicsFamilyIndex(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Display __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Display(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Display __CreateInstance(global::FlounderSharp.Display.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Display(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Display.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Display.__Internal));
            global::FlounderSharp.Display.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Display(global::FlounderSharp.Display.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Display(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new display module.</summary>
        public Display()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Display");
        }

        public Display(global::FlounderSharp.Display _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Display");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Sets window size to a new size.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <param name="height">The new height in pixels.</param>
        public void SetWindowSize(int width, int height)
        {
            __Internal.SetWindowSize((__Instance + __PointerAdjustment), width, height);
        }

        /// <summary>Requests the display to antialias.</summary>
        /// <param name="antialiasing">If the display should antialias.</param>
        public void SetAntialiasing(bool antialiasing)
        {
            __Internal.SetAntialiasing((__Instance + __PointerAdjustment), antialiasing);
        }

        /// <summary>Sets the display to be fullscreen or windowed.</summary>
        /// <param name="fullscreen">Weather or not to be fullscreen.</param>
        public void SetFullscreen(bool fullscreen)
        {
            __Internal.SetFullscreen((__Instance + __PointerAdjustment), fullscreen);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Display Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Display __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Display.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Display) global::FlounderSharp.Display.NativeToManagedMap[__ret];
            else global::FlounderSharp.Display.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Display) global::FlounderSharp.Display.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultGlfw(int result)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultGlfw(new IntPtr(&__ret), result);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static void ErrorGlfw(int result)
        {
            __Internal.ErrorGlfw(result);
        }

        /// <summary>Gets the window's title.</summary>
        /// <param name="title">The new title.</param>
        /// <remarks>Sets window title</remarks>
        public string Title
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetTitle((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetTitle((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the window's icon file.</summary>
        /// <param name="title">The new icon file.</param>
        /// <remarks>Sets window icon image.</remarks>
        public string Icon
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetIcon((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetIcon((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the width of the display in pixels.</summary>
        public int Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the non-fullscreen width of the display in pixels.</summary>
        public int WindowWidth
        {
            get
            {
                var __ret = __Internal.GetWindowWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the height of the display in pixels.</summary>
        public int Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the non-fullscreen height of the display in pixels.</summary>
        public int WindowHeight
        {
            get
            {
                var __ret = __Internal.GetWindowHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the aspect ratio between the displays width and height.</summary>
        public float AspectRatio
        {
            get
            {
                var __ret = __Internal.GetAspectRatio((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display requests antialiased images.</summary>
        public bool IsAntialiasing
        {
            get
            {
                var __ret = __Internal.IsAntialiasing((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets weather the display is fullscreen or not.</summary>
        public bool IsFullscreen
        {
            get
            {
                var __ret = __Internal.IsFullscreen((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current GLFW window.</summary>
        public global::GLFWwindow GlfwWindow
        {
            get
            {
                var __ret = __Internal.GetGlfwWindow((__Instance + __PointerAdjustment));
                global::GLFWwindow __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GLFWwindow) global::GLFWwindow.NativeToManagedMap[__ret];
                else __result0 = global::GLFWwindow.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets if the GLFW display is closed.</summary>
        public bool IsClosed
        {
            get
            {
                var __ret = __Internal.IsClosed((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the GLFW display is selected.</summary>
        public bool IsFocused
        {
            get
            {
                var __ret = __Internal.IsFocused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position of the display in pixels.</summary>
        public int WindowXPos
        {
            get
            {
                var __ret = __Internal.GetWindowXPos((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position of the display in pixels.</summary>
        public int WindowYPos
        {
            get
            {
                var __ret = __Internal.GetWindowYPos((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows is minimized.</summary>
        public bool IsIconified
        {
            get
            {
                var __ret = __Internal.IsIconified((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint VkGraphicsFamilyIndex
        {
            get
            {
                var __ret = __Internal.GetVkGraphicsFamilyIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Display()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Display) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Display) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class Display
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackError@fl@@YAXHPEBD@Z")]
            internal static extern void CallbackError(int error, [MarshalAs(UnmanagedType.LPStr)] string description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackClose@fl@@YAXPEAVGLFWwindow@@@Z")]
            internal static extern void CallbackClose(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFocus@fl@@YAXPEAVGLFWwindow@@H@Z")]
            internal static extern void CallbackFocus(global::System.IntPtr window, int focused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackPosition@fl@@YAXPEAVGLFWwindow@@HH@Z")]
            internal static extern void CallbackPosition(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackSize@fl@@YAXPEAVGLFWwindow@@HH@Z")]
            internal static extern void CallbackSize(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFrame@fl@@YAXPEAVGLFWwindow@@HH@Z")]
            internal static extern void CallbackFrame(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackIconify@fl@@YAXPEAVGLFWwindow@@H@Z")]
            internal static extern void CallbackIconify(global::System.IntPtr window, int iconified);
        }

        public static void CallbackError(int error, string description)
        {
            __Internal.CallbackError(error, description);
        }

        public static void CallbackClose(global::GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackClose(__arg0);
        }

        public static void CallbackFocus(global::GLFWwindow window, int focused)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFocus(__arg0, focused);
        }

        public static void CallbackPosition(global::GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackPosition(__arg0, xpos, ypos);
        }

        public static void CallbackSize(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackSize(__arg0, width, height);
        }

        public static void CallbackFrame(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFrame(__arg0, width, height);
        }

        public static void CallbackIconify(global::GLFWwindow window, int iconified)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackIconify(__arg0, iconified);
        }
    }
}

namespace FlounderSharp
{
    public enum CommandBufferLevel
    {
        BufferLevelPrimary = 0,
        BufferLevelSecondary = 1
    }

    public unsafe partial class CommandBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.CommandBufferLevel m_bufferLevel;

            [FieldOffset(8)]
            internal global::System.IntPtr m_commandBuffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CommandBuffer@fl@@QEAA@AEB_NAEBW4CommandBufferLevel@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool begin, global::FlounderSharp.CommandBufferLevel bufferLevel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CommandBuffer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1CommandBuffer@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Begin@CommandBuffer@fl@@QEAAXXZ")]
            internal static extern void Begin(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.CommandBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.CommandBuffer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.CommandBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.CommandBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.CommandBuffer __CreateInstance(global::FlounderSharp.CommandBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.CommandBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.CommandBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.CommandBuffer.__Internal));
            *(global::FlounderSharp.CommandBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CommandBuffer(global::FlounderSharp.CommandBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CommandBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CommandBuffer(bool begin, global::FlounderSharp.CommandBufferLevel bufferLevel)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.CommandBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), begin, bufferLevel);
        }

        public CommandBuffer(global::FlounderSharp.CommandBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.CommandBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.CommandBuffer.__Internal*) __Instance) = *((global::FlounderSharp.CommandBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.CommandBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Begin()
        {
            __Internal.Begin((__Instance + __PointerAdjustment));
        }
    }
}

namespace FlounderSharp
{
    public enum PipelineMode
    {
        PipelineModePolygon = 0,
        PipelineModePolygonNoDepth = 1,
        PipelineModeMrt = 2,
        PipelineModeMrtNoDepth = 3
    }

    public enum PipelinePolygonMode
    {
        PipelinePolygonModeFill = 0,
        PipelinePolygonModeLine = 1,
        PipelinePolygonModePoint = 2
    }

    public enum PipelineCullMode
    {
        PipelineCullModeNone = 0,
        PipelineCullModeFront = 1,
        PipelineCullModeBack = 2,
        PipelineCullModeAll = 3
    }

    public unsafe partial class GraphicsStage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_renderpass;

            [FieldOffset(4)]
            internal uint m_subpass;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GraphicsStage@fl@@QEAA@AEBI0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint renderpass, uint subpass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GraphicsStage@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderpass@GraphicsStage@fl@@QEBAIXZ")]
            internal static extern uint GetRenderpass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubpass@GraphicsStage@fl@@QEBAIXZ")]
            internal static extern uint GetSubpass(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.GraphicsStage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.GraphicsStage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.GraphicsStage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.GraphicsStage(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.GraphicsStage __CreateInstance(global::FlounderSharp.GraphicsStage.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.GraphicsStage(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.GraphicsStage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GraphicsStage.__Internal));
            *(global::FlounderSharp.GraphicsStage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GraphicsStage(global::FlounderSharp.GraphicsStage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GraphicsStage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GraphicsStage(uint renderpass, uint subpass)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GraphicsStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), renderpass, subpass);
        }

        public GraphicsStage(global::FlounderSharp.GraphicsStage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GraphicsStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.GraphicsStage.__Internal*) __Instance) = *((global::FlounderSharp.GraphicsStage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.GraphicsStage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Renderpass
        {
            get
            {
                var __ret = __Internal.GetRenderpass((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Subpass
        {
            get
            {
                var __ret = __Internal.GetSubpass((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class VertexInput : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputBindingDescription___N_std_S_allocator__S0_ m_bindingDescriptions;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputAttributeDescription___N_std_S_allocator__S0_ m_attributeDescriptions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexInput@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexInput@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexInput> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexInput>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.VertexInput __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexInput(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexInput __CreateInstance(global::FlounderSharp.VertexInput.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexInput(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexInput.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexInput.__Internal));
            global::FlounderSharp.VertexInput.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexInput(global::FlounderSharp.VertexInput.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexInput(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexInput(global::FlounderSharp.VertexInput _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexInput.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.VertexInput __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class DescriptorType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(4)]
            internal uint m_stage;

            [FieldOffset(8)]
            internal global::VkDescriptorSetLayoutBinding.__Internal m_descriptorSetLayoutBinding;

            [FieldOffset(32)]
            internal global::VkDescriptorPoolSize.__Internal m_descriptorPoolSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorType@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@DescriptorType@fl@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStage@DescriptorType@fl@@QEBAIXZ")]
            internal static extern uint GetStage(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.DescriptorType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.DescriptorType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.DescriptorType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DescriptorType(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DescriptorType __CreateInstance(global::FlounderSharp.DescriptorType.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DescriptorType(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DescriptorType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorType.__Internal));
            *(global::FlounderSharp.DescriptorType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DescriptorType(global::FlounderSharp.DescriptorType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorType(global::FlounderSharp.DescriptorType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.DescriptorType.__Internal*) __Instance) = *((global::FlounderSharp.DescriptorType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.DescriptorType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Stage
        {
            get
            {
                var __ret = __Internal.GetStage((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class PipelineCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_shaderStages;

            [FieldOffset(24)]
            internal global::FlounderSharp.VertexInput.__Internal m_vertexInput;

            [FieldOffset(72)]
            internal global::FlounderSharp.PipelineMode m_pipelineMode;

            [FieldOffset(76)]
            internal global::FlounderSharp.PipelinePolygonMode m_polygonMode;

            [FieldOffset(80)]
            internal global::FlounderSharp.PipelineCullMode m_cullMode;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineCreate@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineCreate@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@PipelineCreate@fl@@QEBA?AVVertexInput@2@XZ")]
            internal static extern void GetVertexInput(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMode@PipelineCreate@fl@@QEBA?AW4PipelineMode@2@XZ")]
            internal static extern global::FlounderSharp.PipelineMode GetMode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPolygonMode@PipelineCreate@fl@@QEBA?AW4PipelinePolygonMode@2@XZ")]
            internal static extern global::FlounderSharp.PipelinePolygonMode GetPolygonMode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCullModeF@PipelineCreate@fl@@QEBA?AW4PipelineCullMode@2@XZ")]
            internal static extern global::FlounderSharp.PipelineCullMode GetCullModeF(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.PipelineCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.PipelineCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.PipelineCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PipelineCreate(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.PipelineCreate __CreateInstance(global::FlounderSharp.PipelineCreate.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PipelineCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.PipelineCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PipelineCreate.__Internal));
            global::FlounderSharp.PipelineCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineCreate(global::FlounderSharp.PipelineCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PipelineCreate(global::FlounderSharp.PipelineCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PipelineCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.PipelineCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::FlounderSharp.VertexInput VertexInput
        {
            get
            {
                var __ret = new global::FlounderSharp.VertexInput.__Internal();
                __Internal.GetVertexInput((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.VertexInput.__CreateInstance(__ret);
            }
        }

        public global::FlounderSharp.PipelineMode Mode
        {
            get
            {
                var __ret = __Internal.GetMode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.PipelinePolygonMode PolygonMode
        {
            get
            {
                var __ret = __Internal.GetPolygonMode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.PipelineCullMode CullModeF
        {
            get
            {
                var __ret = __Internal.GetCullModeF((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Glslang
{
    public unsafe partial class TProgram
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Glslang.TProgram> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Glslang.TProgram>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Glslang.TProgram __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Glslang.TProgram(native.ToPointer(), skipVTables);
        }

        internal static global::Glslang.TProgram __CreateInstance(global::Glslang.TProgram.__Internal native, bool skipVTables = false)
        {
            return new global::Glslang.TProgram(native, skipVTables);
        }

        private static void* __CopyValue(global::Glslang.TProgram.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Glslang.TProgram.__Internal));
            *(global::Glslang.TProgram.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TProgram(global::Glslang.TProgram.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TProgram(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Uniform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_binding;

            [FieldOffset(36)]
            internal int m_offset;

            [FieldOffset(40)]
            internal int m_size;

            [FieldOffset(44)]
            internal int m_glType;

            [FieldOffset(48)]
            internal global::VkShaderStageFlagBits m_stageFlags;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uniform@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Uniform@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Uniform@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Uniform@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Uniform@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Uniform@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@Uniform@fl@@QEBAHXZ")]
            internal static extern int GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffset@Uniform@fl@@QEBAHXZ")]
            internal static extern int GetOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Uniform@fl@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlType@Uniform@fl@@QEBAHXZ")]
            internal static extern int GetGlType(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Uniform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Uniform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Uniform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Uniform(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Uniform __CreateInstance(global::FlounderSharp.Uniform.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Uniform(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Uniform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Uniform.__Internal));
            global::FlounderSharp.Uniform.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Uniform(global::FlounderSharp.Uniform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Uniform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Uniform(global::FlounderSharp.Uniform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Uniform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Uniform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::FlounderSharp.Uniform __op, global::FlounderSharp.Uniform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Uniform;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Uniform.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Uniform __op, global::FlounderSharp.Uniform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public int Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Offset
        {
            get
            {
                var __ret = __Internal.GetOffset((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int GlType
        {
            get
            {
                var __ret = __Internal.GetGlType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class UniformBlock : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_binding;

            [FieldOffset(36)]
            internal int m_size;

            [FieldOffset(40)]
            internal global::VkShaderStageFlagBits m_stageFlags;

            [FieldOffset(48)]
            internal global::System.IntPtr m_uniforms;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBlock@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UniformBlock@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddUniform@UniformBlock@fl@@QEAAXPEAVUniform@2@@Z")]
            internal static extern void AddUniform(global::System.IntPtr instance, global::System.IntPtr uniform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniform@UniformBlock@fl@@QEAAPEAVUniform@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetUniform(global::System.IntPtr instance, global::System.IntPtr uniformName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@UniformBlock@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@UniformBlock@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@UniformBlock@fl@@QEBAHXZ")]
            internal static extern int GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@UniformBlock@fl@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UniformBlock> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UniformBlock>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.UniformBlock __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UniformBlock(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UniformBlock __CreateInstance(global::FlounderSharp.UniformBlock.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UniformBlock(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UniformBlock.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformBlock.__Internal));
            global::FlounderSharp.UniformBlock.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UniformBlock(global::FlounderSharp.UniformBlock.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UniformBlock(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UniformBlock(global::FlounderSharp.UniformBlock _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformBlock.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.UniformBlock __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddUniform(global::FlounderSharp.Uniform uniform)
        {
            var __arg0 = ReferenceEquals(uniform, null) ? global::System.IntPtr.Zero : uniform.__Instance;
            __Internal.AddUniform((__Instance + __PointerAdjustment), __arg0);
        }

        public global::FlounderSharp.Uniform GetUniform(string uniformName)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(uniformName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetUniform((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.Uniform __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Uniform.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Uniform) global::FlounderSharp.Uniform.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Uniform.__CreateInstance(__ret);
            return __result0;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public int Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class VertexAttribute : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_location;

            [FieldOffset(36)]
            internal int m_size;

            [FieldOffset(40)]
            internal int m_glType;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAttribute@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH11@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, int location, int size, int glType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAttribute@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexAttribute@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@VertexAttribute@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@VertexAttribute@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocation@VertexAttribute@fl@@QEBAHXZ")]
            internal static extern int GetLocation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@VertexAttribute@fl@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlType@VertexAttribute@fl@@QEBAHXZ")]
            internal static extern int GetGlType(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexAttribute> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexAttribute>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.VertexAttribute __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexAttribute(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexAttribute __CreateInstance(global::FlounderSharp.VertexAttribute.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexAttribute(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexAttribute.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAttribute.__Internal));
            global::FlounderSharp.VertexAttribute.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAttribute(global::FlounderSharp.VertexAttribute.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAttribute(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexAttribute(string name, int location, int size, int glType)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAttribute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, location, size, glType);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public VertexAttribute(global::FlounderSharp.VertexAttribute _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAttribute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.VertexAttribute __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public int Location
        {
            get
            {
                var __ret = __Internal.GetLocation((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int GlType
        {
            get
            {
                var __ret = __Internal.GetGlType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class ShaderProgram : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_uniforms;

            [FieldOffset(8)]
            internal global::System.IntPtr m_uniformBlocks;

            [FieldOffset(16)]
            internal global::System.IntPtr m_vertexAttributes;

            [FieldOffset(24)]
            internal global::System.IntPtr m_descriptors;

            [FieldOffset(32)]
            internal global::System.IntPtr m_attributeDescriptions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShaderProgram@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShaderProgram@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ShaderProgram@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProcessShader@ShaderProgram@fl@@QEAAXXZ")]
            internal static extern void ProcessShader(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorLocation@ShaderProgram@fl@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern int GetDescriptorLocation(global::System.IntPtr instance, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniform@ShaderProgram@fl@@QEAAPEAVUniform@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetUniform(global::System.IntPtr instance, global::System.IntPtr uniformName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniformBlock@ShaderProgram@fl@@QEAAPEAVUniformBlock@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetUniformBlock(global::System.IntPtr instance, global::System.IntPtr blockName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexAttribute@ShaderProgram@fl@@QEAAPEAVVertexAttribute@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetVertexAttribute(global::System.IntPtr instance, global::System.IntPtr attributeName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InsertDefineBlock@ShaderProgram@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z")]
            internal static extern void InsertDefineBlock(global::System.IntPtr @return, global::System.IntPtr shaderCode, global::System.IntPtr blockCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@ShaderProgram@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ShaderProgram> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ShaderProgram>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ShaderProgram __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShaderProgram(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShaderProgram __CreateInstance(global::FlounderSharp.ShaderProgram.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShaderProgram(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShaderProgram.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShaderProgram.__Internal));
            *(global::FlounderSharp.ShaderProgram.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ShaderProgram(global::FlounderSharp.ShaderProgram.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShaderProgram(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ShaderProgram()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShaderProgram.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ShaderProgram(global::FlounderSharp.ShaderProgram _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShaderProgram.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.ShaderProgram.__Internal*) __Instance) = *((global::FlounderSharp.ShaderProgram.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ShaderProgram __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void ProcessShader()
        {
            __Internal.ProcessShader((__Instance + __PointerAdjustment));
        }

        public int GetDescriptorLocation(string descriptor)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptor, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetDescriptorLocation((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public global::FlounderSharp.Uniform GetUniform(string uniformName)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(uniformName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetUniform((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.Uniform __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Uniform.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Uniform) global::FlounderSharp.Uniform.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Uniform.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.UniformBlock GetUniformBlock(string blockName)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(blockName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetUniformBlock((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.UniformBlock __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UniformBlock.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.UniformBlock) global::FlounderSharp.UniformBlock.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.UniformBlock.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.VertexAttribute GetVertexAttribute(string attributeName)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attributeName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetVertexAttribute((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.VertexAttribute __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.VertexAttribute.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.VertexAttribute) global::FlounderSharp.VertexAttribute.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.VertexAttribute.__CreateInstance(__ret);
            return __result0;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static string InsertDefineBlock(string shaderCode, string blockCode)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(shaderCode, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(blockCode, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.InsertDefineBlock(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class DescriptorSet : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_shaderProgram;

            [FieldOffset(8)]
            internal global::System.IntPtr m_pipelineLayout;

            [FieldOffset(16)]
            internal global::System.IntPtr m_descriptorPool;

            [FieldOffset(24)]
            internal global::System.IntPtr m_descriptorSet;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorSet@fl@@QEAA@AEBVPipeline@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorSet@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1DescriptorSet@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindDescriptor@DescriptorSet@fl@@QEAAXAEBVCommandBuffer@2@@Z")]
            internal static extern void BindDescriptor(global::System.IntPtr instance, global::System.IntPtr commandBuffer);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.DescriptorSet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.DescriptorSet>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.DescriptorSet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DescriptorSet(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DescriptorSet __CreateInstance(global::FlounderSharp.DescriptorSet.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DescriptorSet(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DescriptorSet.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorSet.__Internal));
            *(global::FlounderSharp.DescriptorSet.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DescriptorSet(global::FlounderSharp.DescriptorSet.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorSet(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorSet(global::FlounderSharp.Pipeline pipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorSet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pipeline.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public DescriptorSet(global::FlounderSharp.DescriptorSet _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorSet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.DescriptorSet.__Internal*) __Instance) = *((global::FlounderSharp.DescriptorSet.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.DescriptorSet __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void BindDescriptor(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.BindDescriptor((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::FlounderSharp.DescriptorSet(global::FlounderSharp.Pipeline pipeline)
        {
            return new global::FlounderSharp.DescriptorSet(pipeline);
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Buffer : global::FlounderSharp.IBuffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Buffer@fl@@QEAA@AEB_KAEBI1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong size, uint usage, uint properties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Buffer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindMemoryType@Buffer@fl@@SAIAEBI0@Z")]
            internal static extern uint FindMemoryType(uint typeFilter, uint properties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVkSize@Buffer@fl@@QEBA_KXZ")]
            internal static extern ulong GetVkSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IBuffer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Buffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Buffer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Buffer __CreateInstance(global::FlounderSharp.Buffer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Buffer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Buffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Buffer.__Internal));
            global::FlounderSharp.Buffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Buffer(global::FlounderSharp.Buffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Buffer(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public Buffer(ulong size, uint usage, uint properties)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance), size, usage, properties);
            SetupVTables(GetType().FullName == "FlounderSharp.Buffer");
        }

        public Buffer(global::FlounderSharp.IBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToBuffer;
            __Internal.cctor((__Instance), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Buffer");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.Buffer.__Internal*) __Instance)->vfptr_Buffer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static uint FindMemoryType(uint typeFilter, uint properties)
        {
            var __ret = __Internal.FindMemoryType(typeFilter, properties);
            return __ret;
        }

        protected ulong MSize
        {
            get
            {
                return ((global::FlounderSharp.Buffer.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::FlounderSharp.Buffer.__Internal*)__Instance)->m_size = value;
            }
        }

        public global::System.IntPtr __PointerToBuffer
        {
            get
            {
                return __Instance + 0;
            }
        }

        public ulong VkSize
        {
            get
            {
                var __ret = __Internal.GetVkSize((__Instance));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~Buffer()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Buffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial interface IBuffer : IDisposable
    {
        void Dispose();

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToBuffer { get; }

        ulong VkSize { get; }
    }
}

namespace FlounderSharp
{
    public unsafe partial class VertexBuffer : global::FlounderSharp.Buffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal uint m_vertexCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexBuffer@fl@@QEAA@AEB_K0PEAX@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong elementSize, ulong vertexCount, global::System.IntPtr newData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexBuffer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexCount@VertexBuffer@fl@@QEBAIXZ")]
            internal static extern uint GetVertexCount(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.VertexBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexBuffer __CreateInstance(global::FlounderSharp.VertexBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexBuffer.__Internal));
            global::FlounderSharp.VertexBuffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexBuffer(global::FlounderSharp.VertexBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public VertexBuffer(ulong elementSize, ulong vertexCount, global::System.IntPtr newData)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), elementSize, vertexCount, newData);
            SetupVTables(GetType().FullName == "FlounderSharp.VertexBuffer");
        }

        public VertexBuffer(global::FlounderSharp.VertexBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.VertexBuffer");
        }

        public uint VertexCount
        {
            get
            {
                var __ret = __Internal.GetVertexCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~VertexBuffer()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class IndexBuffer : global::FlounderSharp.Buffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal global::VkIndexType m_indexType;

            [FieldOffset(36)]
            internal uint m_indexCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IndexBuffer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndexCount@IndexBuffer@fl@@QEBAIXZ")]
            internal static extern uint GetIndexCount(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.IndexBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IndexBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IndexBuffer __CreateInstance(global::FlounderSharp.IndexBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IndexBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.IndexBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IndexBuffer.__Internal));
            global::FlounderSharp.IndexBuffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private IndexBuffer(global::FlounderSharp.IndexBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IndexBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public IndexBuffer(global::FlounderSharp.IndexBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IndexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IndexBuffer");
        }

        public uint IndexCount
        {
            get
            {
                var __ret = __Internal.GetIndexCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~IndexBuffer()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IndexBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe abstract partial class IVertex : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IVertex@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IVertex@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IVertex@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IVertex> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IVertex>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IVertex __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IVertexInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IVertex __CreateInstance(global::FlounderSharp.IVertex.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IVertexInternal(native, skipVTables);
        }

        protected IVertex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IVertex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IVertex");
        }

        protected IVertex(global::FlounderSharp.IVertex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IVertex");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IVertex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IVertex.__Internal*) __Instance)->vfptr_IVertex = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract global::FlounderSharp.Vector3 Position
        {
            get;

            set;
        }

        public abstract ulong Size
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IVertex() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 GetPosition() const = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        // size_t GetSize() const = 0
        private static global::FlounderSharp.Delegates.Func_ulong_IntPtr _GetSizeDelegateInstance;

        private static ulong _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IVertexInternal : global::FlounderSharp.IVertex, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IVertex.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IVertex.__Internal));
            *(global::FlounderSharp.IVertex.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IVertexInternal(global::FlounderSharp.IVertex.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IVertexInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___SetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override ulong Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetSizeDelegate = (global::FlounderSharp.Delegates.Func_ulong_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_ulong_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class VertexModel : global::FlounderSharp.IVertex, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [FieldOffset(8)]
            internal global::FlounderSharp.Vector3.__Internal m_position;

            [FieldOffset(20)]
            internal global::FlounderSharp.Vector2.__Internal m_uv;

            [FieldOffset(28)]
            internal global::FlounderSharp.Vector3.__Internal m_normal;

            [FieldOffset(40)]
            internal global::FlounderSharp.Vector3.__Internal m_tangent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModel@fl@@QEAA@AEBVVector3@1@AEBVVector2@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr uv, global::System.IntPtr normal, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModel@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@VertexModel@fl@@SA?AVVertexInput@2@XZ")]
            internal static extern void GetVertexInput(global::System.IntPtr @return);
        }

        internal static new global::FlounderSharp.VertexModel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexModel(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexModel __CreateInstance(global::FlounderSharp.VertexModel.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexModel(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexModel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexModel.__Internal));
            global::FlounderSharp.VertexModel.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexModel(global::FlounderSharp.VertexModel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexModel(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public VertexModel(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector2 uv, global::FlounderSharp.Vector3 normal, global::FlounderSharp.Vector3 tangent)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexModel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = normal.__Instance;
            if (ReferenceEquals(tangent, null))
                throw new global::System.ArgumentNullException("tangent", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = tangent.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "FlounderSharp.VertexModel");
        }

        public VertexModel(global::FlounderSharp.VertexModel source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexModel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.VertexModel");
        }

        public global::FlounderSharp.Vector3 MPosition
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexModel.__Internal*) __Instance)->m_position));
            }

            set
            {
                ((global::FlounderSharp.VertexModel.__Internal*)__Instance)->m_position = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector2 MUv
        {
            get
            {
                return global::FlounderSharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexModel.__Internal*) __Instance)->m_uv));
            }

            set
            {
                ((global::FlounderSharp.VertexModel.__Internal*)__Instance)->m_uv = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MNormal
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexModel.__Internal*) __Instance)->m_normal));
            }

            set
            {
                ((global::FlounderSharp.VertexModel.__Internal*)__Instance)->m_normal = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MTangent
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexModel.__Internal*) __Instance)->m_tangent));
            }

            set
            {
                ((global::FlounderSharp.VertexModel.__Internal*)__Instance)->m_tangent = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public override global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___SetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override ulong Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetSizeDelegate = (global::FlounderSharp.Delegates.Func_ulong_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_ulong_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public static global::FlounderSharp.VertexInput VertexInput
        {
            get
            {
                var __ret = new global::FlounderSharp.VertexInput.__Internal();
                __Internal.GetVertexInput(new IntPtr(&__ret));
                return global::FlounderSharp.VertexInput.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~VertexModel()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 GetPosition() const override { return m_position; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) override { m_position = position; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        // size_t GetSize() const override { return sizeof(VertexModel); }
        private static global::FlounderSharp.Delegates.Func_ulong_IntPtr _GetSizeDelegateInstance;

        private static ulong _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class VertexModelData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal int m_uvIndex;

            [FieldOffset(16)]
            internal int m_normalIndex;

            [FieldOffset(24)]
            internal global::System.IntPtr m_duplicateVertex;

            [FieldOffset(32)]
            internal uint m_index;

            [FieldOffset(36)]
            internal float m_length;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_Vector3___N_std_S_allocator__S0_ m_tangents;

            [FieldOffset(64)]
            internal global::FlounderSharp.Vector3.__Internal m_averagedTangent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModelData@fl@@QEAA@AEBIAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint index, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModelData@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexModelData@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddTangent@VertexModelData@fl@@QEAAXPEAVVector3@2@@Z")]
            internal static extern void AddTangent(global::System.IntPtr instance, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AverageTangents@VertexModelData@fl@@QEAAXXZ")]
            internal static extern void AverageTangents(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasSameTextureAndNormal@VertexModelData@fl@@QEBA_NAEBH0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSameTextureAndNormal(global::System.IntPtr instance, int textureIndexOther, int normalIndexOther);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUvIndex@VertexModelData@fl@@QEBAHXZ")]
            internal static extern int GetUvIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUvIndex@VertexModelData@fl@@QEAAXAEBH@Z")]
            internal static extern void SetUvIndex(global::System.IntPtr instance, int uvIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormalIndex@VertexModelData@fl@@QEBAHXZ")]
            internal static extern int GetNormalIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormalIndex@VertexModelData@fl@@QEAAXAEBH@Z")]
            internal static extern void SetNormalIndex(global::System.IntPtr instance, int normalIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDuplicateVertex@VertexModelData@fl@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetDuplicateVertex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDuplicateVertex@VertexModelData@fl@@QEAAXPEAV12@@Z")]
            internal static extern void SetDuplicateVertex(global::System.IntPtr instance, global::System.IntPtr duplicateVertex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@VertexModelData@fl@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@VertexModelData@fl@@QEBAIXZ")]
            internal static extern uint GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@VertexModelData@fl@@QEBAMXZ")]
            internal static extern float GetLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAverageTangent@VertexModelData@fl@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetAverageTangent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSet@VertexModelData@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexModelData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexModelData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.VertexModelData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexModelData(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexModelData __CreateInstance(global::FlounderSharp.VertexModelData.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexModelData(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexModelData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexModelData.__Internal));
            global::FlounderSharp.VertexModelData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexModelData(global::FlounderSharp.VertexModelData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexModelData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexModelData(uint index, global::FlounderSharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexModelData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), index, __arg1);
        }

        public VertexModelData(global::FlounderSharp.VertexModelData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexModelData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.VertexModelData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddTangent(global::FlounderSharp.Vector3 tangent)
        {
            var __arg0 = ReferenceEquals(tangent, null) ? global::System.IntPtr.Zero : tangent.__Instance;
            __Internal.AddTangent((__Instance + __PointerAdjustment), __arg0);
        }

        public void AverageTangents()
        {
            __Internal.AverageTangents((__Instance + __PointerAdjustment));
        }

        public bool HasSameTextureAndNormal(int textureIndexOther, int normalIndexOther)
        {
            var __ret = __Internal.HasSameTextureAndNormal((__Instance + __PointerAdjustment), textureIndexOther, normalIndexOther);
            return __ret;
        }

        public int UvIndex
        {
            get
            {
                var __ret = __Internal.GetUvIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetUvIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public int NormalIndex
        {
            get
            {
                var __ret = __Internal.GetNormalIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetNormalIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.VertexModelData DuplicateVertex
        {
            get
            {
                var __ret = __Internal.GetDuplicateVertex((__Instance + __PointerAdjustment));
                global::FlounderSharp.VertexModelData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.VertexModelData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.VertexModelData) global::FlounderSharp.VertexModelData.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.VertexModelData.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetDuplicateVertex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public uint Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.Vector3 AverageTangent
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.GetAverageTangent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public bool IsSet
        {
            get
            {
                var __ret = __Internal.IsSet((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a OBJ model.</summary>
    public unsafe partial class Model : global::FlounderSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@Model@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Model@fl@@QEAAXAEBVCommandBuffer@2@AEBI@Z")]
            internal static extern void CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, uint instances);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAabb@Model@fl@@QEBAPEAVColliderAabb@2@XZ")]
            internal static extern global::System.IntPtr GetAabb(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexBuffer@Model@fl@@QEBAPEAVVertexBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetVertexBuffer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndexBuffer@Model@fl@@QEBAPEAVIndexBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetIndexBuffer(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Model __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Model(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Model __CreateInstance(global::FlounderSharp.Model.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Model(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Model.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Model.__Internal));
            global::FlounderSharp.Model.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Model(global::FlounderSharp.Model.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Model(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new empty model.</summary>
        public Model()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Model");
        }

        /// <summary>Creates a new model.</summary>
        /// <param name="filename">The file name.</param>
        public Model(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.Model");
        }

        public Model(global::FlounderSharp.Model _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Model");
        }

        public void CmdRender(global::FlounderSharp.CommandBuffer commandBuffer, uint instances)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, instances);
        }

        public static implicit operator global::FlounderSharp.Model(string filename)
        {
            return new global::FlounderSharp.Model(filename);
        }

        public static global::FlounderSharp.Model Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.Model __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Model.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.NativeToManagedMap[__ret];
            else global::FlounderSharp.Model.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.__CreateInstance(__ret);
            return __result0;
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public global::FlounderSharp.ColliderAabb Aabb
        {
            get
            {
                var __ret = __Internal.GetAabb((__Instance + __PointerAdjustment));
                global::FlounderSharp.ColliderAabb __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
                else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.VertexBuffer VertexBuffer
        {
            get
            {
                var __ret = __Internal.GetVertexBuffer((__Instance + __PointerAdjustment));
                global::FlounderSharp.VertexBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.VertexBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.VertexBuffer) global::FlounderSharp.VertexBuffer.NativeToManagedMap[__ret];
                else global::FlounderSharp.VertexBuffer.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.VertexBuffer) global::FlounderSharp.VertexBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.IndexBuffer IndexBuffer
        {
            get
            {
                var __ret = __Internal.GetIndexBuffer((__Instance + __PointerAdjustment));
                global::FlounderSharp.IndexBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.IndexBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.IndexBuffer) global::FlounderSharp.IndexBuffer.NativeToManagedMap[__ret];
                else global::FlounderSharp.IndexBuffer.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IndexBuffer) global::FlounderSharp.IndexBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Model()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Model) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Model) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class VertexSkinData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I m_jointIds;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_weights;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexSkinData@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexSkinData@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexSkinData@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddJointEffect@VertexSkinData@fl@@QEAAXAEBHAEBM@Z")]
            internal static extern void AddJointEffect(global::System.IntPtr instance, int jointId, float weight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LimitJointNumber@VertexSkinData@fl@@QEAAXAEBI@Z")]
            internal static extern void LimitJointNumber(global::System.IntPtr instance, uint max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FillEmptyWeights@VertexSkinData@fl@@QEAAXAEBI@Z")]
            internal static extern void FillEmptyWeights(global::System.IntPtr instance, uint max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveExcessJointIds@VertexSkinData@fl@@QEAAXAEBI@Z")]
            internal static extern void RemoveExcessJointIds(global::System.IntPtr instance, uint max);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexSkinData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexSkinData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.VertexSkinData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexSkinData(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexSkinData __CreateInstance(global::FlounderSharp.VertexSkinData.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexSkinData(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexSkinData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexSkinData.__Internal));
            global::FlounderSharp.VertexSkinData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexSkinData(global::FlounderSharp.VertexSkinData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexSkinData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexSkinData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexSkinData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public VertexSkinData(global::FlounderSharp.VertexSkinData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexSkinData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.VertexSkinData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddJointEffect(int jointId, float weight)
        {
            __Internal.AddJointEffect((__Instance + __PointerAdjustment), jointId, weight);
        }

        public void LimitJointNumber(uint max)
        {
            __Internal.LimitJointNumber((__Instance + __PointerAdjustment), max);
        }

        public void FillEmptyWeights(uint max)
        {
            __Internal.FillEmptyWeights((__Instance + __PointerAdjustment), max);
        }

        public void RemoveExcessJointIds(uint max)
        {
            __Internal.RemoveExcessJointIds((__Instance + __PointerAdjustment), max);
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class SkinLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_skinData;

            [FieldOffset(8)]
            internal int m_maxWeights;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_jointOrder;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_VertexSkinData___N_std_S_allocator__S0_ m_verticesSkinData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkinLoader@fl@@QEAA@PEAVLoadedValue@1@AEBH@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr libraryControllers, int maxWeights);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkinLoader@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SkinLoader@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SkinLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SkinLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.SkinLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SkinLoader(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SkinLoader __CreateInstance(global::FlounderSharp.SkinLoader.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SkinLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SkinLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SkinLoader.__Internal));
            global::FlounderSharp.SkinLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SkinLoader(global::FlounderSharp.SkinLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SkinLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SkinLoader(global::FlounderSharp.LoadedValue libraryControllers, int maxWeights)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SkinLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(libraryControllers, null) ? global::System.IntPtr.Zero : libraryControllers.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, maxWeights);
        }

        public SkinLoader(global::FlounderSharp.SkinLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SkinLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.SkinLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class VertexAnimated : global::FlounderSharp.IVertex, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [FieldOffset(8)]
            internal global::FlounderSharp.Vector3.__Internal m_position;

            [FieldOffset(20)]
            internal global::FlounderSharp.Vector2.__Internal m_uv;

            [FieldOffset(28)]
            internal global::FlounderSharp.Vector3.__Internal m_normal;

            [FieldOffset(40)]
            internal global::FlounderSharp.Vector3.__Internal m_tangent;

            [FieldOffset(52)]
            internal global::FlounderSharp.Vector3.__Internal m_jointId;

            [FieldOffset(64)]
            internal global::FlounderSharp.Vector3.__Internal m_vertexWeight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimated@fl@@QEAA@AEBVVector3@1@AEBVVector2@1@0000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr uv, global::System.IntPtr normal, global::System.IntPtr tangent, global::System.IntPtr jointId, global::System.IntPtr vertexWeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimated@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@VertexAnimated@fl@@SA?AVVertexInput@2@XZ")]
            internal static extern void GetVertexInput(global::System.IntPtr @return);
        }

        internal static new global::FlounderSharp.VertexAnimated __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexAnimated(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexAnimated __CreateInstance(global::FlounderSharp.VertexAnimated.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexAnimated(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexAnimated.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAnimated.__Internal));
            global::FlounderSharp.VertexAnimated.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAnimated(global::FlounderSharp.VertexAnimated.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAnimated(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public VertexAnimated(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector2 uv, global::FlounderSharp.Vector3 normal, global::FlounderSharp.Vector3 tangent, global::FlounderSharp.Vector3 jointId, global::FlounderSharp.Vector3 vertexWeight)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = normal.__Instance;
            if (ReferenceEquals(tangent, null))
                throw new global::System.ArgumentNullException("tangent", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = tangent.__Instance;
            if (ReferenceEquals(jointId, null))
                throw new global::System.ArgumentNullException("jointId", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = jointId.__Instance;
            if (ReferenceEquals(vertexWeight, null))
                throw new global::System.ArgumentNullException("vertexWeight", "Cannot be null because it is a C++ reference (&).");
            var __arg5 = vertexWeight.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
            SetupVTables(GetType().FullName == "FlounderSharp.VertexAnimated");
        }

        public VertexAnimated(global::FlounderSharp.VertexAnimated source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.VertexAnimated");
        }

        public global::FlounderSharp.Vector3 MPosition
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexAnimated.__Internal*) __Instance)->m_position));
            }

            set
            {
                ((global::FlounderSharp.VertexAnimated.__Internal*)__Instance)->m_position = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector2 MUv
        {
            get
            {
                return global::FlounderSharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexAnimated.__Internal*) __Instance)->m_uv));
            }

            set
            {
                ((global::FlounderSharp.VertexAnimated.__Internal*)__Instance)->m_uv = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MNormal
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexAnimated.__Internal*) __Instance)->m_normal));
            }

            set
            {
                ((global::FlounderSharp.VertexAnimated.__Internal*)__Instance)->m_normal = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MTangent
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexAnimated.__Internal*) __Instance)->m_tangent));
            }

            set
            {
                ((global::FlounderSharp.VertexAnimated.__Internal*)__Instance)->m_tangent = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MJointId
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexAnimated.__Internal*) __Instance)->m_jointId));
            }

            set
            {
                ((global::FlounderSharp.VertexAnimated.__Internal*)__Instance)->m_jointId = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::FlounderSharp.Vector3 MVertexWeight
        {
            get
            {
                return global::FlounderSharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::FlounderSharp.VertexAnimated.__Internal*) __Instance)->m_vertexWeight));
            }

            set
            {
                ((global::FlounderSharp.VertexAnimated.__Internal*)__Instance)->m_vertexWeight = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public override global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___SetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override ulong Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetSizeDelegate = (global::FlounderSharp.Delegates.Func_ulong_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_ulong_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public static global::FlounderSharp.VertexInput VertexInput
        {
            get
            {
                var __ret = new global::FlounderSharp.VertexInput.__Internal();
                __Internal.GetVertexInput(new IntPtr(&__ret));
                return global::FlounderSharp.VertexInput.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ~VertexAnimated()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 GetPosition() const override { return m_position; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) override { m_position = position; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        // size_t GetSize() const override { return sizeof(VertexAnimated); }
        private static global::FlounderSharp.Delegates.Func_ulong_IntPtr _GetSizeDelegateInstance;

        private static ulong _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class VertexAnimatedData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal int m_uvIndex;

            [FieldOffset(16)]
            internal int m_normalIndex;

            [FieldOffset(24)]
            internal global::System.IntPtr m_duplicateVertex;

            [FieldOffset(32)]
            internal uint m_index;

            [FieldOffset(36)]
            internal float m_length;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_Vector3___N_std_S_allocator__S0_ m_tangents;

            [FieldOffset(64)]
            internal global::FlounderSharp.Vector3.__Internal m_averagedTangent;

            [FieldOffset(80)]
            internal global::System.IntPtr m_skinData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimatedData@fl@@QEAA@AEBIAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint index, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimatedData@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexAnimatedData@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddTangent@VertexAnimatedData@fl@@QEAAXPEAVVector3@2@@Z")]
            internal static extern void AddTangent(global::System.IntPtr instance, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AverageTangents@VertexAnimatedData@fl@@QEAAXXZ")]
            internal static extern void AverageTangents(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasSameTextureAndNormal@VertexAnimatedData@fl@@QEBA_NAEBH0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSameTextureAndNormal(global::System.IntPtr instance, int textureIndexOther, int normalIndexOther);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUvIndex@VertexAnimatedData@fl@@QEBAHXZ")]
            internal static extern int GetUvIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUvIndex@VertexAnimatedData@fl@@QEAAXAEBH@Z")]
            internal static extern void SetUvIndex(global::System.IntPtr instance, int uvIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormalIndex@VertexAnimatedData@fl@@QEBAHXZ")]
            internal static extern int GetNormalIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormalIndex@VertexAnimatedData@fl@@QEAAXAEBH@Z")]
            internal static extern void SetNormalIndex(global::System.IntPtr instance, int normalIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDuplicateVertex@VertexAnimatedData@fl@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetDuplicateVertex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDuplicateVertex@VertexAnimatedData@fl@@QEAAXPEAV12@@Z")]
            internal static extern void SetDuplicateVertex(global::System.IntPtr instance, global::System.IntPtr duplicateVertex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSkinData@VertexAnimatedData@fl@@QEBAPEAVVertexSkinData@2@XZ")]
            internal static extern global::System.IntPtr GetSkinData(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSkinData@VertexAnimatedData@fl@@QEAAXPEAVVertexSkinData@2@@Z")]
            internal static extern void SetSkinData(global::System.IntPtr instance, global::System.IntPtr skinData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@VertexAnimatedData@fl@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@VertexAnimatedData@fl@@QEBAIXZ")]
            internal static extern uint GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@VertexAnimatedData@fl@@QEBAMXZ")]
            internal static extern float GetLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAverageTangent@VertexAnimatedData@fl@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetAverageTangent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSet@VertexAnimatedData@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexAnimatedData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VertexAnimatedData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.VertexAnimatedData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexAnimatedData(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VertexAnimatedData __CreateInstance(global::FlounderSharp.VertexAnimatedData.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VertexAnimatedData(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VertexAnimatedData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAnimatedData.__Internal));
            global::FlounderSharp.VertexAnimatedData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAnimatedData(global::FlounderSharp.VertexAnimatedData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAnimatedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexAnimatedData(uint index, global::FlounderSharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAnimatedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), index, __arg1);
        }

        public VertexAnimatedData(global::FlounderSharp.VertexAnimatedData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VertexAnimatedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.VertexAnimatedData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddTangent(global::FlounderSharp.Vector3 tangent)
        {
            var __arg0 = ReferenceEquals(tangent, null) ? global::System.IntPtr.Zero : tangent.__Instance;
            __Internal.AddTangent((__Instance + __PointerAdjustment), __arg0);
        }

        public void AverageTangents()
        {
            __Internal.AverageTangents((__Instance + __PointerAdjustment));
        }

        public bool HasSameTextureAndNormal(int textureIndexOther, int normalIndexOther)
        {
            var __ret = __Internal.HasSameTextureAndNormal((__Instance + __PointerAdjustment), textureIndexOther, normalIndexOther);
            return __ret;
        }

        public int UvIndex
        {
            get
            {
                var __ret = __Internal.GetUvIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetUvIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public int NormalIndex
        {
            get
            {
                var __ret = __Internal.GetNormalIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetNormalIndex((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.VertexAnimatedData DuplicateVertex
        {
            get
            {
                var __ret = __Internal.GetDuplicateVertex((__Instance + __PointerAdjustment));
                global::FlounderSharp.VertexAnimatedData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.VertexAnimatedData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.VertexAnimatedData) global::FlounderSharp.VertexAnimatedData.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.VertexAnimatedData.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetDuplicateVertex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.VertexSkinData SkinData
        {
            get
            {
                var __ret = __Internal.GetSkinData((__Instance + __PointerAdjustment));
                global::FlounderSharp.VertexSkinData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.VertexSkinData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.VertexSkinData) global::FlounderSharp.VertexSkinData.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.VertexSkinData.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetSkinData((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public uint Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.Vector3 AverageTangent
        {
            get
            {
                var __ret = new global::FlounderSharp.Vector3.__Internal();
                __Internal.GetAverageTangent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Vector3.__CreateInstance(__ret);
            }
        }

        public bool IsSet
        {
            get
            {
                var __ret = __Internal.IsSet((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class GeometryLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 152)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_meshData;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_VertexSkinData___N_std_S_allocator__S0_ m_vertexWeights;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_VertexAnimatedData___N_std_S_allocator__S0_ m_positionsList;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_fl_S_Vector2___N_std_S_allocator__S0_ m_uvsList;

            [FieldOffset(80)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_fl_S_Vector3___N_std_S_allocator__S0_ m_normalsList;

            [FieldOffset(104)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_IVertex___N_std_S_allocator__S0_ m_vertices;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_indices;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GeometryLoader@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1GeometryLoader@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.GeometryLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.GeometryLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.GeometryLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.GeometryLoader(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.GeometryLoader __CreateInstance(global::FlounderSharp.GeometryLoader.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.GeometryLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.GeometryLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GeometryLoader.__Internal));
            global::FlounderSharp.GeometryLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private GeometryLoader(global::FlounderSharp.GeometryLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GeometryLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GeometryLoader(global::FlounderSharp.GeometryLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.GeometryLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.GeometryLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A class that holds many various math functions.</summary>
    public unsafe partial class Maths : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Maths@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LogRandom@Maths@fl@@SAMAEBM0@Z")]
            internal static extern float LogRandom(float lowerLimit, float upperLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?NormallyDistributedSingle@Maths@fl@@SAMAEBM0@Z")]
            internal static extern float NormallyDistributedSingle(float standardDeviation, float mean);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Radians@Maths@fl@@SAMAEBM@Z")]
            internal static extern float Radians(float degrees);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Degrees@Maths@fl@@SAMAEBM@Z")]
            internal static extern float Degrees(float radians);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?NormalizeAngle@Maths@fl@@SAMAEBM@Z")]
            internal static extern float NormalizeAngle(float angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RoundToPlace@Maths@fl@@SAMAEBMAEBH@Z")]
            internal static extern float RoundToPlace(float value, int place);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Deadband@Maths@fl@@SAMAEBM0@Z")]
            internal static extern float Deadband(float min, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Clamp@Maths@fl@@SAMAEBM00@Z")]
            internal static extern float Clamp(float value, float min, float max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Limit@Maths@fl@@SAMAEBM0@Z")]
            internal static extern float Limit(float value, float limit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AlmostEqual@Maths@fl@@SA_NAEBM00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AlmostEqual(float a, float b, float eps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Maths@fl@@SAMAEBM00@Z")]
            internal static extern float SmoothDamp(float current, float target, float rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@Maths@fl@@SAMAEBM00@Z")]
            internal static extern float Interpolate(float a, float b, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CosInterpolate@Maths@fl@@SAMAEBM00@Z")]
            internal static extern float CosInterpolate(float a, float b, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothlyStep@Maths@fl@@SAMAEBM00@Z")]
            internal static extern float SmoothlyStep(float edge0, float edge1, float x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomInRange@Maths@fl@@SAMAEBM0@Z")]
            internal static extern float RandomInRange(float min, float max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Random@Maths@fl@@SAMXZ")]
            internal static extern float Random();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Maths> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Maths>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Maths __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Maths(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Maths __CreateInstance(global::FlounderSharp.Maths.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Maths(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Maths.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Maths.__Internal));
            *(global::FlounderSharp.Maths.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Maths(global::FlounderSharp.Maths.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Maths(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Maths()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Maths.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Maths(global::FlounderSharp.Maths _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Maths.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Maths.__Internal*) __Instance) = *((global::FlounderSharp.Maths.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Maths __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Creates a number between two numbers, logarithmic.</summary>
        /// <param name="lowerLimit">The lower number.</param>
        /// <param name="upperLimit">The upper number.</param>
        public static float LogRandom(float lowerLimit, float upperLimit)
        {
            var __ret = __Internal.LogRandom(lowerLimit, upperLimit);
            return __ret;
        }

        /// <summary>Generates a single value from a normal distribution, using Box-Muller. https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform</summary>
        /// <param name="standardDeviation">The standards deviation of the distribution.</param>
        /// <param name="mean">The mean of the distribution.</param>
        public static float NormallyDistributedSingle(float standardDeviation, float mean)
        {
            var __ret = __Internal.NormallyDistributedSingle(standardDeviation, mean);
            return __ret;
        }

        /// <summary>Converts degrees to radians.</summary>
        /// <param name="degrees">The degrees value.</param>
        public static float Radians(float degrees)
        {
            var __ret = __Internal.Radians(degrees);
            return __ret;
        }

        /// <summary>Converts radians to degrees.</summary>
        /// <param name="radians">The radians value.</param>
        public static float Degrees(float radians)
        {
            var __ret = __Internal.Degrees(radians);
            return __ret;
        }

        /// <summary>Normalizes a angle into the range of 0-360.</summary>
        /// <param name="angle">The source angle.</param>
        public static float NormalizeAngle(float angle)
        {
            var __ret = __Internal.NormalizeAngle(angle);
            return __ret;
        }

        /// <summary>Rounds a value to a amount of places after the decimal point.</summary>
        /// <param name="value">The value to round.</param>
        /// <param name="place">How many places after the decimal to round to.</param>
        public static float RoundToPlace(float value, int place)
        {
            var __ret = __Internal.RoundToPlace(value, place);
            return __ret;
        }

        /// <summary>Used to floor the value if less than the min.</summary>
        /// <param name="min">The minimum value.</param>
        /// <param name="value">The value.</param>
        public static float Deadband(float min, float value)
        {
            var __ret = __Internal.Deadband(min, value);
            return __ret;
        }

        /// <summary>Ensures {@code value} is in the range of {@code min} to {@code max}. If {@code value} is greater than {@code max}, this will return {@code max}. If {@code value} is less than {@code min}, this will return {@code min}. Otherwise, {@code value} is returned unchanged.</summary>
        /// <param name="value">The value to clamp.</param>
        /// <param name="min">The smallest value of the result.</param>
        /// <param name="max">The largest value of the result.</param>
        public static float Clamp(float value, float min, float max)
        {
            var __ret = __Internal.Clamp(value, min, max);
            return __ret;
        }

        /// <summary>Limits the value.</summary>
        /// <param name="value">The value.</param>
        /// <param name="limit">The limit.</param>
        public static float Limit(float value, float limit)
        {
            var __ret = __Internal.Limit(value, limit);
            return __ret;
        }

        /// <summary>Checks if two values are almost equal.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="eps">EPS is the measure of equality.</param>
        public static bool AlmostEqual(float a, float b, float eps)
        {
            var __ret = __Internal.AlmostEqual(a, b, eps);
            return __ret;
        }

        /// <summary>Gradually changes a value to a target.</summary>
        /// <param name="current">The current value.</param>
        /// <param name="target">The target value.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public static float SmoothDamp(float current, float target, float rate)
        {
            var __ret = __Internal.SmoothDamp(current, target, rate);
            return __ret;
        }

        /// <summary>Interpolates two values by a blendFactor using linear interpolation.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="blend">The blend value.</param>
        public static float Interpolate(float a, float b, float blend)
        {
            var __ret = __Internal.Interpolate(a, b, blend);
            return __ret;
        }

        /// <summary>Interpolates two values by a blendFactor using cos interpolation.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="blend">The blend value.</param>
        public static float CosInterpolate(float a, float b, float blend)
        {
            var __ret = __Internal.CosInterpolate(a, b, blend);
            return __ret;
        }

        /// <summary>A calculation that steps smoothly between two edges.</summary>
        /// <param name="edge0">The inner edge.</param>
        /// <param name="edge1">The outer edge.</param>
        /// <param name="x">The sample.</param>
        public static float SmoothlyStep(float edge0, float edge1, float x)
        {
            var __ret = __Internal.SmoothlyStep(edge0, edge1, x);
            return __ret;
        }

        /// <summary>Generates a random value from between a range.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        public static float RandomInRange(float min, float max)
        {
            var __ret = __Internal.RandomInRange(min, max);
            return __ret;
        }

        /// <summary>Gets a random number between 0.0 and 1.0.</summary>
        public static float Random
        {
            get
            {
                var __ret = __Internal.Random();
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Mesh : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mesh@fl@@QEAA@PEAVModel@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr model);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mesh@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.Mesh __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Mesh(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Mesh __CreateInstance(global::FlounderSharp.Mesh.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Mesh(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Mesh.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Mesh.__Internal));
            global::FlounderSharp.Mesh.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Mesh(global::FlounderSharp.Mesh.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mesh(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public Mesh(global::FlounderSharp.Model model)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Mesh.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(model, null) ? global::System.IntPtr.Zero : model.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Mesh");
        }

        public Mesh(global::FlounderSharp.Mesh _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Mesh.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Mesh");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public virtual void TrySetModel(string filename)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___TrySetModelDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            ___TrySetModelDelegate((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public static implicit operator global::FlounderSharp.Mesh(global::FlounderSharp.Model model)
        {
            return new global::FlounderSharp.Mesh(model);
        }

        public virtual global::FlounderSharp.Model Model
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetModelDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetModelDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Model __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Model.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.NativeToManagedMap[__ret];
                else global::FlounderSharp.Model.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___SetModelDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                ___SetModelDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~Mesh()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "Mesh"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Model *GetModel() const { return m_model; }
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetModelDelegateInstance;

        private static global::System.IntPtr _GetModelDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Model;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // void SetModel(Model *model) { m_model = model; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _SetModelDelegateInstance;

        private static void _SetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr model)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Model __result0;
            if (model == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Model.NativeToManagedMap.ContainsKey(model))
                __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.NativeToManagedMap[model];
            else __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.__CreateInstance(model, skipVTables: true);
            __target.Model = __result0;
        }

        // void TrySetModel(const std::string &filename)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _TrySetModelDelegateInstance;

        private static void _TrySetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(filename);
            __target.TrySetModel(global::Std.BasicStringExtensions.CStr(__basicStringRet));
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _GetModelDelegateInstance += _GetModelDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetModelDelegateInstance).ToPointer();
                _SetModelDelegateInstance += _SetModelDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetModelDelegateInstance).ToPointer();
                _TrySetModelDelegateInstance += _TrySetModelDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_TrySetModelDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class SkeletonLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_armatureData;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_boneOrder;

            [FieldOffset(32)]
            internal int m_jointCount;

            [FieldOffset(40)]
            internal global::System.IntPtr m_headJoint;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkeletonLoader@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SkeletonLoader@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointCount@SkeletonLoader@fl@@QEBAHXZ")]
            internal static extern int GetJointCount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeadJoint@SkeletonLoader@fl@@QEBAPEAVJointData@2@XZ")]
            internal static extern global::System.IntPtr GetHeadJoint(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SkeletonLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SkeletonLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.SkeletonLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SkeletonLoader(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SkeletonLoader __CreateInstance(global::FlounderSharp.SkeletonLoader.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SkeletonLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SkeletonLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SkeletonLoader.__Internal));
            global::FlounderSharp.SkeletonLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SkeletonLoader(global::FlounderSharp.SkeletonLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SkeletonLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SkeletonLoader(global::FlounderSharp.SkeletonLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SkeletonLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.SkeletonLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int JointCount
        {
            get
            {
                var __ret = __Internal.GetJointCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.JointData HeadJoint
        {
            get
            {
                var __ret = __Internal.GetHeadJoint((__Instance + __PointerAdjustment));
                global::FlounderSharp.JointData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.JointData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.JointData) global::FlounderSharp.JointData.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.JointData.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class MeshAnimated : global::FlounderSharp.Mesh, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 152)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_model;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(96)]
            internal global::System.IntPtr m_model1;

            [FieldOffset(104)]
            internal global::System.IntPtr m_headJoint;

            [FieldOffset(112)]
            internal global::System.IntPtr m_animation;

            [FieldOffset(120)]
            internal global::System.IntPtr m_animator;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_Matrix4___N_std_S_allocator__S0_ m_jointMatrices;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshAnimated@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshAnimated@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.MeshAnimated __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshAnimated(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MeshAnimated __CreateInstance(global::FlounderSharp.MeshAnimated.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshAnimated(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MeshAnimated.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshAnimated.__Internal));
            global::FlounderSharp.MeshAnimated.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshAnimated(global::FlounderSharp.MeshAnimated.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshAnimated(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MeshAnimated(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.MeshAnimated");
        }

        public MeshAnimated(global::FlounderSharp.MeshAnimated _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshAnimated");
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            base.Load(value);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            base.Write(value);
        }

        public override void TrySetModel(string filename)
        {
            base.TrySetModel(filename);
        }

        public static implicit operator global::FlounderSharp.MeshAnimated(string filename)
        {
            return new global::FlounderSharp.MeshAnimated(filename);
        }

        public static global::FlounderSharp.Matrix4 SCorrection
        {
            get
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?S_CORRECTION@MeshAnimated@fl@@2PEBVMatrix4@2@EB");
                global::FlounderSharp.Matrix4 __result0;
                if (*__ptr == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(*__ptr))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[*__ptr];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(*__ptr);
                return __result0;
            }

            set
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?S_CORRECTION@MeshAnimated@fl@@2PEBVMatrix4@2@EB");
                *__ptr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public static int MaxWeights
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?MAX_WEIGHTS@MeshAnimated@fl@@2HB");
                return *__ptr;
            }
        }

        public override global::FlounderSharp.Model Model
        {
            get
            {
                return base.Model;
            }

            set
            {
                base.Model = value;
            }
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~MeshAnimated()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "MeshAnimated"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Model *GetModel() const override { return m_model; }
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetModelDelegateInstance;

        private static global::System.IntPtr _GetModelDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Model;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // void SetModel(Model *model) override { m_model = model; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _SetModelDelegateInstance;

        private static void _SetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr model)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Model __result0;
            if (model == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Model.NativeToManagedMap.ContainsKey(model))
                __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.NativeToManagedMap[model];
            else __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.__CreateInstance(model, skipVTables: true);
            __target.Model = __result0;
        }

        // void TrySetModel(const std::string &filename) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _TrySetModelDelegateInstance;

        private static void _TrySetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(filename);
            __target.TrySetModel(global::Std.BasicStringExtensions.CStr(__basicStringRet));
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _GetModelDelegateInstance += _GetModelDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetModelDelegateInstance).ToPointer();
                _SetModelDelegateInstance += _SetModelDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_SetModelDelegateInstance).ToPointer();
                _TrySetModelDelegateInstance += _TrySetModelDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_TrySetModelDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

public unsafe partial class ALCdeviceStruct
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCdeviceStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCdeviceStruct>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::ALCdeviceStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::ALCdeviceStruct(native.ToPointer(), skipVTables);
    }

    internal static global::ALCdeviceStruct __CreateInstance(global::ALCdeviceStruct.__Internal native, bool skipVTables = false)
    {
        return new global::ALCdeviceStruct(native, skipVTables);
    }

    private static void* __CopyValue(global::ALCdeviceStruct.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::ALCdeviceStruct.__Internal));
        *(global::ALCdeviceStruct.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private ALCdeviceStruct(global::ALCdeviceStruct.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected ALCdeviceStruct(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class ALCcontextStruct
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCcontextStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCcontextStruct>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::ALCcontextStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::ALCcontextStruct(native.ToPointer(), skipVTables);
    }

    internal static global::ALCcontextStruct __CreateInstance(global::ALCcontextStruct.__Internal native, bool skipVTables = false)
    {
        return new global::ALCcontextStruct(native, skipVTables);
    }

    private static void* __CopyValue(global::ALCcontextStruct.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::ALCcontextStruct.__Internal));
        *(global::ALCcontextStruct.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private ALCcontextStruct(global::ALCcontextStruct.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected ALCcontextStruct(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for loading, managing and playing a variety of different sound types.</summary>
    public unsafe partial class Audio : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_alDevice;

            [FieldOffset(16)]
            internal global::System.IntPtr m_alContext;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Audio@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Audio@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Audio@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultAl@Audio@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultAl(global::System.IntPtr @return, int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ErrorAl@Audio@fl@@SAXAEBH@Z")]
            internal static extern void ErrorAl(int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAlcDevice@Audio@fl@@QEBAPEAUALCdevice_struct@@XZ")]
            internal static extern global::System.IntPtr GetAlcDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAlcContext@Audio@fl@@QEBAPEAUALCcontext_struct@@XZ")]
            internal static extern global::System.IntPtr GetAlcContext(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Audio __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Audio(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Audio __CreateInstance(global::FlounderSharp.Audio.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Audio(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Audio.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Audio.__Internal));
            global::FlounderSharp.Audio.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Audio(global::FlounderSharp.Audio.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Audio(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new audio module.</summary>
        public Audio()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Audio");
        }

        public Audio(global::FlounderSharp.Audio _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Audio");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Audio Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Audio __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Audio.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Audio) global::FlounderSharp.Audio.NativeToManagedMap[__ret];
            else global::FlounderSharp.Audio.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Audio) global::FlounderSharp.Audio.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultAl(int result)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultAl(new IntPtr(&__ret), result);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static void ErrorAl(int result)
        {
            __Internal.ErrorAl(result);
        }

        public global::ALCdeviceStruct AlcDevice
        {
            get
            {
                var __ret = __Internal.GetAlcDevice((__Instance + __PointerAdjustment));
                global::ALCdeviceStruct __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ALCdeviceStruct.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ALCdeviceStruct) global::ALCdeviceStruct.NativeToManagedMap[__ret];
                else __result0 = global::ALCdeviceStruct.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::ALCcontextStruct AlcContext
        {
            get
            {
                var __ret = __Internal.GetAlcContext((__Instance + __PointerAdjustment));
                global::ALCcontextStruct __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ALCcontextStruct.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ALCcontextStruct) global::ALCcontextStruct.NativeToManagedMap[__ret];
                else __result0 = global::ALCcontextStruct.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Audio()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Audio) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Audio) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a loaded sound.</summary>
    public unsafe partial class Sound : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_source;

            [FieldOffset(4)]
            internal byte m_playing;

            [FieldOffset(8)]
            internal float m_gain;

            [FieldOffset(12)]
            internal float m_pitch;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Sound@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBM1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, float gain, float pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Sound@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Sound@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Play@Sound@fl@@QEAAXXZ")]
            internal static extern void Play(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Loop@Sound@fl@@QEAAXXZ")]
            internal static extern void Loop(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Pause@Sound@fl@@QEAAXXZ")]
            internal static extern void Pause(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resume@Sound@fl@@QEAAXXZ")]
            internal static extern void Resume(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Stop@Sound@fl@@QEAAXXZ")]
            internal static extern void Stop(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Sound@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDirection@Sound@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetDirection(global::System.IntPtr instance, global::System.IntPtr direction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVelocity@Sound@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetVelocity(global::System.IntPtr instance, global::System.IntPtr velocity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGain@Sound@fl@@QEBAMXZ")]
            internal static extern float GetGain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGain@Sound@fl@@QEAAXAEBM@Z")]
            internal static extern void SetGain(global::System.IntPtr instance, float gain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPitch@Sound@fl@@QEBAMXZ")]
            internal static extern float GetPitch(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPitch@Sound@fl@@QEAAXAEBM@Z")]
            internal static extern void SetPitch(global::System.IntPtr instance, float pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPlaying@Sound@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPlaying(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Sound> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Sound>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Sound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Sound(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Sound __CreateInstance(global::FlounderSharp.Sound.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Sound(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Sound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Sound.__Internal));
            *(global::FlounderSharp.Sound.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Sound(global::FlounderSharp.Sound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sound(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Sound(string filename, float gain, float pitch)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, gain, pitch);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public Sound(global::FlounderSharp.Sound _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Sound.__Internal*) __Instance) = *((global::FlounderSharp.Sound.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Sound __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Play()
        {
            __Internal.Play((__Instance + __PointerAdjustment));
        }

        public void Loop()
        {
            __Internal.Loop((__Instance + __PointerAdjustment));
        }

        public void Pause()
        {
            __Internal.Pause((__Instance + __PointerAdjustment));
        }

        public void Resume()
        {
            __Internal.Resume((__Instance + __PointerAdjustment));
        }

        public void Stop()
        {
            __Internal.Stop((__Instance + __PointerAdjustment));
        }

        public void SetPosition(global::FlounderSharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetDirection(global::FlounderSharp.Vector3 direction)
        {
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = direction.__Instance;
            __Internal.SetDirection((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetVelocity(global::FlounderSharp.Vector3 velocity)
        {
            if (ReferenceEquals(velocity, null))
                throw new global::System.ArgumentNullException("velocity", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = velocity.__Instance;
            __Internal.SetVelocity((__Instance + __PointerAdjustment), __arg0);
        }

        public float Gain
        {
            get
            {
                var __ret = __Internal.GetGain((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetGain((__Instance + __PointerAdjustment), value);
            }
        }

        public float Pitch
        {
            get
            {
                var __ret = __Internal.GetPitch((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPitch((__Instance + __PointerAdjustment), value);
            }
        }

        public bool IsPlaying
        {
            get
            {
                var __ret = __Internal.IsPlaying((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a sound buffer.</summary>
    public unsafe partial class SoundBuffer : global::FlounderSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal uint m_buffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SoundBuffer@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SoundBuffer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@SoundBuffer@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBuffer@SoundBuffer@fl@@QEBAIXZ")]
            internal static extern uint GetBuffer(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.SoundBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SoundBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SoundBuffer __CreateInstance(global::FlounderSharp.SoundBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SoundBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SoundBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SoundBuffer.__Internal));
            global::FlounderSharp.SoundBuffer.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SoundBuffer(global::FlounderSharp.SoundBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public SoundBuffer(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SoundBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.SoundBuffer");
        }

        public SoundBuffer(global::FlounderSharp.SoundBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SoundBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.SoundBuffer");
        }

        public static implicit operator global::FlounderSharp.SoundBuffer(string filename)
        {
            return new global::FlounderSharp.SoundBuffer(filename);
        }

        public static global::FlounderSharp.SoundBuffer Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.SoundBuffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.SoundBuffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.SoundBuffer) global::FlounderSharp.SoundBuffer.NativeToManagedMap[__ret];
            else global::FlounderSharp.SoundBuffer.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.SoundBuffer) global::FlounderSharp.SoundBuffer.__CreateInstance(__ret);
            return __result0;
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public uint Buffer
        {
            get
            {
                var __ret = __Internal.GetBuffer((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~SoundBuffer()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SoundBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SoundBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>This class is used throughout the engine wherever the camera is involved, so that the engine doesn't rely at all on the camera's implementation.</summary>
    public unsafe abstract partial class ICamera : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ICamera;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ICamera@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ICamera@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ICamera@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ICamera> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ICamera>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ICamera __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ICameraInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ICamera __CreateInstance(global::FlounderSharp.ICamera.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ICameraInternal(native, skipVTables);
        }

        protected ICamera(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new camera.</summary>
        protected ICamera()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ICamera.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.ICamera");
        }

        protected ICamera(global::FlounderSharp.ICamera _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ICamera.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ICamera");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ICamera __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.ICamera.__Internal*) __Instance)->vfptr_ICamera = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Checks inputs and carries out smooth camera movement. Called before every frame.</summary>
        public abstract void Update();

        /// <summary>Prepares the camera for the reflection render pass.</summary>
        /// <param name="waterHeight">The height of the water to be reflected on.</param>
        public abstract void ReflectView(float waterHeight);

        /// <summary>Gets the distance of the near pane of the view frustum.</summary>
        public abstract float NearPlane
        {
            get;
        }

        /// <summary>Gets the distance of the view frustum's far plane.</summary>
        public abstract float FarPlane
        {
            get;
        }

        /// <summary>Gets the field of view angle for the view frustum.</summary>
        public abstract float Fov
        {
            get;
        }

        /// <summary>Gets the view frustum created by the current camera position and rotation.</summary>
        public abstract global::FlounderSharp.Frustum ViewFrustum
        {
            get;
        }

        /// <summary>Gets the ray that extends from the cameras position though the screen.</summary>
        public abstract global::FlounderSharp.Ray ViewRay
        {
            get;
        }

        /// <summary>Gets the view matrix created by the current camera position and rotation.</summary>
        public abstract global::FlounderSharp.Matrix4 ViewMatrix
        {
            get;
        }

        /// <summary>Gets the projection matrix used in the current scene render.</summary>
        public abstract global::FlounderSharp.Matrix4 ProjectionMatrix
        {
            get;
        }

        /// <summary>Gets the cameras 3D position in the world.</summary>
        public abstract global::FlounderSharp.Vector3 Position
        {
            get;
        }

        /// <summary>Gets the cameras 3D velocity in the world.</summary>
        public abstract global::FlounderSharp.Vector3 Velocity
        {
            get;
        }

        /// <summary>Gets the cameras 3D rotation in the world, where x=pitch, y=yaw, z=roll.</summary>
        public abstract global::FlounderSharp.Vector3 Rotation
        {
            get;
        }

        #region Virtual table interop

        // virtual ~ICamera() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void ReflectView(const float &waterHeight) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_float _ReflectViewDelegateInstance;

        private static void _ReflectViewDelegateHook(global::System.IntPtr instance, float waterHeight)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ReflectView(waterHeight);
        }

        // float GetNearPlane() const = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetNearPlaneDelegateInstance;

        private static float _GetNearPlaneDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.NearPlane;
            return __ret;
        }

        // float GetFarPlane() const = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetFarPlaneDelegateInstance;

        private static float _GetFarPlaneDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.FarPlane;
            return __ret;
        }

        // float GetFov() const = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetFovDelegateInstance;

        private static float _GetFovDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Fov;
            return __ret;
        }

        // Frustum *GetViewFrustum() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetViewFrustumDelegateInstance;

        private static global::System.IntPtr _GetViewFrustumDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewFrustum;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Ray *GetViewRay() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetViewRayDelegateInstance;

        private static global::System.IntPtr _GetViewRayDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewRay;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Matrix4 *GetViewMatrix() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetViewMatrixDelegateInstance;

        private static global::System.IntPtr _GetViewMatrixDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewMatrix;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Matrix4 *GetProjectionMatrix() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetProjectionMatrixDelegateInstance;

        private static global::System.IntPtr _GetProjectionMatrixDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ProjectionMatrix;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Vector3 *GetPosition() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static global::System.IntPtr _GetPositionDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Vector3 *GetVelocity() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetVelocityDelegateInstance;

        private static global::System.IntPtr _GetVelocityDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Velocity;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Vector3 *GetRotation() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetRotationDelegateInstance;

        private static global::System.IntPtr _GetRotationDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Rotation;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[13];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _ReflectViewDelegateInstance += _ReflectViewDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ReflectViewDelegateInstance).ToPointer();
                _GetNearPlaneDelegateInstance += _GetNearPlaneDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetNearPlaneDelegateInstance).ToPointer();
                _GetFarPlaneDelegateInstance += _GetFarPlaneDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetFarPlaneDelegateInstance).ToPointer();
                _GetFovDelegateInstance += _GetFovDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetFovDelegateInstance).ToPointer();
                _GetViewFrustumDelegateInstance += _GetViewFrustumDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetViewFrustumDelegateInstance).ToPointer();
                _GetViewRayDelegateInstance += _GetViewRayDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetViewRayDelegateInstance).ToPointer();
                _GetViewMatrixDelegateInstance += _GetViewMatrixDelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetViewMatrixDelegateInstance).ToPointer();
                _GetProjectionMatrixDelegateInstance += _GetProjectionMatrixDelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetProjectionMatrixDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _GetVelocityDelegateInstance += _GetVelocityDelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetVelocityDelegateInstance).ToPointer();
                _GetRotationDelegateInstance += _GetRotationDelegateHook;
                _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_GetRotationDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(14 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                    *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                    *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                    *(void**) (vfptr0 + 104) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 104);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(14 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                    *(void**) (vfptr0 + 72) = _Thunks[8];
                    *(void**) (vfptr0 + 80) = _Thunks[9];
                    *(void**) (vfptr0 + 88) = _Thunks[10];
                    *(void**) (vfptr0 + 96) = _Thunks[11];
                    *(void**) (vfptr0 + 104) = _Thunks[12];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class ICameraInternal : global::FlounderSharp.ICamera, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.ICamera.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ICamera.__Internal));
            *(global::FlounderSharp.ICamera.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ICameraInternal(global::FlounderSharp.ICamera.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ICameraInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Checks inputs and carries out smooth camera movement. Called before every frame.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Prepares the camera for the reflection render pass.</summary>
        /// <param name="waterHeight">The height of the water to be reflected on.</param>
        public override void ReflectView(float waterHeight)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ReflectViewDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_float));
            ___ReflectViewDelegate((__Instance + __PointerAdjustment), waterHeight);
        }

        /// <summary>Gets the distance of the near pane of the view frustum.</summary>
        public override float NearPlane
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetNearPlaneDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetNearPlaneDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the distance of the view frustum's far plane.</summary>
        public override float FarPlane
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetFarPlaneDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetFarPlaneDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the field of view angle for the view frustum.</summary>
        public override float Fov
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetFovDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetFovDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the view frustum created by the current camera position and rotation.</summary>
        public override global::FlounderSharp.Frustum ViewFrustum
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___GetViewFrustumDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetViewFrustumDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Frustum __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Frustum.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Frustum) global::FlounderSharp.Frustum.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Frustum.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the ray that extends from the cameras position though the screen.</summary>
        public override global::FlounderSharp.Ray ViewRay
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetViewRayDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetViewRayDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Ray __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Ray.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Ray) global::FlounderSharp.Ray.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Ray.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the view matrix created by the current camera position and rotation.</summary>
        public override global::FlounderSharp.Matrix4 ViewMatrix
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
                var ___GetViewMatrixDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetViewMatrixDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the projection matrix used in the current scene render.</summary>
        public override global::FlounderSharp.Matrix4 ProjectionMatrix
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
                var ___GetProjectionMatrixDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetProjectionMatrixDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the cameras 3D position in the world.</summary>
        public override global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
                var ___GetPositionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetPositionDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the cameras 3D velocity in the world.</summary>
        public override global::FlounderSharp.Vector3 Velocity
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
                var ___GetVelocityDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetVelocityDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the cameras 3D rotation in the world, where x=pitch, y=yaw, z=roll.</summary>
        public override global::FlounderSharp.Vector3 Rotation
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 13 * 8);
                var ___GetRotationDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetRotationDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a sub renderer in the engine.</summary>
    public unsafe abstract partial class IRenderer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IRenderer@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IRenderer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IRenderer@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IRenderer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IRenderer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IRenderer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IRendererInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IRenderer __CreateInstance(global::FlounderSharp.IRenderer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IRendererInternal(native, skipVTables);
        }

        protected IRenderer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new renderer.</summary>
        protected IRenderer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IRenderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IRenderer");
        }

        protected IRenderer(global::FlounderSharp.IRenderer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IRenderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IRenderer");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IRenderer.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Called when the renderer is needed to be rendered.</summary>
        /// <param name="clipPlane">The current clip plane.</param>
        /// <param name="camera">The camera to be used when rendering.</param>
        public abstract void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera);

        #region Virtual table interop

        // virtual ~IRenderer() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IRenderer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IRenderer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::FlounderSharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::FlounderSharp.Vector4.__CreateInstance(clipPlane);
            global::FlounderSharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[camera];
            else __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(camera, skipVTables: true);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IRendererInternal : global::FlounderSharp.IRenderer, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IRenderer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IRenderer.__Internal));
            *(global::FlounderSharp.IRenderer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IRendererInternal(global::FlounderSharp.IRenderer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IRendererInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Called when the renderer is needed to be rendered.</summary>
        /// <param name="clipPlane">The current clip plane.</param>
        /// <param name="camera">The camera to be used when rendering.</param>
        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }
    }
}

namespace FlounderSharp
{
    public unsafe abstract partial class IDescriptor : global::FlounderSharp.IIDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDescriptor@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDescriptor@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IDescriptor@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IIDescriptor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IIDescriptor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IDescriptor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IDescriptorInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IDescriptor __CreateInstance(global::FlounderSharp.IDescriptor.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IDescriptorInternal(native, skipVTables);
        }

        protected IDescriptor(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IDescriptor()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance));
            SetupVTables(GetType().FullName == "FlounderSharp.IDescriptor");
        }

        protected IDescriptor(global::FlounderSharp.IIDescriptor _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToIDescriptor;
            __Internal.cctor((__Instance), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IDescriptor");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IIDescriptor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IDescriptor.__Internal*) __Instance)->vfptr_IDescriptor = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance), 0);
                }
                else
                    __Internal.dtor((__Instance), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr __PointerToIDescriptor
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // virtual ~IDescriptor() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IDescriptor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IDescriptorInternal : global::FlounderSharp.IDescriptor, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IDescriptor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IDescriptor.__Internal));
            *(global::FlounderSharp.IDescriptor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IDescriptorInternal(global::FlounderSharp.IDescriptor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IDescriptorInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }
    }

    public unsafe partial interface IIDescriptor : IDisposable
    {
        void Dispose();

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToIDescriptor { get; }
    }
}

namespace FlounderSharp
{
    public unsafe partial class UniformBuffer : global::FlounderSharp.Buffer, global::FlounderSharp.IIDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(40)]
            internal global::VkDescriptorBufferInfo.__Internal m_bufferInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBuffer@fl@@QEAA@AEB_K@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBuffer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UniformBuffer@fl@@QEAAXPEAX@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr newData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateDescriptor@UniformBuffer@fl@@SA?AVDescriptorType@2@AEBI0@Z")]
            internal static extern void CreateDescriptor(global::System.IntPtr @return, uint binding, uint stage);
        }

        internal static new global::FlounderSharp.UniformBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UniformBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UniformBuffer __CreateInstance(global::FlounderSharp.UniformBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UniformBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UniformBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformBuffer.__Internal));
            global::FlounderSharp.UniformBuffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UniformBuffer(global::FlounderSharp.UniformBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UniformBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 32) };
            else
                SetupVTables(true);
        }

        public UniformBuffer(ulong size)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), size);
            SetupVTables(GetType().FullName == "FlounderSharp.UniformBuffer");
        }

        public UniformBuffer(global::FlounderSharp.UniformBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UniformBuffer");
        }

        public void Update(global::System.IntPtr newData)
        {
            __Internal.Update((__Instance + __PointerAdjustment), newData);
        }

        public static implicit operator global::FlounderSharp.UniformBuffer(ulong size)
        {
            return new global::FlounderSharp.UniformBuffer(size);
        }

        public static global::FlounderSharp.DescriptorType CreateDescriptor(uint binding, uint stage)
        {
            var __ret = new global::FlounderSharp.DescriptorType.__Internal();
            __Internal.CreateDescriptor(new IntPtr(&__ret), binding, stage);
            return global::FlounderSharp.DescriptorType.__CreateInstance(__ret);
        }

        public global::System.IntPtr __PointerToIDescriptor
        {
            get
            {
                return __Instance + 32;
            }
        }

        #region Virtual table interop

        // ~UniformBuffer()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UniformBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 32) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    var vfptr1 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 32 + 0);
                    *(void**) (vfptr1 + 8) = _Thunks[0];
                    *(void**) (vfptr1 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 32 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                *(void**) (__Instance + 32) = __ManagedVTablesDtorOnly[1];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    var vfptr1 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 32 + 0);
                    *(void**) (vfptr1 + 8) = _Thunks[0];
                    *(void**) (vfptr1 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 32 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
                *(void**) (__Instance + 32) = __ManagedVTables[1];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a loaded texture.</summary>
    public unsafe partial class Texture : global::FlounderSharp.IResource, global::FlounderSharp.IBuffer, global::FlounderSharp.IIDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 168)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(16)]
            internal ulong m_size;

            [FieldOffset(24)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(32)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(40)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(48)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(80)]
            internal byte m_hasAlpha;

            [FieldOffset(81)]
            internal byte m_repeatEdges;

            [FieldOffset(84)]
            internal uint m_mipLevels;

            [FieldOffset(88)]
            internal byte m_anisotropic;

            [FieldOffset(89)]
            internal byte m_nearest;

            [FieldOffset(92)]
            internal uint m_numberOfRows;

            [FieldOffset(96)]
            internal int m_components;

            [FieldOffset(100)]
            internal int m_width;

            [FieldOffset(104)]
            internal int m_height;

            [FieldOffset(112)]
            internal global::System.IntPtr m_image;

            [FieldOffset(120)]
            internal global::System.IntPtr m_imageView;

            [FieldOffset(128)]
            internal global::System.IntPtr m_sampler;

            [FieldOffset(136)]
            internal global::VkFormat m_format;

            [FieldOffset(144)]
            internal global::VkDescriptorImageInfo.__Internal m_imageInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Texture@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N1111AEBI@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, bool hasAlpha, bool repeatEdges, bool mipmap, bool anisotropic, bool nearest, uint numberOfRows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Texture@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@Texture@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateDescriptor@Texture@fl@@SA?AVDescriptorType@2@AEBI0@Z")]
            internal static extern void CreateDescriptor(global::System.IntPtr @return, uint binding, uint stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LoadSize@Texture@fl@@SA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern ulong LoadSize(global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LoadPixels@Texture@fl@@SAPEAEAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAH11@Z")]
            internal static extern byte* LoadPixels(global::System.IntPtr filepath, int* width, int* height, int* components);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeletePixels@Texture@fl@@SAXPEAE@Z")]
            internal static extern void DeletePixels(byte* pixels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMipLevels@Texture@fl@@SAIAEBH00@Z")]
            internal static extern uint GetMipLevels(int width, int height, int depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasAlpha@Texture@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasAlpha(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHasAlpha@Texture@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetHasAlpha(global::System.IntPtr instance, bool hasAlpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNumberOfRows@Texture@fl@@QEBAIXZ")]
            internal static extern uint GetNumberOfRows(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNumberOfRows@Texture@fl@@QEAAXAEBI@Z")]
            internal static extern void SetNumberOfRows(global::System.IntPtr instance, uint numberOfRows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVkSize@Buffer@fl@@QEBA_KXZ")]
            internal static extern ulong GetVkSize(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Texture __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Texture(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Texture __CreateInstance(global::FlounderSharp.Texture.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Texture(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Texture.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Texture.__Internal));
            global::FlounderSharp.Texture.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Texture(global::FlounderSharp.Texture.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Texture(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8), *(void**) (__Instance + 40) };
            else
                SetupVTables(true);
        }

        /// <summary>A new texture object.</summary>
        public Texture(string filename, bool hasAlpha, bool repeatEdges, bool mipmap, bool anisotropic, bool nearest, uint numberOfRows)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Texture.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, hasAlpha, repeatEdges, mipmap, anisotropic, nearest, numberOfRows);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.Texture");
        }

        public Texture(global::FlounderSharp.Texture _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Texture.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Texture");
        }

        public static global::FlounderSharp.Texture Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
            else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
            return __result0;
        }

        public static global::FlounderSharp.DescriptorType CreateDescriptor(uint binding, uint stage)
        {
            var __ret = new global::FlounderSharp.DescriptorType.__Internal();
            __Internal.CreateDescriptor(new IntPtr(&__ret), binding, stage);
            return global::FlounderSharp.DescriptorType.__CreateInstance(__ret);
        }

        public static ulong LoadSize(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.LoadSize(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public static byte* LoadPixels(string filepath, ref int width, ref int height, ref int components)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            fixed (int* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (int* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    fixed (int* __refParamPtr3 = &components)
                    {
                        var __arg3 = __refParamPtr3;
                        var __ret = __Internal.LoadPixels(__arg0, __arg1, __arg2, __arg3);
                        __basicString0.Dispose(false);
                        __allocator0.Dispose();
                        return __ret;
                    }
                }
            }
        }

        public static void DeletePixels(byte* pixels)
        {
            __Internal.DeletePixels(pixels);
        }

        public static uint GetMipLevels(int width, int height, int depth)
        {
            var __ret = __Internal.GetMipLevels(width, height, depth);
            return __ret;
        }

        protected ulong MSize
        {
            get
            {
                return ((global::FlounderSharp.Texture.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::FlounderSharp.Texture.__Internal*)__Instance)->m_size = value;
            }
        }

        public global::System.IntPtr __PointerToBuffer
        {
            get
            {
                return __Instance + 8;
            }
        }

        public global::System.IntPtr __PointerToIDescriptor
        {
            get
            {
                return __Instance + 40;
            }
        }

        /// <summary>Gets if the texture has alpha.</summary>
        /// <param name="hasAlpha">If the texture has alpha.</param>
        /// <remarks>Sets if the texture has alpha.</remarks>
        public bool HasAlpha
        {
            get
            {
                var __ret = __Internal.HasAlpha((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetHasAlpha((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the number of texture rows.</summary>
        /// <param name="numberOfRows">The number of texture rows.</param>
        /// <remarks>Sets the number of texture rows.</remarks>
        public uint NumberOfRows
        {
            get
            {
                var __ret = __Internal.GetNumberOfRows((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetNumberOfRows((__Instance + __PointerAdjustment), value);
            }
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public ulong VkSize
        {
            get
            {
                var __ret = __Internal.GetVkSize((__Instance + 8));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Texture()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Texture) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Texture) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8), *(void**) (__Instance + 40) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[3];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    var vfptr1 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 0);
                    *(void**) (vfptr1 + 8) = _Thunks[0];
                    var vfptr2 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[2] = vfptr2.ToPointer();
                    *(void**) (vfptr2 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 0);
                    *(void**) (vfptr2 + 8) = _Thunks[0];
                    *(void**) (vfptr2 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                *(void**) (__Instance + 8) = __ManagedVTablesDtorOnly[1];
                *(void**) (__Instance + 40) = __ManagedVTablesDtorOnly[2];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[3];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    var vfptr1 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 0);
                    *(void**) (vfptr1 + 8) = _Thunks[0];
                    var vfptr2 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[2] = vfptr2.ToPointer();
                    *(void**) (vfptr2 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 0);
                    *(void**) (vfptr2 + 8) = _Thunks[0];
                    *(void**) (vfptr2 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
                *(void**) (__Instance + 8) = __ManagedVTables[1];
                *(void**) (__Instance + 40) = __ManagedVTables[2];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that handles a uniform buffer.</summary>
    public unsafe partial class UniformHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_uniformBlock;

            [FieldOffset(8)]
            internal global::System.IntPtr m_uniformBuffer;

            [FieldOffset(16)]
            internal global::System.IntPtr m_data;

            [FieldOffset(24)]
            internal byte m_changed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformHandler@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformHandler@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UniformHandler@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UniformHandler@fl@@QEAA_NPEAVUniformBlock@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Update(global::System.IntPtr instance, global::System.IntPtr uniformBlock);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniformBuffer@UniformHandler@fl@@QEBAPEAVUniformBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetUniformBuffer(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UniformHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UniformHandler>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.UniformHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UniformHandler(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UniformHandler __CreateInstance(global::FlounderSharp.UniformHandler.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UniformHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UniformHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformHandler.__Internal));
            *(global::FlounderSharp.UniformHandler.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UniformHandler(global::FlounderSharp.UniformHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UniformHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UniformHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public UniformHandler(global::FlounderSharp.UniformHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UniformHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.UniformHandler.__Internal*) __Instance) = *((global::FlounderSharp.UniformHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.UniformHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Update(global::FlounderSharp.UniformBlock uniformBlock)
        {
            var __arg0 = ReferenceEquals(uniformBlock, null) ? global::System.IntPtr.Zero : uniformBlock.__Instance;
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public global::FlounderSharp.UniformBuffer UniformBuffer
        {
            get
            {
                var __ret = __Internal.GetUniformBuffer((__Instance + __PointerAdjustment));
                global::FlounderSharp.UniformBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.UniformBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.UniformBuffer) global::FlounderSharp.UniformBuffer.NativeToManagedMap[__ret];
                else global::FlounderSharp.UniformBuffer.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.UniformBuffer) global::FlounderSharp.UniformBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Class that handles a descriptor set.</summary>
    public unsafe partial class DescriptorsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_shaderProgram;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_descriptors;

            [FieldOffset(24)]
            internal byte m_changed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorsHandler@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorsHandler@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1DescriptorsHandler@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVIDescriptor@2@@Z")]
            internal static extern void Push(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVUniformHandler@2@@Z")]
            internal static extern void Push_1(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr uniformHandler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@DescriptorsHandler@fl@@QEAA_NAEBVPipeline@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Update(global::System.IntPtr instance, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorSet@DescriptorsHandler@fl@@QEBAPEAVDescriptorSet@2@XZ")]
            internal static extern global::System.IntPtr GetDescriptorSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.DescriptorsHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.DescriptorsHandler>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.DescriptorsHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DescriptorsHandler(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DescriptorsHandler __CreateInstance(global::FlounderSharp.DescriptorsHandler.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DescriptorsHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DescriptorsHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorsHandler.__Internal));
            *(global::FlounderSharp.DescriptorsHandler.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DescriptorsHandler(global::FlounderSharp.DescriptorsHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public DescriptorsHandler(global::FlounderSharp.DescriptorsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DescriptorsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.DescriptorsHandler.__Internal*) __Instance) = *((global::FlounderSharp.DescriptorsHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.DescriptorsHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Push(string descriptorName, global::FlounderSharp.IIDescriptor descriptor)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(descriptor, null) ? global::System.IntPtr.Zero : descriptor.__PointerToIDescriptor;
            __Internal.Push((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push(string descriptorName, global::FlounderSharp.UniformHandler uniformHandler)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(uniformHandler, null) ? global::System.IntPtr.Zero : uniformHandler.__Instance;
            __Internal.Push_1((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public bool Update(global::FlounderSharp.Pipeline pipeline)
        {
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pipeline.__Instance;
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public global::FlounderSharp.DescriptorSet DescriptorSet
        {
            get
            {
                var __ret = __Internal.GetDescriptorSet((__Instance + __PointerAdjustment));
                global::FlounderSharp.DescriptorSet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.DescriptorSet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.DescriptorSet) global::FlounderSharp.DescriptorSet.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.DescriptorSet.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class PipelineDefine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineDefine@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineDefine@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineDefine@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@PipelineDefine@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@PipelineDefine@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.PipelineDefine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.PipelineDefine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.PipelineDefine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PipelineDefine(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.PipelineDefine __CreateInstance(global::FlounderSharp.PipelineDefine.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PipelineDefine(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.PipelineDefine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PipelineDefine.__Internal));
            global::FlounderSharp.PipelineDefine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineDefine(global::FlounderSharp.PipelineDefine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineDefine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PipelineDefine(string name, string value)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PipelineDefine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public PipelineDefine(global::FlounderSharp.PipelineDefine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PipelineDefine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.PipelineDefine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }
    }

    /// <summary>Class that represents a Vulkan pipeline.</summary>
    public unsafe partial class Pipeline : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 624)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(8)]
            internal global::FlounderSharp.PipelineCreate.__Internal m_pipelineCreateInfo;

            [FieldOffset(96)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_fl_S_PipelineDefine___N_std_S_allocator__S0_ m_defines;

            [FieldOffset(120)]
            internal global::System.IntPtr m_shaderProgram;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkShaderModule_T___N_std_S_allocator__S0_ m_modules;

            [FieldOffset(152)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkPipelineShaderStageCreateInfo___N_std_S_allocator__S0_ m_stages;

            [FieldOffset(176)]
            internal global::System.IntPtr m_descriptorSetLayout;

            [FieldOffset(184)]
            internal global::System.IntPtr m_descriptorPool;

            [FieldOffset(192)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(200)]
            internal global::System.IntPtr m_pipelineLayout;

            [FieldOffset(208)]
            internal global::VkPipelineInputAssemblyStateCreateInfo.__Internal m_inputAssemblyState;

            [FieldOffset(240)]
            internal global::VkPipelineRasterizationStateCreateInfo.__Internal m_rasterizationState;

            [FieldOffset(304)]
            internal global::Std.Array.__Internalc__N_std_S_array____S_VkPipelineColorBlendAttachmentState_Vk1 m_blendAttachmentStates;

            [FieldOffset(336)]
            internal global::VkPipelineColorBlendStateCreateInfo.__Internal m_colourBlendState;

            [FieldOffset(392)]
            internal global::VkPipelineDepthStencilStateCreateInfo.__Internal m_depthStencilState;

            [FieldOffset(496)]
            internal global::VkPipelineViewportStateCreateInfo.__Internal m_viewportState;

            [FieldOffset(544)]
            internal global::VkPipelineMultisampleStateCreateInfo.__Internal m_multisampleState;

            [FieldOffset(592)]
            internal global::VkPipelineDynamicStateCreateInfo.__Internal m_dynamicState;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Pipeline@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Pipeline@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindPipeline@Pipeline@fl@@QEBAXAEBVCommandBuffer@2@@Z")]
            internal static extern void BindPipeline(global::System.IntPtr instance, global::System.IntPtr commandBuffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepthStencil@Pipeline@fl@@QEBAPEAVDepthStencil@2@AEBH@Z")]
            internal static extern global::System.IntPtr GetDepthStencil(global::System.IntPtr instance, int stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTexture@Pipeline@fl@@QEBAPEAVTexture@2@AEBIAEBH@Z")]
            internal static extern global::System.IntPtr GetTexture(global::System.IntPtr instance, uint i, int stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipelineCreateInfo@Pipeline@fl@@QEBA?AVPipelineCreate@2@XZ")]
            internal static extern void GetPipelineCreateInfo(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShaderProgram@Pipeline@fl@@QEBAPEAVShaderProgram@2@XZ")]
            internal static extern global::System.IntPtr GetShaderProgram(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsStage@Pipeline@fl@@QEBA?AVGraphicsStage@2@XZ")]
            internal static extern void GetGraphicsStage(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Pipeline> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Pipeline>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Pipeline __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Pipeline(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Pipeline __CreateInstance(global::FlounderSharp.Pipeline.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Pipeline(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Pipeline.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Pipeline.__Internal));
            global::FlounderSharp.Pipeline.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Pipeline(global::FlounderSharp.Pipeline.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Pipeline(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Pipeline(global::FlounderSharp.Pipeline _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Pipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Pipeline __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void BindPipeline(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.BindPipeline((__Instance + __PointerAdjustment), __arg0);
        }

        public global::FlounderSharp.DepthStencil GetDepthStencil(int stage)
        {
            var __ret = __Internal.GetDepthStencil((__Instance + __PointerAdjustment), stage);
            global::FlounderSharp.DepthStencil __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.DepthStencil.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.DepthStencil) global::FlounderSharp.DepthStencil.NativeToManagedMap[__ret];
            else global::FlounderSharp.DepthStencil.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.DepthStencil) global::FlounderSharp.DepthStencil.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.Texture GetTexture(uint i, int stage)
        {
            var __ret = __Internal.GetTexture((__Instance + __PointerAdjustment), i, stage);
            global::FlounderSharp.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
            else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.PipelineCreate PipelineCreateInfo
        {
            get
            {
                var __ret = new global::FlounderSharp.PipelineCreate.__Internal();
                __Internal.GetPipelineCreateInfo((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.PipelineCreate.__CreateInstance(__ret);
            }
        }

        public global::FlounderSharp.ShaderProgram ShaderProgram
        {
            get
            {
                var __ret = __Internal.GetShaderProgram((__Instance + __PointerAdjustment));
                global::FlounderSharp.ShaderProgram __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ShaderProgram.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ShaderProgram) global::FlounderSharp.ShaderProgram.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.ShaderProgram.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.GraphicsStage GraphicsStage
        {
            get
            {
                var __ret = new global::FlounderSharp.GraphicsStage.__Internal();
                __Internal.GetGraphicsStage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.GraphicsStage.__CreateInstance(__ret);
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class RendererMeshes : global::FlounderSharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::System.IntPtr m_uniformScene;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererMeshes@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererMeshes@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.RendererMeshes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererMeshes(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RendererMeshes __CreateInstance(global::FlounderSharp.RendererMeshes.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererMeshes(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RendererMeshes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererMeshes.__Internal));
            global::FlounderSharp.RendererMeshes.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererMeshes(global::FlounderSharp.RendererMeshes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererMeshes(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public RendererMeshes(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererMeshes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererMeshes");
        }

        public RendererMeshes(global::FlounderSharp.RendererMeshes _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererMeshes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererMeshes");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static implicit operator global::FlounderSharp.RendererMeshes(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.RendererMeshes(graphicsStage);
        }

        #region Virtual table interop

        // ~RendererMeshes()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererMeshes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererMeshes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::FlounderSharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::FlounderSharp.Vector4.__CreateInstance(clipPlane);
            global::FlounderSharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[camera];
            else __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(camera, skipVTables: true);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A simple event listener and runner.</summary>
    public unsafe abstract partial class IEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IEvent@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IEvent@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IEvent@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IEvent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IEvent>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IEvent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IEventInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IEvent __CreateInstance(global::FlounderSharp.IEvent.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IEventInternal(native, skipVTables);
        }

        protected IEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new event.</summary>
        protected IEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IEvent");
        }

        protected IEvent(global::FlounderSharp.IEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IEvent");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IEvent.__Internal*) __Instance)->vfptr_IEvent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Run when a event has occurred.</summary>
        public abstract void OnEvent();

        /// <summary>Gets if the event has occurred.</summary>
        public abstract bool EventTriggered
        {
            get;
        }

        /// <summary>Gets if the event is removed after it has run once.</summary>
        public abstract bool RemoveAfterEvent
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IEvent() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool EventTriggered() = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IEventInternal : global::FlounderSharp.IEvent, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IEvent.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IEvent.__Internal));
            *(global::FlounderSharp.IEvent.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IEventInternal(global::FlounderSharp.IEvent.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IEventInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Run when a event has occurred.</summary>
        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___OnEventDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if the event has occurred.</summary>
        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___EventTriggeredDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the event is removed after it has run once.</summary>
        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___RemoveAfterEventDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
}

namespace FlounderSharp
{
    /// <summary>A module used for managing tasks on engine updates.</summary>
    public unsafe partial class Tasks : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_tasks;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Tasks@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Tasks@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Tasks@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();
        }

        internal static new global::FlounderSharp.Tasks __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Tasks(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Tasks __CreateInstance(global::FlounderSharp.Tasks.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Tasks(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Tasks.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Tasks.__Internal));
            global::FlounderSharp.Tasks.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Tasks(global::FlounderSharp.Tasks.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Tasks(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public Tasks()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Tasks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Tasks");
        }

        public Tasks(global::FlounderSharp.Tasks _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Tasks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Tasks");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Tasks Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Tasks __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Tasks.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Tasks) global::FlounderSharp.Tasks.NativeToManagedMap[__ret];
            else global::FlounderSharp.Tasks.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Tasks) global::FlounderSharp.Tasks.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~Tasks()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Tasks) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Tasks) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for managing events on engine updates.</summary>
    public unsafe partial class Events : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_events;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Events@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Events@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Events@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddEvent@Events@fl@@QEBAXPEAVIEvent@2@@Z")]
            internal static extern void AddEvent(global::System.IntPtr instance, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveEvent@Events@fl@@QEBAXPEAVIEvent@2@@Z")]
            internal static extern void RemoveEvent(global::System.IntPtr instance, global::System.IntPtr @event);
        }

        internal static new global::FlounderSharp.Events __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Events(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Events __CreateInstance(global::FlounderSharp.Events.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Events(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Events.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Events.__Internal));
            global::FlounderSharp.Events.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Events(global::FlounderSharp.Events.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Events(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new events module.</summary>
        public Events()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Events.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Events");
        }

        public Events(global::FlounderSharp.Events _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Events.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Events");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Adds an event to the listening list.</summary>
        /// <param name="event">The event to add.</param>
        public void AddEvent(global::FlounderSharp.IEvent @event)
        {
            var __arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            __Internal.AddEvent((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Removes a event to the listening list.</summary>
        /// <param name="event">The event to remove.</param>
        public void RemoveEvent(global::FlounderSharp.IEvent @event)
        {
            var __arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            __Internal.RemoveEvent((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Events Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Events __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Events.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Events) global::FlounderSharp.Events.NativeToManagedMap[__ret];
            else global::FlounderSharp.Events.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Events) global::FlounderSharp.Events.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~Events()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Events) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Events) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A class that is the most basic implementation of the event interface.</summary>
    public unsafe partial class EventStandard : global::FlounderSharp.IEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [FieldOffset(8)]
            internal byte m_repeat;

            [FieldOffset(16)]
            internal global::Std.Function.__Internal m_triggered;

            [FieldOffset(80)]
            internal global::Std.Function.__Internal m_onEvent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0EventStandard@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.EventStandard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.EventStandard(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.EventStandard __CreateInstance(global::FlounderSharp.EventStandard.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.EventStandard(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.EventStandard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.EventStandard.__Internal));
            global::FlounderSharp.EventStandard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private EventStandard(global::FlounderSharp.EventStandard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventStandard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public EventStandard(global::FlounderSharp.EventStandard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.EventStandard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.EventStandard");
        }

        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___OnEventDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___EventTriggeredDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___RemoveAfterEventDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // EventStandard
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool EventTriggered() override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() override { return !m_repeat; }
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A timer implementation for events.</summary>
    public unsafe partial class Timer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_startTime;

            [FieldOffset(4)]
            internal float m_interval;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@fl@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Timer@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ResetStartTime@Timer@fl@@QEAAXXZ")]
            internal static extern void ResetStartTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterval@Timer@fl@@QEBAMXZ")]
            internal static extern float GetInterval(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInterval@Timer@fl@@QEAAXAEBM@Z")]
            internal static extern void SetInterval(global::System.IntPtr instance, float interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPassedTime@Timer@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPassedTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Timer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Timer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Timer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Timer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Timer __CreateInstance(global::FlounderSharp.Timer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Timer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Timer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Timer.__Internal));
            *(global::FlounderSharp.Timer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Timer(global::FlounderSharp.Timer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Timer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new timer.</summary>
        /// <param name="interval">The time between events (seconds).</param>
        public Timer(float interval)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), interval);
        }

        public Timer(global::FlounderSharp.Timer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Timer.__Internal*) __Instance) = *((global::FlounderSharp.Timer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Timer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds the intervals value to the start time.</summary>
        public void ResetStartTime()
        {
            __Internal.ResetStartTime((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::FlounderSharp.Timer(float interval)
        {
            return new global::FlounderSharp.Timer(interval);
        }

        /// <summary>Gets what the interval is. (Seconds).</summary>
        /// <param name="interval">The new timer interval.</param>
        /// <remarks>Gets the timers interval. (Seconds, Resets timer).</remarks>
        public float Interval
        {
            get
            {
                var __ret = __Internal.GetInterval((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetInterval((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets if the interval has been passes for the timer.</summary>
        public bool IsPassedTime
        {
            get
            {
                var __ret = __Internal.IsPassedTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A class that runs a event after a time has passed.</summary>
    public unsafe partial class EventTime : global::FlounderSharp.IEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_timer;

            [FieldOffset(16)]
            internal byte m_repeat;

            [FieldOffset(24)]
            internal global::Std.Function.__Internal m_onEvent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0EventTime@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.EventTime __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.EventTime(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.EventTime __CreateInstance(global::FlounderSharp.EventTime.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.EventTime(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.EventTime.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.EventTime.__Internal));
            global::FlounderSharp.EventTime.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private EventTime(global::FlounderSharp.EventTime.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventTime(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public EventTime(global::FlounderSharp.EventTime _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.EventTime.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.EventTime");
        }

        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___OnEventDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___EventTriggeredDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___RemoveAfterEventDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~EventTime()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool EventTriggered() override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() override { return !m_repeat; }
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe abstract partial class IFile : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IFile@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IFile@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IFile@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IFile> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IFile>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IFile __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IFileInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IFile __CreateInstance(global::FlounderSharp.IFile.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IFileInternal(native, skipVTables);
        }

        protected IFile(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IFile(global::FlounderSharp.IFile _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IFile");
        }

        protected IFile()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IFile");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IFile.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Load();

        public abstract void Save();

        public abstract void Clear();

        public abstract void ConfigPushValue(string key, string value);

        #region Virtual table interop

        // virtual ~IFile() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Load() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // void ConfigPushValue(const std::string &key, const std::string &value) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _ConfigPushValueDelegateInstance;

        private static void _ConfigPushValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(key);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(value);
            __target.ConfigPushValue(global::Std.BasicStringExtensions.CStr(__basicStringRet), global::Std.BasicStringExtensions.CStr(__basicStringRet));
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _ConfigPushValueDelegateInstance += _ConfigPushValueDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ConfigPushValueDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IFileInternal : global::FlounderSharp.IFile, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IFile.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IFile.__Internal));
            *(global::FlounderSharp.IFile.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IFileInternal(global::FlounderSharp.IFile.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IFileInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___SaveDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___ClearDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override void ConfigPushValue(string key, string value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___ConfigPushValueDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            ___ConfigPushValueDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class ConfigKey : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [FieldOffset(32)]
            internal byte m_fromFile;

            [FieldOffset(40)]
            internal global::System.IntPtr m_getter;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ConfigKey@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr value, bool fromFile);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ConfigKey@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ConfigKey@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@ConfigKey@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@ConfigKey@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFromFile@ConfigKey@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFromFile(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ConfigKey> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ConfigKey>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ConfigKey __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ConfigKey(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ConfigKey __CreateInstance(global::FlounderSharp.ConfigKey.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ConfigKey(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ConfigKey.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ConfigKey.__Internal));
            global::FlounderSharp.ConfigKey.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ConfigKey(global::FlounderSharp.ConfigKey.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ConfigKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ConfigKey(string value, bool fromFile)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ConfigKey.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, fromFile);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public ConfigKey(global::FlounderSharp.ConfigKey _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ConfigKey.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ConfigKey __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public bool IsFromFile
        {
            get
            {
                var __ret = __Internal.IsFromFile((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Config : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_file;

            [FieldOffset(8)]
            internal global::System.IntPtr m_values;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Config@fl@@QEAA@PEAVIFile@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Config@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Config@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Load@Config@fl@@QEAAXXZ")]
            internal static extern void Load(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Config@fl@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Save@Config@fl@@QEAAXXZ")]
            internal static extern void Save(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRaw@Config@fl@@QEAA?AVConfigKey@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void GetRaw(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr key, global::System.IntPtr normal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRaw@Config@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void SetRaw(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr value);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Config> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Config>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Config __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Config(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Config __CreateInstance(global::FlounderSharp.Config.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Config(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Config.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Config.__Internal));
            *(global::FlounderSharp.Config.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Config(global::FlounderSharp.Config.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Config(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Config(global::FlounderSharp.IFile file)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Config.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(file, null) ? global::System.IntPtr.Zero : file.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Config(global::FlounderSharp.Config _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Config.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Config.__Internal*) __Instance) = *((global::FlounderSharp.Config.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Config __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Load()
        {
            __Internal.Load((__Instance + __PointerAdjustment));
        }

        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public void Save()
        {
            __Internal.Save((__Instance + __PointerAdjustment));
        }

        public global::FlounderSharp.ConfigKey GetRaw(string key, string normal)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(normal, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::FlounderSharp.ConfigKey.__Internal();
            __Internal.GetRaw((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return global::FlounderSharp.ConfigKey.__CreateInstance(__ret);
        }

        public void SetRaw(string key, string value)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.SetRaw((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public static implicit operator global::FlounderSharp.Config(global::FlounderSharp.IFile file)
        {
            return new global::FlounderSharp.Config(file);
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class RowCsv : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_elements;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RowCsv@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RowCsv@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.RowCsv> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.RowCsv>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.RowCsv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RowCsv(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RowCsv __CreateInstance(global::FlounderSharp.RowCsv.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RowCsv(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RowCsv.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RowCsv.__Internal));
            global::FlounderSharp.RowCsv.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RowCsv(global::FlounderSharp.RowCsv.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RowCsv(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RowCsv(global::FlounderSharp.RowCsv _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RowCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.RowCsv __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class FileCsv : global::FlounderSharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal sbyte m_delimiter;

            [FieldOffset(48)]
            internal global::System.IntPtr m_rows;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileCsv@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBD@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, sbyte delimiter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileCsv@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRow@FileCsv@fl@@QEAA?AVRowCsv@2@AEBI@Z")]
            internal static extern void GetRow(global::System.IntPtr instance, global::System.IntPtr @return, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PushRow@FileCsv@fl@@QEAAXAEBVRowCsv@2@@Z")]
            internal static extern void PushRow(global::System.IntPtr instance, global::System.IntPtr row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRow@FileCsv@fl@@QEAAXAEBVRowCsv@2@AEBI@Z")]
            internal static extern void SetRow(global::System.IntPtr instance, global::System.IntPtr row, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRowCount@FileCsv@fl@@QEBA_KXZ")]
            internal static extern ulong GetRowCount(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.FileCsv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FileCsv(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FileCsv __CreateInstance(global::FlounderSharp.FileCsv.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FileCsv(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FileCsv.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileCsv.__Internal));
            global::FlounderSharp.FileCsv.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileCsv(global::FlounderSharp.FileCsv.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileCsv(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FileCsv(string filename, sbyte delimiter)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, delimiter);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.FileCsv");
        }

        public FileCsv(global::FlounderSharp.FileCsv _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FileCsv");
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___SaveDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___ClearDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override void ConfigPushValue(string key, string value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___ConfigPushValueDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            ___ConfigPushValueDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public global::FlounderSharp.RowCsv GetRow(uint index)
        {
            var __ret = new global::FlounderSharp.RowCsv.__Internal();
            __Internal.GetRow((__Instance + __PointerAdjustment), new IntPtr(&__ret), index);
            return global::FlounderSharp.RowCsv.__CreateInstance(__ret);
        }

        public void PushRow(global::FlounderSharp.RowCsv row)
        {
            if (ReferenceEquals(row, null))
                throw new global::System.ArgumentNullException("row", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = row.__Instance;
            __Internal.PushRow((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetRow(global::FlounderSharp.RowCsv row, uint index)
        {
            if (ReferenceEquals(row, null))
                throw new global::System.ArgumentNullException("row", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = row.__Instance;
            __Internal.SetRow((__Instance + __PointerAdjustment), __arg0, index);
        }

        public ulong RowCount
        {
            get
            {
                var __ret = __Internal.GetRowCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~FileCsv()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Load() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // void ConfigPushValue(const std::string &key, const std::string &value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _ConfigPushValueDelegateInstance;

        private static void _ConfigPushValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(key);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(value);
            __target.ConfigPushValue(global::Std.BasicStringExtensions.CStr(__basicStringRet), global::Std.BasicStringExtensions.CStr(__basicStringRet));
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _ConfigPushValueDelegateInstance += _ConfigPushValueDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ConfigPushValueDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class JsonSection : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_JsonSection___N_std_S_allocator__S0_ m_children;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_content;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JsonSection@fl@@QEAA@PEAV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr name, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JsonSection@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JsonSection@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AppendData@JsonSection@fl@@SAXPEAVLoadedValue@2@PEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBHAEB_N@Z")]
            internal static extern void AppendData(global::System.IntPtr loadedValue, global::System.IntPtr data, int indentation, bool end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@JsonSection@fl@@SAPEAVLoadedValue@2@PEAV12@PEAV32@AEB_N@Z")]
            internal static extern global::System.IntPtr Convert(global::System.IntPtr source, global::System.IntPtr parent, bool isTopSection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@JsonSection@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@JsonSection@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContent@JsonSection@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetContent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetContent@JsonSection@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetContent(global::System.IntPtr instance, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@JsonSection@fl@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JsonSection> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.JsonSection>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.JsonSection __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JsonSection(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.JsonSection __CreateInstance(global::FlounderSharp.JsonSection.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.JsonSection(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.JsonSection.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JsonSection.__Internal));
            global::FlounderSharp.JsonSection.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JsonSection(global::FlounderSharp.JsonSection.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JsonSection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JsonSection(global::FlounderSharp.JsonSection parent, string name, string content)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JsonSection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(content, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public JsonSection(global::FlounderSharp.JsonSection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.JsonSection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.JsonSection __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static void AppendData(global::FlounderSharp.LoadedValue loadedValue, string data, int indentation, bool end)
        {
            var __arg0 = ReferenceEquals(loadedValue, null) ? global::System.IntPtr.Zero : loadedValue.__Instance;
            var __arg1 = global::Std.BasicStringExtensions.BasicString(data, new global::Std.Allocator<sbyte>()).__Instance;
            __Internal.AppendData(__arg0, __arg1, indentation, end);
        }

        public static global::FlounderSharp.LoadedValue Convert(global::FlounderSharp.JsonSection source, global::FlounderSharp.LoadedValue parent, bool isTopSection)
        {
            var __arg0 = ReferenceEquals(source, null) ? global::System.IntPtr.Zero : source.__Instance;
            var __arg1 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __ret = __Internal.Convert(__arg0, __arg1, isTopSection);
            global::FlounderSharp.LoadedValue __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(__ret);
            return __result0;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Content
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetContent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetContent((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.JsonSection Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::FlounderSharp.JsonSection __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.JsonSection.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.JsonSection) global::FlounderSharp.JsonSection.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.JsonSection.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class FileJson : global::FlounderSharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileJson@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileJson@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChild@FileJson@fl@@QEBAPEAVLoadedValue@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetChild(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@FileJson@fl@@QEBAPEAVLoadedValue@2@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.FileJson __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FileJson(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FileJson __CreateInstance(global::FlounderSharp.FileJson.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FileJson(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FileJson.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileJson.__Internal));
            global::FlounderSharp.FileJson.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileJson(global::FlounderSharp.FileJson.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileJson(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FileJson(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileJson.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.FileJson");
        }

        public FileJson(global::FlounderSharp.FileJson _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileJson.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FileJson");
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___SaveDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___ClearDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override void ConfigPushValue(string key, string value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___ConfigPushValueDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            ___ConfigPushValueDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public global::FlounderSharp.LoadedValue GetChild(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetChild((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.LoadedValue __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(__ret);
            return __result0;
        }

        public static implicit operator global::FlounderSharp.FileJson(string filename)
        {
            return new global::FlounderSharp.FileJson(filename);
        }

        public global::FlounderSharp.LoadedValue Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::FlounderSharp.LoadedValue __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~FileJson()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Load() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // void ConfigPushValue(const std::string &key, const std::string &value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _ConfigPushValueDelegateInstance;

        private static void _ConfigPushValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr key, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(key);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(value);
            __target.ConfigPushValue(global::Std.BasicStringExtensions.CStr(__basicStringRet), global::Std.BasicStringExtensions.CStr(__basicStringRet));
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _ConfigPushValueDelegateInstance += _ConfigPushValueDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ConfigPushValueDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Simple data structure class holding information about a certain glyph in the font texture atlas. All sizes are for a font-size of 1.</summary>
    public unsafe partial class FontCharacter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_id;

            [FieldOffset(8)]
            internal double m_textureCoordX;

            [FieldOffset(16)]
            internal double m_textureCoordY;

            [FieldOffset(24)]
            internal double m_maxTextureCoordX;

            [FieldOffset(32)]
            internal double m_maxTextureCoordY;

            [FieldOffset(40)]
            internal double m_offsetX;

            [FieldOffset(48)]
            internal double m_offsetY;

            [FieldOffset(56)]
            internal double m_sizeX;

            [FieldOffset(64)]
            internal double m_sizeY;

            [FieldOffset(72)]
            internal double m_advanceX;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontCharacter@fl@@QEAA@AEBHAEBN11111111@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int id, double textureCoordX, double textureCoordY, double textureSizeX, double textureSizeY, double offsetX, double offsetY, double sizeX, double sizeY, double advanceX);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontCharacter@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontCharacter@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetId@FontCharacter@fl@@QEBAHXZ")]
            internal static extern int GetId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureCoordX@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetTextureCoordX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureCoordY@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetTextureCoordY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxTextureCoordX@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetMaxTextureCoordX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxTextureCoordY@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetMaxTextureCoordY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffsetX@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetOffsetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffsetY@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetOffsetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSizeX@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetSizeX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSizeY@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetSizeY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAdvanceX@FontCharacter@fl@@QEBANXZ")]
            internal static extern double GetAdvanceX(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontCharacter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontCharacter>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.FontCharacter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontCharacter(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FontCharacter __CreateInstance(global::FlounderSharp.FontCharacter.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontCharacter(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FontCharacter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontCharacter.__Internal));
            *(global::FlounderSharp.FontCharacter.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FontCharacter(global::FlounderSharp.FontCharacter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontCharacter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new character.</summary>
        /// <param name="sizeY">The height of the character's quad in screen space.</param>
        /// <param name="sizeX">The width of the character's quad in screen space.</param>
        /// <param name="offsetY">The y distance from the cursor to the top edge of the character's quad.</param>
        /// <param name="offsetX">The x distance from the cursor to the left edge of the character's quad.</param>
        /// <param name="advanceX">How far in pixels the cursor should advance after adding this character.</param>
        /// <param name="textureSizeX">The width of the character in the texture atlas.</param>
        /// <param name="textureSizeY">The height of the character in the texture atlas.</param>
        /// <param name="textureCoordY">The y texture coordinate for the top left corner of the character in the texture atlas.</param>
        /// <param name="textureCoordX">The x texture coordinate for the top left corner of the character in the texture atlas.</param>
        /// <param name="id">The ASCII value of the character.</param>
        public FontCharacter(int id, double textureCoordX, double textureCoordY, double textureSizeX, double textureSizeY, double offsetX, double offsetY, double sizeX, double sizeY, double advanceX)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontCharacter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), id, textureCoordX, textureCoordY, textureSizeX, textureSizeY, offsetX, offsetY, sizeX, sizeY, advanceX);
        }

        public FontCharacter(global::FlounderSharp.FontCharacter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontCharacter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.FontCharacter.__Internal*) __Instance) = *((global::FlounderSharp.FontCharacter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.FontCharacter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Id
        {
            get
            {
                var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double TextureCoordX
        {
            get
            {
                var __ret = __Internal.GetTextureCoordX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double TextureCoordY
        {
            get
            {
                var __ret = __Internal.GetTextureCoordY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double MaxTextureCoordX
        {
            get
            {
                var __ret = __Internal.GetMaxTextureCoordX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double MaxTextureCoordY
        {
            get
            {
                var __ret = __Internal.GetMaxTextureCoordY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double OffsetX
        {
            get
            {
                var __ret = __Internal.GetOffsetX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double OffsetY
        {
            get
            {
                var __ret = __Internal.GetOffsetY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double SizeX
        {
            get
            {
                var __ret = __Internal.GetSizeX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double SizeY
        {
            get
            {
                var __ret = __Internal.GetSizeY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double AdvanceX
        {
            get
            {
                var __ret = __Internal.GetAdvanceX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Provides functionality for getting the values from a font file.</summary>
    public unsafe partial class FontMetafile : global::FlounderSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::System.IntPtr m_metadata;

            [FieldOffset(16)]
            internal global::System.IntPtr m_values;

            [FieldOffset(24)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(56)]
            internal double m_verticalPerPixelSize;

            [FieldOffset(64)]
            internal double m_horizontalPerPixelSize;

            [FieldOffset(72)]
            internal int m_imageWidth;

            [FieldOffset(80)]
            internal double m_spaceWidth;

            [FieldOffset(88)]
            internal global::System.IntPtr m_padding;

            [FieldOffset(96)]
            internal int m_paddingWidth;

            [FieldOffset(100)]
            internal int m_paddingHeight;

            [FieldOffset(104)]
            internal double m_maxSizeY;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontMetafile@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontMetafile@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@FontMetafile@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCharacter@FontMetafile@fl@@QEAAPEAVFontCharacter@2@AEBH@Z")]
            internal static extern global::System.IntPtr GetCharacter(global::System.IntPtr instance, int ascii);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpaceWidth@FontMetafile@fl@@QEBANXZ")]
            internal static extern double GetSpaceWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxSizeY@FontMetafile@fl@@QEBANXZ")]
            internal static extern double GetMaxSizeY(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.FontMetafile __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontMetafile(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FontMetafile __CreateInstance(global::FlounderSharp.FontMetafile.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontMetafile(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FontMetafile.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontMetafile.__Internal));
            global::FlounderSharp.FontMetafile.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontMetafile(global::FlounderSharp.FontMetafile.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontMetafile(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new meta file.</summary>
        /// <param name="filepath">The font file to load from.</param>
        public FontMetafile(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontMetafile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.FontMetafile");
        }

        public FontMetafile(global::FlounderSharp.FontMetafile _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontMetafile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FontMetafile");
        }

        public global::FlounderSharp.FontCharacter GetCharacter(int ascii)
        {
            var __ret = __Internal.GetCharacter((__Instance + __PointerAdjustment), ascii);
            global::FlounderSharp.FontCharacter __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.FontCharacter.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.FontCharacter) global::FlounderSharp.FontCharacter.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.FontCharacter.__CreateInstance(__ret);
            return __result0;
        }

        public static implicit operator global::FlounderSharp.FontMetafile(string filename)
        {
            return new global::FlounderSharp.FontMetafile(filename);
        }

        public static global::FlounderSharp.FontMetafile Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.FontMetafile __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.FontMetafile.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.FontMetafile) global::FlounderSharp.FontMetafile.NativeToManagedMap[__ret];
            else global::FlounderSharp.FontMetafile.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.FontMetafile) global::FlounderSharp.FontMetafile.__CreateInstance(__ret);
            return __result0;
        }

        public static uint PadTop
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?PAD_TOP@FontMetafile@fl@@2IB");
                return *__ptr;
            }
        }

        public static uint PadLeft
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?PAD_LEFT@FontMetafile@fl@@2IB");
                return *__ptr;
            }
        }

        public static uint PadBottom
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?PAD_BOTTOM@FontMetafile@fl@@2IB");
                return *__ptr;
            }
        }

        public static uint PadRight
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?PAD_RIGHT@FontMetafile@fl@@2IB");
                return *__ptr;
            }
        }

        public static int DesiredPadding
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?DESIRED_PADDING@FontMetafile@fl@@2HB");
                return *__ptr;
            }
        }

        public static string Splitter
        {
            get
            {
                var __ptr = (global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?SPLITTER@FontMetafile@fl@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B");
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(*__ptr);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public static string NumberSeparator
        {
            get
            {
                var __ptr = (global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?NUMBER_SEPARATOR@FontMetafile@fl@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B");
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(*__ptr);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public static double LineHeight
        {
            get
            {
                var __ptr = (double*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?LINE_HEIGHT@FontMetafile@fl@@2NB");
                return *__ptr;
            }
        }

        public static int SpaceAscii
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?SPACE_ASCII@FontMetafile@fl@@2HB");
                return *__ptr;
            }
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public double SpaceWidth
        {
            get
            {
                var __ret = __Internal.GetSpaceWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double MaxSizeY
        {
            get
            {
                var __ret = __Internal.GetMaxSizeY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~FontMetafile()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FontMetafile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FontMetafile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A loader capable of loading font data into a instance of a text mesh.</summary>
    public unsafe partial class FontType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_texture;

            [FieldOffset(8)]
            internal global::System.IntPtr m_metadata;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontType@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr textureFile, global::System.IntPtr fontFile);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontType@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontType@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTexture@FontType@fl@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetTexture(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMetadata@FontType@fl@@QEBAPEAVFontMetafile@2@XZ")]
            internal static extern global::System.IntPtr GetMetadata(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.FontType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontType(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FontType __CreateInstance(global::FlounderSharp.FontType.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontType(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FontType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontType.__Internal));
            *(global::FlounderSharp.FontType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FontType(global::FlounderSharp.FontType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new text loader.</summary>
        /// <param name="textureFile">The file for the font atlas texture.</param>
        /// <param name="fontFile">The font file containing information about each character in the texture atlas.</param>
        public FontType(string textureFile, string fontFile)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(textureFile, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(fontFile, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public FontType(global::FlounderSharp.FontType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.FontType.__Internal*) __Instance) = *((global::FlounderSharp.FontType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.FontType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::FlounderSharp.Texture Texture
        {
            get
            {
                var __ret = __Internal.GetTexture((__Instance + __PointerAdjustment));
                global::FlounderSharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
                else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.FontMetafile Metadata
        {
            get
            {
                var __ret = __Internal.GetMetadata((__Instance + __PointerAdjustment));
                global::FlounderSharp.FontMetafile __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontMetafile.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.FontMetafile) global::FlounderSharp.FontMetafile.NativeToManagedMap[__ret];
                else global::FlounderSharp.FontMetafile.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.FontMetafile) global::FlounderSharp.FontMetafile.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class FontFamily : global::FlounderSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_typeThin;

            [FieldOffset(48)]
            internal global::System.IntPtr m_typeLight;

            [FieldOffset(56)]
            internal global::System.IntPtr m_typeRegular;

            [FieldOffset(64)]
            internal global::System.IntPtr m_typeSemibold;

            [FieldOffset(72)]
            internal global::System.IntPtr m_typeBold;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontFamily@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontFamily@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@FontFamily@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetThin@FontFamily@fl@@QEBAPEAVFontType@2@XZ")]
            internal static extern global::System.IntPtr GetThin(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLight@FontFamily@fl@@QEBAPEAVFontType@2@XZ")]
            internal static extern global::System.IntPtr GetLight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRegular@FontFamily@fl@@QEBAPEAVFontType@2@XZ")]
            internal static extern global::System.IntPtr GetRegular(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSemibold@FontFamily@fl@@QEBAPEAVFontType@2@XZ")]
            internal static extern global::System.IntPtr GetSemibold(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBold@FontFamily@fl@@QEBAPEAVFontType@2@XZ")]
            internal static extern global::System.IntPtr GetBold(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.FontFamily __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontFamily(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FontFamily __CreateInstance(global::FlounderSharp.FontFamily.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontFamily(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FontFamily.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontFamily.__Internal));
            global::FlounderSharp.FontFamily.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontFamily(global::FlounderSharp.FontFamily.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontFamily(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FontFamily(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontFamily.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.FontFamily");
        }

        public FontFamily(global::FlounderSharp.FontFamily _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontFamily.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FontFamily");
        }

        public static implicit operator global::FlounderSharp.FontFamily(string filename)
        {
            return new global::FlounderSharp.FontFamily(filename);
        }

        public static global::FlounderSharp.FontFamily Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.FontFamily __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.FontFamily.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.FontFamily) global::FlounderSharp.FontFamily.NativeToManagedMap[__ret];
            else global::FlounderSharp.FontFamily.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.FontFamily) global::FlounderSharp.FontFamily.__CreateInstance(__ret);
            return __result0;
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public global::FlounderSharp.FontType Thin
        {
            get
            {
                var __ret = __Internal.GetThin((__Instance + __PointerAdjustment));
                global::FlounderSharp.FontType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.FontType) global::FlounderSharp.FontType.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.FontType.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.FontType Light
        {
            get
            {
                var __ret = __Internal.GetLight((__Instance + __PointerAdjustment));
                global::FlounderSharp.FontType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.FontType) global::FlounderSharp.FontType.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.FontType.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.FontType Regular
        {
            get
            {
                var __ret = __Internal.GetRegular((__Instance + __PointerAdjustment));
                global::FlounderSharp.FontType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.FontType) global::FlounderSharp.FontType.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.FontType.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.FontType Semibold
        {
            get
            {
                var __ret = __Internal.GetSemibold((__Instance + __PointerAdjustment));
                global::FlounderSharp.FontType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.FontType) global::FlounderSharp.FontType.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.FontType.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.FontType Bold
        {
            get
            {
                var __ret = __Internal.GetBold((__Instance + __PointerAdjustment));
                global::FlounderSharp.FontType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.FontType) global::FlounderSharp.FontType.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.FontType.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~FontFamily()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FontFamily) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FontFamily) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>During the loading of a text this represents one word in the text.</summary>
    public unsafe partial class FontWord : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_FontCharacter___N_std_S_allocator__S0_ m_characters;

            [FieldOffset(24)]
            internal double m_width;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontWord@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontWord@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontWord@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddCharacter@FontWord@fl@@QEAA_NPEAVFontCharacter@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddCharacter(global::System.IntPtr instance, global::System.IntPtr c, float kerning);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@FontWord@fl@@QEBANXZ")]
            internal static extern double GetWidth(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontWord> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontWord>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.FontWord __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontWord(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FontWord __CreateInstance(global::FlounderSharp.FontWord.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontWord(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FontWord.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontWord.__Internal));
            global::FlounderSharp.FontWord.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontWord(global::FlounderSharp.FontWord.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontWord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new word.</summary>
        public FontWord()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontWord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public FontWord(global::FlounderSharp.FontWord _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontWord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.FontWord __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds a character to the end of the current word and increases the screen-space width of the word.</summary>
        /// <param name="c">The character to be added.</param>
        /// <param name="kerning">The character kerning.</param>
        public bool AddCharacter(global::FlounderSharp.FontCharacter c, float kerning)
        {
            var __arg0 = ReferenceEquals(c, null) ? global::System.IntPtr.Zero : c.__Instance;
            var __ret = __Internal.AddCharacter((__Instance + __PointerAdjustment), __arg0, kerning);
            return __ret;
        }

        public double Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a line of text during the loading of a text.</summary>
    public unsafe partial class FontLine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal double m_maxLength;

            [FieldOffset(8)]
            internal double m_spaceSize;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_FontWord___N_std_S_allocator__S0_ m_words;

            [FieldOffset(40)]
            internal double m_currentWordsLength;

            [FieldOffset(48)]
            internal double m_currentLineLength;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontLine@fl@@QEAA@AEBN0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, double spaceWidth, double maxLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontLine@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontLine@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddWord@FontLine@fl@@QEAA_NPEAVFontWord@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddWord(global::System.IntPtr instance, global::System.IntPtr word);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxLength@FontLine@fl@@QEBANXZ")]
            internal static extern double GetMaxLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpaceSize@FontLine@fl@@QEBANXZ")]
            internal static extern double GetSpaceSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentWordsLength@FontLine@fl@@QEBANXZ")]
            internal static extern double GetCurrentWordsLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentLineLength@FontLine@fl@@QEBANXZ")]
            internal static extern double GetCurrentLineLength(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontLine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FontLine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.FontLine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontLine(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FontLine __CreateInstance(global::FlounderSharp.FontLine.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FontLine(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FontLine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontLine.__Internal));
            global::FlounderSharp.FontLine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontLine(global::FlounderSharp.FontLine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontLine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new line.</summary>
        /// <param name="spaceWidth">The screen-space width of a space character.</param>
        /// <param name="maxLength">The screen-space maximum length of a line.</param>
        public FontLine(double spaceWidth, double maxLength)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), spaceWidth, maxLength);
        }

        public FontLine(global::FlounderSharp.FontLine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FontLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.FontLine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attempt to add a word to the line. If the line can fit the word in without reaching the maximum line length then the word is added and the line length increased.</summary>
        /// <param name="word">The word to try to add.</param>
        public bool AddWord(global::FlounderSharp.FontWord word)
        {
            var __arg0 = ReferenceEquals(word, null) ? global::System.IntPtr.Zero : word.__Instance;
            var __ret = __Internal.AddWord((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public double MaxLength
        {
            get
            {
                var __ret = __Internal.GetMaxLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double SpaceSize
        {
            get
            {
                var __ret = __Internal.GetSpaceSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double CurrentWordsLength
        {
            get
            {
                var __ret = __Internal.GetCurrentWordsLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public double CurrentLineLength
        {
            get
            {
                var __ret = __Internal.GetCurrentLineLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a RGBA colour.</summary>
    public unsafe partial class Colour : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Colour._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@fl@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr hex, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@fl@@QEAA@AEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@fl@@QEAA@AEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Colour@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Colour@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Colour@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Colour@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Colour@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Colour@fl@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Colour@fl@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@Colour@fl@@QEBA?AV12@AEBV12@M@Z")]
            internal static extern void Interpolate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Colour@fl@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Colour@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Colour@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Colour@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MColour@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NColour@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OColour@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PColour@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Colour@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Colour@fl@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Colour@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVColour@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVColour@0@V10@M@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Colour.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorPlus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorMinus_1(global::System.IntPtr @return, float value, global::FlounderSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, float value, global::FlounderSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVColour@0@MV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, float value, global::FlounderSharp.Colour.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetR@Colour@fl@@QEBAMXZ")]
            internal static extern float GetR(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetR@Colour@fl@@QEAAXAEBM@Z")]
            internal static extern void SetR(global::System.IntPtr instance, float r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetG@Colour@fl@@QEBAMXZ")]
            internal static extern float GetG(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetG@Colour@fl@@QEAAXAEBM@Z")]
            internal static extern void SetG(global::System.IntPtr instance, float g);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetB@Colour@fl@@QEBAMXZ")]
            internal static extern float GetB(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetB@Colour@fl@@QEAAXAEBM@Z")]
            internal static extern void SetB(global::System.IntPtr instance, float b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetA@Colour@fl@@QEBAMXZ")]
            internal static extern float GetA(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetA@Colour@fl@@QEAAXAEBM@Z")]
            internal static extern void SetA(global::System.IntPtr instance, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Colour@fl@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Colour@fl@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUnit@Colour@fl@@QEAA?AV12@XZ")]
            internal static extern void GetUnit(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHex@Colour@fl@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetHex(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Colour._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Colour._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float m_r;

                    [FieldOffset(4)]
                    internal float m_g;

                    [FieldOffset(8)]
                    internal float m_b;

                    [FieldOffset(12)]
                    internal float m_a;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Colour> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Colour>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Colour __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Colour(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Colour __CreateInstance(global::FlounderSharp.Colour.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Colour(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Colour.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Colour.__Internal));
            global::FlounderSharp.Colour.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Colour(global::FlounderSharp.Colour.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Colour(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for colour.</summary>
        public Colour()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="r">The new R value.</param>
        /// <param name="g">The new G value.</param>
        /// <param name="b">The new B value.</param>
        /// <param name="a">The new A value.</param>
        public Colour(float r, float g, float b, float a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), r, g, b, a);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="hex">The new values from HEX.</param>
        /// <param name="a">The new A value.</param>
        public Colour(string hex, float a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(hex, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, a);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing one.</param>
        public Colour(global::FlounderSharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing vector.</param>
        public Colour(global::FlounderSharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing vector.</param>
        public Colour(global::FlounderSharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Colour __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Colour Add(global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Colour Subtract(global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Colour Multiply(global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Colour Divide(global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::FlounderSharp.Colour Scale(float scalar)
        {
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), scalar);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::FlounderSharp.Colour Normalize()
        {
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Interpolates between this and another colour.</summary>
        /// <param name="other">The other colour.</param>
        /// <param name="blend">The blend factor.</param>
        public global::FlounderSharp.Colour Interpolate(global::FlounderSharp.Colour other, float blend)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.Interpolate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, blend);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::FlounderSharp.Colour SmoothDamp(global::FlounderSharp.Colour target, global::FlounderSharp.Colour rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Saves this vector into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Colour __op, global::FlounderSharp.Colour other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Colour;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Colour.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Colour __op, global::FlounderSharp.Colour other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::FlounderSharp.Colour __op, global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::FlounderSharp.Colour __op, global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::FlounderSharp.Colour __op, global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::FlounderSharp.Colour __op, global::FlounderSharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::FlounderSharp.Colour __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, value);
            return __ret;
        }

        public static bool operator !=(global::FlounderSharp.Colour __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, value);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Colour(global::FlounderSharp.Vector3 source)
        {
            return new global::FlounderSharp.Colour(source);
        }

        public static implicit operator global::FlounderSharp.Colour(global::FlounderSharp.Vector4 source)
        {
            return new global::FlounderSharp.Colour(source);
        }

        public static global::FlounderSharp.Colour operator +(global::FlounderSharp.Colour left, global::FlounderSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator -(global::FlounderSharp.Colour left, global::FlounderSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator *(global::FlounderSharp.Colour left, global::FlounderSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator /(global::FlounderSharp.Colour left, global::FlounderSharp.Colour right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator +(global::FlounderSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator -(global::FlounderSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator *(global::FlounderSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator /(global::FlounderSharp.Colour left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator +(float value, global::FlounderSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorPlus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator -(float value, global::FlounderSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorMinus_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator *(float value, global::FlounderSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour operator /(float value, global::FlounderSharp.Colour left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Colour.__Internal() : *(global::FlounderSharp.Colour.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Colour.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Colour.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Colour Clear
        {
            get
            {
                var __ptr = (global::FlounderSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?CLEAR@Colour@fl@@2V12@B");
                return global::FlounderSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Colour White
        {
            get
            {
                var __ptr = (global::FlounderSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?WHITE@Colour@fl@@2V12@B");
                return global::FlounderSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Colour Black
        {
            get
            {
                var __ptr = (global::FlounderSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?BLACK@Colour@fl@@2V12@B");
                return global::FlounderSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public float R
        {
            get
            {
                var __ret = __Internal.GetR((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetR((__Instance + __PointerAdjustment), value);
            }
        }

        public float G
        {
            get
            {
                var __ret = __Internal.GetG((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetG((__Instance + __PointerAdjustment), value);
            }
        }

        public float B
        {
            get
            {
                var __ret = __Internal.GetB((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetB((__Instance + __PointerAdjustment), value);
            }
        }

        public float A
        {
            get
            {
                var __ret = __Internal.GetA((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetA((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets a colour representing the unit value of this colour.</summary>
        public global::FlounderSharp.Colour Unit
        {
            get
            {
                var __ret = new global::FlounderSharp.Colour.__Internal();
                __Internal.GetUnit((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Colour.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the hex code from this colour.</summary>
        public string Hex
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetHex((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a driver that changes over time.</summary>
    public unsafe abstract partial class IDriver : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDriver@fl@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDriver@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IDriver@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@IDriver@fl@@QEAAMAEBN@Z")]
            internal static extern float Update(global::System.IntPtr instance, double delta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetActualTime@IDriver@fl@@IEBAMXZ")]
            internal static extern float GetActualTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IDriver> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IDriver>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IDriver __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IDriverInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IDriver __CreateInstance(global::FlounderSharp.IDriver.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IDriverInternal(native, skipVTables);
        }

        protected IDriver(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new driver with a length.</summary>
        /// <param name="length">The drivers length.</param>
        protected IDriver(float length)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IDriver.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), length);
            SetupVTables(GetType().FullName == "FlounderSharp.IDriver");
        }

        protected IDriver(global::FlounderSharp.IDriver _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IDriver.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IDriver");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IDriver __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IDriver.__Internal*) __Instance)->vfptr_IDriver = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the driver with the passed time.</summary>
        /// <param name="delta">The time between the last update.</param>
        public float Update(double delta)
        {
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), delta);
            return __ret;
        }

        /// <summary>Calculates the new value.</summary>
        /// <param name="time">The time into the drivers life.</param>
        protected abstract float Calculate(float time);

        protected float ActualTime
        {
            get
            {
                var __ret = __Internal.GetActualTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~IDriver() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IDriver) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IDriver) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IDriverInternal : global::FlounderSharp.IDriver, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IDriver.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IDriver.__Internal));
            *(global::FlounderSharp.IDriver.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IDriverInternal(global::FlounderSharp.IDriver.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IDriverInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Calculates the new value.</summary>
        /// <param name="time">The time into the drivers life.</param>
        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A rectangle made of a position and dimension.</summary>
    public unsafe partial class UiBound : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_position;

            [FieldOffset(8)]
            internal global::System.IntPtr m_reference;

            [FieldOffset(16)]
            internal byte m_aspectPosition;

            [FieldOffset(17)]
            internal byte m_aspectSize;

            [FieldOffset(24)]
            internal global::System.IntPtr m_dimensions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@fl@@QEAA@AEBVVector2@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N20@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr reference, bool aspectPosition, bool aspectSize, global::System.IntPtr dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiBound@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Set@UiBound@fl@@QEAAPEAV12@AEBV12@@Z")]
            internal static extern global::System.IntPtr Set(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectPosition@UiBound@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectPosition(global::System.IntPtr instance, bool aspectPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectSize@UiBound@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectSize(global::System.IntPtr instance, bool aspectSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindPivot@UiBound@fl@@SA?AVVector2@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void FindPivot(global::System.IntPtr @return, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@UiBound@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@UiBound@fl@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetReference@UiBound@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetReference(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetReference@UiBound@fl@@QEAAXPEAVVector2@2@@Z")]
            internal static extern void SetReference(global::System.IntPtr instance, global::System.IntPtr reference);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDimensions@UiBound@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetDimensions(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@UiBound@fl@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, global::System.IntPtr dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectPosition@UiBound@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAspectPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectSize@UiBound@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAspectSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiBound> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiBound>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.UiBound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiBound(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiBound __CreateInstance(global::FlounderSharp.UiBound.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiBound(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiBound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiBound.__Internal));
            global::FlounderSharp.UiBound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiBound(global::FlounderSharp.UiBound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiBound(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for rectangle.</summary>
        /// <param name="position">The object screen position.</param>
        /// <param name="reference">The reference pivot vertex (TopLeft, TopCentre, TopRight, CentreLeft, Centre, CentreRight, BottomLeft, BottomCentre, BottomRight).</param>
        /// <param name="aspectPosition">The if the x position will change with display width.</param>
        /// <param name="aspectSize">The if the width will scale with display width.</param>
        /// <param name="dimensions">The object dimensions.</param>
        public UiBound(global::FlounderSharp.Vector2 position, string reference, bool aspectPosition, bool aspectSize, global::FlounderSharp.Vector2 dimensions)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(reference, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(dimensions, null))
                throw new global::System.ArgumentNullException("dimensions", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = dimensions.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, aspectPosition, aspectSize, __arg4);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Creates a new rectangle.</summary>
        /// <param name="source">Creates this rectangle out of a existing one.</param>
        public UiBound(global::FlounderSharp.UiBound source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.UiBound __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Loads from another Rectangle.</summary>
        /// <param name="source">The source rectangle.</param>
        public global::FlounderSharp.UiBound Set(global::FlounderSharp.UiBound source)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __ret = __Internal.Set((__Instance + __PointerAdjustment), __arg0);
            global::FlounderSharp.UiBound __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UiBound.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.UiBound) global::FlounderSharp.UiBound.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.UiBound.__CreateInstance(__ret);
            return __result0;
        }

        public void SetAspectPosition(bool aspectPosition)
        {
            __Internal.SetAspectPosition((__Instance + __PointerAdjustment), aspectPosition);
        }

        public void SetAspectSize(bool aspectSize)
        {
            __Internal.SetAspectSize((__Instance + __PointerAdjustment), aspectSize);
        }

        public static global::FlounderSharp.Vector2 FindPivot(string key)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.FindPivot(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        public global::FlounderSharp.Vector2 MPosition
        {
            get
            {
                global::FlounderSharp.Vector2 __result0;
                if (((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_position);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_position = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.Vector2 MReference
        {
            get
            {
                global::FlounderSharp.Vector2 __result0;
                if (((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_reference);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_reference = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public bool MAspectPosition
        {
            get
            {
                return ((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_aspectPosition != 0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_aspectPosition = (byte) (value ? 1 : 0);
            }
        }

        public bool MAspectSize
        {
            get
            {
                return ((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_aspectSize != 0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_aspectSize = (byte) (value ? 1 : 0);
            }
        }

        public global::FlounderSharp.Vector2 MDimensions
        {
            get
            {
                global::FlounderSharp.Vector2 __result0;
                if (((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(((global::FlounderSharp.UiBound.__Internal*) __Instance)->m_dimensions);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.UiBound.__Internal*)__Instance)->m_dimensions = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.Vector2 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector2 Reference
        {
            get
            {
                var __ret = __Internal.GetReference((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetReference((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector2 Dimensions
        {
            get
            {
                var __ret = __Internal.GetDimensions((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsAspectPosition
        {
            get
            {
                var __ret = __Internal.IsAspectPosition((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsAspectSize
        {
            get
            {
                var __ret = __Internal.IsAspectSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A representation of a object this is rendered to a screen. This object is contained in a parent and has children. The screen object has a few values that allow for it to be positioned and scaled, along with other variables that are used when rendering. This class can be extended to create a representation for GUI textures, fonts, etc.</summary>
    public unsafe partial class UiObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 224)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiObject@fl@@QEAA@PEAV01@AEBVUiBound@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr rectangle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiObject@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UiObject@fl@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveChild@UiObject@fl@@QEAAXPEAV12@@Z")]
            internal static extern void RemoveChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVisible@UiObject@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetVisible(global::System.IntPtr instance, bool visible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAlphaDriver@UiObject@fl@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetAlphaDriver(global::System.IntPtr instance, global::System.IntPtr alphaDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaleDriver@UiObject@fl@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetScaleDriver(global::System.IntPtr instance, global::System.IntPtr scaleDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@UiObject@fl@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetParent@UiObject@fl@@QEAAXPEAV12@@Z")]
            internal static extern void SetParent(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRectangle@UiObject@fl@@QEBAPEAVUiBound@2@XZ")]
            internal static extern global::System.IntPtr GetRectangle(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRectangle@UiObject@fl@@QEBAXAEBVUiBound@2@@Z")]
            internal static extern void SetRectangle(global::System.IntPtr instance, global::System.IntPtr rectangle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScissor@UiObject@fl@@QEBAPEAVVector4@2@XZ")]
            internal static extern global::System.IntPtr GetScissor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScissor@UiObject@fl@@QEBAXAEBVVector4@2@@Z")]
            internal static extern void SetScissor(global::System.IntPtr instance, global::System.IntPtr scissor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionOffset@UiObject@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetPositionOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPositionOffset@UiObject@fl@@QEBAXAEBVVector2@2@@Z")]
            internal static extern void SetPositionOffset(global::System.IntPtr instance, global::System.IntPtr positionOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsVisible@UiObject@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsVisible(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScreenTransform@UiObject@fl@@QEBAPEAVVector4@2@XZ")]
            internal static extern global::System.IntPtr GetScreenTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAlpha@UiObject@fl@@QEBAMXZ")]
            internal static extern float GetAlpha(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@UiObject@fl@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.UiObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiObject(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiObject __CreateInstance(global::FlounderSharp.UiObject.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiObject(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiObject.__Internal));
            global::FlounderSharp.UiObject.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiObject(global::FlounderSharp.UiObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new screen object.</summary>
        /// <param name="parent">The parent screen object.</param>
        /// <param name="rectangle">The rectangle that will represent the bounds of the ui object.</param>
        public UiObject(global::FlounderSharp.UiObject parent, global::FlounderSharp.UiBound rectangle)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(rectangle, null))
                throw new global::System.ArgumentNullException("rectangle", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rectangle.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.UiObject");
        }

        public UiObject(global::FlounderSharp.UiObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiObject");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.UiObject.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates this screen object and the extended object.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        /// <summary>Updates the implementation.</summary>
        public virtual void UpdateObject()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateObjectDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateObjectDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Disowns a child from this screen objects children list.</summary>
        /// <param name="child">The child to disown.</param>
        public void RemoveChild(global::FlounderSharp.UiObject child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.RemoveChild((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetVisible(bool visible)
        {
            __Internal.SetVisible((__Instance + __PointerAdjustment), visible);
        }

        public void SetAlphaDriver(global::FlounderSharp.IDriver alphaDriver)
        {
            var __arg0 = ReferenceEquals(alphaDriver, null) ? global::System.IntPtr.Zero : alphaDriver.__Instance;
            __Internal.SetAlphaDriver((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetScaleDriver(global::FlounderSharp.IDriver scaleDriver)
        {
            var __arg0 = ReferenceEquals(scaleDriver, null) ? global::System.IntPtr.Zero : scaleDriver.__Instance;
            __Internal.SetScaleDriver((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the parent object.</summary>
        /// <param name="parent">The new parent object.</param>
        /// <remarks>Removes this object from the previous parent and attaches it to another parent.</remarks>
        public global::FlounderSharp.UiObject Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::FlounderSharp.UiObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.UiObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.UiObject) global::FlounderSharp.UiObject.NativeToManagedMap[__ret];
                else global::FlounderSharp.UiObject.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.UiObject) global::FlounderSharp.UiObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetParent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.UiBound Rectangle
        {
            get
            {
                var __ret = __Internal.GetRectangle((__Instance + __PointerAdjustment));
                global::FlounderSharp.UiBound __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.UiBound.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.UiBound) global::FlounderSharp.UiBound.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.UiBound.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRectangle((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector4 Scissor
        {
            get
            {
                var __ret = __Internal.GetScissor((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector4.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScissor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector2 PositionOffset
        {
            get
            {
                var __ret = __Internal.GetPositionOffset((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPositionOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IsVisible
        {
            get
            {
                var __ret = __Internal.IsVisible((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the ui object screen space transform.</summary>
        public global::FlounderSharp.Vector4 ScreenTransform
        {
            get
            {
                var __ret = __Internal.GetScreenTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector4.__CreateInstance(__ret);
                return __result0;
            }
        }

        public float Alpha
        {
            get
            {
                var __ret = __Internal.GetAlpha((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~UiObject()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject()
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public enum JoystickPort
    {
        Joystick1 = 0,
        Joystick2 = 1,
        Joystick3 = 2,
        Joystick4 = 3,
        Joystick5 = 4,
        Joystick6 = 5,
        Joystick7 = 6,
        Joystick8 = 7,
        Joystick9 = 8,
        Joystick10 = 9,
        Joystick11 = 10,
        Joystick12 = 11,
        Joystick13 = 12,
        Joystick14 = 13,
        Joystick15 = 14,
        Joystick16 = 15,
        JoystickLast = 15
    }

    /// <summary>A definition for a connected joystick.</summary>
    public unsafe partial class Joystick : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_connected;

            [FieldOffset(4)]
            internal int m_id;

            [FieldOffset(8)]
            internal global::System.IntPtr m_name;

            [FieldOffset(16)]
            internal global::System.IntPtr m_axes;

            [FieldOffset(24)]
            internal global::System.IntPtr m_buttons;

            [FieldOffset(32)]
            internal int m_axeCount;

            [FieldOffset(36)]
            internal int m_buttonCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joystick@fl@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Joystick> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Joystick>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Joystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joystick(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Joystick __CreateInstance(global::FlounderSharp.Joystick.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joystick(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Joystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joystick.__Internal));
            *(global::FlounderSharp.Joystick.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Joystick(global::FlounderSharp.Joystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joystick(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Joystick()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Joystick(global::FlounderSharp.Joystick _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Joystick.__Internal*) __Instance) = *((global::FlounderSharp.Joystick.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Joystick __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool MConnected
        {
            get
            {
                return ((global::FlounderSharp.Joystick.__Internal*) __Instance)->m_connected != 0;
            }

            set
            {
                ((global::FlounderSharp.Joystick.__Internal*)__Instance)->m_connected = (byte) (value ? 1 : 0);
            }
        }

        public int MId
        {
            get
            {
                return ((global::FlounderSharp.Joystick.__Internal*) __Instance)->m_id;
            }

            set
            {
                ((global::FlounderSharp.Joystick.__Internal*)__Instance)->m_id = value;
            }
        }

        public string MName
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::FlounderSharp.Joystick.__Internal*) __Instance)->m_name);
            }

            set
            {
                ((global::FlounderSharp.Joystick.__Internal*)__Instance)->m_name = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public float* MAxes
        {
            get
            {
                return (float*) ((global::FlounderSharp.Joystick.__Internal*) __Instance)->m_axes;
            }

            set
            {
                ((global::FlounderSharp.Joystick.__Internal*)__Instance)->m_axes = (global::System.IntPtr) value;
            }
        }

        public byte* MButtons
        {
            get
            {
                return (byte*) ((global::FlounderSharp.Joystick.__Internal*) __Instance)->m_buttons;
            }

            set
            {
                ((global::FlounderSharp.Joystick.__Internal*)__Instance)->m_buttons = (global::System.IntPtr) value;
            }
        }

        public int MAxeCount
        {
            get
            {
                return ((global::FlounderSharp.Joystick.__Internal*) __Instance)->m_axeCount;
            }

            set
            {
                ((global::FlounderSharp.Joystick.__Internal*)__Instance)->m_axeCount = value;
            }
        }

        public int MButtonCount
        {
            get
            {
                return ((global::FlounderSharp.Joystick.__Internal*) __Instance)->m_buttonCount;
            }

            set
            {
                ((global::FlounderSharp.Joystick.__Internal*)__Instance)->m_buttonCount = value;
            }
        }
    }

    /// <summary>A module used for the creation, updating and destruction of the joysticks.</summary>
    public unsafe partial class Joysticks : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_connected;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joysticks@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joysticks@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Joysticks@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsConnected@Joysticks@fl@@QEBA_NAEBW4JoystickPort@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsConnected(global::System.IntPtr instance, global::FlounderSharp.JoystickPort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Joysticks@fl@@QEBAPEBDAEBW4JoystickPort@2@@Z")]
            internal static extern global::System.IntPtr GetName(global::System.IntPtr instance, global::FlounderSharp.JoystickPort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxis@Joysticks@fl@@QEBAMAEBW4JoystickPort@2@AEBH@Z")]
            internal static extern float GetAxis(global::System.IntPtr instance, global::FlounderSharp.JoystickPort port, int axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetButton@Joysticks@fl@@QEBA_NAEBW4JoystickPort@2@AEBH@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetButton(global::System.IntPtr instance, global::FlounderSharp.JoystickPort port, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCountAxes@Joysticks@fl@@QEBAHAEBW4JoystickPort@2@@Z")]
            internal static extern int GetCountAxes(global::System.IntPtr instance, global::FlounderSharp.JoystickPort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCountButtons@Joysticks@fl@@QEBAHAEBW4JoystickPort@2@@Z")]
            internal static extern int GetCountButtons(global::System.IntPtr instance, global::FlounderSharp.JoystickPort port);
        }

        internal static new global::FlounderSharp.Joysticks __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joysticks(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Joysticks __CreateInstance(global::FlounderSharp.Joysticks.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Joysticks(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Joysticks.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joysticks.__Internal));
            global::FlounderSharp.Joysticks.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joysticks(global::FlounderSharp.Joysticks.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joysticks(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new joysticks module.</summary>
        public Joysticks()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joysticks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Joysticks");
        }

        public Joysticks(global::FlounderSharp.Joysticks _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Joysticks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Joysticks");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Determines if the GLFW joystick is connected</summary>
        /// <param name="port">The joystick to check connection with.</param>
        public bool IsConnected(global::FlounderSharp.JoystickPort port)
        {
            var __ret = __Internal.IsConnected((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets the name of the joystick.</summary>
        /// <param name="port">The joystick to get the name of.</param>
        public string GetName(global::FlounderSharp.JoystickPort port)
        {
            var __ret = __Internal.GetName((__Instance + __PointerAdjustment), port);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Gets the value of a joysticks axis.</summary>
        /// <param name="port">The joystick to get the axis from.</param>
        /// <param name="axis">The axis of interest.</param>
        public float GetAxis(global::FlounderSharp.JoystickPort port, int axis)
        {
            var __ret = __Internal.GetAxis((__Instance + __PointerAdjustment), port, axis);
            return __ret;
        }

        /// <summary>Gets the whether a button on a joystick is pressed.</summary>
        /// <param name="port">The joystick to get the button from.</param>
        /// <param name="button">The button of interest.</param>
        public bool GetButton(global::FlounderSharp.JoystickPort port, int button)
        {
            var __ret = __Internal.GetButton((__Instance + __PointerAdjustment), port, button);
            return __ret;
        }

        /// <summary>Gets the number of axes the joystick offers.</summary>
        /// <param name="port">The joystick to the the axis count from.</param>
        public int GetCountAxes(global::FlounderSharp.JoystickPort port)
        {
            var __ret = __Internal.GetCountAxes((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets the number of buttons the joystick offers.</summary>
        /// <param name="port">The joystick to the the button count from.</param>
        public int GetCountButtons(global::FlounderSharp.JoystickPort port)
        {
            var __ret = __Internal.GetCountButtons((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Joysticks Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Joysticks __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Joysticks.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Joysticks) global::FlounderSharp.Joysticks.NativeToManagedMap[__ret];
            else global::FlounderSharp.Joysticks.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Joysticks) global::FlounderSharp.Joysticks.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~Joysticks()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Joysticks) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Joysticks) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Interface for an axis based input device.</summary>
    public unsafe abstract partial class IAxis : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IAxis@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IAxis@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IAxis@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IAxis> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IAxis>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IAxis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IAxisInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IAxis __CreateInstance(global::FlounderSharp.IAxis.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IAxisInternal(native, skipVTables);
        }

        protected IAxis(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new axis.</summary>
        protected IAxis()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IAxis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IAxis");
        }

        protected IAxis(global::FlounderSharp.IAxis _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IAxis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IAxis");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IAxis.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the current value along the axis. -1 is smallest input, 1 is largest input.</summary>
        public abstract float Amount
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IAxis() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IAxis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float GetAmount() const = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IAxis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IAxisInternal : global::FlounderSharp.IAxis, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IAxis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IAxis.__Internal));
            *(global::FlounderSharp.IAxis.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IAxisInternal(global::FlounderSharp.IAxis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IAxisInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets the current value along the axis. -1 is smallest input, 1 is largest input.</summary>
        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetAmountDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Axis from a joystick.</summary>
    public unsafe partial class AxisJoystick : global::FlounderSharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::FlounderSharp.JoystickPort m_joystick;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I m_axes;

            [FieldOffset(40)]
            internal byte m_reverse;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisJoystick@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@AxisJoystick@fl@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::FlounderSharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@AxisJoystick@fl@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::FlounderSharp.JoystickPort joystickPort);
        }

        internal static new global::FlounderSharp.AxisJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AxisJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.AxisJoystick __CreateInstance(global::FlounderSharp.AxisJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AxisJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.AxisJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AxisJoystick.__Internal));
            global::FlounderSharp.AxisJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisJoystick(global::FlounderSharp.AxisJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public AxisJoystick(global::FlounderSharp.AxisJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AxisJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.AxisJoystick");
        }

        public global::FlounderSharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), value);
            }
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetAmountDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~AxisJoystick()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.AxisJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float GetAmount() const override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.AxisJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public enum MouseButton
    {
        MouseButton1 = 0,
        MouseButton2 = 1,
        MouseButton3 = 2,
        MouseButton4 = 3,
        MouseButton5 = 4,
        MouseButton6 = 5,
        MouseButton7 = 6,
        MouseButton8 = 7,
        MouseButtonLast = 7,
        MouseButtonLeft = 0,
        MouseButtonRight = 1,
        MouseButtonMiddle = 2
    }

    /// <summary>A module used for the creation, updating and destruction of the mouse.</summary>
    public unsafe partial class Mouse : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_customMouse;

            [FieldOffset(40)]
            internal global::System.IntPtr m_mouseButtons;

            [FieldOffset(48)]
            internal float m_lastMousePositionX;

            [FieldOffset(52)]
            internal float m_lastMousePositionY;

            [FieldOffset(56)]
            internal float m_mousePositionX;

            [FieldOffset(60)]
            internal float m_mousePositionY;

            [FieldOffset(64)]
            internal float m_mouseDeltaX;

            [FieldOffset(68)]
            internal float m_mouseDeltaY;

            [FieldOffset(72)]
            internal float m_mouseDeltaWheel;

            [FieldOffset(76)]
            internal byte m_displaySelected;

            [FieldOffset(77)]
            internal byte m_cursorDisabled;

            [FieldOffset(78)]
            internal byte m_lastCursorDisabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mouse@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mouse@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Mouse@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCursorHidden@Mouse@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetCursorHidden(global::System.IntPtr instance, bool disabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetButton@Mouse@fl@@QEBA_NAEBW4MouseButton@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetButton(global::System.IntPtr instance, global::FlounderSharp.MouseButton button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Mouse@fl@@QEAAXAEBM0@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, float cursorX, float cursorY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCustomMouse@Mouse@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetCustomMouse(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCustomMouse@Mouse@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetCustomMouse(global::System.IntPtr instance, global::System.IntPtr customMouse);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionX@Mouse@fl@@QEBAMXZ")]
            internal static extern float GetPositionX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionY@Mouse@fl@@QEBAMXZ")]
            internal static extern float GetPositionY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaX@Mouse@fl@@QEBAMXZ")]
            internal static extern float GetDeltaX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaY@Mouse@fl@@QEBAMXZ")]
            internal static extern float GetDeltaY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaWheel@Mouse@fl@@QEBAMXZ")]
            internal static extern float GetDeltaWheel(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsDisplaySelected@Mouse@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsDisplaySelected(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsCursorDisabled@Mouse@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsCursorDisabled(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Mouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Mouse(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Mouse __CreateInstance(global::FlounderSharp.Mouse.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Mouse(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Mouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Mouse.__Internal));
            global::FlounderSharp.Mouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Mouse(global::FlounderSharp.Mouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new mouse module.</summary>
        public Mouse()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Mouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Mouse");
        }

        public Mouse(global::FlounderSharp.Mouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Mouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Mouse");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Sets if the operating systems cursor is hidden whilst in the display.</summary>
        /// <param name="disabled">If the system cursor should be disabled or hidden when not shown.</param>
        public void SetCursorHidden(bool disabled)
        {
            __Internal.SetCursorHidden((__Instance + __PointerAdjustment), disabled);
        }

        /// <summary>Gets whether or not a particular mouse button is currently pressed. GLFW Actions: GLFW_PRESS, GLFW_RELEASE, GLFW_REPEAT</summary>
        /// <param name="button">The mouse button to test.</param>
        public bool GetButton(global::FlounderSharp.MouseButton button)
        {
            var __ret = __Internal.GetButton((__Instance + __PointerAdjustment), button);
            return __ret;
        }

        /// <summary>Sets the mouse position by calling glfwSetCursorPos.</summary>
        /// <param name="cursorX">The x position in screenspace.</param>
        /// <param name="cursorY">The y position in screenspace.</param>
        public void SetPosition(float cursorX, float cursorY)
        {
            __Internal.SetPosition((__Instance + __PointerAdjustment), cursorX, cursorY);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Mouse Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Mouse __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Mouse.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Mouse) global::FlounderSharp.Mouse.NativeToManagedMap[__ret];
            else global::FlounderSharp.Mouse.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Mouse) global::FlounderSharp.Mouse.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the mouses custom mouse file.</summary>
        /// <param name="title">The new custom mouse file.</param>
        /// <remarks>Sets the custom mouse file.</remarks>
        public string CustomMouse
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetCustomMouse((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetCustomMouse((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the mouses screen x position.</summary>
        public float PositionX
        {
            get
            {
                var __ret = __Internal.GetPositionX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses screen y position.</summary>
        public float PositionY
        {
            get
            {
                var __ret = __Internal.GetPositionY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses delta x.</summary>
        public float DeltaX
        {
            get
            {
                var __ret = __Internal.GetDeltaX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses delta y.</summary>
        public float DeltaY
        {
            get
            {
                var __ret = __Internal.GetDeltaY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses wheel delta.</summary>
        public float DeltaWheel
        {
            get
            {
                var __ret = __Internal.GetDeltaWheel((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display is selected.</summary>
        public bool IsDisplaySelected
        {
            get
            {
                var __ret = __Internal.IsDisplaySelected((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>If the cursor is hidden, the mouse is the display locked if true.</summary>
        public bool IsCursorDisabled
        {
            get
            {
                var __ret = __Internal.IsCursorDisabled((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Mouse()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Mouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class Mouse
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackScroll@fl@@YAXPEAVGLFWwindow@@NN@Z")]
            internal static extern void CallbackScroll(global::System.IntPtr window, double xoffset, double yoffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackMouseButton@fl@@YAXPEAVGLFWwindow@@HHH@Z")]
            internal static extern void CallbackMouseButton(global::System.IntPtr window, int button, int action, int mods);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackCursorPos@fl@@YAXPEAVGLFWwindow@@NN@Z")]
            internal static extern void CallbackCursorPos(global::System.IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackCursorEnter@fl@@YAXPEAVGLFWwindow@@H@Z")]
            internal static extern void CallbackCursorEnter(global::System.IntPtr window, int entered);
        }

        public static void CallbackScroll(global::GLFWwindow window, double xoffset, double yoffset)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackScroll(__arg0, xoffset, yoffset);
        }

        public static void CallbackMouseButton(global::GLFWwindow window, int button, int action, int mods)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackMouseButton(__arg0, button, action, mods);
        }

        public static void CallbackCursorPos(global::GLFWwindow window, double xpos, double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackCursorPos(__arg0, xpos, ypos);
        }

        public static void CallbackCursorEnter(global::GLFWwindow window, int entered)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackCursorEnter(__arg0, entered);
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Interface for a binary input device.</summary>
    public unsafe abstract partial class IButton : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IButton@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IButton@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IButton@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IButton> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IButton>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IButtonInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IButton __CreateInstance(global::FlounderSharp.IButton.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IButtonInternal(native, skipVTables);
        }

        protected IButton(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new axis.</summary>
        protected IButton()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IButton");
        }

        protected IButton(global::FlounderSharp.IButton _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IButton");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IButton.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if the key is down and was not down before. Key press recognized as one click.</summary>
        public abstract bool WasDown();

        /// <summary>Returns whether this button is currently pressed.</summary>
        public abstract bool IsDown
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IButton() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool IsDown() const = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IButtonInternal : global::FlounderSharp.IButton, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IButton.__Internal));
            *(global::FlounderSharp.IButton.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IButtonInternal(global::FlounderSharp.IButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IButtonInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets if the key is down and was not down before. Key press recognized as one click.</summary>
        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___WasDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Returns whether this button is currently pressed.</summary>
        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___IsDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Button from a mouse.</summary>
    public unsafe partial class ButtonMouse : global::FlounderSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_fl_E_MouseButton___N_std_S_allocator__S0_ m_buttons;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonMouse@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.ButtonMouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonMouse(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ButtonMouse __CreateInstance(global::FlounderSharp.ButtonMouse.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonMouse(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ButtonMouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonMouse.__Internal));
            global::FlounderSharp.ButtonMouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonMouse(global::FlounderSharp.ButtonMouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonMouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ButtonMouse(global::FlounderSharp.ButtonMouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ButtonMouse");
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___WasDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___IsDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~ButtonMouse()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool IsDown() const override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Button from a joystick.</summary>
    public unsafe partial class ButtonJoystick : global::FlounderSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::FlounderSharp.JoystickPort m_joystick;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I m_buttons;

            [FieldOffset(40)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonJoystick@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@ButtonJoystick@fl@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::FlounderSharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@ButtonJoystick@fl@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::FlounderSharp.JoystickPort joystickPort);
        }

        internal static new global::FlounderSharp.ButtonJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ButtonJoystick __CreateInstance(global::FlounderSharp.ButtonJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ButtonJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonJoystick.__Internal));
            global::FlounderSharp.ButtonJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonJoystick(global::FlounderSharp.ButtonJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ButtonJoystick(global::FlounderSharp.ButtonJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ButtonJoystick");
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___WasDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public global::FlounderSharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), value);
            }
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___IsDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~ButtonJoystick()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool IsDown() const override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class SelectorJoystick : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.JoystickPort joystick;

            [FieldOffset(8)]
            internal global::System.IntPtr clickLeft;

            [FieldOffset(16)]
            internal global::System.IntPtr clickRight;

            [FieldOffset(24)]
            internal global::System.IntPtr axisX;

            [FieldOffset(32)]
            internal global::System.IntPtr axisY;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SelectorJoystick@fl@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SelectorJoystick> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SelectorJoystick>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.SelectorJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SelectorJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SelectorJoystick __CreateInstance(global::FlounderSharp.SelectorJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SelectorJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SelectorJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SelectorJoystick.__Internal));
            *(global::FlounderSharp.SelectorJoystick.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SelectorJoystick(global::FlounderSharp.SelectorJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SelectorJoystick(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SelectorJoystick()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SelectorJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SelectorJoystick(global::FlounderSharp.SelectorJoystick _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SelectorJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance) = *((global::FlounderSharp.SelectorJoystick.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.SelectorJoystick __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::FlounderSharp.JoystickPort Joystick
        {
            get
            {
                return ((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->joystick;
            }

            set
            {
                ((global::FlounderSharp.SelectorJoystick.__Internal*)__Instance)->joystick = value;
            }
        }

        public global::FlounderSharp.ButtonJoystick ClickLeft
        {
            get
            {
                global::FlounderSharp.ButtonJoystick __result0;
                if (((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickLeft == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ButtonJoystick.NativeToManagedMap.ContainsKey(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickLeft))
                    __result0 = (global::FlounderSharp.ButtonJoystick) global::FlounderSharp.ButtonJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickLeft];
                else global::FlounderSharp.ButtonJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickLeft] = __result0 = (global::FlounderSharp.ButtonJoystick) global::FlounderSharp.ButtonJoystick.__CreateInstance(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickLeft);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.SelectorJoystick.__Internal*)__Instance)->clickLeft = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.ButtonJoystick ClickRight
        {
            get
            {
                global::FlounderSharp.ButtonJoystick __result0;
                if (((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickRight == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ButtonJoystick.NativeToManagedMap.ContainsKey(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickRight))
                    __result0 = (global::FlounderSharp.ButtonJoystick) global::FlounderSharp.ButtonJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickRight];
                else global::FlounderSharp.ButtonJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickRight] = __result0 = (global::FlounderSharp.ButtonJoystick) global::FlounderSharp.ButtonJoystick.__CreateInstance(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->clickRight);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.SelectorJoystick.__Internal*)__Instance)->clickRight = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.AxisJoystick AxisX
        {
            get
            {
                global::FlounderSharp.AxisJoystick __result0;
                if (((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisX == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.AxisJoystick.NativeToManagedMap.ContainsKey(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisX))
                    __result0 = (global::FlounderSharp.AxisJoystick) global::FlounderSharp.AxisJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisX];
                else global::FlounderSharp.AxisJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisX] = __result0 = (global::FlounderSharp.AxisJoystick) global::FlounderSharp.AxisJoystick.__CreateInstance(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisX);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.SelectorJoystick.__Internal*)__Instance)->axisX = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.AxisJoystick AxisY
        {
            get
            {
                global::FlounderSharp.AxisJoystick __result0;
                if (((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisY == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.AxisJoystick.NativeToManagedMap.ContainsKey(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisY))
                    __result0 = (global::FlounderSharp.AxisJoystick) global::FlounderSharp.AxisJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisY];
                else global::FlounderSharp.AxisJoystick.NativeToManagedMap[((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisY] = __result0 = (global::FlounderSharp.AxisJoystick) global::FlounderSharp.AxisJoystick.__CreateInstance(((global::FlounderSharp.SelectorJoystick.__Internal*) __Instance)->axisY);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.SelectorJoystick.__Internal*)__Instance)->axisY = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Represents a virtual cursor that will be used to determine if a ui action was preformed by a device.</summary>
    public unsafe partial class UiSelector : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_cursorX;

            [FieldOffset(4)]
            internal float m_cursorY;

            [FieldOffset(8)]
            internal byte m_leftClick;

            [FieldOffset(9)]
            internal byte m_rightClick;

            [FieldOffset(10)]
            internal byte m_leftWasClick;

            [FieldOffset(11)]
            internal byte m_rightWasClick;

            [FieldOffset(16)]
            internal global::System.IntPtr m_mouseLeft;

            [FieldOffset(24)]
            internal global::System.IntPtr m_mouseRight;

            [FieldOffset(32)]
            internal global::System.IntPtr m_selectorJoystick;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelector@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelector@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiSelector@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Load@UiSelector@fl@@QEAAXAEBW4JoystickPort@2@AEBH111@Z")]
            internal static extern void Load(global::System.IntPtr instance, global::FlounderSharp.JoystickPort joystick, int joystickLeftClick, int joystickRightClick, int joystickAxisX, int joystickAxisY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UiSelector@fl@@QEAAXAEB_N@Z")]
            internal static extern void Update(global::System.IntPtr instance, bool paused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSelected@UiSelector@fl@@QEBA_NAEBVUiObject@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSelected(global::System.IntPtr instance, global::System.IntPtr targetObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CancelWasEvent@UiSelector@fl@@QEAAXXZ")]
            internal static extern void CancelWasEvent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WasLeftClick@UiSelector@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WasLeftClick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WasRightClick@UiSelector@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WasRightClick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCursorX@UiSelector@fl@@QEBAMXZ")]
            internal static extern float GetCursorX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCursorY@UiSelector@fl@@QEBAMXZ")]
            internal static extern float GetCursorY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLeftClick@UiSelector@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetLeftClick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRightClick@UiSelector@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRightClick(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiSelector> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiSelector>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.UiSelector __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiSelector(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiSelector __CreateInstance(global::FlounderSharp.UiSelector.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiSelector(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiSelector.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiSelector.__Internal));
            *(global::FlounderSharp.UiSelector.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UiSelector(global::FlounderSharp.UiSelector.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiSelector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UiSelector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiSelector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public UiSelector(global::FlounderSharp.UiSelector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiSelector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.UiSelector.__Internal*) __Instance) = *((global::FlounderSharp.UiSelector.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.UiSelector __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Sets up the joystick settings to be used for controlling the virtual cursor.</summary>
        /// <param name="joystick">The joystick port to attach to.</param>
        /// <param name="joystickLeftClick">The joystick key to be used as the left click.</param>
        /// <param name="joystickRightClick">The joystick key to be used as the right click.</param>
        /// <param name="joystickAxisX">The joystick axis to be used for moving the x axis.</param>
        /// <param name="joystickAxisY">The joystick axis to be used for moving the y axis.</param>
        public void Load(global::FlounderSharp.JoystickPort joystick, int joystickLeftClick, int joystickRightClick, int joystickAxisX, int joystickAxisY)
        {
            __Internal.Load((__Instance + __PointerAdjustment), joystick, joystickLeftClick, joystickRightClick, joystickAxisX, joystickAxisY);
        }

        public void Update(bool paused)
        {
            __Internal.Update((__Instance + __PointerAdjustment), paused);
        }

        /// <summary>Gets if the object provided has the cursor hovered above it.</summary>
        /// <param name="object">The object to check with.</param>
        public bool IsSelected(global::FlounderSharp.UiObject targetObject)
        {
            if (ReferenceEquals(targetObject, null))
                throw new global::System.ArgumentNullException("targetObject", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = targetObject.__Instance;
            var __ret = __Internal.IsSelected((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void CancelWasEvent()
        {
            __Internal.CancelWasEvent((__Instance + __PointerAdjustment));
        }

        public bool WasLeftClick()
        {
            var __ret = __Internal.WasLeftClick((__Instance + __PointerAdjustment));
            return __ret;
        }

        public bool WasRightClick()
        {
            var __ret = __Internal.WasRightClick((__Instance + __PointerAdjustment));
            return __ret;
        }

        public float CursorX
        {
            get
            {
                var __ret = __Internal.GetCursorX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float CursorY
        {
            get
            {
                var __ret = __Internal.GetCursorY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool LeftClick
        {
            get
            {
                var __ret = __Internal.GetLeftClick((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool RightClick
        {
            get
            {
                var __ret = __Internal.GetRightClick((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for that manages gui textures in a container.</summary>
    public unsafe partial class Uis : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_selector;

            [FieldOffset(16)]
            internal global::System.IntPtr m_container;

            [FieldOffset(24)]
            internal global::System.IntPtr m_objects;

            [FieldOffset(32)]
            internal global::System.IntPtr m_proximaNova;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uis@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uis@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Uis@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContainer@Uis@fl@@QEBAPEAVUiObject@2@XZ")]
            internal static extern global::System.IntPtr GetContainer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSelector@Uis@fl@@QEBAPEAVUiSelector@2@XZ")]
            internal static extern global::System.IntPtr GetSelector(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Uis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Uis(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Uis __CreateInstance(global::FlounderSharp.Uis.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Uis(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Uis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Uis.__Internal));
            global::FlounderSharp.Uis.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Uis(global::FlounderSharp.Uis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Uis(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new uis module.</summary>
        public Uis()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Uis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Uis");
        }

        public Uis(global::FlounderSharp.Uis _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Uis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Uis");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Uis Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Uis __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Uis.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Uis) global::FlounderSharp.Uis.NativeToManagedMap[__ret];
            else global::FlounderSharp.Uis.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Uis) global::FlounderSharp.Uis.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.FontFamily MProximaNova
        {
            get
            {
                global::FlounderSharp.FontFamily __result0;
                if (((global::FlounderSharp.Uis.__Internal*) __Instance)->m_proximaNova == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontFamily.NativeToManagedMap.ContainsKey(((global::FlounderSharp.Uis.__Internal*) __Instance)->m_proximaNova))
                    __result0 = (global::FlounderSharp.FontFamily) global::FlounderSharp.FontFamily.NativeToManagedMap[((global::FlounderSharp.Uis.__Internal*) __Instance)->m_proximaNova];
                else global::FlounderSharp.FontFamily.NativeToManagedMap[((global::FlounderSharp.Uis.__Internal*) __Instance)->m_proximaNova] = __result0 = (global::FlounderSharp.FontFamily) global::FlounderSharp.FontFamily.__CreateInstance(((global::FlounderSharp.Uis.__Internal*) __Instance)->m_proximaNova);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.Uis.__Internal*)__Instance)->m_proximaNova = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Gets the screen container.</summary>
        public global::FlounderSharp.UiObject Container
        {
            get
            {
                var __ret = __Internal.GetContainer((__Instance + __PointerAdjustment));
                global::FlounderSharp.UiObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.UiObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.UiObject) global::FlounderSharp.UiObject.NativeToManagedMap[__ret];
                else global::FlounderSharp.UiObject.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.UiObject) global::FlounderSharp.UiObject.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the main GUI selector.</summary>
        public global::FlounderSharp.UiSelector Selector
        {
            get
            {
                var __ret = __Internal.GetSelector((__Instance + __PointerAdjustment));
                global::FlounderSharp.UiSelector __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.UiSelector.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.UiSelector) global::FlounderSharp.UiSelector.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.UiSelector.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Uis()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Uis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Uis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A enum that represents how a font will be justified.</summary>
    public enum FontJustify
    {
        JustifyLeft = 0,
        JustifyCentre = 1,
        JustifyRight = 2,
        JustifyFully = 3
    }

    /// <summary>A object the represents a text in a GUI.</summary>
    public unsafe partial class Text : global::FlounderSharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 400)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [FieldOffset(224)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(232)]
            internal global::System.IntPtr m_uniformObject;

            [FieldOffset(240)]
            internal global::System.IntPtr m_model;

            [FieldOffset(248)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_string;

            [FieldOffset(280)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_newString;

            [FieldOffset(312)]
            internal global::FlounderSharp.FontJustify m_justify;

            [FieldOffset(320)]
            internal global::System.IntPtr m_fontType;

            [FieldOffset(328)]
            internal float m_maxWidth;

            [FieldOffset(332)]
            internal float m_kerning;

            [FieldOffset(336)]
            internal float m_leading;

            [FieldOffset(344)]
            internal global::System.IntPtr m_textColour;

            [FieldOffset(352)]
            internal global::System.IntPtr m_borderColour;

            [FieldOffset(360)]
            internal byte m_solidBorder;

            [FieldOffset(361)]
            internal byte m_glowBorder;

            [FieldOffset(368)]
            internal global::System.IntPtr m_glowDriver;

            [FieldOffset(376)]
            internal float m_glowSize;

            [FieldOffset(384)]
            internal global::System.IntPtr m_borderDriver;

            [FieldOffset(392)]
            internal float m_borderSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Text@fl@@QEAA@PEAVUiObject@1@AEBVUiBound@1@AEBMAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVFontType@1@AEBW4FontJustify@1@222@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr rectangle, float fontSize, global::System.IntPtr text, global::System.IntPtr fontType, global::FlounderSharp.FontJustify justify, float maxWidth, float kerning, float leading);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Text@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Text@fl@@QEAAXAEBVCommandBuffer@2@AEBVPipeline@2@@Z")]
            internal static extern void CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBorder@Text@fl@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetBorder(global::System.IntPtr instance, global::System.IntPtr driver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGlowing@Text@fl@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetGlowing(global::System.IntPtr instance, global::System.IntPtr driver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveBorder@Text@fl@@QEAAXXZ")]
            internal static extern void RemoveBorder(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateEdgeStart@Text@fl@@QEAAMXZ")]
            internal static extern float CalculateEdgeStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateAntialiasSize@Text@fl@@QEAAMXZ")]
            internal static extern float CalculateAntialiasSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetText@Text@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetText(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetText@Text@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetText(global::System.IntPtr instance, global::System.IntPtr newText);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxWidth@Text@fl@@QEBAMXZ")]
            internal static extern float GetMaxWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMaxWidth@Text@fl@@QEAAXAEBM@Z")]
            internal static extern void SetMaxWidth(global::System.IntPtr instance, float maxWidth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetKerning@Text@fl@@QEBAMXZ")]
            internal static extern float GetKerning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetKerning@Text@fl@@QEAAXAEBM@Z")]
            internal static extern void SetKerning(global::System.IntPtr instance, float kerning);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLeading@Text@fl@@QEBAMXZ")]
            internal static extern float GetLeading(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLeading@Text@fl@@QEAAXAEBM@Z")]
            internal static extern void SetLeading(global::System.IntPtr instance, float leading);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextColour@Text@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetTextColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTextColour@Text@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetTextColour(global::System.IntPtr instance, global::System.IntPtr textColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBorderColour@Text@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetBorderColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBorderColour@Text@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetBorderColour(global::System.IntPtr instance, global::System.IntPtr borderColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModel@Text@fl@@QEBAPEAVModel@2@XZ")]
            internal static extern global::System.IntPtr GetModel(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextJustify@Text@fl@@QEBA?AW4FontJustify@2@XZ")]
            internal static extern global::FlounderSharp.FontJustify GetTextJustify(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFontType@Text@fl@@QEBAPEAVFontType@2@XZ")]
            internal static extern global::System.IntPtr GetFontType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTexture@Text@fl@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetTexture(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTotalBorderSize@Text@fl@@QEAAMXZ")]
            internal static extern float GetTotalBorderSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlowSize@Text@fl@@QEAAMXZ")]
            internal static extern float GetGlowSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsLoaded@Text@fl@@QEAA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsLoaded(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Text __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Text(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Text __CreateInstance(global::FlounderSharp.Text.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Text(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Text.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Text.__Internal));
            global::FlounderSharp.Text.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Text(global::FlounderSharp.Text.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Text(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new text object.</summary>
        /// <param name="parent">The parent screen object.</param>
        /// <param name="kerning">The kerning (type character spacing multiplier) of this text.</param>
        /// <param name="rectangle">The rectangle that will represent the bounds of the ui object.</param>
        /// <param name="fontSize">The font size to be used in this text.</param>
        /// <param name="maxWidth">The maximum length of a line of this text.</param>
        /// <param name="text">The string text the object will be created with.</param>
        /// <param name="leading">The leading (vertical line spacing multiplier) of this text.</param>
        /// <param name="fontType">The font type to be used in this text.</param>
        /// <param name="justify">How the text will justify.</param>
        public Text(global::FlounderSharp.UiObject parent, global::FlounderSharp.UiBound rectangle, float fontSize, string text, global::FlounderSharp.FontType fontType, global::FlounderSharp.FontJustify justify, float maxWidth, float kerning, float leading)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Text.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(rectangle, null))
                throw new global::System.ArgumentNullException("rectangle", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rectangle.__Instance;
            var __allocator3 = new global::Std.Allocator<sbyte>();
            var __basicString3 = global::Std.BasicStringExtensions.BasicString(text, __allocator3);
            var __arg3 = __basicString3.__Instance;
            var __arg4 = ReferenceEquals(fontType, null) ? global::System.IntPtr.Zero : fontType.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, fontSize, __arg3, __arg4, justify, maxWidth, kerning, leading);
            __basicString3.Dispose(false);
            __allocator3.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.Text");
        }

        public Text(global::FlounderSharp.Text _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Text.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Text");
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public void CmdRender(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Pipeline pipeline)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Sets a new border driver, will disable glowing.</summary>
        /// <param name="driver">The new border driver.</param>
        public void SetBorder(global::FlounderSharp.IDriver driver)
        {
            var __arg0 = ReferenceEquals(driver, null) ? global::System.IntPtr.Zero : driver.__Instance;
            __Internal.SetBorder((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Sets a new glow driver, will disable solid borders.</summary>
        /// <param name="driver">The new glow driver.</param>
        public void SetGlowing(global::FlounderSharp.IDriver driver)
        {
            var __arg0 = ReferenceEquals(driver, null) ? global::System.IntPtr.Zero : driver.__Instance;
            __Internal.SetGlowing((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Disables both solid borders and glow borders.</summary>
        public void RemoveBorder()
        {
            __Internal.RemoveBorder((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets the distance field edge before antialias.</summary>
        public float CalculateEdgeStart()
        {
            var __ret = __Internal.CalculateEdgeStart((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Gets the distance field antialias distance.</summary>
        public float CalculateAntialiasSize()
        {
            var __ret = __Internal.CalculateAntialiasSize((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Gets the string of text represented.</summary>
        /// <param name="newText">The new text,</param>
        /// <remarks>Changed the current string in this text.</remarks>
        public string Text
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetText((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetText((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the maximum length of a line of this text.</summary>
        /// <param name="maxWidth">The new maximum length.</param>
        /// <remarks>Sets the maximum length of a line of this text.</remarks>
        public float MaxWidth
        {
            get
            {
                var __ret = __Internal.GetMaxWidth((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetMaxWidth((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the kerning (type character spacing multiplier) of this text.</summary>
        /// <param name="leading">The new kerning.</param>
        /// <remarks>Sets the kerning (type character spacing multiplier) of this text.</remarks>
        public float Kerning
        {
            get
            {
                var __ret = __Internal.GetKerning((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetKerning((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the leading (vertical line spacing multiplier) of this text.</summary>
        /// <param name="leading">The new leading.</param>
        /// <remarks>Sets the leading (vertical line spacing multiplier) of this text.</remarks>
        public float Leading
        {
            get
            {
                var __ret = __Internal.GetLeading((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetLeading((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the colour of the text.</summary>
        /// <param name="textColour">The new colour of the text.</param>
        /// <remarks>Sets the colour of the text.</remarks>
        public global::FlounderSharp.Colour TextColour
        {
            get
            {
                var __ret = __Internal.GetTextColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTextColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the border colour of the text. This is used with border and glow drivers.</summary>
        /// <param name="borderColour">The new border colour of the text.</param>
        /// <remarks>Sets the border colour of the text. This is used with border and glow drivers.</remarks>
        public global::FlounderSharp.Colour BorderColour
        {
            get
            {
                var __ret = __Internal.GetBorderColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetBorderColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the text model, which contains all the vertex data for the quads on which the text will be rendered.</summary>
        public global::FlounderSharp.Model Model
        {
            get
            {
                var __ret = __Internal.GetModel((__Instance + __PointerAdjustment));
                global::FlounderSharp.Model __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Model.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.NativeToManagedMap[__ret];
                else global::FlounderSharp.Model.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets how the text should justify.</summary>
        public global::FlounderSharp.FontJustify TextJustify
        {
            get
            {
                var __ret = __Internal.GetTextJustify((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the font used by this text.</summary>
        public global::FlounderSharp.FontType FontType
        {
            get
            {
                var __ret = __Internal.GetFontType((__Instance + __PointerAdjustment));
                global::FlounderSharp.FontType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.FontType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.FontType) global::FlounderSharp.FontType.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.FontType.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets font type texture for this text.</summary>
        public global::FlounderSharp.Texture Texture
        {
            get
            {
                var __ret = __Internal.GetTexture((__Instance + __PointerAdjustment));
                global::FlounderSharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
                else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the calculated border size.</summary>
        public float TotalBorderSize
        {
            get
            {
                var __ret = __Internal.GetTotalBorderSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the size of the glow.</summary>
        public float GlowSize
        {
            get
            {
                var __ret = __Internal.GetGlowSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the text has been loaded to OpenGL.</summary>
        public bool IsLoaded
        {
            get
            {
                var __ret = __Internal.IsLoaded((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Text()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Text) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Text) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class RendererFonts : global::FlounderSharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::System.IntPtr m_pipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererFonts@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererFonts@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.RendererFonts __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererFonts(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RendererFonts __CreateInstance(global::FlounderSharp.RendererFonts.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererFonts(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RendererFonts.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererFonts.__Internal));
            global::FlounderSharp.RendererFonts.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererFonts(global::FlounderSharp.RendererFonts.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererFonts(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public RendererFonts(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererFonts.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererFonts");
        }

        public RendererFonts(global::FlounderSharp.RendererFonts _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererFonts.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererFonts");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static implicit operator global::FlounderSharp.RendererFonts(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.RendererFonts(graphicsStage);
        }

        #region Virtual table interop

        // ~RendererFonts()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererFonts) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererFonts) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::FlounderSharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::FlounderSharp.Vector4.__CreateInstance(clipPlane);
            global::FlounderSharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[camera];
            else __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(camera, skipVTables: true);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A object the represents a texture in a GUI.</summary>
    public unsafe partial class Gui : global::FlounderSharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 280)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [FieldOffset(224)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(232)]
            internal global::System.IntPtr m_uniformObject;

            [FieldOffset(240)]
            internal global::System.IntPtr m_model;

            [FieldOffset(248)]
            internal global::System.IntPtr m_texture;

            [FieldOffset(256)]
            internal int m_selectedRow;

            [FieldOffset(264)]
            internal global::System.IntPtr m_atlasOffset;

            [FieldOffset(272)]
            internal global::System.IntPtr m_colourOffset;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Gui@fl@@QEAA@PEAVUiObject@1@AEBVUiBound@1@PEAVTexture@1@AEBH@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr rectangle, global::System.IntPtr texture, int selectedRow);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Gui@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Gui@fl@@QEAAXAEBVCommandBuffer@2@AEBVPipeline@2@@Z")]
            internal static extern void CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTexture@Gui@fl@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetTexture(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTexture@Gui@fl@@QEAAXPEAVTexture@2@@Z")]
            internal static extern void SetTexture(global::System.IntPtr instance, global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSelectedRow@Gui@fl@@QEBAHXZ")]
            internal static extern int GetSelectedRow(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSelectedRow@Gui@fl@@QEAAXAEBH@Z")]
            internal static extern void SetSelectedRow(global::System.IntPtr instance, int selectedRow);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColourOffset@Gui@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetColourOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColourOffset@Gui@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetColourOffset(global::System.IntPtr instance, global::System.IntPtr colourOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAtlasOffset@Gui@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetAtlasOffset(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Gui __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Gui(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Gui __CreateInstance(global::FlounderSharp.Gui.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Gui(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Gui.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Gui.__Internal));
            global::FlounderSharp.Gui.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Gui(global::FlounderSharp.Gui.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Gui(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new GUI object.</summary>
        /// <param name="rectangle">The rectangle that will represent the bounds of the ui object.</param>
        /// <param name="texture">The objects texture.</param>
        /// <param name="selectedRow">The default row of the texture to render from.</param>
        public Gui(global::FlounderSharp.UiObject parent, global::FlounderSharp.UiBound rectangle, global::FlounderSharp.Texture texture, int selectedRow)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Gui.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(rectangle, null))
                throw new global::System.ArgumentNullException("rectangle", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rectangle.__Instance;
            var __arg2 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, selectedRow);
            SetupVTables(GetType().FullName == "FlounderSharp.Gui");
        }

        public Gui(global::FlounderSharp.Gui _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Gui.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Gui");
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public void CmdRender(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Pipeline pipeline)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public global::FlounderSharp.Texture Texture
        {
            get
            {
                var __ret = __Internal.GetTexture((__Instance + __PointerAdjustment));
                global::FlounderSharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
                else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetTexture((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public int SelectedRow
        {
            get
            {
                var __ret = __Internal.GetSelectedRow((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSelectedRow((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Colour ColourOffset
        {
            get
            {
                var __ret = __Internal.GetColourOffset((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColourOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector2 AtlasOffset
        {
            get
            {
                var __ret = __Internal.GetAtlasOffset((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Gui()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Gui) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Gui) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class RendererGuis : global::FlounderSharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::System.IntPtr m_pipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererGuis@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererGuis@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.RendererGuis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererGuis(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RendererGuis __CreateInstance(global::FlounderSharp.RendererGuis.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererGuis(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RendererGuis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererGuis.__Internal));
            global::FlounderSharp.RendererGuis.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererGuis(global::FlounderSharp.RendererGuis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererGuis(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public RendererGuis(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererGuis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererGuis");
        }

        public RendererGuis(global::FlounderSharp.RendererGuis _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererGuis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererGuis");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static implicit operator global::FlounderSharp.RendererGuis(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.RendererGuis(graphicsStage);
        }

        #region Virtual table interop

        // ~RendererGuis()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererGuis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererGuis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::FlounderSharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::FlounderSharp.Vector4.__CreateInstance(clipPlane);
            global::FlounderSharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[camera];
            else __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(camera, skipVTables: true);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A helper for C++ files.</summary>
    public unsafe partial class FileSystem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileSystem@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FileExists@FileSystem@fl@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool FileExists(global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeleteFile@FileSystem@fl@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeleteFile(global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateFile@FileSystem@fl@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N@Z")]
            internal static extern void CreateFile(global::System.IntPtr filepath, bool createFolders);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ClearFile@FileSystem@fl@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void ClearFile(global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateFolder@FileSystem@fl@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void CreateFolder(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ReadTextFile@FileSystem@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void ReadTextFile(global::System.IntPtr @return, global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WriteTextFile@FileSystem@fl@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void WriteTextFile(global::System.IntPtr filepath, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FixPaths@FileSystem@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FixPaths(global::System.IntPtr @return, global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindExt@FileSystem@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FindExt(global::System.IntPtr @return, global::System.IntPtr filepath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorkingDirectory@FileSystem@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetWorkingDirectory(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FileSystem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.FileSystem>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.FileSystem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FileSystem(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FileSystem __CreateInstance(global::FlounderSharp.FileSystem.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FileSystem(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FileSystem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileSystem.__Internal));
            *(global::FlounderSharp.FileSystem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FileSystem(global::FlounderSharp.FileSystem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileSystem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FileSystem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FileSystem(global::FlounderSharp.FileSystem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FileSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.FileSystem.__Internal*) __Instance) = *((global::FlounderSharp.FileSystem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.FileSystem __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if a file exists.</summary>
        /// <param name="filepath">The filepath.</param>
        public static bool FileExists(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.FileExists(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Deletes a file.</summary>
        /// <param name="filepath">The filepath.</param>
        public static void DeleteFile(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeleteFile(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Creates a file, and the folder path.</summary>
        /// <param name="filepath">The filepath.</param>
        /// <param name="createFolders">If folders should also be created.</param>
        public static void CreateFile(string filepath, bool createFolders)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.CreateFile(__arg0, createFolders);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Clears the contents from a file.</summary>
        /// <param name="filepath">The filepath.</param>
        public static void ClearFile(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ClearFile(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Creates a directory.</summary>
        /// <param name="path">The directory to create.</param>
        public static void CreateFolder(string path)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.CreateFolder(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Reads a text file into a string.</summary>
        /// <param name="filepath">The filepath.</param>
        public static string ReadTextFile(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ReadTextFile(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>Writes to a text file from a string.</summary>
        /// <param name="filepath">The filepath.</param>
        /// <param name="data">The text data.</param>
        public static void WriteTextFile(string filepath, string data)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(data, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.WriteTextFile(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Removes backslashes from directories.</summary>
        public static string FixPaths(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FixPaths(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>Gets the file extension for the file.</summary>
        public static string FindExt(string filepath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filepath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FindExt(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        /// <summary>Gets the current working directory.</summary>
        public static string WorkingDirectory
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetWorkingDirectory(new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A helper for C++ arrays.</summary>
    public unsafe partial class SquareArray : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SquareArray@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FloatArray@SquareArray@fl@@SAPEAPEAMAEBH0@Z")]
            internal static extern float** FloatArray(int size1, int size2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Vector3Array@SquareArray@fl@@SAPEAPEAVVector3@2@AEBH0@Z")]
            internal static extern global::System.IntPtr Vector3Array(int size1, int size2);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SquareArray> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SquareArray>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.SquareArray __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SquareArray(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SquareArray __CreateInstance(global::FlounderSharp.SquareArray.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SquareArray(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SquareArray.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SquareArray.__Internal));
            *(global::FlounderSharp.SquareArray.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SquareArray(global::FlounderSharp.SquareArray.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SquareArray(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SquareArray()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SquareArray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SquareArray(global::FlounderSharp.SquareArray _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SquareArray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.SquareArray.__Internal*) __Instance) = *((global::FlounderSharp.SquareArray.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.SquareArray __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Creates a new rectangular float array.</summary>
        /// <param name="size1">The first size.</param>
        /// <param name="size2">The seconds size.</param>
        public static float** FloatArray(int size1, int size2)
        {
            var __ret = __Internal.FloatArray(size1, size2);
            return __ret;
        }

        /// <summary>Creates a new rectangular Vector3 array.</summary>
        /// <param name="size1">The first size.</param>
        /// <param name="size2">The seconds size.</param>
        public static global::FlounderSharp.Vector3 Vector3Array(int size1, int size2)
        {
            var __ret = __Internal.Vector3Array(size1, size2);
            global::FlounderSharp.Vector3 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
            return __result0;
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Axis composed of two buttons.</summary>
    public unsafe partial class AxisButton : global::FlounderSharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::System.IntPtr m_negative;

            [FieldOffset(16)]
            internal global::System.IntPtr m_positive;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisButton@fl@@QEAA@PEAVIButton@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr negative, global::System.IntPtr positive);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisButton@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.AxisButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AxisButton(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.AxisButton __CreateInstance(global::FlounderSharp.AxisButton.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AxisButton(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.AxisButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AxisButton.__Internal));
            global::FlounderSharp.AxisButton.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisButton(global::FlounderSharp.AxisButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisButton(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new axis button.</summary>
        /// <param name="negative">When this button is down, the axis is negative.</param>
        /// <param name="positive">When this button is down, the axis is positive.</param>
        public AxisButton(global::FlounderSharp.IButton negative, global::FlounderSharp.IButton positive)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AxisButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(negative, null) ? global::System.IntPtr.Zero : negative.__Instance;
            var __arg1 = ReferenceEquals(positive, null) ? global::System.IntPtr.Zero : positive.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.AxisButton");
        }

        public AxisButton(global::FlounderSharp.AxisButton _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AxisButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.AxisButton");
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetAmountDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~AxisButton()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.AxisButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float GetAmount() const override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.AxisButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Axis composed of multiple other axes.</summary>
    public unsafe partial class AxisCompound : global::FlounderSharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_IAxis___N_std_S_allocator__S0_ m_axes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisCompound@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.AxisCompound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AxisCompound(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.AxisCompound __CreateInstance(global::FlounderSharp.AxisCompound.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.AxisCompound(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.AxisCompound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AxisCompound.__Internal));
            global::FlounderSharp.AxisCompound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisCompound(global::FlounderSharp.AxisCompound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisCompound(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public AxisCompound(global::FlounderSharp.AxisCompound _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.AxisCompound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.AxisCompound");
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetAmountDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~AxisCompound()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.AxisCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float GetAmount() const override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.AxisCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Handles multiple buttons at once.</summary>
    public unsafe partial class ButtonCompound : global::FlounderSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_IButton___N_std_S_allocator__S0_ m_buttons;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonCompound@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.ButtonCompound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonCompound(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ButtonCompound __CreateInstance(global::FlounderSharp.ButtonCompound.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonCompound(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ButtonCompound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonCompound.__Internal));
            global::FlounderSharp.ButtonCompound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonCompound(global::FlounderSharp.ButtonCompound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonCompound(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ButtonCompound(global::FlounderSharp.ButtonCompound _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonCompound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ButtonCompound");
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___WasDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___IsDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~ButtonCompound()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool IsDown() const override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    [Flags]
    public enum Mod
    {
        ModShift = 1,
        ModControl = 2,
        ModAlt = 4,
        ModSuper = 8,
        ModCapsLock = 16,
        ModNumLock = 32
    }

    public enum Key
    {
        KeyUnknown = -1,
        KeySpace = 32,
        KeyApostrophe = 39,
        KeyComma = 44,
        KeyMinus = 45,
        KeyPeriod = 46,
        KeySlash = 47,
        Key0 = 48,
        Key1 = 49,
        Key2 = 50,
        Key3 = 51,
        Key4 = 52,
        Key5 = 53,
        Key6 = 54,
        Key7 = 55,
        Key8 = 56,
        Key9 = 57,
        KeySemicolon = 59,
        KeyEqual = 61,
        KeyA = 65,
        KeyB = 66,
        KeyC = 67,
        KeyD = 68,
        KeyE = 69,
        KeyF = 70,
        KeyG = 71,
        KeyH = 72,
        KeyI = 73,
        KeyJ = 74,
        KeyK = 75,
        KeyL = 76,
        KeyM = 77,
        KeyN = 78,
        KeyO = 79,
        KeyP = 80,
        KeyQ = 81,
        KeyR = 82,
        KeyS = 83,
        KeyT = 84,
        KeyU = 85,
        KeyV = 86,
        KeyW = 87,
        KeyX = 88,
        KeyY = 89,
        KeyZ = 90,
        KeyLeftBracket = 91,
        KeyBackslash = 92,
        KeyRightBracket = 93,
        KeyGraveAccent = 96,
        KeyWorld1 = 161,
        KeyWorld2 = 162,
        KeyEscape = 256,
        KeyEnter = 257,
        KeyTab = 258,
        KeyBackspace = 259,
        KeyInsert = 260,
        KeyDelete = 261,
        KeyRight = 262,
        KeyLeft = 263,
        KeyDown = 264,
        KeyUp = 265,
        KeyPageUp = 266,
        KeyPageDown = 267,
        KeyHome = 268,
        KeyEnd = 269,
        KeyCapsLock = 280,
        KeyScrollLock = 281,
        KeyNumLock = 282,
        KeyPrintScreen = 283,
        KeyPause = 284,
        KeyF1 = 290,
        KeyF2 = 291,
        KeyF3 = 292,
        KeyF4 = 293,
        KeyF5 = 294,
        KeyF6 = 295,
        KeyF7 = 296,
        KeyF8 = 297,
        KeyF9 = 298,
        KeyF10 = 299,
        KeyF11 = 300,
        KeyF12 = 301,
        KeyF13 = 302,
        KeyF14 = 303,
        KeyF15 = 304,
        KeyF16 = 305,
        KeyF17 = 306,
        KeyF18 = 307,
        KeyF19 = 308,
        KeyF20 = 309,
        KeyF21 = 310,
        KeyF22 = 311,
        KeyF23 = 312,
        KeyF24 = 313,
        KeyF25 = 314,
        KeyKp0 = 320,
        KeyKp1 = 321,
        KeyKp2 = 322,
        KeyKp3 = 323,
        KeyKp4 = 324,
        KeyKp5 = 325,
        KeyKp6 = 326,
        KeyKp7 = 327,
        KeyKp8 = 328,
        KeyKp9 = 329,
        KeyKpDecimal = 330,
        KeyKpDivide = 331,
        KeyKpMultiply = 332,
        KeyKpSubtract = 333,
        KeyKpAdd = 334,
        KeyKpEnter = 335,
        KeyKpEqual = 336,
        KeyLeftShift = 340,
        KeyLeftControl = 341,
        KeyLeftAlt = 342,
        KeyLeftSuper = 343,
        KeyRightShift = 344,
        KeyRightControl = 345,
        KeyRightAlt = 346,
        KeyRightSuper = 347,
        KeyMenu = 348,
        KeyLast = 348
    }

    /// <summary>A module used for the creation, updating and destruction of the keyboard keys.</summary>
    public unsafe partial class Keyboard : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_keyboardKeys;

            [FieldOffset(16)]
            internal int m_keyboardChar;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyboard@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyboard@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Keyboard@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetKey@Keyboard@fl@@QEBA_NAEBW4Key@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetKey(global::System.IntPtr instance, global::FlounderSharp.Key key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChar@Keyboard@fl@@QEBAHXZ")]
            internal static extern int GetChar(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Keyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Keyboard(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Keyboard __CreateInstance(global::FlounderSharp.Keyboard.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Keyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Keyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Keyboard.__Internal));
            global::FlounderSharp.Keyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Keyboard(global::FlounderSharp.Keyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Keyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new keyboard module.</summary>
        public Keyboard()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Keyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Keyboard");
        }

        public Keyboard(global::FlounderSharp.Keyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Keyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Keyboard");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets whether or not a particular key is currently pressed. GLFW Actions: GLFW_PRESS, GLFW_RELEASE, GLFW_REPEAT</summary>
        /// <param name="key">The key to test.</param>
        public bool GetKey(global::FlounderSharp.Key key)
        {
            var __ret = __Internal.GetKey((__Instance + __PointerAdjustment), key);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Keyboard Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Keyboard __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Keyboard.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Keyboard) global::FlounderSharp.Keyboard.NativeToManagedMap[__ret];
            else global::FlounderSharp.Keyboard.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Keyboard) global::FlounderSharp.Keyboard.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the current user input, ASCII Dec value.</summary>
        public int Char
        {
            get
            {
                var __ret = __Internal.GetChar((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Keyboard() override
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Keyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Keyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class Keyboard
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackKey@fl@@YAXPEAVGLFWwindow@@HHHH@Z")]
            internal static extern void CallbackKey(global::System.IntPtr window, int key, int scancode, int action, int mods);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackChar@fl@@YAXPEAVGLFWwindow@@I@Z")]
            internal static extern void CallbackChar(global::System.IntPtr window, uint codepoint);
        }

        public static void CallbackKey(global::GLFWwindow window, int key, int scancode, int action, int mods)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackKey(__arg0, key, scancode, action, mods);
        }

        public static void CallbackChar(global::GLFWwindow window, uint codepoint)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackChar(__arg0, codepoint);
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Keys from a keyboard.</summary>
    public unsafe partial class ButtonKeyboard : global::FlounderSharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_fl_E_Key___N_std_S_allocator__S0_ m_keys;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonKeyboard@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.ButtonKeyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonKeyboard(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ButtonKeyboard __CreateInstance(global::FlounderSharp.ButtonKeyboard.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ButtonKeyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ButtonKeyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonKeyboard.__Internal));
            global::FlounderSharp.ButtonKeyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonKeyboard(global::FlounderSharp.ButtonKeyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonKeyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ButtonKeyboard(global::FlounderSharp.ButtonKeyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ButtonKeyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ButtonKeyboard");
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___WasDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool IsDown
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___IsDownDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~ButtonKeyboard()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // bool IsDown() const override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _IsDownDelegateInstance;

        private static bool _IsDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsDown;
            return __ret;
        }

        // bool WasDown() override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ButtonKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _IsDownDelegateInstance += _IsDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_IsDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a fog in the world.</summary>
    public unsafe partial class Fog : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_colour;

            [FieldOffset(8)]
            internal float m_density;

            [FieldOffset(12)]
            internal float m_gradient;

            [FieldOffset(16)]
            internal float m_lowerLimit;

            [FieldOffset(20)]
            internal float m_upperLimit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Fog@fl@@QEAA@PEAVColour@1@AEBM111@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr colour, float density, float gradient, float lowerLimit, float upperLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Fog@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Fog@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Fog@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColour@Fog@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColour@Fog@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetColour(global::System.IntPtr instance, global::System.IntPtr colour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDensity@Fog@fl@@QEBAMXZ")]
            internal static extern float GetDensity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDensity@Fog@fl@@QEAAXAEBM@Z")]
            internal static extern void SetDensity(global::System.IntPtr instance, float density);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGradient@Fog@fl@@QEBAMXZ")]
            internal static extern float GetGradient(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGradient@Fog@fl@@QEAAXAEBM@Z")]
            internal static extern void SetGradient(global::System.IntPtr instance, float gradient);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLowerLimit@Fog@fl@@QEBAMXZ")]
            internal static extern float GetLowerLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLowerLimit@Fog@fl@@QEAAXAEBM@Z")]
            internal static extern void SetLowerLimit(global::System.IntPtr instance, float lowerLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUpperLimit@Fog@fl@@QEBAMXZ")]
            internal static extern float GetUpperLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUpperLimit@Fog@fl@@QEAAXAEBM@Z")]
            internal static extern void SetUpperLimit(global::System.IntPtr instance, float upperLimit);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Fog> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Fog>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Fog __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Fog(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Fog __CreateInstance(global::FlounderSharp.Fog.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Fog(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Fog.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Fog.__Internal));
            *(global::FlounderSharp.Fog.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Fog(global::FlounderSharp.Fog.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Fog(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new fog.</summary>
        /// <param name="colour">The colour of the fog.</param>
        /// <param name="density">How dense the fog will be.</param>
        /// <param name="gradient">The gradient of the fog.</param>
        /// <param name="lowerLimit">At what height will the skybox fog begin to appear.</param>
        /// <param name="upperLimit">At what height will there be skybox no fog.</param>
        public Fog(global::FlounderSharp.Colour colour, float density, float gradient, float lowerLimit, float upperLimit)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Fog.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(colour, null) ? global::System.IntPtr.Zero : colour.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, density, gradient, lowerLimit, upperLimit);
        }

        public Fog(global::FlounderSharp.Fog _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Fog.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Fog.__Internal*) __Instance) = *((global::FlounderSharp.Fog.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Fog __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Saves this vector into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public global::FlounderSharp.Colour Colour
        {
            get
            {
                var __ret = __Internal.GetColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Density
        {
            get
            {
                var __ret = __Internal.GetDensity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetDensity((__Instance + __PointerAdjustment), value);
            }
        }

        public float Gradient
        {
            get
            {
                var __ret = __Internal.GetGradient((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetGradient((__Instance + __PointerAdjustment), value);
            }
        }

        public float LowerLimit
        {
            get
            {
                var __ret = __Internal.GetLowerLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetLowerLimit((__Instance + __PointerAdjustment), value);
            }
        }

        public float UpperLimit
        {
            get
            {
                var __ret = __Internal.GetUpperLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetUpperLimit((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a point light, contains a colour, position and attenuation.</summary>
    public unsafe partial class Light : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_colour;

            [FieldOffset(64)]
            internal float m_radius;

            [FieldOffset(72)]
            internal global::System.IntPtr m_offset;

            [FieldOffset(80)]
            internal global::System.IntPtr m_position;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Light@fl@@QEAA@AEBVColour@1@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr colour, float radius, global::System.IntPtr offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Light@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Set@Light@fl@@QEAAPEAV12@AEBVColour@2@AEBVVector3@2@@Z")]
            internal static extern global::System.IntPtr Set(global::System.IntPtr instance, global::System.IntPtr colour, global::System.IntPtr offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Set@Light@fl@@QEAAPEAV12@AEBVColour@2@AEBMAEBVVector3@2@@Z")]
            internal static extern global::System.IntPtr Set(global::System.IntPtr instance, global::System.IntPtr colour, float radius, global::System.IntPtr offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Set@Light@fl@@QEAAPEAV12@AEBV12@@Z")]
            internal static extern global::System.IntPtr Set(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColour@Light@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColour@Light@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetColour(global::System.IntPtr instance, global::System.IntPtr colour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@Light@fl@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@Light@fl@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffset@Light@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetOffset@Light@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetOffset(global::System.IntPtr instance, global::System.IntPtr offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Light@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Light@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.Light __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Light(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Light __CreateInstance(global::FlounderSharp.Light.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Light(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Light.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Light.__Internal));
            global::FlounderSharp.Light.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Light(global::FlounderSharp.Light.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Light(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new point light.</summary>
        /// <param name="colour">The colour of the light.</param>
        /// <param name="radius">How far the light will have influence (-1 sets this to a directional light).</param>
        /// <param name="offset">The parent offset of the light.</param>
        public Light(global::FlounderSharp.Colour colour, float radius, global::FlounderSharp.Vector3 offset)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Light.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(colour, null))
                throw new global::System.ArgumentNullException("colour", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = colour.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = offset.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, radius, __arg2);
            SetupVTables(GetType().FullName == "FlounderSharp.Light");
        }

        /// <summary>Creates a new point light from a source object.</summary>
        /// <param name="source">The source light object.</param>
        public Light(global::FlounderSharp.Light source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Light.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Light");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Sets values in the light.</summary>
        /// <param name="colour">The colour of the light.</param>
        /// <param name="offset">The parent offset of the light.</param>
        public global::FlounderSharp.Light Set(global::FlounderSharp.Colour colour, global::FlounderSharp.Vector3 offset)
        {
            if (ReferenceEquals(colour, null))
                throw new global::System.ArgumentNullException("colour", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = colour.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = offset.__Instance;
            var __ret = __Internal.Set((__Instance + __PointerAdjustment), __arg0, __arg1);
            global::FlounderSharp.Light __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Light.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Light) global::FlounderSharp.Light.NativeToManagedMap[__ret];
            else global::FlounderSharp.Light.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Light) global::FlounderSharp.Light.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets values in the light.</summary>
        /// <param name="colour">The colour of the light.</param>
        /// <param name="radius">How far the light will have influence (-1 sets this to a directional light).</param>
        /// <param name="offset">The parent offset of the light.</param>
        public global::FlounderSharp.Light Set(global::FlounderSharp.Colour colour, float radius, global::FlounderSharp.Vector3 offset)
        {
            if (ReferenceEquals(colour, null))
                throw new global::System.ArgumentNullException("colour", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = colour.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = offset.__Instance;
            var __ret = __Internal.Set((__Instance + __PointerAdjustment), __arg0, radius, __arg2);
            global::FlounderSharp.Light __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Light.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Light) global::FlounderSharp.Light.NativeToManagedMap[__ret];
            else global::FlounderSharp.Light.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Light) global::FlounderSharp.Light.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets values in the light.</summary>
        /// <param name="source">The source light object.</param>
        public global::FlounderSharp.Light Set(global::FlounderSharp.Light source)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __ret = __Internal.Set((__Instance + __PointerAdjustment), __arg0);
            global::FlounderSharp.Light __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Light.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Light) global::FlounderSharp.Light.NativeToManagedMap[__ret];
            else global::FlounderSharp.Light.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Light) global::FlounderSharp.Light.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.Colour Colour
        {
            get
            {
                var __ret = __Internal.GetColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetRadius((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Vector3 Offset
        {
            get
            {
                var __ret = __Internal.GetOffset((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~Light()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "Light"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a material pipeline.</summary>
    public unsafe partial class PipelineMaterial : global::FlounderSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_pipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineMaterial@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipeline@PipelineMaterial@fl@@QEBAPEAVPipeline@2@XZ")]
            internal static extern global::System.IntPtr GetPipeline(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.PipelineMaterial __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PipelineMaterial(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.PipelineMaterial __CreateInstance(global::FlounderSharp.PipelineMaterial.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PipelineMaterial(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.PipelineMaterial.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PipelineMaterial.__Internal));
            global::FlounderSharp.PipelineMaterial.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineMaterial(global::FlounderSharp.PipelineMaterial.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineMaterial(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public PipelineMaterial(global::FlounderSharp.PipelineMaterial _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PipelineMaterial.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.PipelineMaterial");
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public global::FlounderSharp.Pipeline Pipeline
        {
            get
            {
                var __ret = __Internal.GetPipeline((__Instance + __PointerAdjustment));
                global::FlounderSharp.Pipeline __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Pipeline.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Pipeline) global::FlounderSharp.Pipeline.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Pipeline.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~PipelineMaterial()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.PipelineMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.PipelineMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a material shader.</summary>
    public unsafe abstract partial class IMaterial : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IMaterial@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IMaterial@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IMaterial@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.IMaterial __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IMaterialInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IMaterial __CreateInstance(global::FlounderSharp.IMaterial.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IMaterialInternal(native, skipVTables);
        }

        protected IMaterial(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IMaterial()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IMaterial.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IMaterial");
        }

        protected IMaterial(global::FlounderSharp.IMaterial _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IMaterial.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IMaterial");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Component __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IMaterial.__Internal*) __Instance)->vfptr_Component = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override abstract void Update();

        public override abstract void Load(global::FlounderSharp.LoadedValue value);

        public override abstract void Write(global::FlounderSharp.LoadedValue destination);

        public abstract void PushUniforms(global::FlounderSharp.UniformHandler uniformObject);

        public abstract void PushDescriptors(global::FlounderSharp.DescriptorsHandler descriptorSet);

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public abstract global::FlounderSharp.PipelineMaterial Material
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IMaterial() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *destination) override = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (destination == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(destination))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[destination];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(destination);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "IMaterial"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void PushUniforms(UniformHandler *uniformObject) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler *descriptorSet) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        // PipelineMaterial *GetMaterial() const = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetMaterialDelegateInstance;

        private static global::System.IntPtr _GetMaterialDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Material;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
                _GetMaterialDelegateInstance += _GetMaterialDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMaterialDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IMaterialInternal : global::FlounderSharp.IMaterial, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IMaterial.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IMaterial.__Internal));
            *(global::FlounderSharp.IMaterial.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IMaterialInternal(global::FlounderSharp.IMaterial.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IMaterialInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::FlounderSharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushUniformsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(uniformObject, null) ? global::System.IntPtr.Zero : uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::FlounderSharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___PushDescriptorsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override global::FlounderSharp.PipelineMaterial Material
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetMaterialDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetMaterialDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.PipelineMaterial __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.PipelineMaterial.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret];
                else global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents the default material shader.</summary>
    public unsafe partial class MaterialDefault : global::FlounderSharp.IMaterial, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_baseColor;

            [FieldOffset(64)]
            internal global::System.IntPtr m_diffuseTexture;

            [FieldOffset(72)]
            internal float m_metallic;

            [FieldOffset(76)]
            internal float m_roughness;

            [FieldOffset(80)]
            internal global::System.IntPtr m_materialTexture;

            [FieldOffset(88)]
            internal global::System.IntPtr m_normalTexture;

            [FieldOffset(96)]
            internal byte m_castsShadows;

            [FieldOffset(97)]
            internal byte m_ignoreLighting;

            [FieldOffset(98)]
            internal byte m_ignoreFog;

            [FieldOffset(104)]
            internal global::System.IntPtr m_material;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialDefault@fl@@QEAA@AEBVColour@1@PEAVTexture@1@AEBM211AEB_N33@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr baseColor, global::System.IntPtr diffuseTexture, float metallic, float roughness, global::System.IntPtr materialTexture, global::System.IntPtr normalTexture, bool castsShadows, bool ignoreLighting, bool ignoreFog);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialDefault@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TrySetDiffuseTexture@MaterialDefault@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void TrySetDiffuseTexture(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TrySetMaterialTexture@MaterialDefault@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void TrySetMaterialTexture(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TrySetNormalTexture@MaterialDefault@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void TrySetNormalTexture(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIgnoreLighting@MaterialDefault@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetIgnoreLighting(global::System.IntPtr instance, bool ignoreLighting);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIgnoreFog@MaterialDefault@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetIgnoreFog(global::System.IntPtr instance, bool ignoreFog);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBaseColor@MaterialDefault@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetBaseColor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBaseColor@MaterialDefault@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetBaseColor(global::System.IntPtr instance, global::System.IntPtr baseColor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDiffuseTexture@MaterialDefault@fl@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetDiffuseTexture(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDiffuseTexture@MaterialDefault@fl@@QEAAXPEAVTexture@2@@Z")]
            internal static extern void SetDiffuseTexture(global::System.IntPtr instance, global::System.IntPtr diffuseTexture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMetallic@MaterialDefault@fl@@QEBAMXZ")]
            internal static extern float GetMetallic(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMetallic@MaterialDefault@fl@@QEAAXAEBM@Z")]
            internal static extern void SetMetallic(global::System.IntPtr instance, float metallic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRoughness@MaterialDefault@fl@@QEBAMXZ")]
            internal static extern float GetRoughness(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRoughness@MaterialDefault@fl@@QEAAXAEBM@Z")]
            internal static extern void SetRoughness(global::System.IntPtr instance, float roughness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaterialTexture@MaterialDefault@fl@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetMaterialTexture(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMaterialTexture@MaterialDefault@fl@@QEAAXPEAVTexture@2@@Z")]
            internal static extern void SetMaterialTexture(global::System.IntPtr instance, global::System.IntPtr materialTexture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormalTexture@MaterialDefault@fl@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetNormalTexture(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormalTexture@MaterialDefault@fl@@QEAAXPEAVTexture@2@@Z")]
            internal static extern void SetNormalTexture(global::System.IntPtr instance, global::System.IntPtr normalTexture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CastsShadows@MaterialDefault@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CastsShadows(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCastsShadows@MaterialDefault@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetCastsShadows(global::System.IntPtr instance, bool castsShadows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIgnoringLighting@MaterialDefault@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsIgnoringLighting(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIgnoringFog@MaterialDefault@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsIgnoringFog(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.MaterialDefault __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialDefault(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MaterialDefault __CreateInstance(global::FlounderSharp.MaterialDefault.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialDefault(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MaterialDefault.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialDefault.__Internal));
            global::FlounderSharp.MaterialDefault.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MaterialDefault(global::FlounderSharp.MaterialDefault.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialDefault(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MaterialDefault(global::FlounderSharp.Colour baseColor, global::FlounderSharp.Texture diffuseTexture, float metallic, float roughness, global::FlounderSharp.Texture materialTexture, global::FlounderSharp.Texture normalTexture, bool castsShadows, bool ignoreLighting, bool ignoreFog)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialDefault.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(baseColor, null))
                throw new global::System.ArgumentNullException("baseColor", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = baseColor.__Instance;
            var __arg1 = ReferenceEquals(diffuseTexture, null) ? global::System.IntPtr.Zero : diffuseTexture.__Instance;
            var __arg4 = ReferenceEquals(materialTexture, null) ? global::System.IntPtr.Zero : materialTexture.__Instance;
            var __arg5 = ReferenceEquals(normalTexture, null) ? global::System.IntPtr.Zero : normalTexture.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, metallic, roughness, __arg4, __arg5, castsShadows, ignoreLighting, ignoreFog);
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialDefault");
        }

        public MaterialDefault(global::FlounderSharp.MaterialDefault _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialDefault.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialDefault");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::FlounderSharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushUniformsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(uniformObject, null) ? global::System.IntPtr.Zero : uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::FlounderSharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___PushDescriptorsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public void TrySetDiffuseTexture(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.TrySetDiffuseTexture((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void TrySetMaterialTexture(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.TrySetMaterialTexture((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void TrySetNormalTexture(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.TrySetNormalTexture((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void SetIgnoreLighting(bool ignoreLighting)
        {
            __Internal.SetIgnoreLighting((__Instance + __PointerAdjustment), ignoreLighting);
        }

        public void SetIgnoreFog(bool ignoreFog)
        {
            __Internal.SetIgnoreFog((__Instance + __PointerAdjustment), ignoreFog);
        }

        public global::FlounderSharp.Colour BaseColor
        {
            get
            {
                var __ret = __Internal.GetBaseColor((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetBaseColor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Texture DiffuseTexture
        {
            get
            {
                var __ret = __Internal.GetDiffuseTexture((__Instance + __PointerAdjustment));
                global::FlounderSharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
                else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetDiffuseTexture((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Metallic
        {
            get
            {
                var __ret = __Internal.GetMetallic((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetMetallic((__Instance + __PointerAdjustment), value);
            }
        }

        public float Roughness
        {
            get
            {
                var __ret = __Internal.GetRoughness((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetRoughness((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Texture MaterialTexture
        {
            get
            {
                var __ret = __Internal.GetMaterialTexture((__Instance + __PointerAdjustment));
                global::FlounderSharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
                else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetMaterialTexture((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Texture NormalTexture
        {
            get
            {
                var __ret = __Internal.GetNormalTexture((__Instance + __PointerAdjustment));
                global::FlounderSharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
                else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetNormalTexture((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool CastsShadows
        {
            get
            {
                var __ret = __Internal.CastsShadows((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCastsShadows((__Instance + __PointerAdjustment), value);
            }
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::FlounderSharp.PipelineMaterial Material
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetMaterialDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetMaterialDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.PipelineMaterial __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.PipelineMaterial.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret];
                else global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.__CreateInstance(__ret);
                return __result0;
            }
        }

        public bool IsIgnoringLighting
        {
            get
            {
                var __ret = __Internal.IsIgnoringLighting((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsIgnoringFog
        {
            get
            {
                var __ret = __Internal.IsIgnoringFog((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~MaterialDefault()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *destination) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (destination == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(destination))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[destination];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(destination);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "MaterialDefault"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void PushUniforms(UniformHandler *uniformObject) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler *descriptorSet) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        // PipelineMaterial *GetMaterial() const override { return m_material; }
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetMaterialDelegateInstance;

        private static global::System.IntPtr _GetMaterialDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Material;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
                _GetMaterialDelegateInstance += _GetMaterialDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMaterialDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 3-tuple vector.</summary>
    public unsafe partial class Constraint3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 3)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Constraint3._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Constraint3@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Constraint3@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Constraint3@fl@@QEAA@AEB_N00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool x, bool y, bool z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Constraint3@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Constraint3@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Constraint3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Constraint3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Constraint3@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Constraint3@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Constraint3@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetX(global::System.IntPtr instance, bool x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Constraint3@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Constraint3@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetY(global::System.IntPtr instance, bool y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Constraint3@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Constraint3@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, bool z);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 3)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Constraint3._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Constraint3._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 3)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal byte m_x;

                    [FieldOffset(1)]
                    internal byte m_y;

                    [FieldOffset(2)]
                    internal byte m_z;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Constraint3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Constraint3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Constraint3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Constraint3(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Constraint3 __CreateInstance(global::FlounderSharp.Constraint3.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Constraint3(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Constraint3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Constraint3.__Internal));
            global::FlounderSharp.Constraint3.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Constraint3(global::FlounderSharp.Constraint3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Constraint3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Constraint3.</summary>
        public Constraint3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Constraint3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Constraint3.</summary>
        /// <param name="source">Creates this constraint out of a existing one.</param>
        public Constraint3(global::FlounderSharp.Constraint3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Constraint3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Constraint3.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        public Constraint3(bool x, bool y, bool z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Constraint3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), x, y, z);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Constraint3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Saves this constraint into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue source)
        {
            var __arg0 = ReferenceEquals(source, null) ? global::System.IntPtr.Zero : source.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Constraint3 __op, global::FlounderSharp.Constraint3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Constraint3;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Constraint3.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Constraint3 __op, global::FlounderSharp.Constraint3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static global::FlounderSharp.Constraint3 Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Constraint3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Constraint3@fl@@2V12@B");
                return global::FlounderSharp.Constraint3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Constraint3 One
        {
            get
            {
                var __ptr = (global::FlounderSharp.Constraint3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ONE@Constraint3@fl@@2V12@B");
                return global::FlounderSharp.Constraint3.__CreateInstance(*__ptr);
            }
        }

        public bool X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetX((__Instance + __PointerAdjustment), value);
            }
        }

        public bool Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetY((__Instance + __PointerAdjustment), value);
            }
        }

        public bool Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetZ((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A class for handing and calculating deltas.</summary>
    public unsafe partial class Delta : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_currentFrameTime;

            [FieldOffset(4)]
            internal float m_lastFrameTime;

            [FieldOffset(8)]
            internal float m_change;

            [FieldOffset(12)]
            internal float m_time;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Delta@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Delta@fl@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChange@Delta@fl@@QEBAMXZ")]
            internal static extern float GetChange(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Delta@fl@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Delta> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Delta>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Delta __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Delta(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Delta __CreateInstance(global::FlounderSharp.Delta.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Delta(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Delta.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Delta.__Internal));
            *(global::FlounderSharp.Delta.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Delta(global::FlounderSharp.Delta.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Delta(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new change handler.</summary>
        public Delta()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Delta(global::FlounderSharp.Delta _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Delta.__Internal*) __Instance) = *((global::FlounderSharp.Delta.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Delta __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates change and times.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public float Change
        {
            get
            {
                var __ret = __Internal.GetChange((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A class that smoothly increases its value.</summary>
    public unsafe partial class SmoothFloat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_agility;

            [FieldOffset(4)]
            internal float m_target;

            [FieldOffset(8)]
            internal float m_actual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SmoothFloat@fl@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float initialValue, float agility);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SmoothFloat@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SmoothFloat@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@SmoothFloat@fl@@QEAAXAEBM@Z")]
            internal static extern void Update(global::System.IntPtr instance, float delta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IncreaseTarget@SmoothFloat@fl@@QEAAXAEBM@Z")]
            internal static extern void IncreaseTarget(global::System.IntPtr instance, float increase);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@SmoothFloat@fl@@QEBAMXZ")]
            internal static extern float Get(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTarget@SmoothFloat@fl@@QEBAMXZ")]
            internal static extern float GetTarget(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTarget@SmoothFloat@fl@@QEAAXAEBM@Z")]
            internal static extern void SetTarget(global::System.IntPtr instance, float target);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SmoothFloat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SmoothFloat>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.SmoothFloat __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SmoothFloat(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SmoothFloat __CreateInstance(global::FlounderSharp.SmoothFloat.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SmoothFloat(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SmoothFloat.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SmoothFloat.__Internal));
            *(global::FlounderSharp.SmoothFloat.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SmoothFloat(global::FlounderSharp.SmoothFloat.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SmoothFloat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new smooth float.</summary>
        /// <param name="initialValue">The initial value.</param>
        /// <param name="agility">The agility for increasing actual.</param>
        public SmoothFloat(float initialValue, float agility)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SmoothFloat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), initialValue, agility);
        }

        public SmoothFloat(global::FlounderSharp.SmoothFloat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SmoothFloat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.SmoothFloat.__Internal*) __Instance) = *((global::FlounderSharp.SmoothFloat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.SmoothFloat __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the driver with the passed time.</summary>
        /// <param name="delta">The time between the last update.</param>
        public void Update(float delta)
        {
            __Internal.Update((__Instance + __PointerAdjustment), delta);
        }

        /// <summary>Increases the smooth floats target.</summary>
        /// <param name="increase">How much to increase the target by.</param>
        public void IncreaseTarget(float increase)
        {
            __Internal.IncreaseTarget((__Instance + __PointerAdjustment), increase);
        }

        /// <summary>Gets the currently calculated value.</summary>
        public float Get()
        {
            var __ret = __Internal.Get((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Gets the smooth floats current target.</summary>
        /// <param name="target">The new target.</param>
        /// <remarks>Sets the target for the smooth float.</remarks>
        public float Target
        {
            get
            {
                var __ret = __Internal.GetTarget((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetTarget((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 2x2 matrix.</summary>
    public unsafe partial class Matrix2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Matrix2._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@fl@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Matrix2@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix2@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix2@fl@@QEBA?AVVector2@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix2@fl@@QEBA?AV12@AEBVVector2@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix2@fl@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZero@Matrix2@fl@@QEAA?AV12@XZ")]
            internal static extern void SetZero(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIdentity@Matrix2@fl@@QEAA?AV12@XZ")]
            internal static extern void SetIdentity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToArray@Matrix2@fl@@QEBAPEAMXZ")]
            internal static extern float* ToArray(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Matrix2@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix2@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix2@fl@@QEAA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix2@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVMatrix2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVMatrix2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix2@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix2@0@V10@VVector2@0@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, global::FlounderSharp.Vector2.__Internal value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix2@0@V10@VVector2@0@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, global::FlounderSharp.Vector2.__Internal value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix2@0@V10@M@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix2@0@V10@M@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::FlounderSharp.Matrix2.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix2@0@MV10@@Z")]
            internal static extern void OperatorStar_2(global::System.IntPtr @return, float value, global::FlounderSharp.Matrix2.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix2@0@MV10@@Z")]
            internal static extern void OperatorSlash_2(global::System.IntPtr @return, float value, global::FlounderSharp.Matrix2.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix2@fl@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix2@fl@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix2@fl@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix2._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix2._.__.__Internal __1;

                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix2._.__.__Internal __2;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr m_0;

                    [FieldOffset(8)]
                    internal global::System.IntPtr m_1;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Matrix2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Matrix2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Matrix2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Matrix2(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Matrix2 __CreateInstance(global::FlounderSharp.Matrix2.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Matrix2(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Matrix2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix2.__Internal));
            global::FlounderSharp.Matrix2.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix2(global::FlounderSharp.Matrix2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix2. The matrix is initialised to the identity.</summary>
        public Matrix2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix2(global::FlounderSharp.Matrix2 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a 4 element array.</param>
        public Matrix2(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 4)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor((__Instance + __PointerAdjustment), source);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Matrix2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix2 Add(global::FlounderSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix2 Subtract(global::FlounderSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix2 Multiply(global::FlounderSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix2 Divide(global::FlounderSharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector2 Transform(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector2.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Matrix2 Scale(global::FlounderSharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::FlounderSharp.Matrix2 Negate()
        {
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Sets this matrix to 0.</summary>
        public global::FlounderSharp.Matrix2 SetZero()
        {
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.SetZero((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Sets this matrix to be the identity matrix.</summary>
        public global::FlounderSharp.Matrix2 SetIdentity()
        {
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.SetIdentity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Turns this 2x2 matrix into an array.</summary>
        public float* ToArray()
        {
            var __ret = __Internal.ToArray((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Saves this matrix into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Matrix2 __op, global::FlounderSharp.Matrix2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Matrix2;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Matrix2.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Matrix2 __op, global::FlounderSharp.Matrix2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::FlounderSharp.Matrix2 operator -(global::FlounderSharp.Matrix2 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Matrix2(float[] source)
        {
            return new global::FlounderSharp.Matrix2(source);
        }

        public static global::FlounderSharp.Matrix2 operator +(global::FlounderSharp.Matrix2 left, global::FlounderSharp.Matrix2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator -(global::FlounderSharp.Matrix2 left, global::FlounderSharp.Matrix2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator *(global::FlounderSharp.Matrix2 left, global::FlounderSharp.Matrix2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator /(global::FlounderSharp.Matrix2 left, global::FlounderSharp.Matrix2 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator *(global::FlounderSharp.Matrix2 left, global::FlounderSharp.Vector2 value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) value.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator /(global::FlounderSharp.Matrix2 left, global::FlounderSharp.Vector2 value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector2.__Internal() : *(global::FlounderSharp.Vector2.__Internal*) value.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator *(global::FlounderSharp.Matrix2 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator /(global::FlounderSharp.Matrix2 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator *(float value, global::FlounderSharp.Matrix2 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorStar_2(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 operator /(float value, global::FlounderSharp.Matrix2 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix2.__Internal() : *(global::FlounderSharp.Matrix2.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix2.__Internal();
            __Internal.OperatorSlash_2(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix2 Identity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Matrix2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?IDENTITY@Matrix2@fl@@2V12@B");
                return global::FlounderSharp.Matrix2.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Matrix2 Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Matrix2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Matrix2@fl@@2V12@B");
                return global::FlounderSharp.Matrix2.__CreateInstance(*__ptr);
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::FlounderSharp.Matrix2 Invert
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix2.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::FlounderSharp.Matrix2 Transpose
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix2.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix2.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Holds a 3x3 matrix.</summary>
    public unsafe partial class Matrix3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::FlounderSharp.Matrix3._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@fl@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Matrix3@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix3@fl@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix3@fl@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix3@fl@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix3@fl@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZero@Matrix3@fl@@QEAA?AV12@XZ")]
            internal static extern void SetZero(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIdentity@Matrix3@fl@@QEAA?AV12@XZ")]
            internal static extern void SetIdentity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToArray@Matrix3@fl@@QEBAPEAMXZ")]
            internal static extern float* ToArray(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@Matrix3@fl@@QEAAXPEAVLoadedValue@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr destination);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix3@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix3@fl@@QEAA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix3@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hfl@@YA?AVMatrix3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gfl@@YA?AVMatrix3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix3@0@V10@AEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix3@0@V10@VVector3@0@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, global::FlounderSharp.Vector3.__Internal value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix3@0@V10@VVector3@0@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, global::FlounderSharp.Vector3.__Internal value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix3@0@V10@M@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix3@0@V10@M@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::FlounderSharp.Matrix3.__Internal left, float value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dfl@@YA?AVMatrix3@0@MV10@@Z")]
            internal static extern void OperatorStar_2(global::System.IntPtr @return, float value, global::FlounderSharp.Matrix3.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kfl@@YA?AVMatrix3@0@MV10@@Z")]
            internal static extern void OperatorSlash_2(global::System.IntPtr @return, float value, global::FlounderSharp.Matrix3.__Internal left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix3@fl@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix3@fl@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix3@fl@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix3._.__.__Internal __;

                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix3._.__.__Internal __1;

                [FieldOffset(0)]
                internal global::FlounderSharp.Matrix3._.__.__Internal __2;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr m_0;

                    [FieldOffset(8)]
                    internal global::System.IntPtr m_1;

                    [FieldOffset(16)]
                    internal global::System.IntPtr m_2;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Matrix3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Matrix3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Matrix3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Matrix3(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Matrix3 __CreateInstance(global::FlounderSharp.Matrix3.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Matrix3(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Matrix3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix3.__Internal));
            global::FlounderSharp.Matrix3.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix3(global::FlounderSharp.Matrix3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix3. The matrix is initialised to the identity.</summary>
        public Matrix3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix3(global::FlounderSharp.Matrix3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a 9 element array.</param>
        public Matrix3(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 9)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor((__Instance + __PointerAdjustment), source);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Matrix3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix3 Add(global::FlounderSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix3 Subtract(global::FlounderSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix3 Multiply(global::FlounderSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::FlounderSharp.Matrix3 Divide(global::FlounderSharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Vector3 Transform(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::FlounderSharp.Matrix3 Scale(global::FlounderSharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::FlounderSharp.Matrix3 Negate()
        {
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Sets this matrix to 0.</summary>
        public global::FlounderSharp.Matrix3 SetZero()
        {
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.SetZero((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Sets this matrix to be the identity matrix.</summary>
        public global::FlounderSharp.Matrix3 SetIdentity()
        {
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.SetIdentity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Turns this 3x3 matrix into an array.</summary>
        public float* ToArray()
        {
            var __ret = __Internal.ToArray((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Saves this matrix into a loaded value.</summary>
        /// <param name="destination">The destination loaded value.</param>
        public void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::FlounderSharp.Matrix3 __op, global::FlounderSharp.Matrix3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::FlounderSharp.Matrix3;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::FlounderSharp.Matrix3.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::FlounderSharp.Matrix3 __op, global::FlounderSharp.Matrix3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::FlounderSharp.Matrix3 operator -(global::FlounderSharp.Matrix3 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.Matrix3(float[] source)
        {
            return new global::FlounderSharp.Matrix3(source);
        }

        public static global::FlounderSharp.Matrix3 operator +(global::FlounderSharp.Matrix3 left, global::FlounderSharp.Matrix3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator -(global::FlounderSharp.Matrix3 left, global::FlounderSharp.Matrix3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator *(global::FlounderSharp.Matrix3 left, global::FlounderSharp.Matrix3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator /(global::FlounderSharp.Matrix3 left, global::FlounderSharp.Matrix3 right)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator *(global::FlounderSharp.Matrix3 left, global::FlounderSharp.Vector3 value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator /(global::FlounderSharp.Matrix3 left, global::FlounderSharp.Vector3 value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            var __arg1 = ReferenceEquals(value, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) value.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator *(global::FlounderSharp.Matrix3 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator /(global::FlounderSharp.Matrix3 left, float value)
        {
            var __arg0 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, value);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator *(float value, global::FlounderSharp.Matrix3 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorStar_2(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 operator /(float value, global::FlounderSharp.Matrix3 left)
        {
            var __arg1 = ReferenceEquals(left, null) ? new global::FlounderSharp.Matrix3.__Internal() : *(global::FlounderSharp.Matrix3.__Internal*) left.__Instance;
            var __ret = new global::FlounderSharp.Matrix3.__Internal();
            __Internal.OperatorSlash_2(new IntPtr(&__ret), value, __arg1);
            return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::FlounderSharp.Matrix3 Identity
        {
            get
            {
                var __ptr = (global::FlounderSharp.Matrix3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?IDENTITY@Matrix3@fl@@2V12@B");
                return global::FlounderSharp.Matrix3.__CreateInstance(*__ptr);
            }
        }

        public static global::FlounderSharp.Matrix3 Zero
        {
            get
            {
                var __ptr = (global::FlounderSharp.Matrix3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?ZERO@Matrix3@fl@@2V12@B");
                return global::FlounderSharp.Matrix3.__CreateInstance(*__ptr);
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::FlounderSharp.Matrix3 Invert
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix3.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::FlounderSharp.Matrix3 Transpose
        {
            get
            {
                var __ret = new global::FlounderSharp.Matrix3.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Matrix3.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public enum NoiseType
    {
        TypeValue = 0,
        TypeValuefractal = 1,
        TypePerlin = 2,
        TypePerlinfractal = 3,
        TypeSimplex = 4,
        TypeSimplexfractal = 5,
        TypeCellular = 6,
        TypeWhitenoise = 7,
        TypeCubic = 8,
        TypeCubicfractal = 9
    }

    public enum NoiseInterp
    {
        InterpLinear = 0,
        InterpHermite = 1,
        InterpQuintic = 2
    }

    public enum NoiseFractal
    {
        FractalFbm = 0,
        FractalBillow = 1,
        FractalRigidmulti = 2
    }

    public enum NoiseCellularFunc
    {
        CellularEuclidean = 0,
        CellularManhattan = 1,
        CellularNatural = 2
    }

    public enum NoiseCellularReturn
    {
        CellularCellvalue = 0,
        CellularNoiselookup = 1,
        CellularDistance = 2,
        CellularDistance2 = 3,
        CellularDistance2add = 4,
        CellularDistance2sub = 5,
        CellularDistance2mul = 6,
        CellularDistance2div = 7
    }

    public unsafe partial class Noise : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_seed;

            [FieldOffset(8)]
            internal global::System.IntPtr m_perm;

            [FieldOffset(16)]
            internal global::System.IntPtr m_perm12;

            [FieldOffset(24)]
            internal float m_frequency;

            [FieldOffset(28)]
            internal global::FlounderSharp.NoiseInterp m_interp;

            [FieldOffset(32)]
            internal global::FlounderSharp.NoiseType m_noiseType;

            [FieldOffset(36)]
            internal int m_octaves;

            [FieldOffset(40)]
            internal float m_lacunarity;

            [FieldOffset(44)]
            internal float m_gain;

            [FieldOffset(48)]
            internal global::FlounderSharp.NoiseFractal m_fractalType;

            [FieldOffset(52)]
            internal float m_fractalBounding;

            [FieldOffset(56)]
            internal global::FlounderSharp.NoiseCellularFunc m_cellularDistanceFunction;

            [FieldOffset(60)]
            internal global::FlounderSharp.NoiseCellularReturn m_cellularReturnType;

            [FieldOffset(64)]
            internal global::System.IntPtr m_cellularNoiseLookup;

            [FieldOffset(72)]
            internal int m_cellularDistanceIndex0;

            [FieldOffset(76)]
            internal int m_cellularDistanceIndex1;

            [FieldOffset(80)]
            internal float m_cellularJitter;

            [FieldOffset(84)]
            internal float m_gradientPerturbAmp;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Noise@fl@@QEAA@AEBH@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int seed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Noise@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Noise@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularDistance2Indices@Noise@fl@@QEBAXAEAH0@Z")]
            internal static extern void GetCellularDistance2Indices(global::System.IntPtr instance, int* cellularDistanceIndex0, int* cellularDistanceIndex1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularDistance2Indices@Noise@fl@@QEAAXAEBH0@Z")]
            internal static extern void SetCellularDistance2Indices(global::System.IntPtr instance, int cellularDistanceIndex0, int cellularDistanceIndex1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetValue(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValueFractal@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetValueFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlin@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetPerlin(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlinFractal@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetPerlinFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplexFractal@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetSimplexFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellular@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetCellular(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@fl@@QEBAMHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubic@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetCubic(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubicFractal@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetCubicFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoise@Noise@fl@@QEBAMMM@Z")]
            internal static extern float GetNoise(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturb@Noise@fl@@QEBAXAEAM0@Z")]
            internal static extern void GradientPerturb(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturbFractal@Noise@fl@@QEBAXAEAM0@Z")]
            internal static extern void GradientPerturbFractal(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetValue(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValueFractal@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetValueFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlin@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetPerlin(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlinFractal@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetPerlinFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplexFractal@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetSimplexFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellular@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetCellular(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@fl@@QEBAMHHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y, int z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubic@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetCubic(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubicFractal@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetCubicFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoise@Noise@fl@@QEBAMMMM@Z")]
            internal static extern float GetNoise(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturb@Noise@fl@@QEBAXAEAM00@Z")]
            internal static extern void GradientPerturb(global::System.IntPtr instance, float* x, float* y, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturbFractal@Noise@fl@@QEBAXAEAM00@Z")]
            internal static extern void GradientPerturbFractal(global::System.IntPtr instance, float* x, float* y, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@fl@@QEBAMMMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@fl@@QEBAMMMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@fl@@QEBAMHHHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y, int z, int w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSeed@Noise@fl@@QEBAHXZ")]
            internal static extern int GetSeed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSeed@Noise@fl@@QEAAXAEBH@Z")]
            internal static extern void SetSeed(global::System.IntPtr instance, int seed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFrequency@Noise@fl@@QEBAMXZ")]
            internal static extern float GetFrequency(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFrequency@Noise@fl@@QEAAXAEBM@Z")]
            internal static extern void SetFrequency(global::System.IntPtr instance, float frequency);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterp@Noise@fl@@QEBA?AW4NoiseInterp@2@XZ")]
            internal static extern global::FlounderSharp.NoiseInterp GetInterp(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInterp@Noise@fl@@QEAAXAEBW4NoiseInterp@2@@Z")]
            internal static extern void SetInterp(global::System.IntPtr instance, global::FlounderSharp.NoiseInterp interp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoiseType@Noise@fl@@QEBA?AW4NoiseType@2@XZ")]
            internal static extern global::FlounderSharp.NoiseType GetNoiseType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNoiseType@Noise@fl@@QEAAXAEBW4NoiseType@2@@Z")]
            internal static extern void SetNoiseType(global::System.IntPtr instance, global::FlounderSharp.NoiseType noiseType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalOctaves@Noise@fl@@QEBAHXZ")]
            internal static extern int GetFractalOctaves(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalOctaves@Noise@fl@@QEAAXAEBH@Z")]
            internal static extern void SetFractalOctaves(global::System.IntPtr instance, int octaves);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalLacunarity@Noise@fl@@QEBAMXZ")]
            internal static extern float GetFractalLacunarity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalLacunarity@Noise@fl@@QEAAXAEBM@Z")]
            internal static extern void SetFractalLacunarity(global::System.IntPtr instance, float lacunarity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalGain@Noise@fl@@QEBAMXZ")]
            internal static extern float GetFractalGain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalGain@Noise@fl@@QEAAXAEBM@Z")]
            internal static extern void SetFractalGain(global::System.IntPtr instance, float gain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalType@Noise@fl@@QEBA?AW4NoiseFractal@2@XZ")]
            internal static extern global::FlounderSharp.NoiseFractal GetFractalType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalType@Noise@fl@@QEAAXAEBW4NoiseFractal@2@@Z")]
            internal static extern void SetFractalType(global::System.IntPtr instance, global::FlounderSharp.NoiseFractal fractalType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularDistanceFunction@Noise@fl@@QEBA?AW4NoiseCellularFunc@2@XZ")]
            internal static extern global::FlounderSharp.NoiseCellularFunc GetCellularDistanceFunction(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularDistanceFunction@Noise@fl@@QEAAXAEBW4NoiseCellularFunc@2@@Z")]
            internal static extern void SetCellularDistanceFunction(global::System.IntPtr instance, global::FlounderSharp.NoiseCellularFunc cellularDistanceFunction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularReturnType@Noise@fl@@QEBA?AW4NoiseCellularReturn@2@XZ")]
            internal static extern global::FlounderSharp.NoiseCellularReturn GetCellularReturnType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularReturnType@Noise@fl@@QEAAXAEBW4NoiseCellularReturn@2@@Z")]
            internal static extern void SetCellularReturnType(global::System.IntPtr instance, global::FlounderSharp.NoiseCellularReturn cellularReturnType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularNoiseLookup@Noise@fl@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetCellularNoiseLookup(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularNoiseLookup@Noise@fl@@QEAAXPEAV12@@Z")]
            internal static extern void SetCellularNoiseLookup(global::System.IntPtr instance, global::System.IntPtr noise);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularJitter@Noise@fl@@QEBAMXZ")]
            internal static extern float GetCellularJitter(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularJitter@Noise@fl@@QEAAXAEBM@Z")]
            internal static extern void SetCellularJitter(global::System.IntPtr instance, float cellularJitter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGradientPerturbAmp@Noise@fl@@QEBAMXZ")]
            internal static extern float GetGradientPerturbAmp(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGradientPerturbAmp@Noise@fl@@QEAAXAEBM@Z")]
            internal static extern void SetGradientPerturbAmp(global::System.IntPtr instance, float gradientPerturbAmp);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Noise> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Noise>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Noise __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Noise(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Noise __CreateInstance(global::FlounderSharp.Noise.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Noise(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Noise.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Noise.__Internal));
            *(global::FlounderSharp.Noise.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Noise(global::FlounderSharp.Noise.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Noise(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Noise(int seed)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Noise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), seed);
        }

        public Noise(global::FlounderSharp.Noise _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Noise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Noise.__Internal*) __Instance) = *((global::FlounderSharp.Noise.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Noise __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void GetCellularDistance2Indices(ref int cellularDistanceIndex0, ref int cellularDistanceIndex1)
        {
            fixed (int* __refParamPtr0 = &cellularDistanceIndex0)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &cellularDistanceIndex1)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GetCellularDistance2Indices((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public void SetCellularDistance2Indices(int cellularDistanceIndex0, int cellularDistanceIndex1)
        {
            __Internal.SetCellularDistance2Indices((__Instance + __PointerAdjustment), cellularDistanceIndex0, cellularDistanceIndex1);
        }

        public float GetValue(float x, float y)
        {
            var __ret = __Internal.GetValue((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetValueFractal(float x, float y)
        {
            var __ret = __Internal.GetValueFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetPerlin(float x, float y)
        {
            var __ret = __Internal.GetPerlin((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetPerlinFractal(float x, float y)
        {
            var __ret = __Internal.GetPerlinFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetSimplex(float x, float y)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetSimplexFractal(float x, float y)
        {
            var __ret = __Internal.GetSimplexFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCellular(float x, float y)
        {
            var __ret = __Internal.GetCellular((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCubic(float x, float y)
        {
            var __ret = __Internal.GetCubic((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCubicFractal(float x, float y)
        {
            var __ret = __Internal.GetCubicFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetNoise(float x, float y)
        {
            var __ret = __Internal.GetNoise((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public void GradientPerturb(ref float x, ref float y)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GradientPerturb((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public void GradientPerturbFractal(ref float x, ref float y)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GradientPerturbFractal((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public float GetValue(float x, float y, float z)
        {
            var __ret = __Internal.GetValue((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetValueFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetValueFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetPerlin(float x, float y, float z)
        {
            var __ret = __Internal.GetPerlin((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetPerlinFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetPerlinFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetSimplex(float x, float y, float z)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetSimplexFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetSimplexFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCellular(float x, float y, float z)
        {
            var __ret = __Internal.GetCellular((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y, float z)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y, int z)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCubic(float x, float y, float z)
        {
            var __ret = __Internal.GetCubic((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCubicFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetCubicFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetNoise(float x, float y, float z)
        {
            var __ret = __Internal.GetNoise((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public void GradientPerturb(ref float x, ref float y, ref float z)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (float* __refParamPtr2 = &z)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GradientPerturb((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                    }
                }
            }
        }

        public void GradientPerturbFractal(ref float x, ref float y, ref float z)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (float* __refParamPtr2 = &z)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GradientPerturbFractal((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                    }
                }
            }
        }

        public float GetSimplex(float x, float y, float z, float w)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y, float z, float w)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y, int z, int w)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public static implicit operator global::FlounderSharp.Noise(int seed)
        {
            return new global::FlounderSharp.Noise(seed);
        }

        public int Seed
        {
            get
            {
                var __ret = __Internal.GetSeed((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSeed((__Instance + __PointerAdjustment), value);
            }
        }

        public float Frequency
        {
            get
            {
                var __ret = __Internal.GetFrequency((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFrequency((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.NoiseInterp Interp
        {
            get
            {
                var __ret = __Internal.GetInterp((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetInterp((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.NoiseType NoiseType
        {
            get
            {
                var __ret = __Internal.GetNoiseType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetNoiseType((__Instance + __PointerAdjustment), value);
            }
        }

        public int FractalOctaves
        {
            get
            {
                var __ret = __Internal.GetFractalOctaves((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalOctaves((__Instance + __PointerAdjustment), value);
            }
        }

        public float FractalLacunarity
        {
            get
            {
                var __ret = __Internal.GetFractalLacunarity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalLacunarity((__Instance + __PointerAdjustment), value);
            }
        }

        public float FractalGain
        {
            get
            {
                var __ret = __Internal.GetFractalGain((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalGain((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.NoiseFractal FractalType
        {
            get
            {
                var __ret = __Internal.GetFractalType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalType((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.NoiseCellularFunc CellularDistanceFunction
        {
            get
            {
                var __ret = __Internal.GetCellularDistanceFunction((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularDistanceFunction((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.NoiseCellularReturn CellularReturnType
        {
            get
            {
                var __ret = __Internal.GetCellularReturnType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularReturnType((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Noise CellularNoiseLookup
        {
            get
            {
                var __ret = __Internal.GetCellularNoiseLookup((__Instance + __PointerAdjustment));
                global::FlounderSharp.Noise __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Noise.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Noise) global::FlounderSharp.Noise.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Noise.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetCellularNoiseLookup((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float CellularJitter
        {
            get
            {
                var __ret = __Internal.GetCellularJitter((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularJitter((__Instance + __PointerAdjustment), value);
            }
        }

        public float GradientPerturbAmp
        {
            get
            {
                var __ret = __Internal.GetGradientPerturbAmp((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetGradientPerturbAmp((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A bounce driver that uses a sine wave.</summary>
    public unsafe partial class DriverBounce : global::FlounderSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_start;

            [FieldOffset(28)]
            internal float m_amplitude;

            [FieldOffset(32)]
            internal float m_length1;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverBounce@fl@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float start, float end, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverBounce@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.DriverBounce __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverBounce(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DriverBounce __CreateInstance(global::FlounderSharp.DriverBounce.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverBounce(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DriverBounce.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverBounce.__Internal));
            global::FlounderSharp.DriverBounce.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverBounce(global::FlounderSharp.DriverBounce.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverBounce(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new sine wave driver.</summary>
        /// <param name="start">The start value.</param>
        /// <param name="end">The end value.</param>
        /// <param name="length">The length between two waves.</param>
        public DriverBounce(float start, float end, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverBounce.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), start, end, length);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverBounce");
        }

        public DriverBounce(global::FlounderSharp.DriverBounce _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverBounce.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverBounce");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverBounce()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverBounce) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverBounce) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A driver that has a constant value.</summary>
    public unsafe partial class DriverConstant : global::FlounderSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverConstant@fl@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float constant);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverConstant@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.DriverConstant __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverConstant(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DriverConstant __CreateInstance(global::FlounderSharp.DriverConstant.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverConstant(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DriverConstant.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverConstant.__Internal));
            global::FlounderSharp.DriverConstant.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverConstant(global::FlounderSharp.DriverConstant.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverConstant(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new constant driver.</summary>
        /// <param name="constant">The constant value.</param>
        public DriverConstant(float constant)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), constant);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverConstant");
        }

        public DriverConstant(global::FlounderSharp.DriverConstant _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverConstant");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        public static implicit operator global::FlounderSharp.DriverConstant(float constant)
        {
            return new global::FlounderSharp.DriverConstant(constant);
        }

        #region Virtual table interop

        // ~DriverConstant()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverConstant) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverConstant) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A driver that fades from start to end.</summary>
    public unsafe partial class DriverFade : global::FlounderSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_start;

            [FieldOffset(28)]
            internal float m_end;

            [FieldOffset(32)]
            internal float m_peak;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverFade@fl@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float start, float end, float peak, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverFade@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStart@DriverFade@fl@@QEBAMXZ")]
            internal static extern float GetStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStart@DriverFade@fl@@QEAAXAEBM@Z")]
            internal static extern void SetStart(global::System.IntPtr instance, float start);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetEnd@DriverFade@fl@@QEBAMXZ")]
            internal static extern float GetEnd(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnd@DriverFade@fl@@QEAAXAEBM@Z")]
            internal static extern void SetEnd(global::System.IntPtr instance, float end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPeak@DriverFade@fl@@QEBAMXZ")]
            internal static extern float GetPeak(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPeak@DriverFade@fl@@QEAAXAEBM@Z")]
            internal static extern void SetPeak(global::System.IntPtr instance, float peak);
        }

        internal static new global::FlounderSharp.DriverFade __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverFade(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DriverFade __CreateInstance(global::FlounderSharp.DriverFade.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverFade(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DriverFade.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverFade.__Internal));
            global::FlounderSharp.DriverFade.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverFade(global::FlounderSharp.DriverFade.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverFade(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new fade driver.</summary>
        /// <param name="start">The start time.</param>
        /// <param name="end">The end time.</param>
        /// <param name="peak">The peak value.</param>
        /// <param name="length">The time taken to get to the end.</param>
        public DriverFade(float start, float end, float peak, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverFade.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), start, end, peak, length);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverFade");
        }

        public DriverFade(global::FlounderSharp.DriverFade _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverFade.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverFade");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        /// <summary>Gets the start time.</summary>
        /// <param name="start">The new start time.</param>
        /// <remarks>Sets the start time.</remarks>
        public float Start
        {
            get
            {
                var __ret = __Internal.GetStart((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetStart((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the end time.</summary>
        /// <param name="end">The new end time.</param>
        /// <remarks>Sets the end time.</remarks>
        public float End
        {
            get
            {
                var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetEnd((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the peak value.</summary>
        /// <param name="peak">The new peak value.</param>
        /// <remarks>Sets the peak value.</remarks>
        public float Peak
        {
            get
            {
                var __ret = __Internal.GetPeak((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPeak((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~DriverFade()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverFade) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverFade) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A driver that linearly increases its value.</summary>
    public unsafe partial class DriverLinear : global::FlounderSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_startValue;

            [FieldOffset(28)]
            internal float m_difference;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverLinear@fl@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float startValue, float endValue, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverLinear@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.DriverLinear __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverLinear(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DriverLinear __CreateInstance(global::FlounderSharp.DriverLinear.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverLinear(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DriverLinear.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverLinear.__Internal));
            global::FlounderSharp.DriverLinear.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverLinear(global::FlounderSharp.DriverLinear.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverLinear(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new linear driver.</summary>
        /// <param name="startValue">The start value.</param>
        /// <param name="endValue">The end value.</param>
        /// <param name="length">The time to go between values.</param>
        public DriverLinear(float startValue, float endValue, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverLinear.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), startValue, endValue, length);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverLinear");
        }

        public DriverLinear(global::FlounderSharp.DriverLinear _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverLinear.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverLinear");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverLinear()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverLinear) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverLinear) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A driver that uses a sine wave.</summary>
    public unsafe partial class DriverSinwave : global::FlounderSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_min;

            [FieldOffset(28)]
            internal float m_amplitude;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSinwave@fl@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float min, float max, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSinwave@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.DriverSinwave __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverSinwave(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DriverSinwave __CreateInstance(global::FlounderSharp.DriverSinwave.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverSinwave(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DriverSinwave.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverSinwave.__Internal));
            global::FlounderSharp.DriverSinwave.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverSinwave(global::FlounderSharp.DriverSinwave.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverSinwave(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new sine wave driver.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <param name="length">The length between two waves.</param>
        public DriverSinwave(float min, float max, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverSinwave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), min, max, length);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverSinwave");
        }

        public DriverSinwave(global::FlounderSharp.DriverSinwave _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverSinwave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverSinwave");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverSinwave()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverSinwave) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverSinwave) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A driver that slides to its destination using cosine interpolation.</summary>
    public unsafe partial class DriverSlide : global::FlounderSharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal float m_actualTime;

            [FieldOffset(16)]
            internal float m_currentTime;

            [FieldOffset(24)]
            internal float m_start;

            [FieldOffset(28)]
            internal float m_end;

            [FieldOffset(32)]
            internal float m_max;

            [FieldOffset(36)]
            internal byte m_reachedTarget;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSlide@fl@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float start, float end, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSlide@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.DriverSlide __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverSlide(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DriverSlide __CreateInstance(global::FlounderSharp.DriverSlide.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DriverSlide(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DriverSlide.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverSlide.__Internal));
            global::FlounderSharp.DriverSlide.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverSlide(global::FlounderSharp.DriverSlide.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverSlide(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new slide driver.</summary>
        /// <param name="start">The start value.</param>
        /// <param name="end">The end value.</param>
        /// <param name="length">The time to get to the end value.</param>
        public DriverSlide(float start, float end, float length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverSlide.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), start, end, length);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverSlide");
        }

        public DriverSlide(global::FlounderSharp.DriverSlide _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DriverSlide.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.DriverSlide");
        }

        protected override float Calculate(float time)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___CalculateDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr_float));
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), time);
            return __ret;
        }

        #region Virtual table interop

        // ~DriverSlide()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverSlide) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // float Calculate(const float &time) override
        private static global::FlounderSharp.Delegates.Func_float_IntPtr_float _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float time)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DriverSlide) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(time);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class MeshRender : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(64)]
            internal global::System.IntPtr m_uniformObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshRender@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshRender@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@MeshRender@fl@@QEAAXAEBVCommandBuffer@2@PEAVUniformHandler@2@@Z")]
            internal static extern void CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr uniformScene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniformObject@MeshRender@fl@@QEBAPEAVUniformHandler@2@XZ")]
            internal static extern global::System.IntPtr GetUniformObject(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.MeshRender __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshRender(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MeshRender __CreateInstance(global::FlounderSharp.MeshRender.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshRender(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MeshRender.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshRender.__Internal));
            global::FlounderSharp.MeshRender.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshRender(global::FlounderSharp.MeshRender.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshRender(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MeshRender()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.MeshRender");
        }

        public MeshRender(global::FlounderSharp.MeshRender _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshRender");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public void CmdRender(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.UniformHandler uniformScene)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            var __arg1 = ReferenceEquals(uniformScene, null) ? global::System.IntPtr.Zero : uniformScene.__Instance;
            __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.UniformHandler UniformObject
        {
            get
            {
                var __ret = __Internal.GetUniformObject((__Instance + __PointerAdjustment));
                global::FlounderSharp.UniformHandler __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~MeshRender()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "MeshRender"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class MeshPattern : global::FlounderSharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [FieldOffset(64)]
            internal float m_sideLength;

            [FieldOffset(68)]
            internal float m_squareSize;

            [FieldOffset(72)]
            internal int m_vertexCount;

            [FieldOffset(76)]
            internal float m_textureScale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshPattern@fl@@QEAA@AEBM0AEBH0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float sideLength, float squareSize, int vertexCount, float textureScale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshPattern@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GenerateMesh@MeshPattern@fl@@IEAAXXZ")]
            internal static extern void GenerateMesh(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.MeshPattern __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshPattern(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MeshPattern __CreateInstance(global::FlounderSharp.MeshPattern.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshPattern(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MeshPattern.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshPattern.__Internal));
            global::FlounderSharp.MeshPattern.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshPattern(global::FlounderSharp.MeshPattern.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshPattern(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MeshPattern(float sideLength, float squareSize, int vertexCount, float textureScale)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshPattern.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), sideLength, squareSize, vertexCount, textureScale);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshPattern");
        }

        public MeshPattern(global::FlounderSharp.MeshPattern _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshPattern.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshPattern");
        }

        protected void GenerateMesh()
        {
            __Internal.GenerateMesh((__Instance + __PointerAdjustment));
        }

        protected virtual global::FlounderSharp.Vector3 GetPosition(float x, float z)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float));
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), x, z);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        protected virtual global::FlounderSharp.Vector3 GetNormal(global::FlounderSharp.Vector3 position)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___GetNormalDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            ___GetNormalDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        protected virtual global::FlounderSharp.Vector3 GetColour(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 normal)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___GetColourDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = normal.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            ___GetColourDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        #region Virtual table interop

        // MeshPattern
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshPattern) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshPattern) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Vector3 GetPosition(const float &x, const float &z)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, float x, float z)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshPattern) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetPosition(x, z);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetNormal(const Vector3 &position)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _GetNormalDelegateInstance;

        private static void _GetNormalDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshPattern) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            var __ret = __target.GetNormal(__result1);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetColour(const Vector3 &position, const Vector3 &normal)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _GetColourDelegateInstance;

        private static void _GetColourDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr normal)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshPattern) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            global::FlounderSharp.Vector3 __result2;
            if (normal == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(normal))
                __result2 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[normal];
            else __result2 = global::FlounderSharp.Vector3.__CreateInstance(normal);
            var __ret = __target.GetColour(__result1, __result2);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _GetNormalDelegateInstance += _GetNormalDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetNormalDelegateInstance).ToPointer();
                _GetColourDelegateInstance += _GetColourDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetColourDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class MeshSimple : global::FlounderSharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [FieldOffset(64)]
            internal float m_sideLength;

            [FieldOffset(68)]
            internal float m_squareSize;

            [FieldOffset(72)]
            internal int m_vertexCount;

            [FieldOffset(76)]
            internal float m_textureScale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshSimple@fl@@QEAA@AEBM0AEBH0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float sideLength, float squareSize, int vertexCount, float textureScale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshSimple@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GenerateMesh@MeshSimple@fl@@IEAAXXZ")]
            internal static extern void GenerateMesh(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.MeshSimple __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshSimple(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MeshSimple __CreateInstance(global::FlounderSharp.MeshSimple.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshSimple(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MeshSimple.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshSimple.__Internal));
            global::FlounderSharp.MeshSimple.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshSimple(global::FlounderSharp.MeshSimple.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshSimple(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MeshSimple(float sideLength, float squareSize, int vertexCount, float textureScale)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshSimple.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), sideLength, squareSize, vertexCount, textureScale);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshSimple");
        }

        public MeshSimple(global::FlounderSharp.MeshSimple _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshSimple.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshSimple");
        }

        protected void GenerateMesh()
        {
            __Internal.GenerateMesh((__Instance + __PointerAdjustment));
        }

        public virtual global::FlounderSharp.Vector3 GetPosition(float x, float z)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GetPositionDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float));
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), x, z);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public virtual global::FlounderSharp.Vector3 GetNormal(global::FlounderSharp.Vector3 position)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___GetNormalDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            ___GetNormalDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public virtual global::FlounderSharp.Vector3 GetColour(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 normal)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___GetColourDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = normal.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            ___GetColourDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        #region Virtual table interop

        // MeshSimple
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshSimple) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshSimple) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Vector3 GetPosition(const float &x, const float &z)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, float x, float z)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshSimple) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetPosition(x, z);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetNormal(const Vector3 &position)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _GetNormalDelegateInstance;

        private static void _GetNormalDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshSimple) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            var __ret = __target.GetNormal(__result1);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetColour(const Vector3 &position, const Vector3 &normal)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _GetColourDelegateInstance;

        private static void _GetColourDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr normal)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshSimple) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            global::FlounderSharp.Vector3 __result2;
            if (normal == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(normal))
                __result2 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[normal];
            else __result2 = global::FlounderSharp.Vector3.__CreateInstance(normal);
            var __ret = __target.GetColour(__result1, __result2);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _GetNormalDelegateInstance += _GetNormalDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetNormalDelegateInstance).ToPointer();
                _GetColourDelegateInstance += _GetColourDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetColourDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class ShapeCube : global::FlounderSharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeCube@fl@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float width, float height, float depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeCube@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeCube@fl@@SAPEAV12@AEBM00@Z")]
            internal static extern global::System.IntPtr Resource(float width, float height, float depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeCube@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);
        }

        internal static new global::FlounderSharp.ShapeCube __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeCube(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShapeCube __CreateInstance(global::FlounderSharp.ShapeCube.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeCube(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShapeCube.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeCube.__Internal));
            global::FlounderSharp.ShapeCube.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShapeCube(global::FlounderSharp.ShapeCube.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShapeCube(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ShapeCube(float width, float height, float depth)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeCube.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), width, height, depth);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeCube");
        }

        public ShapeCube(global::FlounderSharp.ShapeCube _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeCube.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeCube");
        }

        public static global::FlounderSharp.ShapeCube Resource(float width, float height, float depth)
        {
            var __ret = __Internal.Resource(width, height, depth);
            global::FlounderSharp.ShapeCube __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeCube.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeCube) global::FlounderSharp.ShapeCube.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeCube.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeCube) global::FlounderSharp.ShapeCube.__CreateInstance(__ret);
            return __result0;
        }

        public static global::FlounderSharp.ShapeCube Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.ShapeCube __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeCube.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeCube) global::FlounderSharp.ShapeCube.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeCube.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeCube) global::FlounderSharp.ShapeCube.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ShapeCube
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class ShapeCylinder : global::FlounderSharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeCylinder@fl@@QEAA@AEBM00AEBI10@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float radiusBase, float radiusTop, float height, uint slices, uint stacks, float y0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeCylinder@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeCylinder@fl@@SAPEAV12@AEBM00AEBI10@Z")]
            internal static extern global::System.IntPtr Resource(float radiusBase, float radiusTop, float height, uint slices, uint stacks, float y0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeCylinder@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);
        }

        internal static new global::FlounderSharp.ShapeCylinder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeCylinder(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShapeCylinder __CreateInstance(global::FlounderSharp.ShapeCylinder.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeCylinder(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShapeCylinder.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeCylinder.__Internal));
            global::FlounderSharp.ShapeCylinder.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShapeCylinder(global::FlounderSharp.ShapeCylinder.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShapeCylinder(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ShapeCylinder(float radiusBase, float radiusTop, float height, uint slices, uint stacks, float y0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeCylinder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), radiusBase, radiusTop, height, slices, stacks, y0);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeCylinder");
        }

        public ShapeCylinder(global::FlounderSharp.ShapeCylinder _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeCylinder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeCylinder");
        }

        public static global::FlounderSharp.ShapeCylinder Resource(float radiusBase, float radiusTop, float height, uint slices, uint stacks, float y0)
        {
            var __ret = __Internal.Resource(radiusBase, radiusTop, height, slices, stacks, y0);
            global::FlounderSharp.ShapeCylinder __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeCylinder.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeCylinder) global::FlounderSharp.ShapeCylinder.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeCylinder.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeCylinder) global::FlounderSharp.ShapeCylinder.__CreateInstance(__ret);
            return __result0;
        }

        public static global::FlounderSharp.ShapeCylinder Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.ShapeCylinder __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeCylinder.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeCylinder) global::FlounderSharp.ShapeCylinder.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeCylinder.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeCylinder) global::FlounderSharp.ShapeCylinder.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~ShapeCylinder()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class ShapeDisk : global::FlounderSharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeDisk@fl@@QEAA@AEBM0AEBI1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float innerRadius, float outerRadius, uint slices, uint loops);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeDisk@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeDisk@fl@@SAPEAV12@AEBM0AEBI1@Z")]
            internal static extern global::System.IntPtr Resource(float innerRadius, float outerRadius, uint slices, uint loops);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeDisk@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);
        }

        internal static new global::FlounderSharp.ShapeDisk __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeDisk(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShapeDisk __CreateInstance(global::FlounderSharp.ShapeDisk.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeDisk(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShapeDisk.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeDisk.__Internal));
            global::FlounderSharp.ShapeDisk.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShapeDisk(global::FlounderSharp.ShapeDisk.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShapeDisk(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ShapeDisk(float innerRadius, float outerRadius, uint slices, uint loops)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeDisk.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), innerRadius, outerRadius, slices, loops);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeDisk");
        }

        public ShapeDisk(global::FlounderSharp.ShapeDisk _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeDisk.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeDisk");
        }

        public static global::FlounderSharp.ShapeDisk Resource(float innerRadius, float outerRadius, uint slices, uint loops)
        {
            var __ret = __Internal.Resource(innerRadius, outerRadius, slices, loops);
            global::FlounderSharp.ShapeDisk __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeDisk.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeDisk) global::FlounderSharp.ShapeDisk.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeDisk.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeDisk) global::FlounderSharp.ShapeDisk.__CreateInstance(__ret);
            return __result0;
        }

        public static global::FlounderSharp.ShapeDisk Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.ShapeDisk __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeDisk.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeDisk) global::FlounderSharp.ShapeDisk.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeDisk.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeDisk) global::FlounderSharp.ShapeDisk.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~ShapeDisk()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeDisk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeDisk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class ShapeRectangle : global::FlounderSharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeRectangle@fl@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float width, float height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeRectangle@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeRectangle@fl@@SAPEAV12@AEBM0@Z")]
            internal static extern global::System.IntPtr Resource(float min, float max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeRectangle@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);
        }

        internal static new global::FlounderSharp.ShapeRectangle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeRectangle(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShapeRectangle __CreateInstance(global::FlounderSharp.ShapeRectangle.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeRectangle(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShapeRectangle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeRectangle.__Internal));
            global::FlounderSharp.ShapeRectangle.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShapeRectangle(global::FlounderSharp.ShapeRectangle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShapeRectangle(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ShapeRectangle(float width, float height)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeRectangle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), width, height);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeRectangle");
        }

        public ShapeRectangle(global::FlounderSharp.ShapeRectangle _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeRectangle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeRectangle");
        }

        public static global::FlounderSharp.ShapeRectangle Resource(float min, float max)
        {
            var __ret = __Internal.Resource(min, max);
            global::FlounderSharp.ShapeRectangle __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeRectangle.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeRectangle) global::FlounderSharp.ShapeRectangle.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeRectangle.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeRectangle) global::FlounderSharp.ShapeRectangle.__CreateInstance(__ret);
            return __result0;
        }

        public static global::FlounderSharp.ShapeRectangle Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.ShapeRectangle __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeRectangle.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeRectangle) global::FlounderSharp.ShapeRectangle.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeRectangle.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeRectangle) global::FlounderSharp.ShapeRectangle.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ShapeRectangle
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeRectangle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeRectangle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class ShapeSphere : global::FlounderSharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeSphere@fl@@QEAA@AEBI0AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint latitudeBands, uint longitudeBands, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShapeSphere@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeSphere@fl@@SAPEAV12@AEBI0AEBM@Z")]
            internal static extern global::System.IntPtr Resource(uint latitudeBands, uint longitudeBands, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@ShapeSphere@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);
        }

        internal static new global::FlounderSharp.ShapeSphere __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeSphere(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShapeSphere __CreateInstance(global::FlounderSharp.ShapeSphere.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShapeSphere(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShapeSphere.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeSphere.__Internal));
            global::FlounderSharp.ShapeSphere.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShapeSphere(global::FlounderSharp.ShapeSphere.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShapeSphere(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ShapeSphere(uint latitudeBands, uint longitudeBands, float radius)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), latitudeBands, longitudeBands, radius);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeSphere");
        }

        public ShapeSphere(global::FlounderSharp.ShapeSphere _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShapeSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ShapeSphere");
        }

        public static global::FlounderSharp.ShapeSphere Resource(uint latitudeBands, uint longitudeBands, float radius)
        {
            var __ret = __Internal.Resource(latitudeBands, longitudeBands, radius);
            global::FlounderSharp.ShapeSphere __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeSphere.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeSphere) global::FlounderSharp.ShapeSphere.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeSphere.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeSphere) global::FlounderSharp.ShapeSphere.__CreateInstance(__ret);
            return __result0;
        }

        public static global::FlounderSharp.ShapeSphere Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.ShapeSphere __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ShapeSphere.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.ShapeSphere) global::FlounderSharp.ShapeSphere.NativeToManagedMap[__ret];
            else global::FlounderSharp.ShapeSphere.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ShapeSphere) global::FlounderSharp.ShapeSphere.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~ShapeSphere()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShapeSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A definition for what a particle should act and look like.</summary>
    public unsafe partial class ParticleType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::System.IntPtr m_texture;

            [FieldOffset(40)]
            internal float m_lifeLength;

            [FieldOffset(44)]
            internal float m_scale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ParticleType@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVTexture@1@AEBM2@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr texture, float lifeLength, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ParticleType@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ParticleType@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@ParticleType@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@ParticleType@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTexture@ParticleType@fl@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetTexture(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTexture@ParticleType@fl@@QEAAXPEAVTexture@2@@Z")]
            internal static extern void SetTexture(global::System.IntPtr instance, global::System.IntPtr texture);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLifeLength@ParticleType@fl@@QEBAMXZ")]
            internal static extern float GetLifeLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLifeLength@ParticleType@fl@@QEAAXAEBM@Z")]
            internal static extern void SetLifeLength(global::System.IntPtr instance, float lifeLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@ParticleType@fl@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScale@ParticleType@fl@@QEAAXAEBM@Z")]
            internal static extern void SetScale(global::System.IntPtr instance, float scale);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ParticleType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ParticleType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ParticleType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ParticleType(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ParticleType __CreateInstance(global::FlounderSharp.ParticleType.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ParticleType(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ParticleType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ParticleType.__Internal));
            global::FlounderSharp.ParticleType.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ParticleType(global::FlounderSharp.ParticleType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ParticleType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new particle type.</summary>
        /// <param name="name">The name for the particle type.</param>
        /// <param name="texture">The particles texture.</param>
        /// <param name="lifeLength">The averaged life length for the particle.</param>
        /// <param name="scale">The averaged scale for the particle.</param>
        public ParticleType(string name, global::FlounderSharp.Texture texture, float lifeLength, float scale)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ParticleType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(texture, null) ? global::System.IntPtr.Zero : texture.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, lifeLength, scale);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public ParticleType(global::FlounderSharp.ParticleType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ParticleType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ParticleType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.Texture Texture
        {
            get
            {
                var __ret = __Internal.GetTexture((__Instance + __PointerAdjustment));
                global::FlounderSharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
                else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetTexture((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float LifeLength
        {
            get
            {
                var __ret = __Internal.GetLifeLength((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetLifeLength((__Instance + __PointerAdjustment), value);
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetScale((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A instance of a particle type.</summary>
    public unsafe partial class Particle : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_particleType;

            [FieldOffset(8)]
            internal global::System.IntPtr m_position;

            [FieldOffset(16)]
            internal global::System.IntPtr m_velocity;

            [FieldOffset(24)]
            internal global::System.IntPtr m_change;

            [FieldOffset(32)]
            internal global::System.IntPtr m_textureOffset1;

            [FieldOffset(40)]
            internal global::System.IntPtr m_textureOffset2;

            [FieldOffset(48)]
            internal float m_lifeLength;

            [FieldOffset(52)]
            internal float m_rotation;

            [FieldOffset(56)]
            internal float m_scale;

            [FieldOffset(60)]
            internal float m_gravityEffect;

            [FieldOffset(64)]
            internal float m_elapsedTime;

            [FieldOffset(68)]
            internal float m_transparency;

            [FieldOffset(72)]
            internal float m_textureBlendFactor;

            [FieldOffset(76)]
            internal float m_distanceToCamera;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Particle@fl@@QEAA@PEAVParticleType@1@AEBVVector3@1@1AEBM222@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr particleType, global::System.IntPtr position, global::System.IntPtr velocity, float lifeLength, float rotation, float scale, float gravityEffect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Particle@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Particle@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Particle@fl@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MParticle@fl@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAlive@Particle@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAlive(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParticleType@Particle@fl@@QEBAPEAVParticleType@2@XZ")]
            internal static extern global::System.IntPtr GetParticleType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Particle@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVelocity@Particle@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetVelocity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChange@Particle@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetChange(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureOffset1@Particle@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetTextureOffset1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureOffset2@Particle@fl@@QEBAPEAVVector2@2@XZ")]
            internal static extern global::System.IntPtr GetTextureOffset2(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLifeLength@Particle@fl@@QEBAMXZ")]
            internal static extern float GetLifeLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@Particle@fl@@QEBAMXZ")]
            internal static extern float GetRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@Particle@fl@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGravityEffect@Particle@fl@@QEBAMXZ")]
            internal static extern float GetGravityEffect(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetElapsedTime@Particle@fl@@QEBAMXZ")]
            internal static extern float GetElapsedTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransparency@Particle@fl@@QEBAMXZ")]
            internal static extern float GetTransparency(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureBlendFactor@Particle@fl@@QEBAMXZ")]
            internal static extern float GetTextureBlendFactor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceToCamera@Particle@fl@@QEBAMXZ")]
            internal static extern float DistanceToCamera(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Particle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Particle>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Particle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Particle(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Particle __CreateInstance(global::FlounderSharp.Particle.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Particle(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Particle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Particle.__Internal));
            *(global::FlounderSharp.Particle.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Particle(global::FlounderSharp.Particle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Particle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new particle object.</summary>
        /// <param name="particleType">The particle template to build from.</param>
        /// <param name="position">The particles initial position.</param>
        /// <param name="velocity">The particles initial velocity.</param>
        /// <param name="lifeLength">The particles life length.</param>
        /// <param name="rotation">The particles rotation.</param>
        /// <param name="scale">The particles scale.</param>
        /// <param name="gravityEffect">The particles gravity effect.</param>
        public Particle(global::FlounderSharp.ParticleType particleType, global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 velocity, float lifeLength, float rotation, float scale, float gravityEffect)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Particle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(particleType, null) ? global::System.IntPtr.Zero : particleType.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            if (ReferenceEquals(velocity, null))
                throw new global::System.ArgumentNullException("velocity", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = velocity.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, lifeLength, rotation, scale, gravityEffect);
        }

        public Particle(global::FlounderSharp.Particle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Particle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Particle.__Internal*) __Instance) = *((global::FlounderSharp.Particle.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Particle __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the particle.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public static bool operator >(global::FlounderSharp.Particle __op, global::FlounderSharp.Particle other)
        {
            return !(__op < other);
        }

        public static bool operator <(global::FlounderSharp.Particle __op, global::FlounderSharp.Particle other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public bool IsAlive
        {
            get
            {
                var __ret = __Internal.IsAlive((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.ParticleType ParticleType
        {
            get
            {
                var __ret = __Internal.GetParticleType((__Instance + __PointerAdjustment));
                global::FlounderSharp.ParticleType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ParticleType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ParticleType) global::FlounderSharp.ParticleType.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.ParticleType.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector3 Velocity
        {
            get
            {
                var __ret = __Internal.GetVelocity((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector3 Change
        {
            get
            {
                var __ret = __Internal.GetChange((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector2 TextureOffset1
        {
            get
            {
                var __ret = __Internal.GetTextureOffset1((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector2 TextureOffset2
        {
            get
            {
                var __ret = __Internal.GetTextureOffset2((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector2) global::FlounderSharp.Vector2.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector2.__CreateInstance(__ret);
                return __result0;
            }
        }

        public float LifeLength
        {
            get
            {
                var __ret = __Internal.GetLifeLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Rotation
        {
            get
            {
                var __ret = __Internal.GetRotation((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float GravityEffect
        {
            get
            {
                var __ret = __Internal.GetGravityEffect((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float ElapsedTime
        {
            get
            {
                var __ret = __Internal.GetElapsedTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Transparency
        {
            get
            {
                var __ret = __Internal.GetTransparency((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float TextureBlendFactor
        {
            get
            {
                var __ret = __Internal.GetTextureBlendFactor((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float DistanceToCamera
        {
            get
            {
                var __ret = __Internal.DistanceToCamera((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A manager that manages particles.</summary>
    public unsafe partial class Particles : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_particles;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Particles@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Particles@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Particles@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddParticle@Particles@fl@@QEAAXPEAVParticle@2@@Z")]
            internal static extern void AddParticle(global::System.IntPtr instance, global::System.IntPtr created);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Clear@Particles@fl@@QEAAXXZ")]
            internal static extern void Clear(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Particles __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Particles(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Particles __CreateInstance(global::FlounderSharp.Particles.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Particles(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Particles.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Particles.__Internal));
            global::FlounderSharp.Particles.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Particles(global::FlounderSharp.Particles.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Particles(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new particles module.</summary>
        public Particles()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Particles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Particles");
        }

        public Particles(global::FlounderSharp.Particles _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Particles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Particles");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public void AddParticle(global::FlounderSharp.Particle created)
        {
            var __arg0 = ReferenceEquals(created, null) ? global::System.IntPtr.Zero : created.__Instance;
            __Internal.AddParticle((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Clears all particles from the scene.</summary>
        public void Clear()
        {
            __Internal.Clear((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Particles Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Particles __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Particles.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Particles) global::FlounderSharp.Particles.NativeToManagedMap[__ret];
            else global::FlounderSharp.Particles.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Particles) global::FlounderSharp.Particles.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // ~Particles()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Particles) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Particles) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A interface that defines a particle spawn type.</summary>
    public unsafe abstract partial class ISpawnParticle : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpawnParticle@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpawnParticle@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ISpawnParticle@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ISpawnParticle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ISpawnParticle>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ISpawnParticle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ISpawnParticleInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ISpawnParticle __CreateInstance(global::FlounderSharp.ISpawnParticle.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ISpawnParticleInternal(native, skipVTables);
        }

        protected ISpawnParticle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new particle spawn.</summary>
        protected ISpawnParticle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ISpawnParticle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.ISpawnParticle");
        }

        protected ISpawnParticle(global::FlounderSharp.ISpawnParticle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ISpawnParticle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ISpawnParticle");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ISpawnParticle __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.ISpawnParticle.__Internal*) __Instance)->vfptr_ISpawnParticle = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the base spawn position.</summary>
        public abstract global::FlounderSharp.Vector3 BaseSpawnPosition
        {
            get;
        }

        #region Virtual table interop

        // virtual ~ISpawnParticle() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpawnParticle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 *GetBaseSpawnPosition() = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetBaseSpawnPositionDelegateInstance;

        private static global::System.IntPtr _GetBaseSpawnPositionDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ISpawnParticle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.BaseSpawnPosition;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetBaseSpawnPositionDelegateInstance += _GetBaseSpawnPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetBaseSpawnPositionDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class ISpawnParticleInternal : global::FlounderSharp.ISpawnParticle, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.ISpawnParticle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ISpawnParticle.__Internal));
            *(global::FlounderSharp.ISpawnParticle.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ISpawnParticleInternal(global::FlounderSharp.ISpawnParticle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ISpawnParticleInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets the base spawn position.</summary>
        public override global::FlounderSharp.Vector3 BaseSpawnPosition
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetBaseSpawnPositionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetBaseSpawnPositionDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A system of particles that are to be spawned.</summary>
    public unsafe partial class ParticleSystem : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_types;

            [FieldOffset(64)]
            internal global::System.IntPtr m_spawn;

            [FieldOffset(72)]
            internal float m_pps;

            [FieldOffset(76)]
            internal float m_averageSpeed;

            [FieldOffset(80)]
            internal float m_gravityEffect;

            [FieldOffset(84)]
            internal byte m_randomRotation;

            [FieldOffset(88)]
            internal global::System.IntPtr m_lastPosition;

            [FieldOffset(96)]
            internal global::System.IntPtr m_systemOffset;

            [FieldOffset(104)]
            internal global::System.IntPtr m_direction;

            [FieldOffset(112)]
            internal float m_directionDeviation;

            [FieldOffset(116)]
            internal float m_speedError;

            [FieldOffset(120)]
            internal float m_lifeError;

            [FieldOffset(124)]
            internal float m_scaleError;

            [FieldOffset(128)]
            internal float m_timePassed;

            [FieldOffset(132)]
            internal byte m_paused;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ParticleSystem@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddParticleType@ParticleSystem@fl@@QEBAXPEAVParticleType@2@@Z")]
            internal static extern void AddParticleType(global::System.IntPtr instance, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveParticleType@ParticleSystem@fl@@QEBAXPEAVParticleType@2@@Z")]
            internal static extern void RemoveParticleType(global::System.IntPtr instance, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDirection@ParticleSystem@fl@@QEAAXAEBVVector3@2@AEBM@Z")]
            internal static extern void SetDirection(global::System.IntPtr instance, global::System.IntPtr direction, float deviation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpawn@ParticleSystem@fl@@QEBAPEAVISpawnParticle@2@XZ")]
            internal static extern global::System.IntPtr GetSpawn(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSpawn@ParticleSystem@fl@@QEAAXPEAVISpawnParticle@2@@Z")]
            internal static extern void SetSpawn(global::System.IntPtr instance, global::System.IntPtr spawn);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPps@ParticleSystem@fl@@QEBAMXZ")]
            internal static extern float GetPps(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPps@ParticleSystem@fl@@QEAAXAEBM@Z")]
            internal static extern void SetPps(global::System.IntPtr instance, float pps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAverageSpeed@ParticleSystem@fl@@QEBAMXZ")]
            internal static extern float GetAverageSpeed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAverageSpeed@ParticleSystem@fl@@QEAAXAEBM@Z")]
            internal static extern void SetAverageSpeed(global::System.IntPtr instance, float averageSpeed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGravityEffect@ParticleSystem@fl@@QEBAMXZ")]
            internal static extern float GetGravityEffect(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGravityEffect@ParticleSystem@fl@@QEAAXAEBM@Z")]
            internal static extern void SetGravityEffect(global::System.IntPtr instance, float gravityEffect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRandomRotation@ParticleSystem@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRandomRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRandomRotation@ParticleSystem@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetRandomRotation(global::System.IntPtr instance, bool randomRotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffsetCentre@ParticleSystem@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetOffsetCentre(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetOffsetCentre@ParticleSystem@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetOffsetCentre(global::System.IntPtr instance, global::System.IntPtr systemOffsetCentre);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpeedError@ParticleSystem@fl@@QEBAMXZ")]
            internal static extern float GetSpeedError(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSpeedError@ParticleSystem@fl@@QEAAXAEBM@Z")]
            internal static extern void SetSpeedError(global::System.IntPtr instance, float speedError);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLifeError@ParticleSystem@fl@@QEBAMXZ")]
            internal static extern float GetLifeError(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLifeError@ParticleSystem@fl@@QEAAXAEBM@Z")]
            internal static extern void SetLifeError(global::System.IntPtr instance, float lifeError);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScaleError@ParticleSystem@fl@@QEBAMXZ")]
            internal static extern float GetScaleError(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaleError@ParticleSystem@fl@@QEAAXAEBM@Z")]
            internal static extern void SetScaleError(global::System.IntPtr instance, float scaleError);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPaused@ParticleSystem@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetPaused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPaused@ParticleSystem@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetPaused(global::System.IntPtr instance, bool paused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDirection@ParticleSystem@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetDirection(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.ParticleSystem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ParticleSystem(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ParticleSystem __CreateInstance(global::FlounderSharp.ParticleSystem.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ParticleSystem(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ParticleSystem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ParticleSystem.__Internal));
            global::FlounderSharp.ParticleSystem.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ParticleSystem(global::FlounderSharp.ParticleSystem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ParticleSystem(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ParticleSystem(global::FlounderSharp.ParticleSystem _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ParticleSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ParticleSystem");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public void AddParticleType(global::FlounderSharp.ParticleType type)
        {
            var __arg0 = ReferenceEquals(type, null) ? global::System.IntPtr.Zero : type.__Instance;
            __Internal.AddParticleType((__Instance + __PointerAdjustment), __arg0);
        }

        public void RemoveParticleType(global::FlounderSharp.ParticleType type)
        {
            var __arg0 = ReferenceEquals(type, null) ? global::System.IntPtr.Zero : type.__Instance;
            __Internal.RemoveParticleType((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetDirection(global::FlounderSharp.Vector3 direction, float deviation)
        {
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = direction.__Instance;
            __Internal.SetDirection((__Instance + __PointerAdjustment), __arg0, deviation);
        }

        public global::FlounderSharp.ISpawnParticle Spawn
        {
            get
            {
                var __ret = __Internal.GetSpawn((__Instance + __PointerAdjustment));
                global::FlounderSharp.ISpawnParticle __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ISpawnParticle.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ISpawnParticle) global::FlounderSharp.ISpawnParticle.NativeToManagedMap[__ret];
                else global::FlounderSharp.ISpawnParticle.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ISpawnParticle) global::FlounderSharp.ISpawnParticle.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetSpawn((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Pps
        {
            get
            {
                var __ret = __Internal.GetPps((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPps((__Instance + __PointerAdjustment), value);
            }
        }

        public float AverageSpeed
        {
            get
            {
                var __ret = __Internal.GetAverageSpeed((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetAverageSpeed((__Instance + __PointerAdjustment), value);
            }
        }

        public float GravityEffect
        {
            get
            {
                var __ret = __Internal.GetGravityEffect((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetGravityEffect((__Instance + __PointerAdjustment), value);
            }
        }

        public bool RandomRotation
        {
            get
            {
                var __ret = __Internal.GetRandomRotation((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetRandomRotation((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Vector3 OffsetCentre
        {
            get
            {
                var __ret = __Internal.GetOffsetCentre((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetOffsetCentre((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float SpeedError
        {
            get
            {
                var __ret = __Internal.GetSpeedError((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSpeedError((__Instance + __PointerAdjustment), value);
            }
        }

        public float LifeError
        {
            get
            {
                var __ret = __Internal.GetLifeError((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetLifeError((__Instance + __PointerAdjustment), value);
            }
        }

        public float ScaleError
        {
            get
            {
                var __ret = __Internal.GetScaleError((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetScaleError((__Instance + __PointerAdjustment), value);
            }
        }

        public bool Paused
        {
            get
            {
                var __ret = __Internal.GetPaused((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPaused((__Instance + __PointerAdjustment), value);
            }
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.Vector3 Direction
        {
            get
            {
                var __ret = __Internal.GetDirection((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~ParticleSystem()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "ParticleSystem"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class RendererParticles : global::FlounderSharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererParticles@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererParticles@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.RendererParticles __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererParticles(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RendererParticles __CreateInstance(global::FlounderSharp.RendererParticles.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererParticles(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RendererParticles.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererParticles.__Internal));
            global::FlounderSharp.RendererParticles.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererParticles(global::FlounderSharp.RendererParticles.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererParticles(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public RendererParticles(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererParticles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererParticles");
        }

        public RendererParticles(global::FlounderSharp.RendererParticles _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererParticles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererParticles");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static implicit operator global::FlounderSharp.RendererParticles(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.RendererParticles(graphicsStage);
        }

        #region Virtual table interop

        // ~RendererParticles()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererParticles) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererParticles) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::FlounderSharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::FlounderSharp.Vector4.__CreateInstance(clipPlane);
            global::FlounderSharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[camera];
            else __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(camera, skipVTables: true);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class SpawnCircle : global::FlounderSharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal float m_radius;

            [FieldOffset(16)]
            internal global::System.IntPtr m_heading;

            [FieldOffset(24)]
            internal global::System.IntPtr m_spawnPosition;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnCircle@fl@@QEAA@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float radius, global::System.IntPtr heading);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnCircle@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@SpawnCircle@fl@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@SpawnCircle@fl@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeading@SpawnCircle@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetHeading(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeading@SpawnCircle@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetHeading(global::System.IntPtr instance, global::System.IntPtr heading);
        }

        internal static new global::FlounderSharp.SpawnCircle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnCircle(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SpawnCircle __CreateInstance(global::FlounderSharp.SpawnCircle.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnCircle(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SpawnCircle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnCircle.__Internal));
            global::FlounderSharp.SpawnCircle.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnCircle(global::FlounderSharp.SpawnCircle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnCircle(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public SpawnCircle(float radius, global::FlounderSharp.Vector3 heading)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnCircle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(heading, null))
                throw new global::System.ArgumentNullException("heading", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = heading.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), radius, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnCircle");
        }

        public SpawnCircle(global::FlounderSharp.SpawnCircle _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnCircle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnCircle");
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetRadius((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Vector3 Heading
        {
            get
            {
                var __ret = __Internal.GetHeading((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetHeading((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::FlounderSharp.Vector3 BaseSpawnPosition
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetBaseSpawnPositionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetBaseSpawnPositionDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~SpawnCircle()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnCircle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 *GetBaseSpawnPosition() override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetBaseSpawnPositionDelegateInstance;

        private static global::System.IntPtr _GetBaseSpawnPositionDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnCircle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.BaseSpawnPosition;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetBaseSpawnPositionDelegateInstance += _GetBaseSpawnPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetBaseSpawnPositionDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class SpawnLine : global::FlounderSharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(16)]
            internal global::System.IntPtr m_axis;

            [FieldOffset(24)]
            internal global::System.IntPtr m_spawnPosition;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnLine@fl@@QEAA@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float length, global::System.IntPtr axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnLine@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@SpawnLine@fl@@QEBAMXZ")]
            internal static extern float GetLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLength@SpawnLine@fl@@QEAAXAEBM@Z")]
            internal static extern void SetLength(global::System.IntPtr instance, float length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxis@SpawnLine@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetAxis(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAxis@SpawnLine@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetAxis(global::System.IntPtr instance, global::System.IntPtr axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpawnPosition@SpawnLine@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetSpawnPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSpawnPosition@SpawnLine@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetSpawnPosition(global::System.IntPtr instance, global::System.IntPtr spawnPosition);
        }

        internal static new global::FlounderSharp.SpawnLine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnLine(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SpawnLine __CreateInstance(global::FlounderSharp.SpawnLine.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnLine(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SpawnLine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnLine.__Internal));
            global::FlounderSharp.SpawnLine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnLine(global::FlounderSharp.SpawnLine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnLine(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public SpawnLine(float length, global::FlounderSharp.Vector3 axis)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(axis, null))
                throw new global::System.ArgumentNullException("axis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = axis.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), length, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnLine");
        }

        public SpawnLine(global::FlounderSharp.SpawnLine _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnLine");
        }

        public float Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetLength((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Vector3 Axis
        {
            get
            {
                var __ret = __Internal.GetAxis((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAxis((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Vector3 SpawnPosition
        {
            get
            {
                var __ret = __Internal.GetSpawnPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetSpawnPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::FlounderSharp.Vector3 BaseSpawnPosition
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetBaseSpawnPositionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetBaseSpawnPositionDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~SpawnLine()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnLine) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 *GetBaseSpawnPosition() override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetBaseSpawnPositionDelegateInstance;

        private static global::System.IntPtr _GetBaseSpawnPositionDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnLine) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.BaseSpawnPosition;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetBaseSpawnPositionDelegateInstance += _GetBaseSpawnPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetBaseSpawnPositionDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class SpawnPoint : global::FlounderSharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal global::System.IntPtr m_point;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnPoint@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnPoint@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?getPoint@SpawnPoint@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPoint(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?setPoint@SpawnPoint@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPoint(global::System.IntPtr instance, global::System.IntPtr point);
        }

        internal static new global::FlounderSharp.SpawnPoint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnPoint(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SpawnPoint __CreateInstance(global::FlounderSharp.SpawnPoint.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnPoint(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SpawnPoint.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnPoint.__Internal));
            global::FlounderSharp.SpawnPoint.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnPoint(global::FlounderSharp.SpawnPoint.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnPoint(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public SpawnPoint()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnPoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnPoint");
        }

        public SpawnPoint(global::FlounderSharp.SpawnPoint _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnPoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnPoint");
        }

        public global::FlounderSharp.Vector3 Point
        {
            get
            {
                var __ret = __Internal.GetPoint((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPoint((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::FlounderSharp.Vector3 BaseSpawnPosition
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetBaseSpawnPositionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetBaseSpawnPositionDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~SpawnPoint()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnPoint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 *GetBaseSpawnPosition() override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetBaseSpawnPositionDelegateInstance;

        private static global::System.IntPtr _GetBaseSpawnPositionDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnPoint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.BaseSpawnPosition;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetBaseSpawnPositionDelegateInstance += _GetBaseSpawnPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetBaseSpawnPositionDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class SpawnSphere : global::FlounderSharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal float m_radius;

            [FieldOffset(16)]
            internal global::System.IntPtr m_spawnPosition;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnSphere@fl@@QEAA@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float radius, global::System.IntPtr heading);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnSphere@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@SpawnSphere@fl@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@SpawnSphere@fl@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float radius);
        }

        internal static new global::FlounderSharp.SpawnSphere __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnSphere(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SpawnSphere __CreateInstance(global::FlounderSharp.SpawnSphere.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SpawnSphere(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SpawnSphere.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnSphere.__Internal));
            global::FlounderSharp.SpawnSphere.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnSphere(global::FlounderSharp.SpawnSphere.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnSphere(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public SpawnSphere(float radius, global::FlounderSharp.Vector3 heading)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(heading, null))
                throw new global::System.ArgumentNullException("heading", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = heading.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), radius, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnSphere");
        }

        public SpawnSphere(global::FlounderSharp.SpawnSphere _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SpawnSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.SpawnSphere");
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetRadius((__Instance + __PointerAdjustment), value);
            }
        }

        public override global::FlounderSharp.Vector3 BaseSpawnPosition
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetBaseSpawnPositionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetBaseSpawnPositionDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~SpawnSphere()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // Vector3 *GetBaseSpawnPosition() override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetBaseSpawnPositionDelegateInstance;

        private static global::System.IntPtr _GetBaseSpawnPositionDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SpawnSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.BaseSpawnPosition;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetBaseSpawnPositionDelegateInstance += _GetBaseSpawnPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetBaseSpawnPositionDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a sphere in a 3d space.</summary>
    public unsafe partial class ColliderSphere : global::FlounderSharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal float m_radius;

            [FieldOffset(64)]
            internal global::System.IntPtr m_position;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderSphere@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderSphere@fl@@QEAA@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float radius, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderSphere@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@ColliderSphere@fl@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@ColliderSphere@fl@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@ColliderSphere@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@ColliderSphere@fl@@QEBAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.ColliderSphere __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ColliderSphere(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ColliderSphere __CreateInstance(global::FlounderSharp.ColliderSphere.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ColliderSphere(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ColliderSphere.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderSphere.__Internal));
            global::FlounderSharp.ColliderSphere.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderSphere(global::FlounderSharp.ColliderSphere.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderSphere(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new unit sphere</summary>
        public ColliderSphere()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.ColliderSphere");
        }

        /// <summary>Creates a new sphere</summary>
        /// <param name="radius">The spheres radius.</param>
        /// <param name="position">The spheres initial position.</param>
        public ColliderSphere(float radius, global::FlounderSharp.Vector3 position)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), radius, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.ColliderSphere");
        }

        /// <summary>Creates a new sphere from another sphere source.</summary>
        /// <param name="source">The source to create off of.</param>
        public ColliderSphere(global::FlounderSharp.ColliderSphere source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ColliderSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ColliderSphere");
        }

        public override global::FlounderSharp.Collider Update(global::FlounderSharp.Transform transform, global::FlounderSharp.Collider destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            var __arg1 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = ___UpdateDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            global::FlounderSharp.Collider __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[__ret];
            else global::FlounderSharp.Collider.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(__ret);
            return __result0;
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            base.Load(value);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            base.Write(value);
        }

        public override global::FlounderSharp.Vector3 ResolveCollision(global::FlounderSharp.Collider other, global::FlounderSharp.Vector3 positionDelta, global::FlounderSharp.Vector3 destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___ResolveCollisionDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            if (ReferenceEquals(positionDelta, null))
                throw new global::System.ArgumentNullException("positionDelta", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = positionDelta.__Instance;
            var __arg2 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            var __ret = ___ResolveCollisionDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            global::FlounderSharp.Vector3 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
            return __result0;
        }

        public override global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Collider other)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
            var ___IntersectsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::FlounderSharp.Intersect.__Internal();
            ___IntersectsDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Intersect.__CreateInstance(__ret);
        }

        public override global::FlounderSharp.Intersect Intersects(global::FlounderSharp.Ray ray)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___Intersects_1Delegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(ray, null))
                throw new global::System.ArgumentNullException("ray", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = ray.__Instance;
            var __ret = new global::FlounderSharp.Intersect.__Internal();
            ___Intersects_1Delegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Intersect.__CreateInstance(__ret);
        }

        public override bool InFrustum(global::FlounderSharp.Frustum frustum)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
            var ___InFrustumDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(frustum, null))
                throw new global::System.ArgumentNullException("frustum", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frustum.__Instance;
            var __ret = ___InFrustumDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override bool Contains(global::FlounderSharp.Collider other)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
            var ___ContainsDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override bool Contains(global::FlounderSharp.Vector3 point)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
            var ___Contains_1Delegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(point, null))
                throw new global::System.ArgumentNullException("point", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = point.__Instance;
            var __ret = ___Contains_1Delegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public float MRadius
        {
            get
            {
                return ((global::FlounderSharp.ColliderSphere.__Internal*) __Instance)->m_radius;
            }

            set
            {
                ((global::FlounderSharp.ColliderSphere.__Internal*)__Instance)->m_radius = value;
            }
        }

        public global::FlounderSharp.Vector3 MPosition
        {
            get
            {
                global::FlounderSharp.Vector3 __result0;
                if (((global::FlounderSharp.ColliderSphere.__Internal*) __Instance)->m_position == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(((global::FlounderSharp.ColliderSphere.__Internal*) __Instance)->m_position))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[((global::FlounderSharp.ColliderSphere.__Internal*) __Instance)->m_position];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(((global::FlounderSharp.ColliderSphere.__Internal*) __Instance)->m_position);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.ColliderSphere.__Internal*)__Instance)->m_position = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetRadius((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~ColliderSphere()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "ColliderSphere"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Collider *Update(const Transform &transform, Collider *destination) override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr _UpdateDelegateInstance;

        private static global::System.IntPtr _UpdateDelegateHook(global::System.IntPtr instance, global::System.IntPtr transform, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Transform __result0;
            if (transform == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Transform.NativeToManagedMap.ContainsKey(transform))
                __result0 = (global::FlounderSharp.Transform) global::FlounderSharp.Transform.NativeToManagedMap[transform];
            else __result0 = global::FlounderSharp.Transform.__CreateInstance(transform);
            global::FlounderSharp.Collider __result1;
            if (destination == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(destination))
                __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[destination];
            else __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(destination, skipVTables: true);
            var __ret = __target.Update(__result0, __result1);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Vector3 *ResolveCollision(const Collider &other, const Vector3 &positionDelta, Vector3 *destination) override
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr_IntPtr_IntPtr_IntPtr _ResolveCollisionDelegateInstance;

        private static global::System.IntPtr _ResolveCollisionDelegateHook(global::System.IntPtr instance, global::System.IntPtr other, global::System.IntPtr positionDelta, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result0;
            if (other == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            global::FlounderSharp.Vector3 __result1;
            if (positionDelta == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(positionDelta))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[positionDelta];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(positionDelta);
            global::FlounderSharp.Vector3 __result2;
            if (destination == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(destination))
                __result2 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[destination];
            else __result2 = global::FlounderSharp.Vector3.__CreateInstance(destination);
            var __ret = __target.ResolveCollision(__result0, __result1, __result2);
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        // Intersect Intersects(const Ray &ray) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _Intersects_1DelegateInstance;

        private static void _Intersects_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr ray)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Ray __result1;
            if (ray == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Ray.NativeToManagedMap.ContainsKey(ray))
                __result1 = (global::FlounderSharp.Ray) global::FlounderSharp.Ray.NativeToManagedMap[ray];
            else __result1 = global::FlounderSharp.Ray.__CreateInstance(ray);
            var __ret = __target.Intersects(__result1);
            *(global::FlounderSharp.Intersect.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Intersect.__Internal() : *(global::FlounderSharp.Intersect.__Internal*) __ret.__Instance;
        }

        // Intersect Intersects(const Collider &other) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _IntersectsDelegateInstance;

        private static void _IntersectsDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result1;
            if (other == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result1 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            var __ret = __target.Intersects(__result1);
            *(global::FlounderSharp.Intersect.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Intersect.__Internal() : *(global::FlounderSharp.Intersect.__Internal*) __ret.__Instance;
        }

        // bool InFrustum(const Frustum &frustum) override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _InFrustumDelegateInstance;

        private static bool _InFrustumDelegateHook(global::System.IntPtr instance, global::System.IntPtr frustum)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Frustum __result0;
            if (frustum == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Frustum.NativeToManagedMap.ContainsKey(frustum))
                __result0 = (global::FlounderSharp.Frustum) global::FlounderSharp.Frustum.NativeToManagedMap[frustum];
            else __result0 = global::FlounderSharp.Frustum.__CreateInstance(frustum);
            var __ret = __target.InFrustum(__result0);
            return __ret;
        }

        // bool Contains(const Vector3 &point) override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _Contains_1DelegateInstance;

        private static bool _Contains_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr point)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result0;
            if (point == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(point))
                __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[point];
            else __result0 = global::FlounderSharp.Vector3.__CreateInstance(point);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        // bool Contains(const Collider &other) override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr other)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Collider __result0;
            if (other == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(other))
                __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[other];
            else __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(other, skipVTables: true);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[12];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _ResolveCollisionDelegateInstance += _ResolveCollisionDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ResolveCollisionDelegateInstance).ToPointer();
                _Intersects_1DelegateInstance += _Intersects_1DelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_Intersects_1DelegateInstance).ToPointer();
                _IntersectsDelegateInstance += _IntersectsDelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_IntersectsDelegateInstance).ToPointer();
                _InFrustumDelegateInstance += _InFrustumDelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_InFrustumDelegateInstance).ToPointer();
                _Contains_1DelegateInstance += _Contains_1DelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_Contains_1DelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                    *(void**) (vfptr0 + 88) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 88);
                    *(void**) (vfptr0 + 96) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 96);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                    *(void**) (vfptr0 + 72) = _Thunks[8];
                    *(void**) (vfptr0 + 80) = _Thunks[9];
                    *(void**) (vfptr0 + 88) = _Thunks[10];
                    *(void**) (vfptr0 + 96) = _Thunks[11];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class Rigidbody : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal float m_mass;

            [FieldOffset(60)]
            internal float m_drag;

            [FieldOffset(64)]
            internal byte m_useGravity;

            [FieldOffset(72)]
            internal global::System.IntPtr m_freezePosition;

            [FieldOffset(80)]
            internal global::System.IntPtr m_freezeRotation;

            [FieldOffset(88)]
            internal global::System.IntPtr m_colliderCopy;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Rigidbody@fl@@QEAA@AEBM0AEB_NAEBVConstraint3@1@2@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float mass, float drag, bool useGravity, global::System.IntPtr freezePosition, global::System.IntPtr freezeRotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Rigidbody@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ResolveCollisions@Rigidbody@fl@@QEAA?AVVector3@2@AEBV32@@Z")]
            internal static extern void ResolveCollisions(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUseGravity@Rigidbody@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetUseGravity(global::System.IntPtr instance, bool useGravity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMass@Rigidbody@fl@@QEBAMXZ")]
            internal static extern float GetMass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMass@Rigidbody@fl@@QEAAXAEBM@Z")]
            internal static extern void SetMass(global::System.IntPtr instance, float mass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDrag@Rigidbody@fl@@QEBAMXZ")]
            internal static extern float GetDrag(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDrag@Rigidbody@fl@@QEAAXAEBM@Z")]
            internal static extern void SetDrag(global::System.IntPtr instance, float drag);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFreezePosition@Rigidbody@fl@@QEBAPEAVConstraint3@2@XZ")]
            internal static extern global::System.IntPtr GetFreezePosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFreezePosition@Rigidbody@fl@@QEBAXAEBVConstraint3@2@@Z")]
            internal static extern void SetFreezePosition(global::System.IntPtr instance, global::System.IntPtr freezePosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFreezeRotation@Rigidbody@fl@@QEBAPEAVConstraint3@2@XZ")]
            internal static extern global::System.IntPtr GetFreezeRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFreezeRotation@Rigidbody@fl@@QEBAXAEBVConstraint3@2@@Z")]
            internal static extern void SetFreezeRotation(global::System.IntPtr instance, global::System.IntPtr freezeRotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsUseGravity@Rigidbody@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsUseGravity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCollider@Rigidbody@fl@@QEBAPEAVCollider@2@XZ")]
            internal static extern global::System.IntPtr GetCollider(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Rigidbody __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Rigidbody(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Rigidbody __CreateInstance(global::FlounderSharp.Rigidbody.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Rigidbody(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Rigidbody.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Rigidbody.__Internal));
            global::FlounderSharp.Rigidbody.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Rigidbody(global::FlounderSharp.Rigidbody.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Rigidbody(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public Rigidbody(float mass, float drag, bool useGravity, global::FlounderSharp.Constraint3 freezePosition, global::FlounderSharp.Constraint3 freezeRotation)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Rigidbody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(freezePosition, null))
                throw new global::System.ArgumentNullException("freezePosition", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = freezePosition.__Instance;
            if (ReferenceEquals(freezeRotation, null))
                throw new global::System.ArgumentNullException("freezeRotation", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = freezeRotation.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), mass, drag, useGravity, __arg3, __arg4);
            SetupVTables(GetType().FullName == "FlounderSharp.Rigidbody");
        }

        public Rigidbody(global::FlounderSharp.Rigidbody _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Rigidbody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Rigidbody");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public global::FlounderSharp.Vector3 ResolveCollisions(global::FlounderSharp.Vector3 amount)
        {
            if (ReferenceEquals(amount, null))
                throw new global::System.ArgumentNullException("amount", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = amount.__Instance;
            var __ret = new global::FlounderSharp.Vector3.__Internal();
            __Internal.ResolveCollisions((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::FlounderSharp.Vector3.__CreateInstance(__ret);
        }

        public void SetUseGravity(bool useGravity)
        {
            __Internal.SetUseGravity((__Instance + __PointerAdjustment), useGravity);
        }

        public float Mass
        {
            get
            {
                var __ret = __Internal.GetMass((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetMass((__Instance + __PointerAdjustment), value);
            }
        }

        public float Drag
        {
            get
            {
                var __ret = __Internal.GetDrag((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetDrag((__Instance + __PointerAdjustment), value);
            }
        }

        public global::FlounderSharp.Constraint3 FreezePosition
        {
            get
            {
                var __ret = __Internal.GetFreezePosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Constraint3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Constraint3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Constraint3) global::FlounderSharp.Constraint3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Constraint3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetFreezePosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Constraint3 FreezeRotation
        {
            get
            {
                var __ret = __Internal.GetFreezeRotation((__Instance + __PointerAdjustment));
                global::FlounderSharp.Constraint3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Constraint3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Constraint3) global::FlounderSharp.Constraint3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Constraint3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetFreezeRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public bool IsUseGravity
        {
            get
            {
                var __ret = __Internal.IsUseGravity((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.Collider Collider
        {
            get
            {
                var __ret = __Internal.GetCollider((__Instance + __PointerAdjustment));
                global::FlounderSharp.Collider __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Collider.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.NativeToManagedMap[__ret];
                else global::FlounderSharp.Collider.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Collider) global::FlounderSharp.Collider.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Rigidbody()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "Rigidbody"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A structure of spatial objects for a 3D space.</summary>
    public unsafe partial class SceneStructure : global::FlounderSharp.ISpatialStructure, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpatialStructure;

            [FieldOffset(8)]
            internal global::System.IntPtr m_objects;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SceneStructure@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SceneStructure@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.SceneStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SceneStructure(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SceneStructure __CreateInstance(global::FlounderSharp.SceneStructure.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SceneStructure(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SceneStructure.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SceneStructure.__Internal));
            global::FlounderSharp.SceneStructure.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SceneStructure(global::FlounderSharp.SceneStructure.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SceneStructure(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new basic structure.</summary>
        public SceneStructure()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SceneStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.SceneStructure");
        }

        public SceneStructure(global::FlounderSharp.SceneStructure _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SceneStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.SceneStructure");
        }

        public override void Add(global::FlounderSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___AddDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            ___AddDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Remove(global::FlounderSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___RemoveDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            ___RemoveDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___ClearDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override bool Contains(global::FlounderSharp.GameObject targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
            var ___ContainsDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override uint Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetSizeDelegate = (global::FlounderSharp.Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_uint_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~SceneStructure()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Add(GameObject *object) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _AddDelegateInstance;

        private static void _AddDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.__CreateInstance(targetObject, skipVTables: true);
            __target.Add(__result0);
        }

        // void Remove(GameObject *object) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RemoveDelegateInstance;

        private static void _RemoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.__CreateInstance(targetObject, skipVTables: true);
            __target.Remove(__result0);
        }

        // void Clear() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // unsigned int GetSize() override { return m_objects->size(); }
        private static global::FlounderSharp.Delegates.Func_uint_IntPtr _GetSizeDelegateInstance;

        private static uint _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        // bool Contains(GameObject *object) override
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.GameObject __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.GameObject.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.GameObject) global::FlounderSharp.GameObject.__CreateInstance(targetObject, skipVTables: true);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _AddDelegateInstance += _AddDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                _RemoveDelegateInstance += _RemoveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 80);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                    *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                    *(void**) (vfptr0 + 80) = _Thunks[5];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a loaded cubemap texture.</summary>
    public unsafe partial class Cubemap : global::FlounderSharp.IResource, global::FlounderSharp.IBuffer, global::FlounderSharp.IIDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 192)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::System.IntPtr vfptr_Buffer;

            [FieldOffset(16)]
            internal ulong m_size;

            [FieldOffset(24)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(32)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(40)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(48)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(80)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_fileExt;

            [FieldOffset(112)]
            internal uint m_mipLevels;

            [FieldOffset(116)]
            internal int m_components;

            [FieldOffset(120)]
            internal int m_width;

            [FieldOffset(124)]
            internal int m_height;

            [FieldOffset(128)]
            internal int m_depth;

            [FieldOffset(136)]
            internal global::System.IntPtr m_image;

            [FieldOffset(144)]
            internal global::System.IntPtr m_imageView;

            [FieldOffset(152)]
            internal global::System.IntPtr m_sampler;

            [FieldOffset(160)]
            internal global::VkFormat m_format;

            [FieldOffset(168)]
            internal global::VkDescriptorImageInfo.__Internal m_imageInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Cubemap@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, global::System.IntPtr fileExt, bool mipmap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Cubemap@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@Cubemap@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename, global::System.IntPtr fileExt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateDescriptor@Cubemap@fl@@SA?AVDescriptorType@2@AEBI0@Z")]
            internal static extern void CreateDescriptor(global::System.IntPtr @return, uint binding, uint stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVkSize@Buffer@fl@@QEBA_KXZ")]
            internal static extern ulong GetVkSize(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Cubemap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Cubemap(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Cubemap __CreateInstance(global::FlounderSharp.Cubemap.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Cubemap(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Cubemap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Cubemap.__Internal));
            global::FlounderSharp.Cubemap.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Cubemap(global::FlounderSharp.Cubemap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Cubemap(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8), *(void**) (__Instance + 40) };
            else
                SetupVTables(true);
        }

        /// <summary>A new cubemap object.</summary>
        public Cubemap(string filename, string fileExt, bool mipmap)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Cubemap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(fileExt, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, mipmap);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.Cubemap");
        }

        public Cubemap(global::FlounderSharp.Cubemap _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Cubemap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Cubemap");
        }

        public static global::FlounderSharp.Cubemap Resource(string filename, string fileExt)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(fileExt, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.Resource(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            global::FlounderSharp.Cubemap __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Cubemap.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Cubemap) global::FlounderSharp.Cubemap.NativeToManagedMap[__ret];
            else global::FlounderSharp.Cubemap.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Cubemap) global::FlounderSharp.Cubemap.__CreateInstance(__ret);
            return __result0;
        }

        public static global::FlounderSharp.DescriptorType CreateDescriptor(uint binding, uint stage)
        {
            var __ret = new global::FlounderSharp.DescriptorType.__Internal();
            __Internal.CreateDescriptor(new IntPtr(&__ret), binding, stage);
            return global::FlounderSharp.DescriptorType.__CreateInstance(__ret);
        }

        protected ulong MSize
        {
            get
            {
                return ((global::FlounderSharp.Cubemap.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::FlounderSharp.Cubemap.__Internal*)__Instance)->m_size = value;
            }
        }

        public global::System.IntPtr __PointerToBuffer
        {
            get
            {
                return __Instance + 8;
            }
        }

        public global::System.IntPtr __PointerToIDescriptor
        {
            get
            {
                return __Instance + 40;
            }
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public ulong VkSize
        {
            get
            {
                var __ret = __Internal.GetVkSize((__Instance + 8));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Cubemap()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Cubemap) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Cubemap) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8), *(void**) (__Instance + 40) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[3];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    var vfptr1 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 0);
                    *(void**) (vfptr1 + 8) = _Thunks[0];
                    var vfptr2 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[2] = vfptr2.ToPointer();
                    *(void**) (vfptr2 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 0);
                    *(void**) (vfptr2 + 8) = _Thunks[0];
                    *(void**) (vfptr2 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                *(void**) (__Instance + 8) = __ManagedVTablesDtorOnly[1];
                *(void**) (__Instance + 40) = __ManagedVTablesDtorOnly[2];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[3];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    var vfptr1 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 0);
                    *(void**) (vfptr1 + 8) = _Thunks[0];
                    var vfptr2 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[2] = vfptr2.ToPointer();
                    *(void**) (vfptr2 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 0);
                    *(void**) (vfptr2 + 8) = _Thunks[0];
                    *(void**) (vfptr2 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 40 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
                *(void**) (__Instance + 8) = __ManagedVTables[1];
                *(void**) (__Instance + 40) = __ManagedVTables[2];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class RendererDeferred : global::FlounderSharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(24)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(32)]
            internal global::System.IntPtr m_model;

            [FieldOffset(40)]
            internal global::System.IntPtr m_brdflut;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererDeferred@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererDeferred@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.RendererDeferred __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererDeferred(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RendererDeferred __CreateInstance(global::FlounderSharp.RendererDeferred.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererDeferred(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RendererDeferred.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererDeferred.__Internal));
            global::FlounderSharp.RendererDeferred.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererDeferred(global::FlounderSharp.RendererDeferred.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererDeferred(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public RendererDeferred(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererDeferred.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererDeferred");
        }

        public RendererDeferred(global::FlounderSharp.RendererDeferred _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererDeferred.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererDeferred");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static implicit operator global::FlounderSharp.RendererDeferred(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.RendererDeferred(graphicsStage);
        }

        #region Virtual table interop

        // ~RendererDeferred()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererDeferred) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererDeferred) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::FlounderSharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::FlounderSharp.Vector4.__CreateInstance(clipPlane);
            global::FlounderSharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[camera];
            else __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(camera, skipVTables: true);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a post effect shader and on application saves the result into a fbo.</summary>
    public unsafe partial class IPostFilter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPostFilter@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorSet@IPostFilter@fl@@QEBAPEAVDescriptorsHandler@2@XZ")]
            internal static extern global::System.IntPtr GetDescriptorSet(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipeline@IPostFilter@fl@@QEBAPEAVPipeline@2@XZ")]
            internal static extern global::System.IntPtr GetPipeline(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModel@IPostFilter@fl@@QEBAPEAVModel@2@XZ")]
            internal static extern global::System.IntPtr GetModel(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IPostFilter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IPostFilter>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IPostFilter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IPostFilter(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IPostFilter __CreateInstance(global::FlounderSharp.IPostFilter.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IPostFilter(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.IPostFilter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IPostFilter.__Internal));
            global::FlounderSharp.IPostFilter.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private IPostFilter(global::FlounderSharp.IPostFilter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IPostFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public IPostFilter(global::FlounderSharp.IPostFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IPostFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IPostFilter");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IPostFilter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->vfptr_IPostFilter = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Renders the filter.</summary>
        public virtual void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        protected global::FlounderSharp.DescriptorsHandler MDescriptorSet
        {
            get
            {
                global::FlounderSharp.DescriptorsHandler __result0;
                if (((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_descriptorSet == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_descriptorSet))
                    __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_descriptorSet];
                else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_descriptorSet);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.IPostFilter.__Internal*)__Instance)->m_descriptorSet = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        protected global::FlounderSharp.Pipeline MPipeline
        {
            get
            {
                global::FlounderSharp.Pipeline __result0;
                if (((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_pipeline == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Pipeline.NativeToManagedMap.ContainsKey(((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_pipeline))
                    __result0 = (global::FlounderSharp.Pipeline) global::FlounderSharp.Pipeline.NativeToManagedMap[((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_pipeline];
                else __result0 = global::FlounderSharp.Pipeline.__CreateInstance(((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_pipeline);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.IPostFilter.__Internal*)__Instance)->m_pipeline = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        protected global::FlounderSharp.Model MModel
        {
            get
            {
                global::FlounderSharp.Model __result0;
                if (((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_model == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Model.NativeToManagedMap.ContainsKey(((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_model))
                    __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.NativeToManagedMap[((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_model];
                else global::FlounderSharp.Model.NativeToManagedMap[((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_model] = __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.__CreateInstance(((global::FlounderSharp.IPostFilter.__Internal*) __Instance)->m_model);
                return __result0;
            }

            set
            {
                ((global::FlounderSharp.IPostFilter.__Internal*)__Instance)->m_model = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::FlounderSharp.DescriptorsHandler DescriptorSet
        {
            get
            {
                var __ret = __Internal.GetDescriptorSet((__Instance + __PointerAdjustment));
                global::FlounderSharp.DescriptorsHandler __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Pipeline Pipeline
        {
            get
            {
                var __ret = __Internal.GetPipeline((__Instance + __PointerAdjustment));
                global::FlounderSharp.Pipeline __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Pipeline.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Pipeline) global::FlounderSharp.Pipeline.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Pipeline.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Model Model
        {
            get
            {
                var __ret = __Internal.GetModel((__Instance + __PointerAdjustment));
                global::FlounderSharp.Model __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Model.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.NativeToManagedMap[__ret];
                else global::FlounderSharp.Model.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Model) global::FlounderSharp.Model.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // virtual ~IPostFilter()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IPostFilter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IPostFilter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterCrt : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal global::System.IntPtr m_screenColour;

            [FieldOffset(48)]
            internal float m_curveAmountX;

            [FieldOffset(52)]
            internal float m_curveAmountY;

            [FieldOffset(56)]
            internal float m_scanLineSize;

            [FieldOffset(60)]
            internal float m_scanIntensity;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterCrt@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterCrt@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScreenColour@FilterCrt@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetScreenColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScreenColour@FilterCrt@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetScreenColour(global::System.IntPtr instance, global::System.IntPtr screenColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurveAmountX@FilterCrt@fl@@QEBAMXZ")]
            internal static extern float GetCurveAmountX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCurveAmountX@FilterCrt@fl@@QEAAXAEBM@Z")]
            internal static extern void SetCurveAmountX(global::System.IntPtr instance, float curveAmountX);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurveAmountY@FilterCrt@fl@@QEBAMXZ")]
            internal static extern float GetCurveAmountY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCurveAmountY@FilterCrt@fl@@QEAAXAEBM@Z")]
            internal static extern void SetCurveAmountY(global::System.IntPtr instance, float curveAmountY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScanLineSize@FilterCrt@fl@@QEBAMXZ")]
            internal static extern float GetScanLineSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScanLineSize@FilterCrt@fl@@QEAAXAEBM@Z")]
            internal static extern void SetScanLineSize(global::System.IntPtr instance, float scanLineSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScanIntensity@FilterCrt@fl@@QEBAMXZ")]
            internal static extern float GetScanIntensity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScanIntensity@FilterCrt@fl@@QEAAXAEBM@Z")]
            internal static extern void SetScanIntensity(global::System.IntPtr instance, float scanIntensity);
        }

        internal static new global::FlounderSharp.FilterCrt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterCrt(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterCrt __CreateInstance(global::FlounderSharp.FilterCrt.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterCrt(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterCrt.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterCrt.__Internal));
            global::FlounderSharp.FilterCrt.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterCrt(global::FlounderSharp.FilterCrt.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterCrt(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterCrt(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterCrt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterCrt");
        }

        public FilterCrt(global::FlounderSharp.FilterCrt _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterCrt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterCrt");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterCrt(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterCrt(graphicsStage);
        }

        public global::FlounderSharp.Colour ScreenColour
        {
            get
            {
                var __ret = __Internal.GetScreenColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScreenColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float CurveAmountX
        {
            get
            {
                var __ret = __Internal.GetCurveAmountX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCurveAmountX((__Instance + __PointerAdjustment), value);
            }
        }

        public float CurveAmountY
        {
            get
            {
                var __ret = __Internal.GetCurveAmountY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCurveAmountY((__Instance + __PointerAdjustment), value);
            }
        }

        public float ScanLineSize
        {
            get
            {
                var __ret = __Internal.GetScanLineSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetScanLineSize((__Instance + __PointerAdjustment), value);
            }
        }

        public float ScanIntensity
        {
            get
            {
                var __ret = __Internal.GetScanIntensity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetScanIntensity((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterCrt()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterCrt) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterCrt) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterDarken : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal float m_factor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDarken@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDarken@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFactor@FilterDarken@fl@@QEBAMXZ")]
            internal static extern float GetFactor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFactor@FilterDarken@fl@@QEAAXAEBM@Z")]
            internal static extern void SetFactor(global::System.IntPtr instance, float factor);
        }

        internal static new global::FlounderSharp.FilterDarken __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterDarken(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterDarken __CreateInstance(global::FlounderSharp.FilterDarken.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterDarken(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterDarken.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterDarken.__Internal));
            global::FlounderSharp.FilterDarken.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterDarken(global::FlounderSharp.FilterDarken.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterDarken(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterDarken(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterDarken.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterDarken");
        }

        public FilterDarken(global::FlounderSharp.FilterDarken _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterDarken.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterDarken");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterDarken(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterDarken(graphicsStage);
        }

        public float Factor
        {
            get
            {
                var __ret = __Internal.GetFactor((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFactor((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterDarken()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterDarken) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterDarken) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterDefault : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDefault@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDefault@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.FilterDefault __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterDefault(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterDefault __CreateInstance(global::FlounderSharp.FilterDefault.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterDefault(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterDefault.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterDefault.__Internal));
            global::FlounderSharp.FilterDefault.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterDefault(global::FlounderSharp.FilterDefault.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterDefault(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterDefault(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterDefault.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterDefault");
        }

        public FilterDefault(global::FlounderSharp.FilterDefault _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterDefault.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterDefault");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterDefault(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterDefault(graphicsStage);
        }

        #region Virtual table interop

        // ~FilterDefault()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterEmboss : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterEmboss@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterEmboss@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.FilterEmboss __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterEmboss(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterEmboss __CreateInstance(global::FlounderSharp.FilterEmboss.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterEmboss(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterEmboss.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterEmboss.__Internal));
            global::FlounderSharp.FilterEmboss.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterEmboss(global::FlounderSharp.FilterEmboss.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterEmboss(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterEmboss(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterEmboss.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterEmboss");
        }

        public FilterEmboss(global::FlounderSharp.FilterEmboss _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterEmboss.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterEmboss");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterEmboss(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterEmboss(graphicsStage);
        }

        #region Virtual table interop

        // ~FilterEmboss()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterEmboss) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterEmboss) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterFxaa : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal float m_spanMax;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterFxaa@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterFxaa@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpanMax@FilterFxaa@fl@@QEBAMXZ")]
            internal static extern float GetSpanMax(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSpanMax@FilterFxaa@fl@@QEAAXAEBM@Z")]
            internal static extern void SetSpanMax(global::System.IntPtr instance, float spanMax);
        }

        internal static new global::FlounderSharp.FilterFxaa __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterFxaa(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterFxaa __CreateInstance(global::FlounderSharp.FilterFxaa.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterFxaa(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterFxaa.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterFxaa.__Internal));
            global::FlounderSharp.FilterFxaa.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterFxaa(global::FlounderSharp.FilterFxaa.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterFxaa(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterFxaa(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterFxaa.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterFxaa");
        }

        public FilterFxaa(global::FlounderSharp.FilterFxaa _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterFxaa.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterFxaa");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterFxaa(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterFxaa(graphicsStage);
        }

        public float SpanMax
        {
            get
            {
                var __ret = __Internal.GetSpanMax((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSpanMax((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterFxaa()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterFxaa) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterFxaa) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterGrain : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal float m_strength;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrain@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrain@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStrength@FilterGrain@fl@@QEBAMXZ")]
            internal static extern float GetStrength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStrength@FilterGrain@fl@@QEAAXAEBM@Z")]
            internal static extern void SetStrength(global::System.IntPtr instance, float strength);
        }

        internal static new global::FlounderSharp.FilterGrain __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterGrain(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterGrain __CreateInstance(global::FlounderSharp.FilterGrain.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterGrain(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterGrain.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterGrain.__Internal));
            global::FlounderSharp.FilterGrain.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterGrain(global::FlounderSharp.FilterGrain.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterGrain(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterGrain(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterGrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterGrain");
        }

        public FilterGrain(global::FlounderSharp.FilterGrain _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterGrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterGrain");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterGrain(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterGrain(graphicsStage);
        }

        public float Strength
        {
            get
            {
                var __ret = __Internal.GetStrength((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetStrength((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterGrain()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterGrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterGrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterGrey : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrey@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrey@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.FilterGrey __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterGrey(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterGrey __CreateInstance(global::FlounderSharp.FilterGrey.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterGrey(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterGrey.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterGrey.__Internal));
            global::FlounderSharp.FilterGrey.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterGrey(global::FlounderSharp.FilterGrey.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterGrey(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterGrey(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterGrey.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterGrey");
        }

        public FilterGrey(global::FlounderSharp.FilterGrey _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterGrey.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterGrey");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterGrey(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterGrey(graphicsStage);
        }

        #region Virtual table interop

        // ~FilterGrey()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterGrey) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterGrey) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterLensflare : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal global::System.IntPtr m_sunPosition;

            [FieldOffset(48)]
            internal float m_sunHeight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterLensflare@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterLensflare@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunPosition@FilterLensflare@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetSunPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSunPosition@FilterLensflare@fl@@QEBAXAEBVVector3@2@@Z")]
            internal static extern void SetSunPosition(global::System.IntPtr instance, global::System.IntPtr sunPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunHeight@FilterLensflare@fl@@QEBAMXZ")]
            internal static extern float GetSunHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSunHeight@FilterLensflare@fl@@QEAAXAEBM@Z")]
            internal static extern void SetSunHeight(global::System.IntPtr instance, float sunHeight);
        }

        internal static new global::FlounderSharp.FilterLensflare __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterLensflare(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterLensflare __CreateInstance(global::FlounderSharp.FilterLensflare.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterLensflare(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterLensflare.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterLensflare.__Internal));
            global::FlounderSharp.FilterLensflare.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterLensflare(global::FlounderSharp.FilterLensflare.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterLensflare(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterLensflare(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterLensflare.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterLensflare");
        }

        public FilterLensflare(global::FlounderSharp.FilterLensflare _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterLensflare.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterLensflare");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterLensflare(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterLensflare(graphicsStage);
        }

        public global::FlounderSharp.Vector3 SunPosition
        {
            get
            {
                var __ret = __Internal.GetSunPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetSunPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float SunHeight
        {
            get
            {
                var __ret = __Internal.GetSunHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSunHeight((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterLensflare()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterLensflare) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterLensflare) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterNegative : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterNegative@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterNegative@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.FilterNegative __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterNegative(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterNegative __CreateInstance(global::FlounderSharp.FilterNegative.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterNegative(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterNegative.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterNegative.__Internal));
            global::FlounderSharp.FilterNegative.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterNegative(global::FlounderSharp.FilterNegative.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterNegative(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterNegative(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterNegative.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterNegative");
        }

        public FilterNegative(global::FlounderSharp.FilterNegative _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterNegative.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterNegative");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterNegative(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterNegative(graphicsStage);
        }

        #region Virtual table interop

        // ~FilterNegative()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterNegative) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterNegative) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterPixel : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal float m_pixelSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterPixel@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterPixel@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPixelSize@FilterPixel@fl@@QEBAMXZ")]
            internal static extern float GetPixelSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPixelSize@FilterPixel@fl@@QEAAXAEBM@Z")]
            internal static extern void SetPixelSize(global::System.IntPtr instance, float pixelSize);
        }

        internal static new global::FlounderSharp.FilterPixel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterPixel(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterPixel __CreateInstance(global::FlounderSharp.FilterPixel.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterPixel(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterPixel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterPixel.__Internal));
            global::FlounderSharp.FilterPixel.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterPixel(global::FlounderSharp.FilterPixel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterPixel(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterPixel(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterPixel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterPixel");
        }

        public FilterPixel(global::FlounderSharp.FilterPixel _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterPixel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterPixel");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterPixel(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterPixel(graphicsStage);
        }

        public float PixelSize
        {
            get
            {
                var __ret = __Internal.GetPixelSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPixelSize((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterPixel()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterPixel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterPixel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterSepia : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterSepia@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterSepia@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.FilterSepia __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterSepia(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterSepia __CreateInstance(global::FlounderSharp.FilterSepia.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterSepia(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterSepia.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterSepia.__Internal));
            global::FlounderSharp.FilterSepia.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterSepia(global::FlounderSharp.FilterSepia.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterSepia(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterSepia(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterSepia.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterSepia");
        }

        public FilterSepia(global::FlounderSharp.FilterSepia _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterSepia.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterSepia");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterSepia(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterSepia(graphicsStage);
        }

        #region Virtual table interop

        // ~FilterSepia()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterSepia) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterSepia) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterTiltshift : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal float m_blurAmount;

            [FieldOffset(44)]
            internal float m_centre;

            [FieldOffset(48)]
            internal float m_stepSize;

            [FieldOffset(52)]
            internal float m_steps;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTiltshift@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTiltshift@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBlurAmount@FilterTiltshift@fl@@QEBAMXZ")]
            internal static extern float GetBlurAmount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBlurAmount@FilterTiltshift@fl@@QEAAXAEBM@Z")]
            internal static extern void SetBlurAmount(global::System.IntPtr instance, float blurAmount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCentre@FilterTiltshift@fl@@QEBAMXZ")]
            internal static extern float GetCentre(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCentre@FilterTiltshift@fl@@QEAAXAEBM@Z")]
            internal static extern void SetCentre(global::System.IntPtr instance, float centre);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStepSize@FilterTiltshift@fl@@QEBAMXZ")]
            internal static extern float GetStepSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStepSize@FilterTiltshift@fl@@QEAAXAEBM@Z")]
            internal static extern void SetStepSize(global::System.IntPtr instance, float stepSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSteps@FilterTiltshift@fl@@QEBAMXZ")]
            internal static extern float GetSteps(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSteps@FilterTiltshift@fl@@QEAAXAEBM@Z")]
            internal static extern void SetSteps(global::System.IntPtr instance, float steps);
        }

        internal static new global::FlounderSharp.FilterTiltshift __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterTiltshift(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterTiltshift __CreateInstance(global::FlounderSharp.FilterTiltshift.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterTiltshift(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterTiltshift.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterTiltshift.__Internal));
            global::FlounderSharp.FilterTiltshift.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterTiltshift(global::FlounderSharp.FilterTiltshift.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterTiltshift(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterTiltshift(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterTiltshift.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterTiltshift");
        }

        public FilterTiltshift(global::FlounderSharp.FilterTiltshift _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterTiltshift.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterTiltshift");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterTiltshift(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterTiltshift(graphicsStage);
        }

        public float BlurAmount
        {
            get
            {
                var __ret = __Internal.GetBlurAmount((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetBlurAmount((__Instance + __PointerAdjustment), value);
            }
        }

        public float Centre
        {
            get
            {
                var __ret = __Internal.GetCentre((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCentre((__Instance + __PointerAdjustment), value);
            }
        }

        public float StepSize
        {
            get
            {
                var __ret = __Internal.GetStepSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetStepSize((__Instance + __PointerAdjustment), value);
            }
        }

        public float Steps
        {
            get
            {
                var __ret = __Internal.GetSteps((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSteps((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterTiltshift()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterTiltshift) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterTiltshift) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterTone : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTone@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTone@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.FilterTone __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterTone(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterTone __CreateInstance(global::FlounderSharp.FilterTone.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterTone(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterTone.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterTone.__Internal));
            global::FlounderSharp.FilterTone.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterTone(global::FlounderSharp.FilterTone.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterTone(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterTone(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterTone.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterTone");
        }

        public FilterTone(global::FlounderSharp.FilterTone _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterTone.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterTone");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterTone(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterTone(graphicsStage);
        }

        #region Virtual table interop

        // ~FilterTone()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterTone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterTone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class FilterWobble : global::FlounderSharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostFilter;

            [FieldOffset(8)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(16)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(24)]
            internal global::System.IntPtr m_model;

            [FieldOffset(32)]
            internal global::System.IntPtr m_uniformScene;

            [FieldOffset(40)]
            internal float m_wobbleSpeed;

            [FieldOffset(44)]
            internal float m_wobbleAmount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterWobble@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterWobble@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWobbleSpeed@FilterWobble@fl@@QEBAMXZ")]
            internal static extern float GetWobbleSpeed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWobbleSpeed@FilterWobble@fl@@QEAAXAEBM@Z")]
            internal static extern void SetWobbleSpeed(global::System.IntPtr instance, float wobbleSpeed);
        }

        internal static new global::FlounderSharp.FilterWobble __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterWobble(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.FilterWobble __CreateInstance(global::FlounderSharp.FilterWobble.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.FilterWobble(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.FilterWobble.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterWobble.__Internal));
            global::FlounderSharp.FilterWobble.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterWobble(global::FlounderSharp.FilterWobble.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterWobble(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public FilterWobble(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterWobble.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterWobble");
        }

        public FilterWobble(global::FlounderSharp.FilterWobble _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.FilterWobble.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.FilterWobble");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            base.Render(commandBuffer);
        }

        public static implicit operator global::FlounderSharp.FilterWobble(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.FilterWobble(graphicsStage);
        }

        public float WobbleSpeed
        {
            get
            {
                var __ret = __Internal.GetWobbleSpeed((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetWobbleSpeed((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~FilterWobble()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterWobble) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.FilterWobble) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.Render(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Represents a system of post effects.</summary>
    public unsafe partial class IPostPipeline : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPostPipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPostPipeline@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPostPipeline@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IPostPipeline> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IPostPipeline>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IPostPipeline __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IPostPipeline(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IPostPipeline __CreateInstance(global::FlounderSharp.IPostPipeline.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IPostPipeline(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.IPostPipeline.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IPostPipeline.__Internal));
            global::FlounderSharp.IPostPipeline.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private IPostPipeline(global::FlounderSharp.IPostPipeline.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IPostPipeline(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new post pipeline.</summary>
        public IPostPipeline()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IPostPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IPostPipeline");
        }

        public IPostPipeline(global::FlounderSharp.IPostPipeline _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IPostPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IPostPipeline");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IPostPipeline __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IPostPipeline.__Internal*) __Instance)->vfptr_IPostPipeline = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Renders the post pipeline.</summary>
        public virtual void RenderPipeline(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderPipelineDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            ___RenderPipelineDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        #region Virtual table interop

        // virtual ~IPostPipeline()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IPostPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void RenderPipeline(const CommandBuffer &commandBuffer)
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _RenderPipelineDelegateInstance;

        private static void _RenderPipelineDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IPostPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            __target.RenderPipeline(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderPipelineDelegateInstance += _RenderPipelineDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderPipelineDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public enum AttachmentType
    {
        AttachmentImage = 0,
        AttachmentDepth = 1,
        AttachmentSwapchain = 2
    }

    public enum AttachmentFormat
    {
        FormatR8Unorm = 9,
        FormatR8Snorm = 10,
        FormatR8Uint = 13,
        FormatR8Sint = 14,
        FormatR8Srgb = 15,
        FormatR8g8Unorm = 16,
        FormatR8g8Snorm = 17,
        FormatR8g8Uint = 20,
        FormatR8g8Sint = 21,
        FormatR8g8Srgb = 22,
        FormatR8g8b8Unorm = 23,
        FormatR8g8b8Snorm = 24,
        FormatR8g8b8Uint = 27,
        FormatR8g8b8Sint = 28,
        FormatR8g8b8Srgb = 29,
        FormatB8g8r8Unorm = 30,
        FormatB8g8r8Snorm = 31,
        FormatB8g8r8Uint = 34,
        FormatB8g8r8Sint = 35,
        FormatB8g8r8Srgb = 36,
        FormatR8g8b8a8Unorm = 37,
        FormatR8g8b8a8Snorm = 38,
        FormatR8g8b8a8Uint = 41,
        FormatR8g8b8a8Sint = 42,
        FormatR8g8b8a8Srgb = 43,
        FormatB8g8r8a8Unorm = 44,
        FormatB8g8r8a8Snorm = 45,
        FormatB8g8r8a8Uint = 48,
        FormatB8g8r8a8Sint = 49,
        FormatB8g8r8a8Srgb = 50,
        FormatR16Unorm = 70,
        FormatR16Snorm = 71,
        FormatR16Uint = 74,
        FormatR16Sint = 75,
        FormatR16Sfloat = 76,
        FormatR16g16Unorm = 77,
        FormatR16g16Snorm = 78,
        FormatR16g16Uint = 81,
        FormatR16g16Sint = 82,
        FormatR16g16Sfloat = 83,
        FormatR16g16b16Unorm = 84,
        FormatR16g16b16Snorm = 85,
        FormatR16g16b16Uint = 88,
        FormatR16g16b16Sint = 89,
        FormatR16g16b16Sfloat = 90,
        FormatR16g16b16a16Unorm = 91,
        FormatR16g16b16a16Snorm = 92,
        FormatR16g16b16a16Uint = 95,
        FormatR16g16b16a16Sint = 96,
        FormatR16g16b16a16Sfloat = 97,
        FormatR32Uint = 98,
        FormatR32Sint = 99,
        FormatR32Sfloat = 100,
        FormatR32g32Uint = 101,
        FormatR32g32Sint = 102,
        FormatR32g32Sfloat = 103,
        FormatR32g32b32Uint = 104,
        FormatR32g32b32Sint = 105,
        FormatR32g32b32Sfloat = 106,
        FormatR32g32b32a32Uint = 107,
        FormatR32g32b32a32Sint = 108,
        FormatR32g32b32a32Sfloat = 109,
        FormatD16Unorm = 124,
        FormatD32Sfloat = 126,
        FormatS8Uint = 127
    }

    public unsafe partial class Attachment : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(4)]
            internal global::FlounderSharp.AttachmentType m_type;

            [FieldOffset(8)]
            internal global::FlounderSharp.AttachmentFormat m_format;

            [FieldOffset(12)]
            internal global::FlounderSharp.Colour.__Internal m_clearColour;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Attachment@fl@@QEAA@AEBIAEBW4AttachmentType@1@AEBW4AttachmentFormat@1@AEBVColour@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint binding, global::FlounderSharp.AttachmentType type, global::FlounderSharp.AttachmentFormat format, global::System.IntPtr clearColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Attachment@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Attachment@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@Attachment@fl@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetType@Attachment@fl@@QEBA?AW4AttachmentType@2@XZ")]
            internal static extern global::FlounderSharp.AttachmentType GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFormat@Attachment@fl@@QEBA?AW4AttachmentFormat@2@XZ")]
            internal static extern global::FlounderSharp.AttachmentFormat GetFormat(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetClearColour@Attachment@fl@@QEBA?AVColour@2@XZ")]
            internal static extern void GetClearColour(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Attachment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Attachment>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Attachment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Attachment(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Attachment __CreateInstance(global::FlounderSharp.Attachment.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Attachment(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Attachment.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Attachment.__Internal));
            global::FlounderSharp.Attachment.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Attachment(global::FlounderSharp.Attachment.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Attachment(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Attachment(uint binding, global::FlounderSharp.AttachmentType type, global::FlounderSharp.AttachmentFormat format, global::FlounderSharp.Colour clearColour)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Attachment.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(clearColour, null))
                throw new global::System.ArgumentNullException("clearColour", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = clearColour.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), binding, type, format, __arg3);
        }

        public Attachment(global::FlounderSharp.Attachment _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Attachment.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Attachment __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.AttachmentType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.AttachmentFormat Format
        {
            get
            {
                var __ret = __Internal.GetFormat((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.Colour ClearColour
        {
            get
            {
                var __ret = new global::FlounderSharp.Colour.__Internal();
                __Internal.GetClearColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::FlounderSharp.Colour.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class SubpassType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_attachments;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SubpassType@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SubpassType@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@SubpassType@fl@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SubpassType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.SubpassType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.SubpassType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SubpassType(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.SubpassType __CreateInstance(global::FlounderSharp.SubpassType.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SubpassType(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.SubpassType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SubpassType.__Internal));
            global::FlounderSharp.SubpassType.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SubpassType(global::FlounderSharp.SubpassType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SubpassType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SubpassType(global::FlounderSharp.SubpassType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.SubpassType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.SubpassType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class RenderpassCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_width;

            [FieldOffset(4)]
            internal uint m_height;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_fl_S_Attachment___N_std_S_allocator__S0_ m_images;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_fl_S_SubpassType___N_std_S_allocator__S0_ m_subpasses;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RenderpassCreate@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RenderpassCreate@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@RenderpassCreate@fl@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWidth@RenderpassCreate@fl@@QEAAXAEBI@Z")]
            internal static extern void SetWidth(global::System.IntPtr instance, uint width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@RenderpassCreate@fl@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@RenderpassCreate@fl@@QEAAXAEBI@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, uint height);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.RenderpassCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.RenderpassCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.RenderpassCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RenderpassCreate(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RenderpassCreate __CreateInstance(global::FlounderSharp.RenderpassCreate.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RenderpassCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RenderpassCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RenderpassCreate.__Internal));
            global::FlounderSharp.RenderpassCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RenderpassCreate(global::FlounderSharp.RenderpassCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RenderpassCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RenderpassCreate(global::FlounderSharp.RenderpassCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RenderpassCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.RenderpassCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetWidth((__Instance + __PointerAdjustment), value);
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetHeight((__Instance + __PointerAdjustment), value);
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A extension used with IRenderer's to define a master renderer.</summary>
    public unsafe abstract partial class IManagerRender : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IManagerRender;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IManagerRender@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IManagerRender@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IManagerRender> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IManagerRender>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IManagerRender __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IManagerRenderInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IManagerRender __CreateInstance(global::FlounderSharp.IManagerRender.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IManagerRenderInternal(native, skipVTables);
        }

        protected IManagerRender(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IManagerRender(global::FlounderSharp.IManagerRender _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IManagerRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IManagerRender");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IManagerRender __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IManagerRender.__Internal*) __Instance)->vfptr_IManagerRender = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Run when rendering the master renderer.</summary>
        public abstract void Render();

        #region Virtual table interop

        // virtual ~IManagerRender()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IManagerRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IManagerRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Render();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IManagerRenderInternal : global::FlounderSharp.IManagerRender, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IManagerRender.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IManagerRender.__Internal));
            *(global::FlounderSharp.IManagerRender.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IManagerRenderInternal(global::FlounderSharp.IManagerRender.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IManagerRenderInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Run when rendering the master renderer.</summary>
        public override void Render()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___RenderDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Used to store index of a QueueFamily with particular qualities.</summary>
    public unsafe partial class QueueFamilyIndices : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_graphicsFamily;

            [FieldOffset(4)]
            internal int m_presentFamily;

            [FieldOffset(8)]
            internal int m_computeFamily;

            [FieldOffset(12)]
            internal global::Std.Array.__Internalc__N_std_S_array__i_Vk3 m_array;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0QueueFamilyIndices@fl@@QEAA@AEBH00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int graphicsFamily, int presentFamily, int computeFamily);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0QueueFamilyIndices@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsComplete@QueueFamilyIndices@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsComplete(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsFamily@QueueFamilyIndices@fl@@QEBAHXZ")]
            internal static extern int GetGraphicsFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPresentFamily@QueueFamilyIndices@fl@@QEBAHXZ")]
            internal static extern int GetPresentFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComputeFamily@QueueFamilyIndices@fl@@QEBAHXZ")]
            internal static extern int GetComputeFamily(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.QueueFamilyIndices> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.QueueFamilyIndices>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.QueueFamilyIndices __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.QueueFamilyIndices(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.QueueFamilyIndices __CreateInstance(global::FlounderSharp.QueueFamilyIndices.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.QueueFamilyIndices(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.QueueFamilyIndices.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.QueueFamilyIndices.__Internal));
            *(global::FlounderSharp.QueueFamilyIndices.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QueueFamilyIndices(global::FlounderSharp.QueueFamilyIndices.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QueueFamilyIndices(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public QueueFamilyIndices(int graphicsFamily, int presentFamily, int computeFamily)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.QueueFamilyIndices.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), graphicsFamily, presentFamily, computeFamily);
        }

        public QueueFamilyIndices(global::FlounderSharp.QueueFamilyIndices _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.QueueFamilyIndices.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.QueueFamilyIndices.__Internal*) __Instance) = *((global::FlounderSharp.QueueFamilyIndices.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.QueueFamilyIndices __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if an index has been assigned.</summary>
        public bool IsComplete
        {
            get
            {
                var __ret = __Internal.IsComplete((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int GraphicsFamily
        {
            get
            {
                var __ret = __Internal.GetGraphicsFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int PresentFamily
        {
            get
            {
                var __ret = __Internal.GetPresentFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int ComputeFamily
        {
            get
            {
                var __ret = __Internal.GetComputeFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    /// <summary>A Vulkan queue family.</summary>
    public unsafe partial class QueueFamily : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0QueueFamily@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.QueueFamily> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.QueueFamily>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.QueueFamily __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.QueueFamily(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.QueueFamily __CreateInstance(global::FlounderSharp.QueueFamily.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.QueueFamily(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.QueueFamily.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.QueueFamily.__Internal));
            *(global::FlounderSharp.QueueFamily.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QueueFamily(global::FlounderSharp.QueueFamily.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QueueFamily(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public QueueFamily()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.QueueFamily.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public QueueFamily(global::FlounderSharp.QueueFamily _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.QueueFamily.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.QueueFamily.__Internal*) __Instance) = *((global::FlounderSharp.QueueFamily.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.QueueFamily __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class DepthStencil : global::FlounderSharp.IDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(8)]
            internal global::System.IntPtr m_image;

            [FieldOffset(16)]
            internal global::System.IntPtr m_imageMemory;

            [FieldOffset(24)]
            internal global::System.IntPtr m_imageView;

            [FieldOffset(32)]
            internal global::System.IntPtr m_sampler;

            [FieldOffset(40)]
            internal global::VkFormat m_format;

            [FieldOffset(48)]
            internal global::VkDescriptorImageInfo.__Internal m_imageInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DepthStencil@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateDescriptor@DepthStencil@fl@@SA?AVDescriptorType@2@AEBI0@Z")]
            internal static extern void CreateDescriptor(global::System.IntPtr @return, uint binding, uint stage);
        }

        internal static new global::FlounderSharp.DepthStencil __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DepthStencil(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.DepthStencil __CreateInstance(global::FlounderSharp.DepthStencil.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.DepthStencil(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.DepthStencil.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DepthStencil.__Internal));
            global::FlounderSharp.DepthStencil.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DepthStencil(global::FlounderSharp.DepthStencil.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DepthStencil(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public DepthStencil(global::FlounderSharp.DepthStencil _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.DepthStencil.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.DepthStencil");
        }

        public static global::FlounderSharp.DescriptorType CreateDescriptor(uint binding, uint stage)
        {
            var __ret = new global::FlounderSharp.DescriptorType.__Internal();
            __Internal.CreateDescriptor(new IntPtr(&__ret), binding, stage);
            return global::FlounderSharp.DescriptorType.__CreateInstance(__ret);
        }

        #region Virtual table interop

        // ~DepthStencil()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.DepthStencil) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class Swapchain : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::VkPresentModeKHR m_presentMode;

            [FieldOffset(8)]
            internal global::System.IntPtr m_swapchain;

            [FieldOffset(16)]
            internal uint m_swapchainImageCount;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkImage_T___N_std_S_allocator__S0_ m_swapchainImages;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkImageView_T___N_std_S_allocator__S0_ m_swapchainImageViews;

            [FieldOffset(72)]
            internal global::VkExtent2D.__Internal m_extent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Swapchain@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Swapchain@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVkImageCount@Swapchain@fl@@QEBAIXZ")]
            internal static extern uint GetVkImageCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Swapchain> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Swapchain>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Swapchain __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Swapchain(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Swapchain __CreateInstance(global::FlounderSharp.Swapchain.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Swapchain(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Swapchain.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Swapchain.__Internal));
            global::FlounderSharp.Swapchain.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Swapchain(global::FlounderSharp.Swapchain.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Swapchain(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Swapchain(global::FlounderSharp.Swapchain _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Swapchain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Swapchain __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint VkImageCount
        {
            get
            {
                var __ret = __Internal.GetVkImageCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Renderpass : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_renderPass;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Renderpass@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Renderpass@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Renderpass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Renderpass>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Renderpass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Renderpass(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Renderpass __CreateInstance(global::FlounderSharp.Renderpass.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Renderpass(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Renderpass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Renderpass.__Internal));
            *(global::FlounderSharp.Renderpass.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Renderpass(global::FlounderSharp.Renderpass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Renderpass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Renderpass(global::FlounderSharp.Renderpass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Renderpass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Renderpass.__Internal*) __Instance) = *((global::FlounderSharp.Renderpass.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Renderpass __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Framebuffers : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_Texture___N_std_S_allocator__S0_ m_imageAttachments;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkFramebuffer_T___N_std_S_allocator__S0_ m_framebuffers;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Framebuffers@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Framebuffers@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTexture@Framebuffers@fl@@QEBAPEAVTexture@2@AEBI@Z")]
            internal static extern global::System.IntPtr GetTexture(global::System.IntPtr instance, uint i);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Framebuffers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Framebuffers>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Framebuffers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Framebuffers(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Framebuffers __CreateInstance(global::FlounderSharp.Framebuffers.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Framebuffers(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Framebuffers.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Framebuffers.__Internal));
            global::FlounderSharp.Framebuffers.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Framebuffers(global::FlounderSharp.Framebuffers.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Framebuffers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Framebuffers(global::FlounderSharp.Framebuffers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Framebuffers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Framebuffers __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::FlounderSharp.Texture GetTexture(uint i)
        {
            var __ret = __Internal.GetTexture((__Instance + __PointerAdjustment), i);
            global::FlounderSharp.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.NativeToManagedMap[__ret];
            else global::FlounderSharp.Texture.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Texture) global::FlounderSharp.Texture.__CreateInstance(__ret);
            return __result0;
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class RenderStage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_lastWidth;

            [FieldOffset(4)]
            internal uint m_lastHeight;

            [FieldOffset(8)]
            internal int m_stageIndex;

            [FieldOffset(16)]
            internal global::System.IntPtr m_renderpassCreate;

            [FieldOffset(24)]
            internal global::System.IntPtr m_depthStencil;

            [FieldOffset(32)]
            internal global::System.IntPtr m_renderpass;

            [FieldOffset(40)]
            internal global::System.IntPtr m_framebuffers;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____U_VkClearValue___N_std_S_allocator__S0_ m_clearValues;

            [FieldOffset(72)]
            internal uint m_imageAttachments;

            [FieldOffset(76)]
            internal byte m_hasDepth;

            [FieldOffset(77)]
            internal byte m_hasSwapchain;

            [FieldOffset(78)]
            internal byte m_fitDisplaySize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RenderStage@fl@@QEAA@AEBHPEAVRenderpassCreate@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int stageIndex, global::System.IntPtr renderpassCreate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RenderStage@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RenderStage@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rebuild@RenderStage@fl@@QEAAXPEAVSwapchain@2@@Z")]
            internal static extern void Rebuild(global::System.IntPtr instance, global::System.IntPtr swapchain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@RenderStage@fl@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@RenderStage@fl@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepthStencil@RenderStage@fl@@QEBAPEAVDepthStencil@2@XZ")]
            internal static extern global::System.IntPtr GetDepthStencil(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderpass@RenderStage@fl@@QEBAPEAVRenderpass@2@XZ")]
            internal static extern global::System.IntPtr GetRenderpass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFramebuffers@RenderStage@fl@@QEBAPEAVFramebuffers@2@XZ")]
            internal static extern global::System.IntPtr GetFramebuffers(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetImageAttachments@RenderStage@fl@@QEBAIXZ")]
            internal static extern uint GetImageAttachments(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasDepth@RenderStage@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasDepth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasSwapchain@RenderStage@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSwapchain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FitDisplaySize@RenderStage@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool FitDisplaySize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.RenderStage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.RenderStage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.RenderStage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RenderStage(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RenderStage __CreateInstance(global::FlounderSharp.RenderStage.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RenderStage(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RenderStage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RenderStage.__Internal));
            global::FlounderSharp.RenderStage.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RenderStage(global::FlounderSharp.RenderStage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RenderStage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RenderStage(int stageIndex, global::FlounderSharp.RenderpassCreate renderpassCreate)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RenderStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg1 = ReferenceEquals(renderpassCreate, null) ? global::System.IntPtr.Zero : renderpassCreate.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), stageIndex, __arg1);
        }

        public RenderStage(global::FlounderSharp.RenderStage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RenderStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.RenderStage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Rebuild(global::FlounderSharp.Swapchain swapchain)
        {
            var __arg0 = ReferenceEquals(swapchain, null) ? global::System.IntPtr.Zero : swapchain.__Instance;
            __Internal.Rebuild((__Instance + __PointerAdjustment), __arg0);
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.DepthStencil DepthStencil
        {
            get
            {
                var __ret = __Internal.GetDepthStencil((__Instance + __PointerAdjustment));
                global::FlounderSharp.DepthStencil __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.DepthStencil.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.DepthStencil) global::FlounderSharp.DepthStencil.NativeToManagedMap[__ret];
                else global::FlounderSharp.DepthStencil.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.DepthStencil) global::FlounderSharp.DepthStencil.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Renderpass Renderpass
        {
            get
            {
                var __ret = __Internal.GetRenderpass((__Instance + __PointerAdjustment));
                global::FlounderSharp.Renderpass __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Renderpass.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Renderpass) global::FlounderSharp.Renderpass.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Renderpass.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Framebuffers Framebuffers
        {
            get
            {
                var __ret = __Internal.GetFramebuffers((__Instance + __PointerAdjustment));
                global::FlounderSharp.Framebuffers __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Framebuffers.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Framebuffers) global::FlounderSharp.Framebuffers.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Framebuffers.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint ImageAttachments
        {
            get
            {
                var __ret = __Internal.GetImageAttachments((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool HasDepth
        {
            get
            {
                var __ret = __Internal.HasDepth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool HasSwapchain
        {
            get
            {
                var __ret = __Internal.HasSwapchain((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool FitDisplaySize
        {
            get
            {
                var __ret = __Internal.FitDisplaySize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Renderer : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_managerRender;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_RenderStage___N_std_S_allocator__S0_ m_renderStages;

            [FieldOffset(40)]
            internal global::System.IntPtr m_swapchain;

            [FieldOffset(48)]
            internal global::System.IntPtr m_fenceSwapchainImage;

            [FieldOffset(56)]
            internal uint m_activeSwapchainImage;

            [FieldOffset(64)]
            internal global::System.IntPtr m_pipelineCache;

            [FieldOffset(72)]
            internal global::System.IntPtr m_semaphore;

            [FieldOffset(80)]
            internal global::System.IntPtr m_commandPool;

            [FieldOffset(88)]
            internal global::System.IntPtr m_commandBuffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Renderer@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Renderer@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Renderer@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StartRenderpass@Renderer@fl@@QEAA_NAEBVCommandBuffer@2@AEBI@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool StartRenderpass(global::System.IntPtr instance, global::System.IntPtr commandBuffer, uint i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EndRenderpass@Renderer@fl@@QEAAXAEBVCommandBuffer@2@AEBI@Z")]
            internal static extern void EndRenderpass(global::System.IntPtr instance, global::System.IntPtr commandBuffer, uint i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?NextSubpass@Renderer@fl@@QEAAXAEBVCommandBuffer@2@@Z")]
            internal static extern void NextSubpass(global::System.IntPtr instance, global::System.IntPtr commandBuffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderStage@Renderer@fl@@QEBAPEAVRenderStage@2@AEBH@Z")]
            internal static extern global::System.IntPtr GetRenderStage(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetManager@Renderer@fl@@QEBAPEAVIManagerRender@2@XZ")]
            internal static extern global::System.IntPtr GetManager(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetManager@Renderer@fl@@QEAAXPEAVIManagerRender@2@@Z")]
            internal static extern void SetManager(global::System.IntPtr instance, global::System.IntPtr managerRender);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSwapchain@Renderer@fl@@QEBAPEAVSwapchain@2@XZ")]
            internal static extern global::System.IntPtr GetSwapchain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCommandBuffer@Renderer@fl@@QEBAPEAVCommandBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetCommandBuffer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVkActiveSwapchainImage@Renderer@fl@@QEBAIXZ")]
            internal static extern uint GetVkActiveSwapchainImage(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Renderer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Renderer(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Renderer __CreateInstance(global::FlounderSharp.Renderer.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Renderer(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Renderer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Renderer.__Internal));
            global::FlounderSharp.Renderer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Renderer(global::FlounderSharp.Renderer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Renderer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new renderer module.</summary>
        public Renderer()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Renderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Renderer");
        }

        public Renderer(global::FlounderSharp.Renderer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Renderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Renderer");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Starts a renderpass.</summary>
        /// <param name="commandBuffer">The command buffer to use.</param>
        /// <param name="i">The index of the render pass being rendered.</param>
        public bool StartRenderpass(global::FlounderSharp.CommandBuffer commandBuffer, uint i)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            var __ret = __Internal.StartRenderpass((__Instance + __PointerAdjustment), __arg0, i);
            return __ret;
        }

        /// <summary>Ends the renderpass.</summary>
        /// <param name="commandBuffer">The command buffer to use.</param>
        public void EndRenderpass(global::FlounderSharp.CommandBuffer commandBuffer, uint i)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.EndRenderpass((__Instance + __PointerAdjustment), __arg0, i);
        }

        /// <summary>Starts the next render subpass.</summary>
        /// <param name="commandBuffer">The command buffer to use.</param>
        public void NextSubpass(global::FlounderSharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.NextSubpass((__Instance + __PointerAdjustment), __arg0);
        }

        public global::FlounderSharp.RenderStage GetRenderStage(int i)
        {
            var __ret = __Internal.GetRenderStage((__Instance + __PointerAdjustment), i);
            global::FlounderSharp.RenderStage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.RenderStage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.RenderStage) global::FlounderSharp.RenderStage.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.RenderStage.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Renderer Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Renderer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Renderer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Renderer) global::FlounderSharp.Renderer.NativeToManagedMap[__ret];
            else global::FlounderSharp.Renderer.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Renderer) global::FlounderSharp.Renderer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the renderer manager.</summary>
        /// <param name="rendererMaster">The new renderer manager.</param>
        /// <remarks>Sets the current renderer manager to a new renderer manager.</remarks>
        public global::FlounderSharp.IManagerRender Manager
        {
            get
            {
                var __ret = __Internal.GetManager((__Instance + __PointerAdjustment));
                global::FlounderSharp.IManagerRender __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.IManagerRender.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.IManagerRender) global::FlounderSharp.IManagerRender.NativeToManagedMap[__ret];
                else global::FlounderSharp.IManagerRender.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IManagerRender) global::FlounderSharp.IManagerRender.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetManager((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Swapchain Swapchain
        {
            get
            {
                var __ret = __Internal.GetSwapchain((__Instance + __PointerAdjustment));
                global::FlounderSharp.Swapchain __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Swapchain.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Swapchain) global::FlounderSharp.Swapchain.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Swapchain.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.CommandBuffer CommandBuffer
        {
            get
            {
                var __ret = __Internal.GetCommandBuffer((__Instance + __PointerAdjustment));
                global::FlounderSharp.CommandBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint VkActiveSwapchainImage
        {
            get
            {
                var __ret = __Internal.GetVkActiveSwapchainImage((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Renderer()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Renderer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Renderer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class Screenshot : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Screenshot@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Capture@Screenshot@fl@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Capture(global::System.IntPtr filename);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Screenshot> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Screenshot>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Screenshot __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Screenshot(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Screenshot __CreateInstance(global::FlounderSharp.Screenshot.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Screenshot(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Screenshot.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Screenshot.__Internal));
            *(global::FlounderSharp.Screenshot.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Screenshot(global::FlounderSharp.Screenshot.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Screenshot(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Screenshot()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Screenshot.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Screenshot(global::FlounderSharp.Screenshot _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Screenshot.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Screenshot.__Internal*) __Instance) = *((global::FlounderSharp.Screenshot.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Screenshot __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Takes a screenshot of the current image of the display and saves it into the screenshots folder a png image.</summary>
        /// <param name="filename">The new width in pixels.</param>
        public static void Capture(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.Capture(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A interface used to manage a main UI system.</summary>
    public unsafe abstract partial class IManagerUis : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IManagerUis;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IManagerUis@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IManagerUis@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IManagerUis@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IManagerUis> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IManagerUis>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IManagerUis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IManagerUisInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IManagerUis __CreateInstance(global::FlounderSharp.IManagerUis.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IManagerUisInternal(native, skipVTables);
        }

        protected IManagerUis(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new ui manager.</summary>
        protected IManagerUis()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IManagerUis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IManagerUis");
        }

        protected IManagerUis(global::FlounderSharp.IManagerUis _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IManagerUis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IManagerUis");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IManagerUis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IManagerUis.__Internal*) __Instance)->vfptr_IManagerUis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Run when updating the ui manager.</summary>
        public abstract void Update();

        /// <summary>Gets if the main menu is open.</summary>
        public abstract bool IsGamePaused
        {
            get;
        }

        /// <summary>Gets the main menu's blur factor.</summary>
        public abstract float BlurFactor
        {
            get;
        }

        /// <summary>The primary colour to be used in UI elements.</summary>
        public abstract global::FlounderSharp.Colour PrimaryColour
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IManagerUis() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IManagerUis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IManagerUis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // bool IsGamePaused() = 0
        private static global::FlounderSharp.Delegates.Func_bool_IntPtr _IsGamePausedDelegateInstance;

        private static bool _IsGamePausedDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IManagerUis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.IsGamePaused;
            return __ret;
        }

        // float GetBlurFactor() = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetBlurFactorDelegateInstance;

        private static float _GetBlurFactorDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IManagerUis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.BlurFactor;
            return __ret;
        }

        // Colour *GetPrimaryColour() = 0
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetPrimaryColourDelegateInstance;

        private static global::System.IntPtr _GetPrimaryColourDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IManagerUis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PrimaryColour;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _IsGamePausedDelegateInstance += _IsGamePausedDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_IsGamePausedDelegateInstance).ToPointer();
                _GetBlurFactorDelegateInstance += _GetBlurFactorDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetBlurFactorDelegateInstance).ToPointer();
                _GetPrimaryColourDelegateInstance += _GetPrimaryColourDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetPrimaryColourDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IManagerUisInternal : global::FlounderSharp.IManagerUis, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IManagerUis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IManagerUis.__Internal));
            *(global::FlounderSharp.IManagerUis.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IManagerUisInternal(global::FlounderSharp.IManagerUis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IManagerUisInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Run when updating the ui manager.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if the main menu is open.</summary>
        public override bool IsGamePaused
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___IsGamePausedDelegate = (global::FlounderSharp.Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_bool_IntPtr));
                var __ret = ___IsGamePausedDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the main menu's blur factor.</summary>
        public override float BlurFactor
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetBlurFactorDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetBlurFactorDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>The primary colour to be used in UI elements.</summary>
        public override global::FlounderSharp.Colour PrimaryColour
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetPrimaryColourDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetPrimaryColourDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class Behaviour : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Behaviour@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Behaviour@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.Behaviour __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Behaviour(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Behaviour __CreateInstance(global::FlounderSharp.Behaviour.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Behaviour(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Behaviour.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Behaviour.__Internal));
            global::FlounderSharp.Behaviour.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Behaviour(global::FlounderSharp.Behaviour.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Behaviour(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public Behaviour()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Behaviour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Behaviour");
        }

        public Behaviour(global::FlounderSharp.Behaviour _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Behaviour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Behaviour");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // virtual ~Behaviour()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Behaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Behaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Behaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Behaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "Behaviour"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Behaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A class that holds registerd components.</summary>
    public unsafe partial class ComponentRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_components;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentRegister@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentRegister@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ComponentRegister@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterComponent@ComponentRegister@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeregisterComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateComponent@ComponentRegister@fl@@QEAAPEAVComponent@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr CreateComponent(global::System.IntPtr instance, global::System.IntPtr name);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ComponentRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ComponentRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ComponentRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ComponentRegister(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ComponentRegister __CreateInstance(global::FlounderSharp.ComponentRegister.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ComponentRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ComponentRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ComponentRegister.__Internal));
            *(global::FlounderSharp.ComponentRegister.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ComponentRegister(global::FlounderSharp.ComponentRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComponentRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new component register.</summary>
        public ComponentRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ComponentRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ComponentRegister(global::FlounderSharp.ComponentRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ComponentRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.ComponentRegister.__Internal*) __Instance) = *((global::FlounderSharp.ComponentRegister.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ComponentRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Deregisters a component.</summary>
        /// <param name="name">The components name.</param>
        public void DeregisterComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeregisterComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Creates a new component from the register.</summary>
        /// <param name="name">The component name to create.</param>
        public global::FlounderSharp.Component CreateComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.Component __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Component.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.NativeToManagedMap[__ret];
            else global::FlounderSharp.Component.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.__CreateInstance(__ret);
            return __result0;
        }
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a entity prefab.</summary>
    public unsafe partial class PrefabObject : global::FlounderSharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_fileJson;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PrefabObject@fl@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PrefabObject@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resource@PrefabObject@fl@@SAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr Resource(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@PrefabObject@fl@@QEAAXPEAVGameObject@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Save@PrefabObject@fl@@QEAAXXZ")]
            internal static extern void Save(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@PrefabObject@fl@@QEBAPEAVLoadedValue@2@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.PrefabObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PrefabObject(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.PrefabObject __CreateInstance(global::FlounderSharp.PrefabObject.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.PrefabObject(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.PrefabObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PrefabObject.__Internal));
            global::FlounderSharp.PrefabObject.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PrefabObject(global::FlounderSharp.PrefabObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PrefabObject(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new entity prefab.</summary>
        /// <param name="filename">The file name.</param>
        public PrefabObject(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PrefabObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.PrefabObject");
        }

        public PrefabObject(global::FlounderSharp.PrefabObject _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.PrefabObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.PrefabObject");
        }

        public void Write(global::FlounderSharp.GameObject gameObject)
        {
            var __arg0 = ReferenceEquals(gameObject, null) ? global::System.IntPtr.Zero : gameObject.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public void Save()
        {
            __Internal.Save((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::FlounderSharp.PrefabObject(string filename)
        {
            return new global::FlounderSharp.PrefabObject(filename);
        }

        public static global::FlounderSharp.PrefabObject Resource(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Resource(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.PrefabObject __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.PrefabObject.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.PrefabObject) global::FlounderSharp.PrefabObject.NativeToManagedMap[__ret];
            else global::FlounderSharp.PrefabObject.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.PrefabObject) global::FlounderSharp.PrefabObject.__CreateInstance(__ret);
            return __result0;
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___GetFilenameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }

        public global::FlounderSharp.LoadedValue Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::FlounderSharp.LoadedValue __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~PrefabObject()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.PrefabObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.PrefabObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A object used to represent a scene.</summary>
    public unsafe abstract partial class Scene : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Scene;

            [FieldOffset(8)]
            internal global::System.IntPtr m_camera;

            [FieldOffset(16)]
            internal global::System.IntPtr m_managerUis;

            [FieldOffset(24)]
            internal global::System.IntPtr m_structure;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scene@fl@@QEAA@PEAVICamera@1@PEAVIManagerUis@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr camera, global::System.IntPtr managerUis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scene@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Scene@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCamera@Scene@fl@@QEBAPEAVICamera@2@XZ")]
            internal static extern global::System.IntPtr GetCamera(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCamera@Scene@fl@@QEAAXPEAVICamera@2@@Z")]
            internal static extern void SetCamera(global::System.IntPtr instance, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUiManager@Scene@fl@@QEBAPEAVIManagerUis@2@XZ")]
            internal static extern global::System.IntPtr GetUiManager(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUiManager@Scene@fl@@QEAAXPEAVIManagerUis@2@@Z")]
            internal static extern void SetUiManager(global::System.IntPtr instance, global::System.IntPtr managerUis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@Scene@fl@@QEBAPEAVSceneStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Scene> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Scene>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Scene __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SceneInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Scene __CreateInstance(global::FlounderSharp.Scene.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.SceneInternal(native, skipVTables);
        }

        protected Scene(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new scene.</summary>
        /// <param name="camera">The camera.</param>
        /// <param name="managerUis">The new uis manager.</param>
        protected Scene(global::FlounderSharp.ICamera camera, global::FlounderSharp.IManagerUis managerUis)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Scene.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(camera, null) ? global::System.IntPtr.Zero : camera.__Instance;
            var __arg1 = ReferenceEquals(managerUis, null) ? global::System.IntPtr.Zero : managerUis.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.Scene");
        }

        protected Scene(global::FlounderSharp.Scene _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Scene.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Scene");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Scene __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.Scene.__Internal*) __Instance)->vfptr_Scene = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Start();

        /// <summary>Run when updating the scene.</summary>
        public abstract void Update();

        /// <summary>Gets the current camera object.</summary>
        /// <param name="camera">The new camera.</param>
        /// <remarks>Sets the current camera to a new camera.</remarks>
        public global::FlounderSharp.ICamera Camera
        {
            get
            {
                var __ret = __Internal.GetCamera((__Instance + __PointerAdjustment));
                global::FlounderSharp.ICamera __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[__ret];
                else global::FlounderSharp.ICamera.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetCamera((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the uis manager.</summary>
        /// <param name="managerUis">The new uis manager.</param>
        /// <remarks>Sets the current uis manager to a new uis manager.</remarks>
        public global::FlounderSharp.IManagerUis UiManager
        {
            get
            {
                var __ret = __Internal.GetUiManager((__Instance + __PointerAdjustment));
                global::FlounderSharp.IManagerUis __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.IManagerUis.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.IManagerUis) global::FlounderSharp.IManagerUis.NativeToManagedMap[__ret];
                else global::FlounderSharp.IManagerUis.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IManagerUis) global::FlounderSharp.IManagerUis.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetUiManager((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the GameObjects structure.</summary>
        public global::FlounderSharp.SceneStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::FlounderSharp.SceneStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.SceneStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.SceneStructure) global::FlounderSharp.SceneStructure.NativeToManagedMap[__ret];
                else global::FlounderSharp.SceneStructure.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.SceneStructure) global::FlounderSharp.SceneStructure.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // virtual ~Scene()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Scene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Start() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Scene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Scene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class SceneInternal : global::FlounderSharp.Scene, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.Scene.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Scene.__Internal));
            *(global::FlounderSharp.Scene.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal SceneInternal(global::FlounderSharp.Scene.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal SceneInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___StartDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Run when updating the scene.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for managing game scenes on engine updates.</summary>
    public unsafe partial class Scenes : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_componentRegister;

            [FieldOffset(16)]
            internal global::System.IntPtr m_scene;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scenes@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scenes@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Scenes@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterComponent@Scenes@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeregisterComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateComponent@Scenes@fl@@QEAAPEAVComponent@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr CreateComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScene@Scenes@fl@@QEBAPEAVScene@2@XZ")]
            internal static extern global::System.IntPtr GetScene(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScene@Scenes@fl@@QEAAXPEAVScene@2@@Z")]
            internal static extern void SetScene(global::System.IntPtr instance, global::System.IntPtr scene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCamera@Scenes@fl@@QEBAPEAVICamera@2@XZ")]
            internal static extern global::System.IntPtr GetCamera(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUiManager@Scenes@fl@@QEBAPEAVIManagerUis@2@XZ")]
            internal static extern global::System.IntPtr GetUiManager(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsGamePaused@Scenes@fl@@QEAA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGamePaused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@Scenes@fl@@QEBAPEAVSceneStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Scenes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Scenes(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Scenes __CreateInstance(global::FlounderSharp.Scenes.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Scenes(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Scenes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Scenes.__Internal));
            global::FlounderSharp.Scenes.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Scenes(global::FlounderSharp.Scenes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Scenes(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new Scenes module.</summary>
        public Scenes()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Scenes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Scenes");
        }

        public Scenes(global::FlounderSharp.Scenes _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Scenes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Scenes");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Deregisters a component.</summary>
        /// <param name="name">The components name.</param>
        public void DeregisterComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeregisterComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Creates a new component from the register.</summary>
        /// <param name="name">The component name to create.</param>
        public global::FlounderSharp.Component CreateComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.Component __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Component.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.NativeToManagedMap[__ret];
            else global::FlounderSharp.Component.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Component) global::FlounderSharp.Component.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Scenes Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Scenes __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Scenes.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Scenes) global::FlounderSharp.Scenes.NativeToManagedMap[__ret];
            else global::FlounderSharp.Scenes.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Scenes) global::FlounderSharp.Scenes.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.Scene Scene
        {
            get
            {
                var __ret = __Internal.GetScene((__Instance + __PointerAdjustment));
                global::FlounderSharp.Scene __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Scene.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Scene) global::FlounderSharp.Scene.NativeToManagedMap[__ret];
                else global::FlounderSharp.Scene.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Scene) global::FlounderSharp.Scene.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetScene((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the current camera object.</summary>
        public global::FlounderSharp.ICamera Camera
        {
            get
            {
                var __ret = __Internal.GetCamera((__Instance + __PointerAdjustment));
                global::FlounderSharp.ICamera __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[__ret];
                else global::FlounderSharp.ICamera.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the uis manager.</summary>
        public global::FlounderSharp.IManagerUis UiManager
        {
            get
            {
                var __ret = __Internal.GetUiManager((__Instance + __PointerAdjustment));
                global::FlounderSharp.IManagerUis __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.IManagerUis.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.IManagerUis) global::FlounderSharp.IManagerUis.NativeToManagedMap[__ret];
                else global::FlounderSharp.IManagerUis.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IManagerUis) global::FlounderSharp.IManagerUis.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets if the scene is paused.</summary>
        public bool IsGamePaused
        {
            get
            {
                var __ret = __Internal.IsGamePaused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the GameObjects structure.</summary>
        public global::FlounderSharp.SceneStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::FlounderSharp.SceneStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.SceneStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.SceneStructure) global::FlounderSharp.SceneStructure.NativeToManagedMap[__ret];
                else global::FlounderSharp.SceneStructure.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.SceneStructure) global::FlounderSharp.SceneStructure.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Scenes()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Scenes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Scenes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Represents the 3D area of the world in which engine.shadows will be cast (basically represents the orthographic projection area for the shadow render pass). It can be updated each frame to optimise the area, making it as small as possible (to allow for optimal shadow map resolution) while not being too small to avoid objects not having shadows when they should. This class also provides functionality to test whether an object is inside this shadow box. Everything inside the box will be rendered to the shadow map in the shadow render pass.</summary>
    public unsafe partial class ShadowBox : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_lightDirection;

            [FieldOffset(8)]
            internal float m_shadowOffset;

            [FieldOffset(12)]
            internal float m_shadowDistance;

            [FieldOffset(16)]
            internal global::System.IntPtr m_projectionMatrix;

            [FieldOffset(24)]
            internal global::System.IntPtr m_lightViewMatrix;

            [FieldOffset(32)]
            internal global::System.IntPtr m_projectionViewMatrix;

            [FieldOffset(40)]
            internal global::System.IntPtr m_shadowMapSpaceMatrix;

            [FieldOffset(48)]
            internal global::System.IntPtr m_offset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_centre;

            [FieldOffset(64)]
            internal float m_farHeight;

            [FieldOffset(68)]
            internal float m_farWidth;

            [FieldOffset(72)]
            internal float m_nearHeight;

            [FieldOffset(76)]
            internal float m_nearWidth;

            [FieldOffset(80)]
            internal global::System.IntPtr m_aabb;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowBox@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowBox@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ShadowBox@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ShadowBox@fl@@QEAAXAEBVICamera@2@AEBVVector3@2@AEBM2@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr camera, global::System.IntPtr lightPosition, float shadowOffset, float shadowDistance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInBox@ShadowBox@fl@@QEBA_NAEBVVector3@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInBox(global::System.IntPtr instance, global::System.IntPtr position, float radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProjectionViewMatrix@ShadowBox@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetProjectionViewMatrix(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetToShadowMapSpaceMatrix@ShadowBox@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetToShadowMapSpaceMatrix(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLightSpaceTransform@ShadowBox@fl@@QEBAPEAVMatrix4@2@XZ")]
            internal static extern global::System.IntPtr GetLightSpaceTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAabb@ShadowBox@fl@@QEBAPEAVColliderAabb@2@XZ")]
            internal static extern global::System.IntPtr GetAabb(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ShadowBox> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ShadowBox>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ShadowBox __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShadowBox(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShadowBox __CreateInstance(global::FlounderSharp.ShadowBox.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShadowBox(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShadowBox.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowBox.__Internal));
            *(global::FlounderSharp.ShadowBox.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ShadowBox(global::FlounderSharp.ShadowBox.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShadowBox(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new shadow box and calculates some initial values relating to the camera's view frustum.</summary>
        public ShadowBox()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowBox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ShadowBox(global::FlounderSharp.ShadowBox _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowBox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.ShadowBox.__Internal*) __Instance) = *((global::FlounderSharp.ShadowBox.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ShadowBox __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the bounds of the shadow box based on the light direction and the camera's view frustum. Will make sure that the box covers the smallest area possible while still ensuring that everything. Objects inside the camera's view (and in range) will be shadowed.</summary>
        /// <param name="camera">The camera object to be used when calculating the shadow boxes size.</param>
        /// <param name="lightPosition">The lights position.</param>
        /// <param name="shadowOffset">The shadows offset.</param>
        /// <param name="shadowDistance">The shadows distance.</param>
        public void Update(global::FlounderSharp.ICamera camera, global::FlounderSharp.Vector3 lightPosition, float shadowOffset, float shadowDistance)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = camera.__Instance;
            if (ReferenceEquals(lightPosition, null))
                throw new global::System.ArgumentNullException("lightPosition", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = lightPosition.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1, shadowOffset, shadowDistance);
        }

        /// <summary>Test if a bounding sphere intersects the shadow box. Can be used to decide which engine.entities should be rendered in the shadow render pass.</summary>
        /// <param name="position">The centre of the bounding sphere in world space.</param>
        /// <param name="radius">The radius of the bounding sphere.</param>
        public bool IsInBox(global::FlounderSharp.Vector3 position, float radius)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = __Internal.IsInBox((__Instance + __PointerAdjustment), __arg0, radius);
            return __ret;
        }

        public global::FlounderSharp.Matrix4 ProjectionViewMatrix
        {
            get
            {
                var __ret = __Internal.GetProjectionViewMatrix((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>This biased projection-view matrix is used to convert fragments into &quot;shadow map space&quot; when rendering the main render pass.</summary>
        public global::FlounderSharp.Matrix4 ToShadowMapSpaceMatrix
        {
            get
            {
                var __ret = __Internal.GetToShadowMapSpaceMatrix((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the light's &quot;view&quot; matrix</summary>
        public global::FlounderSharp.Matrix4 LightSpaceTransform
        {
            get
            {
                var __ret = __Internal.GetLightSpaceTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Matrix4 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Matrix4.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Matrix4) global::FlounderSharp.Matrix4.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Matrix4.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.ColliderAabb Aabb
        {
            get
            {
                var __ret = __Internal.GetAabb((__Instance + __PointerAdjustment));
                global::FlounderSharp.ColliderAabb __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ColliderAabb.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret];
                else global::FlounderSharp.ColliderAabb.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.ColliderAabb) global::FlounderSharp.ColliderAabb.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for managing shadow maps in 3D worlds.</summary>
    public unsafe partial class Shadows : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_lightDirection;

            [FieldOffset(16)]
            internal uint m_shadowSize;

            [FieldOffset(20)]
            internal int m_shadowPcf;

            [FieldOffset(24)]
            internal float m_shadowBias;

            [FieldOffset(28)]
            internal float m_shadowDarkness;

            [FieldOffset(32)]
            internal float m_shadowTransition;

            [FieldOffset(36)]
            internal float m_shadowBoxOffset;

            [FieldOffset(40)]
            internal float m_shadowBoxDistance;

            [FieldOffset(48)]
            internal global::System.IntPtr m_shadowBox;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Shadows@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Shadows@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Shadows@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLightDirection@Shadows@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetLightDirection(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLightDirection@Shadows@fl@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLightDirection(global::System.IntPtr instance, global::System.IntPtr lightDirection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowSize@Shadows@fl@@QEBAIXZ")]
            internal static extern uint GetShadowSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowSize@Shadows@fl@@QEAAXAEBI@Z")]
            internal static extern void SetShadowSize(global::System.IntPtr instance, uint shadowSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowPcf@Shadows@fl@@QEBAHXZ")]
            internal static extern int GetShadowPcf(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowPcf@Shadows@fl@@QEAAXAEBH@Z")]
            internal static extern void SetShadowPcf(global::System.IntPtr instance, int shadowPcf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBias@Shadows@fl@@QEBAMXZ")]
            internal static extern float GetShadowBias(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowBias@Shadows@fl@@QEAAXAEBM@Z")]
            internal static extern void SetShadowBias(global::System.IntPtr instance, float shadowBias);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowDarkness@Shadows@fl@@QEBAMXZ")]
            internal static extern float GetShadowDarkness(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowDarkness@Shadows@fl@@QEAAXAEBM@Z")]
            internal static extern void SetShadowDarkness(global::System.IntPtr instance, float shadowDarkness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowTransition@Shadows@fl@@QEBAMXZ")]
            internal static extern float GetShadowTransition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowTransition@Shadows@fl@@QEAAXAEBM@Z")]
            internal static extern void SetShadowTransition(global::System.IntPtr instance, float shadowTransition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBoxOffset@Shadows@fl@@QEBAMXZ")]
            internal static extern float GetShadowBoxOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowBoxOffset@Shadows@fl@@QEAAXAEBM@Z")]
            internal static extern void SetShadowBoxOffset(global::System.IntPtr instance, float shadowBoxOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBoxDistance@Shadows@fl@@QEBAMXZ")]
            internal static extern float GetShadowBoxDistance(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowBoxDistance@Shadows@fl@@QEAAXAEBM@Z")]
            internal static extern void SetShadowBoxDistance(global::System.IntPtr instance, float shadowBoxDistance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBox@Shadows@fl@@QEBAPEAVShadowBox@2@XZ")]
            internal static extern global::System.IntPtr GetShadowBox(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Shadows __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Shadows(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Shadows __CreateInstance(global::FlounderSharp.Shadows.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Shadows(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Shadows.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Shadows.__Internal));
            global::FlounderSharp.Shadows.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Shadows(global::FlounderSharp.Shadows.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Shadows(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new shadows module.</summary>
        public Shadows()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Shadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Shadows");
        }

        public Shadows(global::FlounderSharp.Shadows _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Shadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Shadows");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Shadows Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Shadows __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Shadows.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Shadows) global::FlounderSharp.Shadows.NativeToManagedMap[__ret];
            else global::FlounderSharp.Shadows.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Shadows) global::FlounderSharp.Shadows.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.Vector3 LightDirection
        {
            get
            {
                var __ret = __Internal.GetLightDirection((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLightDirection((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public uint ShadowSize
        {
            get
            {
                var __ret = __Internal.GetShadowSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetShadowSize((__Instance + __PointerAdjustment), value);
            }
        }

        public int ShadowPcf
        {
            get
            {
                var __ret = __Internal.GetShadowPcf((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetShadowPcf((__Instance + __PointerAdjustment), value);
            }
        }

        public float ShadowBias
        {
            get
            {
                var __ret = __Internal.GetShadowBias((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetShadowBias((__Instance + __PointerAdjustment), value);
            }
        }

        public float ShadowDarkness
        {
            get
            {
                var __ret = __Internal.GetShadowDarkness((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetShadowDarkness((__Instance + __PointerAdjustment), value);
            }
        }

        public float ShadowTransition
        {
            get
            {
                var __ret = __Internal.GetShadowTransition((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetShadowTransition((__Instance + __PointerAdjustment), value);
            }
        }

        public float ShadowBoxOffset
        {
            get
            {
                var __ret = __Internal.GetShadowBoxOffset((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetShadowBoxOffset((__Instance + __PointerAdjustment), value);
            }
        }

        public float ShadowBoxDistance
        {
            get
            {
                var __ret = __Internal.GetShadowBoxDistance((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetShadowBoxDistance((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Get the shadow box, so that it can be used by other class to test if engine.entities are inside the box.</summary>
        public global::FlounderSharp.ShadowBox ShadowBox
        {
            get
            {
                var __ret = __Internal.GetShadowBox((__Instance + __PointerAdjustment));
                global::FlounderSharp.ShadowBox __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.ShadowBox.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.ShadowBox) global::FlounderSharp.ShadowBox.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.ShadowBox.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Shadows()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Shadows) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Shadows) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class RendererShadows : global::FlounderSharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(16)]
            internal global::System.IntPtr m_uniformScene;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererShadows@fl@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererShadows@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.RendererShadows __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererShadows(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.RendererShadows __CreateInstance(global::FlounderSharp.RendererShadows.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.RendererShadows(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.RendererShadows.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererShadows.__Internal));
            global::FlounderSharp.RendererShadows.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererShadows(global::FlounderSharp.RendererShadows.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererShadows(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public RendererShadows(global::FlounderSharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererShadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererShadows");
        }

        public RendererShadows(global::FlounderSharp.RendererShadows _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.RendererShadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.RendererShadows");
        }

        public override void Render(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Vector4 clipPlane, global::FlounderSharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___RenderDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static implicit operator global::FlounderSharp.RendererShadows(global::FlounderSharp.GraphicsStage graphicsStage)
        {
            return new global::FlounderSharp.RendererShadows(graphicsStage);
        }

        #region Virtual table interop

        // ~RendererShadows()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererShadows) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.RendererShadows) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::FlounderSharp.CommandBuffer) global::FlounderSharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::FlounderSharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::FlounderSharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::FlounderSharp.Vector4) global::FlounderSharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::FlounderSharp.Vector4.__CreateInstance(clipPlane);
            global::FlounderSharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.NativeToManagedMap[camera];
            else __result2 = (global::FlounderSharp.ICamera) global::FlounderSharp.ICamera.__CreateInstance(camera, skipVTables: true);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class used to render a GameObject as a shadow.</summary>
    public unsafe partial class ShadowRender : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_descriptorSet;

            [FieldOffset(64)]
            internal global::System.IntPtr m_uniformObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowRender@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowRender@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@ShadowRender@fl@@QEAAXAEBVCommandBuffer@2@AEBVPipeline@2@PEAVUniformHandler@2@@Z")]
            internal static extern void CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline, global::System.IntPtr uniformScene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniformObject@ShadowRender@fl@@QEBAPEAVUniformHandler@2@XZ")]
            internal static extern global::System.IntPtr GetUniformObject(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.ShadowRender __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShadowRender(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ShadowRender __CreateInstance(global::FlounderSharp.ShadowRender.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ShadowRender(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ShadowRender.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowRender.__Internal));
            global::FlounderSharp.ShadowRender.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShadowRender(global::FlounderSharp.ShadowRender.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShadowRender(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public ShadowRender()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.ShadowRender");
        }

        public ShadowRender(global::FlounderSharp.ShadowRender _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ShadowRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.ShadowRender");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public void CmdRender(global::FlounderSharp.CommandBuffer commandBuffer, global::FlounderSharp.Pipeline pipeline, global::FlounderSharp.UniformHandler uniformScene)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            var __arg2 = ReferenceEquals(uniformScene, null) ? global::System.IntPtr.Zero : uniformScene.__Instance;
            __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.UniformHandler UniformObject
        {
            get
            {
                var __ret = __Internal.GetUniformObject((__Instance + __PointerAdjustment));
                global::FlounderSharp.UniformHandler __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~ShadowRender()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "ShadowRender"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public enum CelestialType
    {
        CelestialSun = 0,
        CelestialMoon = 1
    }

    public unsafe partial class CelestialBody : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::FlounderSharp.CelestialType m_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CelestialBody@fl@@QEAA@AEBW4CelestialType@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::FlounderSharp.CelestialType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CelestialBody@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetType@CelestialBody@fl@@QEBA?AW4CelestialType@2@XZ")]
            internal static extern global::FlounderSharp.CelestialType GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetType@CelestialBody@fl@@QEAAXAEBW4CelestialType@2@@Z")]
            internal static extern void SetType(global::System.IntPtr instance, global::FlounderSharp.CelestialType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.CelestialBody __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.CelestialBody(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.CelestialBody __CreateInstance(global::FlounderSharp.CelestialBody.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.CelestialBody(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.CelestialBody.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.CelestialBody.__Internal));
            global::FlounderSharp.CelestialBody.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CelestialBody(global::FlounderSharp.CelestialBody.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CelestialBody(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public CelestialBody(global::FlounderSharp.CelestialType type)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.CelestialBody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), type);
            SetupVTables(GetType().FullName == "FlounderSharp.CelestialBody");
        }

        public CelestialBody(global::FlounderSharp.CelestialBody _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.CelestialBody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.CelestialBody");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public static implicit operator global::FlounderSharp.CelestialBody(global::FlounderSharp.CelestialType type)
        {
            return new global::FlounderSharp.CelestialBody(type);
        }

        public global::FlounderSharp.CelestialType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetType((__Instance + __PointerAdjustment), value);
            }
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~CelestialBody()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.CelestialBody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.CelestialBody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.CelestialBody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.CelestialBody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "CelestialBody"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.CelestialBody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a skybox material shader.</summary>
    public unsafe partial class MaterialSkybox : global::FlounderSharp.IMaterial, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_cubemap;

            [FieldOffset(64)]
            internal byte m_enableFog;

            [FieldOffset(68)]
            internal float m_blend;

            [FieldOffset(72)]
            internal global::System.IntPtr m_material;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialSkybox@fl@@QEAA@PEAVCubemap@1@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr cubemap, bool enableFog);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialSkybox@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TrySetCubemap@MaterialSkybox@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void TrySetCubemap(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubemap@MaterialSkybox@fl@@QEBAPEAVCubemap@2@XZ")]
            internal static extern global::System.IntPtr GetCubemap(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCubemap@MaterialSkybox@fl@@QEAAXPEAVCubemap@2@@Z")]
            internal static extern void SetCubemap(global::System.IntPtr instance, global::System.IntPtr cubemap);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBlend@MaterialSkybox@fl@@QEBAMXZ")]
            internal static extern float GetBlend(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBlend@MaterialSkybox@fl@@QEAAXM@Z")]
            internal static extern void SetBlend(global::System.IntPtr instance, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.MaterialSkybox __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialSkybox(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MaterialSkybox __CreateInstance(global::FlounderSharp.MaterialSkybox.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialSkybox(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MaterialSkybox.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialSkybox.__Internal));
            global::FlounderSharp.MaterialSkybox.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MaterialSkybox(global::FlounderSharp.MaterialSkybox.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialSkybox(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MaterialSkybox(global::FlounderSharp.Cubemap cubemap, bool enableFog)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialSkybox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(cubemap, null) ? global::System.IntPtr.Zero : cubemap.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, enableFog);
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialSkybox");
        }

        public MaterialSkybox(global::FlounderSharp.MaterialSkybox _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialSkybox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialSkybox");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::FlounderSharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushUniformsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(uniformObject, null) ? global::System.IntPtr.Zero : uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::FlounderSharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___PushDescriptorsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public void TrySetCubemap(string filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.TrySetCubemap((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public global::FlounderSharp.Cubemap Cubemap
        {
            get
            {
                var __ret = __Internal.GetCubemap((__Instance + __PointerAdjustment));
                global::FlounderSharp.Cubemap __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Cubemap.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Cubemap) global::FlounderSharp.Cubemap.NativeToManagedMap[__ret];
                else global::FlounderSharp.Cubemap.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Cubemap) global::FlounderSharp.Cubemap.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetCubemap((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Blend
        {
            get
            {
                var __ret = __Internal.GetBlend((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetBlend((__Instance + __PointerAdjustment), value);
            }
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::FlounderSharp.PipelineMaterial Material
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetMaterialDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetMaterialDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.PipelineMaterial __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.PipelineMaterial.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret];
                else global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~MaterialSkybox()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *destination) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (destination == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(destination))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[destination];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(destination);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "MaterialSkybox"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void PushUniforms(UniformHandler *uniformObject) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler *descriptorSet) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        // PipelineMaterial *GetMaterial() const override { return m_material; }
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetMaterialDelegateInstance;

        private static global::System.IntPtr _GetMaterialDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Material;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
                _GetMaterialDelegateInstance += _GetMaterialDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMaterialDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class LodBehaviour : global::FlounderSharp.Behaviour, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal float m_radius;

            [FieldOffset(64)]
            internal global::System.IntPtr m_transform;

            [FieldOffset(72)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_fl_S_Model___N_std_S_allocator__S0_ m_modelLods;

            [FieldOffset(96)]
            internal uint m_currentLod;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0LodBehaviour@fl@@QEAA@AEBMAEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float radius, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0LodBehaviour@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransform@LodBehaviour@fl@@QEBAPEAVTransform@2@XZ")]
            internal static extern global::System.IntPtr GetTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTransform@LodBehaviour@fl@@QEAAXAEBVTransform@2@@Z")]
            internal static extern void SetTransform(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@LodBehaviour@fl@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@LodBehaviour@fl@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float radius);
        }

        internal static new global::FlounderSharp.LodBehaviour __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.LodBehaviour(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.LodBehaviour __CreateInstance(global::FlounderSharp.LodBehaviour.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.LodBehaviour(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.LodBehaviour.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.LodBehaviour.__Internal));
            global::FlounderSharp.LodBehaviour.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private LodBehaviour(global::FlounderSharp.LodBehaviour.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LodBehaviour(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public LodBehaviour(float radius, global::FlounderSharp.Transform transform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.LodBehaviour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = transform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), radius, __arg1);
            SetupVTables(GetType().FullName == "FlounderSharp.LodBehaviour");
        }

        public LodBehaviour(global::FlounderSharp.LodBehaviour _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.LodBehaviour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.LodBehaviour");
        }

        public override void Update()
        {
            base.Update();
        }

        public global::FlounderSharp.Transform Transform
        {
            get
            {
                var __ret = __Internal.GetTransform((__Instance + __PointerAdjustment));
                global::FlounderSharp.Transform __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Transform.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Transform) global::FlounderSharp.Transform.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Transform.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetRadius((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~LodBehaviour()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.LodBehaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.LodBehaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.LodBehaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.LodBehaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "Behaviour"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.LodBehaviour) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a terrain material shader.</summary>
    public unsafe partial class MaterialTerrain : global::FlounderSharp.IMaterial, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_material;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialTerrain@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialTerrain@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.MaterialTerrain __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialTerrain(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MaterialTerrain __CreateInstance(global::FlounderSharp.MaterialTerrain.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialTerrain(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MaterialTerrain.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialTerrain.__Internal));
            global::FlounderSharp.MaterialTerrain.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MaterialTerrain(global::FlounderSharp.MaterialTerrain.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialTerrain(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MaterialTerrain()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialTerrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialTerrain");
        }

        public MaterialTerrain(global::FlounderSharp.MaterialTerrain _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialTerrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialTerrain");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::FlounderSharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushUniformsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(uniformObject, null) ? global::System.IntPtr.Zero : uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::FlounderSharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___PushDescriptorsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::FlounderSharp.PipelineMaterial Material
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetMaterialDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetMaterialDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.PipelineMaterial __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.PipelineMaterial.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret];
                else global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~MaterialTerrain()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *destination) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (destination == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(destination))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[destination];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(destination);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "MaterialTerrain"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void PushUniforms(UniformHandler *uniformObject) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler *descriptorSet) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        // PipelineMaterial *GetMaterial() const override { return m_material; }
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetMaterialDelegateInstance;

        private static global::System.IntPtr _GetMaterialDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Material;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
                _GetMaterialDelegateInstance += _GetMaterialDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMaterialDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class MeshTerrain : global::FlounderSharp.MeshSimple, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [FieldOffset(64)]
            internal float m_sideLength;

            [FieldOffset(68)]
            internal float m_squareSize;

            [FieldOffset(72)]
            internal int m_vertexCount;

            [FieldOffset(76)]
            internal float m_textureScale;

            [FieldOffset(80)]
            internal float m_radius;

            [FieldOffset(88)]
            internal global::System.IntPtr m_transform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshTerrain@fl@@QEAA@AEBM0AEBH00PEAVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float sideLength, float squareSize, int vertexCount, float textureScale, float radius, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshTerrain@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.MeshTerrain __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshTerrain(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MeshTerrain __CreateInstance(global::FlounderSharp.MeshTerrain.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshTerrain(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MeshTerrain.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshTerrain.__Internal));
            global::FlounderSharp.MeshTerrain.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshTerrain(global::FlounderSharp.MeshTerrain.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshTerrain(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MeshTerrain(float sideLength, float squareSize, int vertexCount, float textureScale, float radius, global::FlounderSharp.Transform transform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshTerrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg5 = ReferenceEquals(transform, null) ? global::System.IntPtr.Zero : transform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), sideLength, squareSize, vertexCount, textureScale, radius, __arg5);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshTerrain");
        }

        public MeshTerrain(global::FlounderSharp.MeshTerrain _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshTerrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshTerrain");
        }

        public override global::FlounderSharp.Vector3 GetPosition(float x, float z)
        {
            return base.GetPosition(x, z);
        }

        public override global::FlounderSharp.Vector3 GetNormal(global::FlounderSharp.Vector3 position)
        {
            return base.GetNormal(position);
        }

        public override global::FlounderSharp.Vector3 GetColour(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 normal)
        {
            return base.GetColour(position, normal);
        }

        public static int SideLength
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?SIDE_LENGTH@MeshTerrain@fl@@2HB");
                return *__ptr;
            }
        }

        #region Virtual table interop

        // ~MeshTerrain()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Vector3 GetPosition(const float &x, const float &z) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, float x, float z)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetPosition(x, z);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetNormal(const Vector3 &position) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _GetNormalDelegateInstance;

        private static void _GetNormalDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            var __ret = __target.GetNormal(__result1);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetColour(const Vector3 &position, const Vector3 &normal) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _GetColourDelegateInstance;

        private static void _GetColourDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr normal)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshTerrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            global::FlounderSharp.Vector3 __result2;
            if (normal == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(normal))
                __result2 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[normal];
            else __result2 = global::FlounderSharp.Vector3.__CreateInstance(normal);
            var __ret = __target.GetColour(__result1, __result2);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _GetNormalDelegateInstance += _GetNormalDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetNormalDelegateInstance).ToPointer();
                _GetColourDelegateInstance += _GetColourDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetColourDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class UiInputButton : global::FlounderSharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 248)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [FieldOffset(224)]
            internal global::System.IntPtr m_text;

            [FieldOffset(232)]
            internal global::System.IntPtr m_background;

            [FieldOffset(240)]
            internal byte m_mouseOver;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputButton@fl@@QEAA@PEAVUiObject@1@AEBVVector2@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBW4FontJustify@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr @string, global::FlounderSharp.FontJustify justify);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputButton@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetText@UiInputButton@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetText(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetText@UiInputButton@fl@@QEBAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetText(global::System.IntPtr instance, global::System.IntPtr @string);
        }

        internal static new global::FlounderSharp.UiInputButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputButton(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiInputButton __CreateInstance(global::FlounderSharp.UiInputButton.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputButton(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiInputButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputButton.__Internal));
            global::FlounderSharp.UiInputButton.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputButton(global::FlounderSharp.UiInputButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputButton(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiInputButton(global::FlounderSharp.UiObject parent, global::FlounderSharp.Vector2 position, string @string, global::FlounderSharp.FontJustify justify)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(@string, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, justify);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputButton");
        }

        public UiInputButton(global::FlounderSharp.UiInputButton _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputButton");
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Text
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetText((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetText((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~UiInputButton()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class UiInputDelay : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_timerDelay;

            [FieldOffset(8)]
            internal global::System.IntPtr m_timerRepeat;

            [FieldOffset(16)]
            internal byte m_delayOver;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputDelay@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputDelay@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiInputDelay@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UiInputDelay@fl@@QEAAXAEB_N@Z")]
            internal static extern void Update(global::System.IntPtr instance, bool keyIsDown);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CanInput@UiInputDelay@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CanInput(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiInputDelay> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.UiInputDelay>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.UiInputDelay __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputDelay(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiInputDelay __CreateInstance(global::FlounderSharp.UiInputDelay.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputDelay(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiInputDelay.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputDelay.__Internal));
            *(global::FlounderSharp.UiInputDelay.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UiInputDelay(global::FlounderSharp.UiInputDelay.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputDelay(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UiInputDelay()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputDelay.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public UiInputDelay(global::FlounderSharp.UiInputDelay _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputDelay.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.UiInputDelay.__Internal*) __Instance) = *((global::FlounderSharp.UiInputDelay.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.UiInputDelay __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update(bool keyIsDown)
        {
            __Internal.Update((__Instance + __PointerAdjustment), keyIsDown);
        }

        public bool CanInput()
        {
            var __ret = __Internal.CanInput((__Instance + __PointerAdjustment));
            return __ret;
        }
    }
}

namespace FlounderSharp
{
    public unsafe abstract partial class IUiGrabber : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUiGrabber@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUiGrabber@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IUiGrabber@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IUiGrabber> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IUiGrabber>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IUiGrabber __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IUiGrabberInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IUiGrabber __CreateInstance(global::FlounderSharp.IUiGrabber.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IUiGrabberInternal(native, skipVTables);
        }

        protected IUiGrabber(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected IUiGrabber(global::FlounderSharp.IUiGrabber _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUiGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IUiGrabber");
        }

        protected IUiGrabber()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUiGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IUiGrabber");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IUiGrabber __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IUiGrabber.__Internal*) __Instance)->vfptr_IUiGrabber = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract int GetCurrent(global::FlounderSharp.Text targetObject);

        public abstract string GetValue(int value);

        #region Virtual table interop

        // virtual ~IUiGrabber() = default
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUiGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int GetCurrent(Text *object) = 0
        private static global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUiGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Text __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Text.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.__CreateInstance(targetObject, skipVTables: true);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int &value) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUiGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class UiGrabberJoystick : global::FlounderSharp.IUiGrabber, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [FieldOffset(8)]
            internal global::FlounderSharp.JoystickPort m_joystick;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberJoystick@fl@@QEAA@AEBW4JoystickPort@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::FlounderSharp.JoystickPort joystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberJoystick@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.UiGrabberJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiGrabberJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiGrabberJoystick __CreateInstance(global::FlounderSharp.UiGrabberJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiGrabberJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiGrabberJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberJoystick.__Internal));
            global::FlounderSharp.UiGrabberJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiGrabberJoystick(global::FlounderSharp.UiGrabberJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiGrabberJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiGrabberJoystick(global::FlounderSharp.JoystickPort joystick)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), joystick);
            SetupVTables(GetType().FullName == "FlounderSharp.UiGrabberJoystick");
        }

        public UiGrabberJoystick(global::FlounderSharp.UiGrabberJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiGrabberJoystick");
        }

        public override int GetCurrent(global::FlounderSharp.Text targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetCurrentDelegate = (global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GetValueDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int));
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), value);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static implicit operator global::FlounderSharp.UiGrabberJoystick(global::FlounderSharp.JoystickPort joystick)
        {
            return new global::FlounderSharp.UiGrabberJoystick(joystick);
        }

        #region Virtual table interop

        // UiGrabberJoystick
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int GetCurrent(Text *object) override
        private static global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Text __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Text.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.__CreateInstance(targetObject, skipVTables: true);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int &value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class UiGrabberKeyboard : global::FlounderSharp.IUiGrabber, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberKeyboard@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberKeyboard@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.UiGrabberKeyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiGrabberKeyboard(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiGrabberKeyboard __CreateInstance(global::FlounderSharp.UiGrabberKeyboard.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiGrabberKeyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiGrabberKeyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberKeyboard.__Internal));
            global::FlounderSharp.UiGrabberKeyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiGrabberKeyboard(global::FlounderSharp.UiGrabberKeyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiGrabberKeyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiGrabberKeyboard(global::FlounderSharp.UiGrabberKeyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberKeyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiGrabberKeyboard");
        }

        public UiGrabberKeyboard()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberKeyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.UiGrabberKeyboard");
        }

        public override int GetCurrent(global::FlounderSharp.Text targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetCurrentDelegate = (global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GetValueDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int));
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), value);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        #region Virtual table interop

        // UiGrabberKeyboard
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int GetCurrent(Text *object) override
        private static global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Text __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Text.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.__CreateInstance(targetObject, skipVTables: true);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int &value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class UiGrabberMouse : global::FlounderSharp.IUiGrabber, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberMouse@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberMouse@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.UiGrabberMouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiGrabberMouse(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiGrabberMouse __CreateInstance(global::FlounderSharp.UiGrabberMouse.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiGrabberMouse(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiGrabberMouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberMouse.__Internal));
            global::FlounderSharp.UiGrabberMouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiGrabberMouse(global::FlounderSharp.UiGrabberMouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiGrabberMouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiGrabberMouse(global::FlounderSharp.UiGrabberMouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiGrabberMouse");
        }

        public UiGrabberMouse()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiGrabberMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.UiGrabberMouse");
        }

        public override int GetCurrent(global::FlounderSharp.Text targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetCurrentDelegate = (global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GetValueDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int));
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), value);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        #region Virtual table interop

        // UiGrabberMouse
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int GetCurrent(Text *object) override
        private static global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr targetObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Text __result0;
            if (targetObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Text.NativeToManagedMap.ContainsKey(targetObject))
                __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.NativeToManagedMap[targetObject];
            else __result0 = (global::FlounderSharp.Text) global::FlounderSharp.Text.__CreateInstance(targetObject, skipVTables: true);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int &value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiGrabberMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class UiInputGrabber : global::FlounderSharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 368)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [FieldOffset(224)]
            internal global::System.IntPtr m_text;

            [FieldOffset(232)]
            internal global::System.IntPtr m_background;

            [FieldOffset(240)]
            internal global::System.IntPtr m_grabber;

            [FieldOffset(248)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_prefix;

            [FieldOffset(280)]
            internal int m_value;

            [FieldOffset(288)]
            internal global::System.IntPtr m_inputDelay;

            [FieldOffset(296)]
            internal int m_lastKey;

            [FieldOffset(300)]
            internal byte m_selected;

            [FieldOffset(301)]
            internal byte m_mouseOver;

            [FieldOffset(304)]
            internal global::Std.Function.__Internal m_actionChange;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputGrabber@fl@@QEAA@PEAVUiObject@1@AEBVVector3@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBHPEAVIUiGrabber@1@AEBW4FontJustify@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr prefix, int value, global::System.IntPtr grabber, global::FlounderSharp.FontJustify justify);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputGrabber@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPrefix@UiInputGrabber@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetPrefix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPrefix@UiInputGrabber@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetPrefix(global::System.IntPtr instance, global::System.IntPtr prefix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@UiInputGrabber@fl@@QEBAHXZ")]
            internal static extern int GetValue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@UiInputGrabber@fl@@QEAAXAEBH@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, int value);
        }

        internal static new global::FlounderSharp.UiInputGrabber __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputGrabber(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiInputGrabber __CreateInstance(global::FlounderSharp.UiInputGrabber.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputGrabber(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiInputGrabber.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputGrabber.__Internal));
            global::FlounderSharp.UiInputGrabber.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputGrabber(global::FlounderSharp.UiInputGrabber.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputGrabber(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiInputGrabber(global::FlounderSharp.UiObject parent, global::FlounderSharp.Vector3 position, string prefix, int value, global::FlounderSharp.IUiGrabber grabber, global::FlounderSharp.FontJustify justify)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(prefix, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __arg4 = ReferenceEquals(grabber, null) ? global::System.IntPtr.Zero : grabber.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, value, __arg4, justify);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputGrabber");
        }

        public UiInputGrabber(global::FlounderSharp.UiInputGrabber _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputGrabber");
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Prefix
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetPrefix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetPrefix((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public int Value
        {
            get
            {
                var __ret = __Internal.GetValue((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetValue((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~UiInputGrabber()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IUiGrabberInternal : global::FlounderSharp.IUiGrabber, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IUiGrabber.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUiGrabber.__Internal));
            *(global::FlounderSharp.IUiGrabber.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IUiGrabberInternal(global::FlounderSharp.IUiGrabber.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IUiGrabberInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int GetCurrent(global::FlounderSharp.Text targetObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetCurrentDelegate = (global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(targetObject, null) ? global::System.IntPtr.Zero : targetObject.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GetValueDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_int));
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), value);
            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }
    }
}

namespace FlounderSharp
{
    public unsafe partial class UiInputSlider : global::FlounderSharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 344)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [FieldOffset(224)]
            internal global::System.IntPtr m_text;

            [FieldOffset(232)]
            internal global::System.IntPtr m_background;

            [FieldOffset(240)]
            internal global::System.IntPtr m_slider;

            [FieldOffset(248)]
            internal byte m_updating;

            [FieldOffset(252)]
            internal float m_progressMin;

            [FieldOffset(256)]
            internal float m_progressMax;

            [FieldOffset(260)]
            internal float m_value;

            [FieldOffset(264)]
            internal byte m_mouseOver;

            [FieldOffset(265)]
            internal byte m_hasChange;

            [FieldOffset(272)]
            internal global::System.IntPtr m_timerChange;

            [FieldOffset(280)]
            internal global::Std.Function.__Internal m_actionChange;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputSlider@fl@@QEAA@PEAVUiObject@1@AEBVVector3@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBM33AEBW4FontJustify@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr @string, float progressMin, float progressMax, float value, global::FlounderSharp.FontJustify justify);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputSlider@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetText@UiInputSlider@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetText(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetText@UiInputSlider@fl@@QEBAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetText(global::System.IntPtr instance, global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProgressMin@UiInputSlider@fl@@QEBAMXZ")]
            internal static extern float GetProgressMin(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetProgressMin@UiInputSlider@fl@@QEAAXAEBM@Z")]
            internal static extern void SetProgressMin(global::System.IntPtr instance, float progressMin);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProgressMax@UiInputSlider@fl@@QEBAMXZ")]
            internal static extern float GetProgressMax(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetProgressMax@UiInputSlider@fl@@QEAAXAEBM@Z")]
            internal static extern void SetProgressMax(global::System.IntPtr instance, float progressMax);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@UiInputSlider@fl@@QEBAMXZ")]
            internal static extern float GetValue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@UiInputSlider@fl@@QEAAXAEBM@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, float value);
        }

        internal static new global::FlounderSharp.UiInputSlider __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputSlider(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiInputSlider __CreateInstance(global::FlounderSharp.UiInputSlider.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputSlider(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiInputSlider.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputSlider.__Internal));
            global::FlounderSharp.UiInputSlider.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputSlider(global::FlounderSharp.UiInputSlider.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputSlider(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiInputSlider(global::FlounderSharp.UiObject parent, global::FlounderSharp.Vector3 position, string @string, float progressMin, float progressMax, float value, global::FlounderSharp.FontJustify justify)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputSlider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(@string, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, progressMin, progressMax, value, justify);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputSlider");
        }

        public UiInputSlider(global::FlounderSharp.UiInputSlider _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputSlider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputSlider");
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Text
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetText((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetText((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public float ProgressMin
        {
            get
            {
                var __ret = __Internal.GetProgressMin((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetProgressMin((__Instance + __PointerAdjustment), value);
            }
        }

        public float ProgressMax
        {
            get
            {
                var __ret = __Internal.GetProgressMax((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetProgressMax((__Instance + __PointerAdjustment), value);
            }
        }

        public float Value
        {
            get
            {
                var __ret = __Internal.GetValue((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetValue((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // ~UiInputSlider()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputSlider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputSlider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class UiInputText : global::FlounderSharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 384)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [FieldOffset(224)]
            internal global::System.IntPtr m_text;

            [FieldOffset(232)]
            internal global::System.IntPtr m_background;

            [FieldOffset(240)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_prefix;

            [FieldOffset(272)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [FieldOffset(304)]
            internal global::System.IntPtr m_inputDelay;

            [FieldOffset(312)]
            internal int m_lastKey;

            [FieldOffset(316)]
            internal byte m_selected;

            [FieldOffset(317)]
            internal byte m_mouseOver;

            [FieldOffset(320)]
            internal global::Std.Function.__Internal m_actionChange;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputText@fl@@QEAA@PEAVUiObject@1@AEBVVector3@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2AEBW4FontJustify@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr prefix, global::System.IntPtr value, global::FlounderSharp.FontJustify justify);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputText@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPrefix@UiInputText@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetPrefix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPrefix@UiInputText@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetPrefix(global::System.IntPtr instance, global::System.IntPtr prefix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@UiInputText@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@UiInputText@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, global::System.IntPtr value);
        }

        internal static new global::FlounderSharp.UiInputText __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputText(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiInputText __CreateInstance(global::FlounderSharp.UiInputText.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiInputText(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiInputText.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputText.__Internal));
            global::FlounderSharp.UiInputText.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputText(global::FlounderSharp.UiInputText.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputText(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiInputText(global::FlounderSharp.UiObject parent, global::FlounderSharp.Vector3 position, string prefix, string value, global::FlounderSharp.FontJustify justify)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputText.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(prefix, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __allocator3 = new global::Std.Allocator<sbyte>();
            var __basicString3 = global::Std.BasicStringExtensions.BasicString(value, __allocator3);
            var __arg3 = __basicString3.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, justify);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            __basicString3.Dispose(false);
            __allocator3.Dispose();
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputText");
        }

        public UiInputText(global::FlounderSharp.UiInputText _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiInputText.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiInputText");
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Prefix
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetPrefix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetPrefix((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~UiInputText()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputText) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiInputText) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class UiStartLogo : global::FlounderSharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 256)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::System.IntPtr m_children;

            [FieldOffset(24)]
            internal byte m_visible;

            [FieldOffset(32)]
            internal global::System.IntPtr m_rectangle;

            [FieldOffset(40)]
            internal global::System.IntPtr m_scissor;

            [FieldOffset(48)]
            internal global::System.IntPtr m_positionOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr m_screenTransform;

            [FieldOffset(64)]
            internal global::System.IntPtr m_alphaDriver;

            [FieldOffset(72)]
            internal float m_alpha;

            [FieldOffset(80)]
            internal global::System.IntPtr m_scaleDriver;

            [FieldOffset(88)]
            internal float m_scale;

            [FieldOffset(96)]
            internal global::Std.Function.__Internal m_actionLeft;

            [FieldOffset(160)]
            internal global::Std.Function.__Internal m_actionRight;

            [FieldOffset(224)]
            internal global::System.IntPtr m_guiBackground;

            [FieldOffset(232)]
            internal global::System.IntPtr m_guiLogo;

            [FieldOffset(240)]
            internal global::System.IntPtr m_textCopyright;

            [FieldOffset(248)]
            internal byte m_starting;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiStartLogo@fl@@QEAA@PEAVUiObject@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiStartLogo@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStarting@UiStartLogo@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetStarting(global::System.IntPtr instance, bool starting);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsStarting@UiStartLogo@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsStarting(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.UiStartLogo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiStartLogo(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.UiStartLogo __CreateInstance(global::FlounderSharp.UiStartLogo.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.UiStartLogo(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.UiStartLogo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiStartLogo.__Internal));
            global::FlounderSharp.UiStartLogo.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiStartLogo(global::FlounderSharp.UiStartLogo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiStartLogo(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UiStartLogo(global::FlounderSharp.UiObject parent)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiStartLogo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiStartLogo");
        }

        public UiStartLogo(global::FlounderSharp.UiStartLogo _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.UiStartLogo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.UiStartLogo");
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public void SetStarting(bool starting)
        {
            __Internal.SetStarting((__Instance + __PointerAdjustment), starting);
        }

        public bool IsStarting
        {
            get
            {
                var __ret = __Internal.IsStarting((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~UiStartLogo()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiStartLogo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void UpdateObject() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.UiStartLogo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a voxel material shader.</summary>
    public unsafe partial class MaterialVoxel : global::FlounderSharp.IMaterial, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_material;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialVoxel@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialVoxel@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.MaterialVoxel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialVoxel(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MaterialVoxel __CreateInstance(global::FlounderSharp.MaterialVoxel.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialVoxel(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MaterialVoxel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialVoxel.__Internal));
            global::FlounderSharp.MaterialVoxel.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MaterialVoxel(global::FlounderSharp.MaterialVoxel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialVoxel(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MaterialVoxel()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialVoxel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialVoxel");
        }

        public MaterialVoxel(global::FlounderSharp.MaterialVoxel _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialVoxel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialVoxel");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::FlounderSharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushUniformsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(uniformObject, null) ? global::System.IntPtr.Zero : uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::FlounderSharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___PushDescriptorsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::FlounderSharp.PipelineMaterial Material
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetMaterialDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetMaterialDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.PipelineMaterial __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.PipelineMaterial.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret];
                else global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~MaterialVoxel()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *destination) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (destination == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(destination))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[destination];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(destination);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "MaterialVoxel"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void PushUniforms(UniformHandler *uniformObject) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler *descriptorSet) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        // PipelineMaterial *GetMaterial() const override { return m_material; }
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetMaterialDelegateInstance;

        private static global::System.IntPtr _GetMaterialDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialVoxel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Material;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
                _GetMaterialDelegateInstance += _GetMaterialDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMaterialDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public enum BlockFace
    {
        Facefront = 0,
        Faceback = 1,
        Faceup = 2,
        Facedown = 3,
        Faceleft = 4,
        Faceright = 5
    }

    public unsafe partial class VoxelBlock : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_position;

            [FieldOffset(16)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_type;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VoxelBlock@fl@@QEAA@PEAVVoxelChunk@1@AEBVVector3@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VoxelBlock@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VoxelBlock@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetChanged@VoxelBlock@fl@@QEAAXXZ")]
            internal static extern void SetChanged(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindColour@VoxelBlock@fl@@SAPEAVColour@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr FindColour(global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetType@VoxelBlock@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetType(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetType@VoxelBlock@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetType(global::System.IntPtr instance, global::System.IntPtr type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@VoxelBlock@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPosition(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VoxelBlock> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.VoxelBlock>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.VoxelBlock __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VoxelBlock(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VoxelBlock __CreateInstance(global::FlounderSharp.VoxelBlock.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VoxelBlock(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VoxelBlock.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VoxelBlock.__Internal));
            global::FlounderSharp.VoxelBlock.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VoxelBlock(global::FlounderSharp.VoxelBlock.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VoxelBlock(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VoxelBlock(global::FlounderSharp.VoxelChunk parent, global::FlounderSharp.Vector3 position, string type)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VoxelBlock.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(type, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public VoxelBlock(global::FlounderSharp.VoxelBlock _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VoxelBlock.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.VoxelBlock __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetChanged()
        {
            __Internal.SetChanged((__Instance + __PointerAdjustment));
        }

        public static global::FlounderSharp.Colour FindColour(string key)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.FindColour(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.Colour __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
            return __result0;
        }

        public string Type
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetType((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetType((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::FlounderSharp.Vector3 Position
        {
            get
            {
                var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace FlounderSharp
{
    public enum ChunkMesh
    {
        MeshGreedy = 0,
        MeshSimple = 1
    }

    public unsafe partial class VoxelChunk : global::FlounderSharp.Component, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_blocks;

            [FieldOffset(64)]
            internal global::FlounderSharp.ChunkMesh m_chunkMesh;

            [FieldOffset(68)]
            internal byte m_generate;

            [FieldOffset(69)]
            internal byte m_rebuild;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VoxelChunk@fl@@QEAA@AEBW4ChunkMesh@1@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::FlounderSharp.ChunkMesh chunkMesh, bool generate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VoxelChunk@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBlock@VoxelChunk@fl@@QEAAPEAVVoxelBlock@2@AEBH00@Z")]
            internal static extern global::System.IntPtr GetBlock(global::System.IntPtr instance, int x, int y, int z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsBlockFilled@VoxelChunk@fl@@QEAA_NAEBH00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsBlockFilled(global::System.IntPtr instance, int x, int y, int z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFaceVisible@VoxelChunk@fl@@QEAA_NAEBH00AEBW4BlockFace@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFaceVisible(global::System.IntPtr instance, int x, int y, int z, global::FlounderSharp.BlockFace faceType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rebuild@VoxelChunk@fl@@QEAAXXZ")]
            internal static extern void Rebuild(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.VoxelChunk __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VoxelChunk(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.VoxelChunk __CreateInstance(global::FlounderSharp.VoxelChunk.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.VoxelChunk(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.VoxelChunk.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VoxelChunk.__Internal));
            global::FlounderSharp.VoxelChunk.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VoxelChunk(global::FlounderSharp.VoxelChunk.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VoxelChunk(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public VoxelChunk(global::FlounderSharp.ChunkMesh chunkMesh, bool generate)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VoxelChunk.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), chunkMesh, generate);
            SetupVTables(GetType().FullName == "FlounderSharp.VoxelChunk");
        }

        public VoxelChunk(global::FlounderSharp.VoxelChunk _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.VoxelChunk.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.VoxelChunk");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public global::FlounderSharp.VoxelBlock GetBlock(int x, int y, int z)
        {
            var __ret = __Internal.GetBlock((__Instance + __PointerAdjustment), x, y, z);
            global::FlounderSharp.VoxelBlock __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.VoxelBlock.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.VoxelBlock) global::FlounderSharp.VoxelBlock.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.VoxelBlock.__CreateInstance(__ret);
            return __result0;
        }

        public bool IsBlockFilled(int x, int y, int z)
        {
            var __ret = __Internal.IsBlockFilled((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public bool IsFaceVisible(int x, int y, int z, global::FlounderSharp.BlockFace faceType)
        {
            var __ret = __Internal.IsFaceVisible((__Instance + __PointerAdjustment), x, y, z, faceType);
            return __ret;
        }

        public void Rebuild()
        {
            __Internal.Rebuild((__Instance + __PointerAdjustment));
        }

        public static int ChunkWidth
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?CHUNK_WIDTH@VoxelChunk@fl@@2HB");
                return *__ptr;
            }
        }

        public static int ChunkHeight
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?CHUNK_HEIGHT@VoxelChunk@fl@@2HB");
                return *__ptr;
            }
        }

        public static float VoxelSize
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?VOXEL_SIZE@VoxelChunk@fl@@2MB");
                return *__ptr;
            }
        }

        public static global::FlounderSharp.Vector3 ChunkSize
        {
            get
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?CHUNK_SIZE@VoxelChunk@fl@@2PEBVVector3@2@EB");
                global::FlounderSharp.Vector3 __result0;
                if (*__ptr == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(*__ptr))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[*__ptr];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(*__ptr);
                return __result0;
            }

            set
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?CHUNK_SIZE@VoxelChunk@fl@@2PEBVVector3@2@EB");
                *__ptr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public override string Name
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetNameDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetNameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // ~VoxelChunk()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VoxelChunk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VoxelChunk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VoxelChunk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VoxelChunk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "Chunk"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.VoxelChunk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    public unsafe partial class MeshWater : global::FlounderSharp.MeshSimple, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::System.IntPtr m_vertexBuffer;

            [FieldOffset(48)]
            internal global::System.IntPtr m_indexBuffer;

            [FieldOffset(56)]
            internal global::System.IntPtr m_aabb;

            [FieldOffset(64)]
            internal float m_sideLength;

            [FieldOffset(68)]
            internal float m_squareSize;

            [FieldOffset(72)]
            internal int m_vertexCount;

            [FieldOffset(76)]
            internal float m_textureScale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshWater@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshWater@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::FlounderSharp.MeshWater __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshWater(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MeshWater __CreateInstance(global::FlounderSharp.MeshWater.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MeshWater(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MeshWater.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshWater.__Internal));
            global::FlounderSharp.MeshWater.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshWater(global::FlounderSharp.MeshWater.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshWater(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MeshWater()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshWater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.MeshWater");
        }

        public MeshWater(global::FlounderSharp.MeshWater _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MeshWater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MeshWater");
        }

        public override global::FlounderSharp.Vector3 GetPosition(float x, float z)
        {
            return base.GetPosition(x, z);
        }

        public override global::FlounderSharp.Vector3 GetNormal(global::FlounderSharp.Vector3 position)
        {
            return base.GetNormal(position);
        }

        public override global::FlounderSharp.Vector3 GetColour(global::FlounderSharp.Vector3 position, global::FlounderSharp.Vector3 normal)
        {
            return base.GetColour(position, normal);
        }

        public static float SideLength
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?SIDE_LENGTH@MeshWater@fl@@2MB");
                return *__ptr;
            }
        }

        public static float SquareSize
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?SQUARE_SIZE@MeshWater@fl@@2MB");
                return *__ptr;
            }
        }

        public static int VertexCount
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?VERTEX_COUNT@MeshWater@fl@@2HB");
                return *__ptr;
            }
        }

        public static float TextureScale
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?TEXTURE_SCALE@MeshWater@fl@@2MB");
                return *__ptr;
            }
        }

        public static global::FlounderSharp.Colour WaterColour
        {
            get
            {
                var __ptr = (global::FlounderSharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Flounder", "?WATER_COLOUR@MeshWater@fl@@2VColour@2@B");
                return global::FlounderSharp.Colour.__CreateInstance(*__ptr);
            }
        }

        #region Virtual table interop

        // ~MeshWater()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // std::string GetFilename() override { return m_filename; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // Vector3 GetPosition(const float &x, const float &z) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_float_float _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, float x, float z)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetPosition(x, z);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetNormal(const Vector3 &position) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _GetNormalDelegateInstance;

        private static void _GetNormalDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            var __ret = __target.GetNormal(__result1);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetColour(const Vector3 &position, const Vector3 &normal) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _GetColourDelegateInstance;

        private static void _GetColourDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr normal)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MeshWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.Vector3 __result1;
            if (position == IntPtr.Zero) __result1 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result1 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[position];
            else __result1 = global::FlounderSharp.Vector3.__CreateInstance(position);
            global::FlounderSharp.Vector3 __result2;
            if (normal == IntPtr.Zero) __result2 = null;
            else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(normal))
                __result2 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[normal];
            else __result2 = global::FlounderSharp.Vector3.__CreateInstance(normal);
            var __ret = __target.GetColour(__result1, __result2);
            *(global::FlounderSharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::FlounderSharp.Vector3.__Internal() : *(global::FlounderSharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _GetNormalDelegateInstance += _GetNormalDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetNormalDelegateInstance).ToPointer();
                _GetColourDelegateInstance += _GetColourDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetColourDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>Class that represents a water material shader.</summary>
    public unsafe partial class MaterialWater : global::FlounderSharp.IMaterial, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Component;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(48)]
            internal byte m_enabled;

            [FieldOffset(56)]
            internal global::System.IntPtr m_colour;

            [FieldOffset(64)]
            internal global::System.IntPtr m_material;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialWater@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialWater@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColour@MaterialWater@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColour@MaterialWater@fl@@QEBAXAEBVColour@2@@Z")]
            internal static extern void SetColour(global::System.IntPtr instance, global::System.IntPtr colour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Component@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::FlounderSharp.MaterialWater __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialWater(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.MaterialWater __CreateInstance(global::FlounderSharp.MaterialWater.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.MaterialWater(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.MaterialWater.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialWater.__Internal));
            global::FlounderSharp.MaterialWater.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MaterialWater(global::FlounderSharp.MaterialWater.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialWater(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public MaterialWater()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialWater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialWater");
        }

        public MaterialWater(global::FlounderSharp.MaterialWater _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.MaterialWater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.MaterialWater");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Load(global::FlounderSharp.LoadedValue value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___LoadDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            ___LoadDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Write(global::FlounderSharp.LoadedValue destination)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___WriteDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(destination, null) ? global::System.IntPtr.Zero : destination.__Instance;
            ___WriteDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::FlounderSharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushUniformsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(uniformObject, null) ? global::System.IntPtr.Zero : uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::FlounderSharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___PushDescriptorsDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(descriptorSet, null) ? global::System.IntPtr.Zero : descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public global::FlounderSharp.Colour Colour
        {
            get
            {
                var __ret = __Internal.GetColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override string Name
        {
            get
            {
                return base.Name;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<sbyte>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::FlounderSharp.PipelineMaterial Material
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetMaterialDelegate = (global::FlounderSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetMaterialDelegate((__Instance + __PointerAdjustment));
                global::FlounderSharp.PipelineMaterial __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.PipelineMaterial.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret];
                else global::FlounderSharp.PipelineMaterial.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.PipelineMaterial) global::FlounderSharp.PipelineMaterial.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~MaterialWater()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Load(LoadedValue *value) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance, global::System.IntPtr value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (value == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(value))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[value];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(value);
            __target.Load(__result0);
        }

        // void Write(LoadedValue *destination) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _WriteDelegateInstance;

        private static void _WriteDelegateHook(global::System.IntPtr instance, global::System.IntPtr destination)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.LoadedValue __result0;
            if (destination == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.LoadedValue.NativeToManagedMap.ContainsKey(destination))
                __result0 = (global::FlounderSharp.LoadedValue) global::FlounderSharp.LoadedValue.NativeToManagedMap[destination];
            else __result0 = global::FlounderSharp.LoadedValue.__CreateInstance(destination);
            __target.Write(__result0);
        }

        // std::string GetName() const override { return "MaterialWater"; }
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _GetNameDelegateInstance;

        private static void _GetNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Name;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void PushUniforms(UniformHandler *uniformObject) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::FlounderSharp.UniformHandler) global::FlounderSharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::FlounderSharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler *descriptorSet) override
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::FlounderSharp.DescriptorsHandler) global::FlounderSharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::FlounderSharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        // PipelineMaterial *GetMaterial() const override { return m_material; }
        private static global::FlounderSharp.Delegates.Func_IntPtr_IntPtr _GetMaterialDelegateInstance;

        private static global::System.IntPtr _GetMaterialDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.MaterialWater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Material;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[8];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _WriteDelegateInstance += _WriteDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_WriteDelegateInstance).ToPointer();
                _GetNameDelegateInstance += _GetNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetNameDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
                _GetMaterialDelegateInstance += _GetMaterialDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetMaterialDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                    *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                    *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                    *(void**) (vfptr0 + 40) = _Thunks[4];
                    *(void**) (vfptr0 + 48) = _Thunks[5];
                    *(void**) (vfptr0 + 56) = _Thunks[6];
                    *(void**) (vfptr0 + 64) = _Thunks[7];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for managing worlds.</summary>
    public unsafe partial class Worlds : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_noiseTerrain;

            [FieldOffset(16)]
            internal global::System.IntPtr m_driverDay;

            [FieldOffset(24)]
            internal float m_factorDay;

            [FieldOffset(32)]
            internal global::System.IntPtr m_skyboxRotation;

            [FieldOffset(40)]
            internal global::System.IntPtr m_sunPosition;

            [FieldOffset(48)]
            internal global::System.IntPtr m_moonPosition;

            [FieldOffset(56)]
            internal global::System.IntPtr m_sunColour;

            [FieldOffset(64)]
            internal global::System.IntPtr m_moonColour;

            [FieldOffset(72)]
            internal global::System.IntPtr m_fog;

            [FieldOffset(80)]
            internal global::System.IntPtr m_skyColour;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Worlds@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Worlds@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Worlds@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTerrainRadius@Worlds@fl@@QEAAMAEBM00@Z")]
            internal static extern float GetTerrainRadius(global::System.IntPtr instance, float radius, float theta, float phi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFog@Worlds@fl@@QEBAPEAVFog@2@XZ")]
            internal static extern global::System.IntPtr GetFog(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFog@Worlds@fl@@QEAAXAEBVFog@2@@Z")]
            internal static extern void SetFog(global::System.IntPtr instance, global::System.IntPtr fog);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSkyColour@Worlds@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetSkyColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSkyColour@Worlds@fl@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetSkyColour(global::System.IntPtr instance, global::System.IntPtr skyColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDayFactor@Worlds@fl@@QEBAMXZ")]
            internal static extern float GetDayFactor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunriseFactor@Worlds@fl@@QEBAMXZ")]
            internal static extern float GetSunriseFactor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowFactor@Worlds@fl@@QEBAMXZ")]
            internal static extern float GetShadowFactor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunHeight@Worlds@fl@@QEBAMXZ")]
            internal static extern float GetSunHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStarIntensity@Worlds@fl@@QEBAMXZ")]
            internal static extern float GetStarIntensity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoiseTerrain@Worlds@fl@@QEBAPEAVNoise@2@XZ")]
            internal static extern global::System.IntPtr GetNoiseTerrain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSkyboxRotation@Worlds@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetSkyboxRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunPosition@Worlds@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetSunPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMoonPosition@Worlds@fl@@QEBAPEAVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetMoonPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunColour@Worlds@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetSunColour(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMoonColour@Worlds@fl@@QEBAPEAVColour@2@XZ")]
            internal static extern global::System.IntPtr GetMoonColour(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Worlds __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Worlds(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Worlds __CreateInstance(global::FlounderSharp.Worlds.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Worlds(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Worlds.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Worlds.__Internal));
            global::FlounderSharp.Worlds.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Worlds(global::FlounderSharp.Worlds.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Worlds(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new worlds module.</summary>
        public Worlds()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Worlds.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Worlds");
        }

        public Worlds(global::FlounderSharp.Worlds _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Worlds.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Worlds");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public float GetTerrainRadius(float radius, float theta, float phi)
        {
            var __ret = __Internal.GetTerrainRadius((__Instance + __PointerAdjustment), radius, theta, phi);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Worlds Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Worlds __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Worlds.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Worlds) global::FlounderSharp.Worlds.NativeToManagedMap[__ret];
            else global::FlounderSharp.Worlds.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Worlds) global::FlounderSharp.Worlds.__CreateInstance(__ret);
            return __result0;
        }

        public global::FlounderSharp.Fog Fog
        {
            get
            {
                var __ret = __Internal.GetFog((__Instance + __PointerAdjustment));
                global::FlounderSharp.Fog __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Fog.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Fog) global::FlounderSharp.Fog.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Fog.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetFog((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::FlounderSharp.Colour SkyColour
        {
            get
            {
                var __ret = __Internal.GetSkyColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetSkyColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float DayFactor
        {
            get
            {
                var __ret = __Internal.GetDayFactor((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float SunriseFactor
        {
            get
            {
                var __ret = __Internal.GetSunriseFactor((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float ShadowFactor
        {
            get
            {
                var __ret = __Internal.GetShadowFactor((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float SunHeight
        {
            get
            {
                var __ret = __Internal.GetSunHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float StarIntensity
        {
            get
            {
                var __ret = __Internal.GetStarIntensity((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::FlounderSharp.Noise NoiseTerrain
        {
            get
            {
                var __ret = __Internal.GetNoiseTerrain((__Instance + __PointerAdjustment));
                global::FlounderSharp.Noise __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Noise.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Noise) global::FlounderSharp.Noise.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Noise.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector3 SkyboxRotation
        {
            get
            {
                var __ret = __Internal.GetSkyboxRotation((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector3 SunPosition
        {
            get
            {
                var __ret = __Internal.GetSunPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Vector3 MoonPosition
        {
            get
            {
                var __ret = __Internal.GetMoonPosition((__Instance + __PointerAdjustment));
                global::FlounderSharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Vector3) global::FlounderSharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Colour SunColour
        {
            get
            {
                var __ret = __Internal.GetSunColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::FlounderSharp.Colour MoonColour
        {
            get
            {
                var __ret = __Internal.GetMoonColour((__Instance + __PointerAdjustment));
                global::FlounderSharp.Colour __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.Colour.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.Colour) global::FlounderSharp.Colour.NativeToManagedMap[__ret];
                else __result0 = global::FlounderSharp.Colour.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // ~Worlds()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Worlds) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Worlds) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            internal global::System.IntPtr first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I____N_fl_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(8)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_fl_S_ConfigKey
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::FlounderSharp.ConfigKey.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
