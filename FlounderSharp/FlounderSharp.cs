// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FlounderSharp
{
    /// <summary>Represents when a module will update in the game loop.</summary>
    public enum ModuleUpdate
    {
        UpdateAlways = 0,
        UpdatePre = 1,
        UpdateNormal = 2,
        UpdatePost = 3,
        UpdateRender = 4
    }

    /// <summary>A interface used for defining engine modules.</summary>
    public unsafe abstract partial class IModule : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IModule@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IModule> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IModule>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IModule __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IModuleInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IModule __CreateInstance(global::FlounderSharp.IModule.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IModuleInternal(native, skipVTables);
        }

        protected IModule(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new module.</summary>
        protected IModule()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IModule");
        }

        protected IModule(global::FlounderSharp.IModule _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IModule");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IModule.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the module.</summary>
        public abstract void Update();

        #region Virtual table interop

        // virtual ~IModule() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IModule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IModule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IModuleInternal : global::FlounderSharp.IModule, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IModule.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IModule.__Internal));
            *(global::FlounderSharp.IModule.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IModuleInternal(global::FlounderSharp.IModule.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IModuleInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>The update function for the module.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace FlounderSharp
{
    /// <summary>The default updater for the engine.</summary>
    public unsafe partial class ModuleRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_modules;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModuleRegister@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@ModuleRegister@fl@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::FlounderSharp.ModuleUpdate update, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@ModuleRegister@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeregisterModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModule@ModuleRegister@fl@@QEAAPEAVIModule@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RunUpdate@ModuleRegister@fl@@QEBAXAEBW4ModuleUpdate@2@@Z")]
            internal static extern void RunUpdate(global::System.IntPtr instance, global::FlounderSharp.ModuleUpdate update);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ModuleRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.ModuleRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.ModuleRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ModuleRegister(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.ModuleRegister __CreateInstance(global::FlounderSharp.ModuleRegister.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.ModuleRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.ModuleRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ModuleRegister.__Internal));
            *(global::FlounderSharp.ModuleRegister.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleRegister(global::FlounderSharp.ModuleRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new module register.</summary>
        public ModuleRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleRegister(global::FlounderSharp.ModuleRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.ModuleRegister.__Internal*) __Instance) = *((global::FlounderSharp.ModuleRegister.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.ModuleRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        /// <param name="name">The modules name.</param>
        public global::FlounderSharp.IModule RegisterModule(global::FlounderSharp.IModule module, global::FlounderSharp.ModuleUpdate update, string name)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(name, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            global::FlounderSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.NativeToManagedMap[__ret];
            else global::FlounderSharp.IModule.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="name">The modules name.</param>
        public void DeregisterModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Gets a module from the register.</summary>
        /// <param name="name">The module name to get.</param>
        public global::FlounderSharp.IModule GetModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.NativeToManagedMap[__ret];
            else global::FlounderSharp.IModule.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Runs updates for all module update types.</summary>
        /// <param name="update">The modules update type.</param>
        public void RunUpdate(global::FlounderSharp.ModuleUpdate update)
        {
            __Internal.RunUpdate((__Instance + __PointerAdjustment), update);
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A class used to define how the engine will run updates and timings.</summary>
    public unsafe abstract partial class IUpdater : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUpdater;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUpdater@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUpdater@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IUpdater@fl@@UEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IUpdater> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.IUpdater>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.IUpdater __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IUpdaterInternal(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.IUpdater __CreateInstance(global::FlounderSharp.IUpdater.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.IUpdaterInternal(native, skipVTables);
        }

        protected IUpdater(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new updater.</summary>
        protected IUpdater()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.IUpdater");
        }

        protected IUpdater(global::FlounderSharp.IUpdater _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.IUpdater");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.IUpdater __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::FlounderSharp.IUpdater.__Internal*) __Instance)->vfptr_IUpdater = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_int));
                    ___dtorDelegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates all modules in order.</summary>
        public abstract void Update(global::FlounderSharp.ModuleRegister moduleRegister);

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public abstract float Delta
        {
            get;
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public abstract float DeltaRender
        {
            get;
        }

        #region Virtual table interop

        // virtual ~IUpdater() { }
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update(ModuleRegister *moduleRegister) = 0
        private static global::FlounderSharp.Delegates.Action_IntPtr_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance, global::System.IntPtr moduleRegister)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::FlounderSharp.ModuleRegister __result0;
            if (moduleRegister == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.ModuleRegister.NativeToManagedMap.ContainsKey(moduleRegister))
                __result0 = (global::FlounderSharp.ModuleRegister) global::FlounderSharp.ModuleRegister.NativeToManagedMap[moduleRegister];
            else __result0 = global::FlounderSharp.ModuleRegister.__CreateInstance(moduleRegister);
            __target.Update(__result0);
        }

        // float GetDelta() = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetDeltaDelegateInstance;

        private static float _GetDeltaDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Delta;
            return __ret;
        }

        // float GetDeltaRender() = 0
        private static global::FlounderSharp.Delegates.Func_float_IntPtr _GetDeltaRenderDelegateInstance;

        private static float _GetDeltaRenderDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.IUpdater) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.DeltaRender;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _GetDeltaDelegateInstance += _GetDeltaDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetDeltaDelegateInstance).ToPointer();
                _GetDeltaRenderDelegateInstance += _GetDeltaRenderDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetDeltaRenderDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                    *(void**) (vfptr0 + 32) = _Thunks[3];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class IUpdaterInternal : global::FlounderSharp.IUpdater, IDisposable
    {
        private static void* __CopyValue(global::FlounderSharp.IUpdater.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.IUpdater.__Internal));
            *(global::FlounderSharp.IUpdater.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IUpdaterInternal(global::FlounderSharp.IUpdater.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IUpdaterInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Updates all modules in order.</summary>
        public override void Update(global::FlounderSharp.ModuleRegister moduleRegister)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(moduleRegister, null) ? global::System.IntPtr.Zero : moduleRegister.__Instance;
            ___UpdateDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public override float Delta
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetDeltaDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetDeltaDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public override float DeltaRender
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetDeltaRenderDelegate = (global::FlounderSharp.Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Func_float_IntPtr));
                var __ret = ___GetDeltaRenderDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace FlounderSharp
{
    /// <summary>A engine used for simplifying the creation of complicated applications. By using flexible Module loading and Extension injecting, it allows the engine to be used for Networking, Imaging, AIs, Games, and many more applications. Start off by creating a new Engine object in your main thread, using Extensions in the constructor. By using Extensions: Modules can be required and therefor loaded into the engine. Implementing interfaces like  with your extension can allow you do task specific things with your Extensions. After creating your Engine object call  to start.</summary>
    public unsafe partial class Engine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Chrono.TimePoint.__Internalc__N_std_N_chrono_S_time_point____N_std_N_chrono_S_steady_clock___N_std_N_chrono_S_duration__K___N_std_S_ratio__VK1_VK1000000000 m_start;

            [FieldOffset(8)]
            internal float m_timeOffset;

            [FieldOffset(16)]
            internal global::System.IntPtr m_moduleRegister;

            [FieldOffset(24)]
            internal global::System.IntPtr m_updater;

            [FieldOffset(32)]
            internal float m_fpsLimit;

            [FieldOffset(36)]
            internal byte m_initialized;

            [FieldOffset(37)]
            internal byte m_running;

            [FieldOffset(38)]
            internal byte m_error;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Engine@fl@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Engine@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Run@Engine@fl@@QEBAHXZ")]
            internal static extern int Run(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@Engine@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeregisterModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModule@Engine@fl@@QEBAPEAVIModule@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetModule(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInitialized@Engine@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetInitialized(global::System.IntPtr instance, bool initialized);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RequestClose@Engine@fl@@QEAAXAEB_N@Z")]
            internal static extern void RequestClose(global::System.IntPtr instance, bool error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUpdater@Engine@fl@@QEBAPEAVIUpdater@2@XZ")]
            internal static extern global::System.IntPtr GetUpdater(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUpdater@Engine@fl@@QEAAXPEAVIUpdater@2@@Z")]
            internal static extern void SetUpdater(global::System.IntPtr instance, global::System.IntPtr updater);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeOffset@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTimeOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeOffset@Engine@fl@@QEAAXAEBM@Z")]
            internal static extern void SetTimeOffset(global::System.IntPtr instance, float timeOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFpsLimit@Engine@fl@@QEBAMXZ")]
            internal static extern float GetFpsLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFpsLimit@Engine@fl@@QEAAXAEBM@Z")]
            internal static extern void SetFpsLimit(global::System.IntPtr instance, float fpsLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@Engine@fl@@QEAAMXZ")]
            internal static extern float GetDelta(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@Engine@fl@@QEAAMXZ")]
            internal static extern float GetDeltaRender(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeMs@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTimeMs(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Engine@fl@@QEBAMXZ")]
            internal static extern float GetTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInitialized@Engine@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsInitialized(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@Engine@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRunning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDateTime@Engine@fl@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetDateTime(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Engine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::FlounderSharp.Engine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::FlounderSharp.Engine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Engine(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Engine __CreateInstance(global::FlounderSharp.Engine.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Engine(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Engine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            *(global::FlounderSharp.Engine.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Engine(global::FlounderSharp.Engine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Engine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Carries out the setup for basic engine components and the engine. Call  after creating a instance.</summary>
        public Engine()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Engine(global::FlounderSharp.Engine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::FlounderSharp.Engine.__Internal*) __Instance) = *((global::FlounderSharp.Engine.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::FlounderSharp.Engine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the updater.</summary>
        public int Run()
        {
            var __ret = __Internal.Run((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="name">The modules name.</param>
        public void DeregisterModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Gets a module instance by name.</summary>
        /// <param name="name">The module name to find.</param>
        public global::FlounderSharp.IModule GetModule(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetModule((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::FlounderSharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.NativeToManagedMap[__ret];
            else global::FlounderSharp.IModule.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IModule) global::FlounderSharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets if the engine has been initialized.</summary>
        /// <param name="initialized">If the engine has been initialized.</param>
        public void SetInitialized(bool initialized)
        {
            __Internal.SetInitialized((__Instance + __PointerAdjustment), initialized);
        }

        /// <summary>Requests the engine to delete and stop the gameloop.</summary>
        /// <param name="error">If a bad error occured.</param>
        public void RequestClose(bool error)
        {
            __Internal.RequestClose((__Instance + __PointerAdjustment), error);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Engine Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Engine __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Engine.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Engine) global::FlounderSharp.Engine.NativeToManagedMap[__ret];
            else __result0 = global::FlounderSharp.Engine.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the current updater.</summary>
        /// <param name="updater">The updater.</param>
        /// <remarks>Loads the updater into the engine.</remarks>
        public global::FlounderSharp.IUpdater Updater
        {
            get
            {
                var __ret = __Internal.GetUpdater((__Instance + __PointerAdjustment));
                global::FlounderSharp.IUpdater __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::FlounderSharp.IUpdater.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::FlounderSharp.IUpdater) global::FlounderSharp.IUpdater.NativeToManagedMap[__ret];
                else global::FlounderSharp.IUpdater.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.IUpdater) global::FlounderSharp.IUpdater.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetUpdater((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the added/removed time for the engine (seconds).</summary>
        /// <param name="timeOffset">The new time offset.</param>
        /// <remarks>Sets the time offset for the engine (seconds).</remarks>
        public float TimeOffset
        {
            get
            {
                var __ret = __Internal.GetTimeOffset((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetTimeOffset((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the fps limit.</summary>
        /// <param name="fpsLimit">The new fps limit.</param>
        /// <remarks>Sets the fps limit. -1 disables limits.</remarks>
        public float FpsLimit
        {
            get
            {
                var __ret = __Internal.GetFpsLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFpsLimit((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public float Delta
        {
            get
            {
                var __ret = __Internal.GetDelta((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public float DeltaRender
        {
            get
            {
                var __ret = __Internal.GetDeltaRender((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float TimeMs
        {
            get
            {
                var __ret = __Internal.GetTimeMs((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public float Time
        {
            get
            {
                var __ret = __Internal.GetTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine has been initialized.</summary>
        public bool IsInitialized
        {
            get
            {
                var __ret = __Internal.IsInitialized((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the engine is running.</summary>
        public bool IsRunning
        {
            get
            {
                var __ret = __Internal.IsRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current date time as a string. &quot;%d-%m-%Y %I:%M:%S&quot;</summary>
        public string DateTime
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetDateTime((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }
        }
    }
}

public unsafe partial class GLFWwindow
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native.ToPointer(), skipVTables);
    }

    internal static global::GLFWwindow __CreateInstance(global::GLFWwindow.__Internal native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native, skipVTables);
    }

    private static void* __CopyValue(global::GLFWwindow.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::GLFWwindow.__Internal));
        *(global::GLFWwindow.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private GLFWwindow(global::GLFWwindow.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected GLFWwindow(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace FlounderSharp
{
    /// <summary>A module used for the creation, updating and destruction of the display.</summary>
    public unsafe partial class Display : global::FlounderSharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1888)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal int m_windowWidth;

            [FieldOffset(12)]
            internal int m_windowHeight;

            [FieldOffset(16)]
            internal int m_fullscreenWidth;

            [FieldOffset(20)]
            internal int m_fullscreenHeight;

            [FieldOffset(24)]
            internal float m_aspectRatio;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_icon;

            [FieldOffset(96)]
            internal byte m_antialiasing;

            [FieldOffset(97)]
            internal byte m_fullscreen;

            [FieldOffset(104)]
            internal global::System.IntPtr m_window;

            [FieldOffset(112)]
            internal byte m_closed;

            [FieldOffset(113)]
            internal byte m_focused;

            [FieldOffset(116)]
            internal int m_windowPosX;

            [FieldOffset(120)]
            internal int m_windowPosY;

            [FieldOffset(124)]
            internal byte m_iconified;

            [FieldOffset(125)]
            internal byte m_validationLayers;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceLayerList;

            [FieldOffset(152)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceExtensionList;

            [FieldOffset(176)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_deviceExtensionList;

            [FieldOffset(200)]
            internal global::System.IntPtr m_debugReport;

            [FieldOffset(208)]
            internal global::System.IntPtr m_instance;

            [FieldOffset(216)]
            internal global::System.IntPtr m_surface;

        //    [FieldOffset(224)]
        //    internal global::VkSurfaceCapabilitiesKHR.__Internal m_surfaceCapabilities;
        //
        //    [FieldOffset(276)]
        //    internal global::VkSurfaceFormatKHR.__Internal m_surfaceFormat;

            [FieldOffset(288)]
            internal global::System.IntPtr m_logicalDevice;

            [FieldOffset(296)]
            internal global::System.IntPtr m_queue;

            [FieldOffset(304)]
            internal global::System.IntPtr m_physicalDevice;

        //    [FieldOffset(312)]
        //    internal global::VkPhysicalDeviceProperties.__Internal m_physicalDeviceProperties;
        //
        //    [FieldOffset(1136)]
        //    internal global::VkPhysicalDeviceFeatures.__Internal m_physicalDeviceFeatures;
        //
        //    [FieldOffset(1360)]
        //    internal global::VkPhysicalDeviceMemoryProperties.__Internal m_physicalDeviceMemoryProperties;

            [FieldOffset(1880)]
            internal uint m_graphicsFamilyIndex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@fl@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@fl@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Display@fl@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWindowSize@Display@fl@@QEAAXAEBH0@Z")]
            internal static extern void SetWindowSize(global::System.IntPtr instance, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAntialiasing@Display@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetAntialiasing(global::System.IntPtr instance, bool antialiasing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFullscreen@Display@fl@@QEAAXAEB_N@Z")]
            internal static extern void SetFullscreen(global::System.IntPtr instance, bool fullscreen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultGlfw@Display@fl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultGlfw(global::System.IntPtr @return, int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ErrorGlfw@Display@fl@@SAXAEBH@Z")]
            internal static extern void ErrorGlfw(int result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTitle@Display@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetTitle(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTitle@Display@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetTitle(global::System.IntPtr instance, global::System.IntPtr title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIcon@Display@fl@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetIcon(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIcon@Display@fl@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetIcon(global::System.IntPtr instance, global::System.IntPtr icon);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Display@fl@@QEAAHXZ")]
            internal static extern int GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowWidth@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Display@fl@@QEAAHXZ")]
            internal static extern int GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowHeight@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAspectRatio@Display@fl@@QEBAMXZ")]
            internal static extern float GetAspectRatio(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAntialiasing@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAntialiasing(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFullscreen@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFullscreen(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlfwWindow@Display@fl@@QEBAPEAVGLFWwindow@@XZ")]
            internal static extern global::System.IntPtr GetGlfwWindow(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsClosed@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsClosed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFocused@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFocused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowXPos@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowXPos(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowYPos@Display@fl@@QEBAHXZ")]
            internal static extern int GetWindowYPos(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIconified@Display@fl@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsIconified(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVkGraphicsFamilyIndex@Display@fl@@QEBAIXZ")]
            internal static extern uint GetVkGraphicsFamilyIndex(global::System.IntPtr instance);
        }

        internal static new global::FlounderSharp.Display __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Display(native.ToPointer(), skipVTables);
        }

        internal static global::FlounderSharp.Display __CreateInstance(global::FlounderSharp.Display.__Internal native, bool skipVTables = false)
        {
            return new global::FlounderSharp.Display(native, skipVTables);
        }

        private static void* __CopyValue(global::FlounderSharp.Display.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Display.__Internal));
            global::FlounderSharp.Display.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Display(global::FlounderSharp.Display.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Display(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Creates a new display module.</summary>
        public Display()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "FlounderSharp.Display");
        }

        public Display(global::FlounderSharp.Display _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::FlounderSharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "FlounderSharp.Display");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::FlounderSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::FlounderSharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Sets window size to a new size.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <param name="height">The new height in pixels.</param>
        public void SetWindowSize(int width, int height)
        {
            __Internal.SetWindowSize((__Instance + __PointerAdjustment), width, height);
        }

        /// <summary>Requests the display to antialias.</summary>
        /// <param name="antialiasing">If the display should antialias.</param>
        public void SetAntialiasing(bool antialiasing)
        {
            __Internal.SetAntialiasing((__Instance + __PointerAdjustment), antialiasing);
        }

        /// <summary>Sets the display to be fullscreen or windowed.</summary>
        /// <param name="fullscreen">Weather or not to be fullscreen.</param>
        public void SetFullscreen(bool fullscreen)
        {
            __Internal.SetFullscreen((__Instance + __PointerAdjustment), fullscreen);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::FlounderSharp.Display Get()
        {
            var __ret = __Internal.Get();
            global::FlounderSharp.Display __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::FlounderSharp.Display.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::FlounderSharp.Display) global::FlounderSharp.Display.NativeToManagedMap[__ret];
            else global::FlounderSharp.Display.NativeToManagedMap[__ret] = __result0 = (global::FlounderSharp.Display) global::FlounderSharp.Display.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultGlfw(int result)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultGlfw(new IntPtr(&__ret), result);
            var __basicStringRet = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
            __basicStringRet.Dispose(false);
            return __stringRet;
        }

        public static void ErrorGlfw(int result)
        {
            __Internal.ErrorGlfw(result);
        }

        /// <summary>Gets the window's title.</summary>
        /// <param name="title">The new title.</param>
        /// <remarks>Sets window title</remarks>
        public string Title
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetTitle((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetTitle((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the window's icon file.</summary>
        /// <param name="title">The new icon file.</param>
        /// <remarks>Sets window icon image.</remarks>
        public string Icon
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetIcon((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                __basicStringRet.Dispose(false);
                return __stringRet;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetIcon((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the width of the display in pixels.</summary>
        public int Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the non-fullscreen width of the display in pixels.</summary>
        public int WindowWidth
        {
            get
            {
                var __ret = __Internal.GetWindowWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the height of the display in pixels.</summary>
        public int Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the non-fullscreen height of the display in pixels.</summary>
        public int WindowHeight
        {
            get
            {
                var __ret = __Internal.GetWindowHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the aspect ratio between the displays width and height.</summary>
        public float AspectRatio
        {
            get
            {
                var __ret = __Internal.GetAspectRatio((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display requests antialiased images.</summary>
        public bool IsAntialiasing
        {
            get
            {
                var __ret = __Internal.IsAntialiasing((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets weather the display is fullscreen or not.</summary>
        public bool IsFullscreen
        {
            get
            {
                var __ret = __Internal.IsFullscreen((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current GLFW window.</summary>
        public global::GLFWwindow GlfwWindow
        {
            get
            {
                var __ret = __Internal.GetGlfwWindow((__Instance + __PointerAdjustment));
                global::GLFWwindow __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GLFWwindow) global::GLFWwindow.NativeToManagedMap[__ret];
                else __result0 = global::GLFWwindow.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets if the GLFW display is closed.</summary>
        public bool IsClosed
        {
            get
            {
                var __ret = __Internal.IsClosed((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the GLFW display is selected.</summary>
        public bool IsFocused
        {
            get
            {
                var __ret = __Internal.IsFocused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position of the display in pixels.</summary>
        public int WindowXPos
        {
            get
            {
                var __ret = __Internal.GetWindowXPos((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position of the display in pixels.</summary>
        public int WindowYPos
        {
            get
            {
                var __ret = __Internal.GetWindowYPos((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows is minimized.</summary>
        public bool IsIconified
        {
            get
            {
                var __ret = __Internal.IsIconified((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint VkGraphicsFamilyIndex
        {
            get
            {
                var __ret = __Internal.GetVkGraphicsFamilyIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // ~Display()
        private static global::FlounderSharp.Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Display) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void Update() override
        private static global::FlounderSharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::FlounderSharp.Display) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class Display
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackError@fl@@YAXHPEBD@Z")]
            internal static extern void CallbackError(int error, [MarshalAs(UnmanagedType.LPStr)] string description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackClose@fl@@YAXPEAVGLFWwindow@@@Z")]
            internal static extern void CallbackClose(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFocus@fl@@YAXPEAVGLFWwindow@@H@Z")]
            internal static extern void CallbackFocus(global::System.IntPtr window, int focused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackPosition@fl@@YAXPEAVGLFWwindow@@HH@Z")]
            internal static extern void CallbackPosition(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackSize@fl@@YAXPEAVGLFWwindow@@HH@Z")]
            internal static extern void CallbackSize(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFrame@fl@@YAXPEAVGLFWwindow@@HH@Z")]
            internal static extern void CallbackFrame(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Flounder", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackIconify@fl@@YAXPEAVGLFWwindow@@H@Z")]
            internal static extern void CallbackIconify(global::System.IntPtr window, int iconified);
        }

        public static void CallbackError(int error, string description)
        {
            __Internal.CallbackError(error, description);
        }

        public static void CallbackClose(global::GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackClose(__arg0);
        }

        public static void CallbackFocus(global::GLFWwindow window, int focused)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFocus(__arg0, focused);
        }

        public static void CallbackPosition(global::GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackPosition(__arg0, xpos, ypos);
        }

        public static void CallbackSize(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackSize(__arg0, width, height);
        }

        public static void CallbackFrame(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFrame(__arg0, width, height);
        }

        public static void CallbackIconify(global::GLFWwindow window, int iconified)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackIconify(__arg0, iconified);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr _0, int _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate float Func_float_IntPtr(global::System.IntPtr _0);
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_fl_S_IModule
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }
    }
}
