// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace Acid.Sharp
{
    /// <summary>A logging class used in Acid, will write output to a file one the application has closed.</summary>
    public unsafe partial class Log : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Log@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Out@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Out(global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Error@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Error(global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateLog@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void CreateLog(global::System.IntPtr filename);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Log(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Log __CreateInstance(global::Acid.Sharp.Log.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Log.__Internal));
            *(global::Acid.Sharp.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::Acid.Sharp.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Log()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Log.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Log(global::Acid.Sharp.Log _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Log.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Log.__Internal*) __Instance) = *((global::Acid.Sharp.Log.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Log __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Outputs a message into the console.</summary>
        /// <param name="string">The string to output.</param>
        public static void Out(string @string)
        {
        //    var __allocator0 = new global::Std.Allocator<sbyte>();
        //    var __basicString0 = global::Std.BasicStringExtensions.BasicString(@string, __allocator0);
        //    var __arg0 = __basicString0.__Instance;
        //    __Internal.Out(__arg0);
        //    __basicString0.Dispose(false);
        //    __allocator0.Dispose();
        }

        /// <summary>Outputs a error into the console.</summary>
        /// <param name="string">The string to output.</param>
        public static void Error(string @string)
        {
        //    var __allocator0 = new global::Std.Allocator<sbyte>();
        //    var __basicString0 = global::Std.BasicStringExtensions.BasicString(@string, __allocator0);
        //    var __arg0 = __basicString0.__Instance;
        //    __Internal.Error(__arg0);
        //    __basicString0.Dispose(false);
        //    __allocator0.Dispose();
        }

        /// <summary>Outputs all logs into a file.</summary>
        /// <param name="filename">The filename to output into.</param>
        public static void CreateLog(string filename)
        {
        //    var __allocator0 = new global::Std.Allocator<sbyte>();
        //    var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
        //    var __arg0 = __basicString0.__Instance;
        //    __Internal.CreateLog(__arg0);
        //    __basicString0.Dispose(false);
        //    __allocator0.Dispose();
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a time value stored in microseconds.</summary>
    public unsafe partial class Time : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long m_microseconds;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Time@acid@@QEAA@AEB_J@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, long* microseconds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Time@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Seconds@Time@acid@@SA?AV12@AEBM@Z")]
            internal static extern void Seconds(global::System.IntPtr @return, float* amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Milliseconds@Time@acid@@SA?AV12@AEBH@Z")]
            internal static extern void Milliseconds(global::System.IntPtr @return, int* amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Microseconds@Time@acid@@SA?AV12@AEB_J@Z")]
            internal static extern void Microseconds(global::System.IntPtr @return, long* amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Time@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Time@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GTime@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVTime@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVTime@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEBV10@AEB_J@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, long* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEB_JAEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, long* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVTime@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVTime@0@AEBV10@AEB_J@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, long* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YAMAEBVTime@0@0@Z")]
            internal static extern float OperatorSlash(global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Lacid@@YA?AVTime@0@AEBV10@0@Z")]
            internal static extern void OperatorPercent(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AsSeconds@Time@acid@@QEBAMXZ")]
            internal static extern float AsSeconds(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AsMilliseconds@Time@acid@@QEBAHXZ")]
            internal static extern int AsMilliseconds(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AsMicroseconds@Time@acid@@QEBA_JXZ")]
            internal static extern long AsMicroseconds(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Time> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Time>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Time __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Time(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Time __CreateInstance(global::Acid.Sharp.Time.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Time(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Time.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Time.__Internal));
            *(global::Acid.Sharp.Time.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Time(global::Acid.Sharp.Time.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Time(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for time. This function is internal. To construct time values, use Time::Seconds, Time::Milliseconds or Time::Microseconds instead.</summary>
        /// <param name="microseconds">Number of microseconds.</param>
        public Time(long microseconds)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Time.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &microseconds;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Time(global::Acid.Sharp.Time _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Time.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Time.__Internal*) __Instance) = *((global::Acid.Sharp.Time.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Time __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Time;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Time.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Time operator -(global::Acid.Sharp.Time __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static explicit operator global::Acid.Sharp.Time(long microseconds)
        {
            return new global::Acid.Sharp.Time(microseconds);
        }

        /// <summary>Constructs a time value from a number of seconds.</summary>
        /// <param name="amount">Number of seconds.</param>
        public static global::Acid.Sharp.Time Seconds(float amount)
        {
            var __arg0 = &amount;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.Seconds(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        /// <summary>Constructs a time value from a number of milliseconds.</summary>
        /// <param name="amount">Number of milliseconds.</param>
        public static global::Acid.Sharp.Time Milliseconds(int amount)
        {
            var __arg0 = &amount;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.Milliseconds(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        /// <summary>Constructs a time value from a number of microseconds.</summary>
        /// <param name="amount">Number of microseconds.</param>
        public static global::Acid.Sharp.Time Microseconds(long amount)
        {
            var __arg0 = &amount;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.Microseconds(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator +(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator -(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(global::Acid.Sharp.Time left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(global::Acid.Sharp.Time left, long right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(float left, global::Acid.Sharp.Time right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(long left, global::Acid.Sharp.Time right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator /(global::Acid.Sharp.Time left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator /(global::Acid.Sharp.Time left, long right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static float operator /(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = __Internal.OperatorSlash(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Time operator %(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorPercent(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Time.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Time@acid@@2V12@B");
                return global::Acid.Sharp.Time.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Time NegativeInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Time.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Time@acid@@2V12@B");
                return global::Acid.Sharp.Time.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Time PositiveInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Time.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Time@acid@@2V12@B");
                return global::Acid.Sharp.Time.__CreateInstance(*__ptr);
            }
        }

        /// <summary>Return the time value as a number of seconds.</summary>
        public float AsSeconds
        {
            get
            {
                var __ret = __Internal.AsSeconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Return the time value as a number of milliseconds.</summary>
        public int AsMilliseconds
        {
            get
            {
                var __ret = __Internal.AsMilliseconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Return the time value as a number of microseconds.</summary>
        public long AsMicroseconds
        {
            get
            {
                var __ret = __Internal.AsMicroseconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents when a module will update in the game loop.</summary>
    public enum ModuleUpdate
    {
        Always = 0,
        Pre = 1,
        Normal = 2,
        Post = 3,
        Render = 4
    }

    /// <summary>A interface used for defining engine modules.</summary>
    public unsafe abstract partial class IModule : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IModule> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IModule>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IModule __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IModuleInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IModule __CreateInstance(global::Acid.Sharp.IModule.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IModuleInternal(native, skipVTables);
        }

        protected IModule(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IModule()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IModule");
        }

        protected IModule(global::Acid.Sharp.IModule _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IModule");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IModule.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the module.</summary>
        public abstract void Update();

        #region Virtual table interop

        // void Update() = 0
        private static global::Acid.Sharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IModule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IModuleInternal : global::Acid.Sharp.IModule, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IModule.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IModule.__Internal));
            *(global::Acid.Sharp.IModule.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IModuleInternal(global::Acid.Sharp.IModule.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IModuleInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>The update function for the module.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Acid.Sharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Acid.Sharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that contains and manages modules registered to a engine.</summary>
    public unsafe partial class ModuleRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map__f___N_std_S_unique_ptr____N_acid_S_IModule___N_std_S_default_delete__S1____N_std_S_less__f___N_std_S_allocator____N_std_S_pair__1f_S0_ m_modules;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModuleRegister@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FillRegister@ModuleRegister@acid@@QEAAXXZ")]
            internal static extern void FillRegister(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ContainsModule@ModuleRegister@acid@@QEBA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ContainsModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@ModuleRegister@acid@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::Acid.Sharp.ModuleUpdate* update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@ModuleRegister@acid@@QEAA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RunUpdate@ModuleRegister@acid@@QEBAXAEBW4ModuleUpdate@2@@Z")]
            internal static extern void RunUpdate(global::System.IntPtr instance, global::Acid.Sharp.ModuleUpdate* update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModuleCount@ModuleRegister@acid@@QEBAIXZ")]
            internal static extern uint GetModuleCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ModuleRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleRegister(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModuleRegister __CreateInstance(global::Acid.Sharp.ModuleRegister.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModuleRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleRegister.__Internal));
            global::Acid.Sharp.ModuleRegister.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModuleRegister(global::Acid.Sharp.ModuleRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleRegister(global::Acid.Sharp.ModuleRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ModuleRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Fills the module register with default modules.</summary>
        public void FillRegister()
        {
            __Internal.FillRegister((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if a module is contained in this registry.</summary>
        /// <param name="module">The module to find.</param>
        public bool ContainsModule(global::Acid.Sharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.ContainsModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        public global::Acid.Sharp.IModule RegisterModule(global::Acid.Sharp.IModule module, global::Acid.Sharp.ModuleUpdate* update)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update);
            global::Acid.Sharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IModule) global::Acid.Sharp.IModule.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="module">The module to deregister.</param>
        public bool DeregisterModule(global::Acid.Sharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Runs updates for all module update types.</summary>
        /// <param name="update">The modules update type.</param>
        public void RunUpdate(global::Acid.Sharp.ModuleUpdate* update)
        {
            __Internal.RunUpdate((__Instance + __PointerAdjustment), update);
        }

        public uint ModuleCount
        {
            get
            {
                var __ret = __Internal.GetModuleCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class for handing and calculating deltas.</summary>
    public unsafe partial class Delta : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_currentFrameTime;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_lastFrameTime;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_change;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_time;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Delta@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChange@Delta@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetChange(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Delta@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetTime(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Delta> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Delta>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Delta __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Delta(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Delta __CreateInstance(global::Acid.Sharp.Delta.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Delta(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Delta.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Delta.__Internal));
            *(global::Acid.Sharp.Delta.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Delta(global::Acid.Sharp.Delta.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Delta(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new change handler.</summary>
        public Delta()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Delta(global::Acid.Sharp.Delta _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Delta.__Internal*) __Instance) = *((global::Acid.Sharp.Delta.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Delta __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates change and times.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.Time Change
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetChange((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Time Time
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTime((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A timer implementation for events.</summary>
    public unsafe partial class Timer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_startTime;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_interval;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@acid@@QEAA@AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ResetStartTime@Timer@acid@@QEAAXXZ")]
            internal static extern void ResetStartTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterval@Timer@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetInterval(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInterval@Timer@acid@@QEAAXAEBVTime@2@@Z")]
            internal static extern void SetInterval(global::System.IntPtr instance, global::System.IntPtr interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPassedTime@Timer@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetPassedTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Timer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Timer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Timer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Timer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Timer __CreateInstance(global::Acid.Sharp.Timer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Timer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Timer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Timer.__Internal));
            *(global::Acid.Sharp.Timer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Timer(global::Acid.Sharp.Timer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Timer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new timer.</summary>
        /// <param name="interval">The time between events.</param>
        public Timer(global::Acid.Sharp.Time interval)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(interval, null))
                throw new global::System.ArgumentNullException("interval", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = interval.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Timer(global::Acid.Sharp.Timer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Timer.__Internal*) __Instance) = *((global::Acid.Sharp.Timer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Timer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds the intervals value to the start time.</summary>
        public void ResetStartTime()
        {
            __Internal.ResetStartTime((__Instance + __PointerAdjustment));
        }

        public static explicit operator global::Acid.Sharp.Timer(global::Acid.Sharp.Time interval)
        {
            return new global::Acid.Sharp.Timer(interval);
        }

        /// <summary>Gets what the interval is.</summary>
        /// <param name="interval">The new timer interval.</param>
        /// <remarks>Gets the timers interval (resets timer).</remarks>
        public global::Acid.Sharp.Time Interval
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetInterval((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetInterval((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets if the interval has been passes for the timer.</summary>
        public bool PassedTime
        {
            get
            {
                var __ret = __Internal.GetPassedTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class used to define how the engine will run updates and timings on modules.</summary>
    public unsafe partial class ModuleUpdater : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Delta.__Internal m_deltaUpdate;

            [FieldOffset(32)]
            internal global::Acid.Sharp.Delta.__Internal m_deltaRender;

            [FieldOffset(64)]
            internal global::Acid.Sharp.Timer.__Internal m_timerUpdate;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Timer.__Internal m_timerRender;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleUpdater@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleUpdater@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ModuleUpdater@acid@@QEAAXAEBVModuleRegister@2@@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr moduleRegister);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@ModuleUpdater@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDelta(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@ModuleUpdater@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDeltaRender(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleUpdater> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleUpdater>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ModuleUpdater __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleUpdater(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModuleUpdater __CreateInstance(global::Acid.Sharp.ModuleUpdater.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleUpdater(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModuleUpdater.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleUpdater.__Internal));
            *(global::Acid.Sharp.ModuleUpdater.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleUpdater(global::Acid.Sharp.ModuleUpdater.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleUpdater(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleUpdater()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleUpdater(global::Acid.Sharp.ModuleUpdater _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.ModuleUpdater.__Internal*) __Instance) = *((global::Acid.Sharp.ModuleUpdater.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ModuleUpdater __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates all modules in order.</summary>
        public void Update(global::Acid.Sharp.ModuleRegister moduleRegister)
        {
            if (ReferenceEquals(moduleRegister, null))
                throw new global::System.ArgumentNullException("moduleRegister", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = moduleRegister.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public global::Acid.Sharp.Time Delta
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDelta((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public global::Acid.Sharp.Time DeltaRender
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDeltaRender((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Main class for Acid, manages modules and updates. After creating your Engine object call  to start.</summary>
    public unsafe partial class Engine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_timeOffset;

            [FieldOffset(8)]
            internal global::Acid.Sharp.ModuleRegister.__Internal m_moduleRegister;

            [FieldOffset(24)]
            internal global::Acid.Sharp.ModuleUpdater.__Internal m_moduleUpdater;

            [FieldOffset(120)]
            internal float m_fpsLimit;

            [FieldOffset(124)]
            internal byte m_initialized;

            [FieldOffset(125)]
            internal byte m_running;

            [FieldOffset(126)]
            internal byte m_error;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@acid@@QEAA@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool* emptyRegister);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Engine@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Engine@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Run@Engine@acid@@QEAAHXZ")]
            internal static extern int Run(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@Engine@acid@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::Acid.Sharp.ModuleUpdate* update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@Engine@acid@@QEAA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RequestClose@Engine@acid@@QEAAXAEB_N@Z")]
            internal static extern void RequestClose(global::System.IntPtr instance, bool* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeOffset@Engine@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetTimeOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeOffset@Engine@acid@@QEAAXAEBVTime@2@@Z")]
            internal static extern void SetTimeOffset(global::System.IntPtr instance, global::System.IntPtr timeOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFpsLimit@Engine@acid@@QEBAMXZ")]
            internal static extern float GetFpsLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFpsLimit@Engine@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFpsLimit(global::System.IntPtr instance, float* fpsLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInitialized@Engine@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetInitialized(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInitialized@Engine@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetInitialized(global::System.IntPtr instance, bool* initialized);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@Engine@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDelta(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@Engine@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDeltaRender(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Engine@acid@@SA?AVTime@2@XZ")]
            internal static extern void GetTime(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@Engine@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRunning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDateTime@Engine@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetDateTime(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Engine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Engine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Engine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Engine(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Engine __CreateInstance(global::Acid.Sharp.Engine.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Engine(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Engine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Engine.__Internal));
            global::Acid.Sharp.Engine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Engine(global::Acid.Sharp.Engine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Engine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Carries out the setup for basic engine components and the engine. Call  after creating a instance.</summary>
        /// <param name="emptyRegister">If the module register will start empty.</param>
        public Engine(bool emptyRegister)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &emptyRegister;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Engine(global::Acid.Sharp.Engine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Engine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the updater.</summary>
        public int Run()
        {
            var __ret = __Internal.Run((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        public global::Acid.Sharp.IModule RegisterModule(global::Acid.Sharp.IModule module, global::Acid.Sharp.ModuleUpdate* update)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update);
            global::Acid.Sharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IModule) global::Acid.Sharp.IModule.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="module">The module to deregister.</param>
        public bool DeregisterModule(global::Acid.Sharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Requests the engine to delete and stop the game-loop.</summary>
        /// <param name="error">If a bad error occurred.</param>
        public void RequestClose(bool error)
        {
            var __arg0 = &error;
            __Internal.RequestClose((__Instance + __PointerAdjustment), __arg0);
        }

        public static explicit operator global::Acid.Sharp.Engine(bool emptyRegister)
        {
            return new global::Acid.Sharp.Engine(emptyRegister);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Engine Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Engine __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Engine.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Engine) global::Acid.Sharp.Engine.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Engine.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the added/removed time for the engine.</summary>
        /// <param name="timeOffset">The new time offset.</param>
        /// <remarks>Sets the time offset for the engine.</remarks>
        public global::Acid.Sharp.Time TimeOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTimeOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTimeOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the fps limit.</summary>
        /// <param name="fpsLimit">The new fps limit.</param>
        /// <remarks>Sets the fps limit. -1 disables limits.</remarks>
        public float FpsLimit
        {
            get
            {
                var __ret = __Internal.GetFpsLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFpsLimit((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets if the engine has been initialized.</summary>
        /// <param name="initialized">If the engine has been initialized.</param>
        /// <remarks>Sets if the engine has been initialized.</remarks>
        public bool Initialized
        {
            get
            {
                var __ret = __Internal.GetInitialized((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetInitialized((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public global::Acid.Sharp.Time Delta
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDelta((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public global::Acid.Sharp.Time DeltaRender
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDeltaRender((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public static global::Acid.Sharp.Time Time
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTime(new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets if the engine is running.</summary>
        public bool Running
        {
            get
            {
                var __ret = __Internal.GetRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current date time as a string. &quot;%d-%m-%Y %I:%M:%S&quot;</summary>
        public static string DateTime
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetDateTime(new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Vector3
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Vector3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector3(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Vector3 __CreateInstance(global::Acid.Sharp.Vector3.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector3(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Vector3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            *(global::Acid.Sharp.Vector3.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector3(global::Acid.Sharp.Vector3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Packet
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Packet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Packet>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Packet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Packet(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Packet __CreateInstance(global::Acid.Sharp.Packet.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Packet(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Packet.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Packet.__Internal));
            *(global::Acid.Sharp.Packet.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Packet(global::Acid.Sharp.Packet.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Packet(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Metadata
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Metadata> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Metadata>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Metadata __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Metadata(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Metadata __CreateInstance(global::Acid.Sharp.Metadata.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Metadata(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Metadata.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Metadata.__Internal));
            *(global::Acid.Sharp.Metadata.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Metadata(global::Acid.Sharp.Metadata.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Metadata(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Holds a 2-tuple vector.</summary>
    public unsafe partial class Vector2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector2._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector2@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float* scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float* angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@acid@@QEBA?AV12@AEBMAEBV12@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float* angle, global::System.IntPtr rotationAxis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InTriangle@Vector2@acid@@QEBA_NAEBV12@00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InTriangle(global::System.IntPtr instance, global::System.IntPtr v1, global::System.IntPtr v2, global::System.IntPtr v3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector2@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Vector2@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Vector2@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector2@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector2@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AVector2@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector2@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector2@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float* x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector2@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector2@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector2@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector2@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector2@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector2@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CartesianToPolar@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void CartesianToPolar(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PolarToCartesian@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void PolarToCartesian(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector2._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector2._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[2];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Vector2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector2(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Vector2 __CreateInstance(global::Acid.Sharp.Vector2.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector2(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Vector2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            global::Acid.Sharp.Vector2.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector2(global::Acid.Sharp.Vector2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector2.</summary>
        public Vector2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        public Vector2(float x, float y)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &x;
            var __arg1 = &y;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::Acid.Sharp.Vector2 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::Acid.Sharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Vector2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Add(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Subtract(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Multiply(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Divide(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::Acid.Sharp.Vector2 Scale(float scalar)
        {
            var __arg0 = &scalar;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around the origin.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        public global::Acid.Sharp.Vector2 Rotate(float angle)
        {
            var __arg0 = &angle;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around a rotation axis.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        /// <param name="rotationAxis">The point to rotate the vector around.</param>
        public global::Acid.Sharp.Vector2 Rotate(float angle, global::Acid.Sharp.Vector2 rotationAxis)
        {
            var __arg0 = &angle;
            if (ReferenceEquals(rotationAxis, null))
                throw new global::System.ArgumentNullException("rotationAxis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotationAxis.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::Acid.Sharp.Vector2 Negate()
        {
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::Acid.Sharp.Vector2 Normalize()
        {
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 DistanceVector(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets if this vector is in a triangle.</summary>
        /// <param name="v1">The first triangle vertex.</param>
        /// <param name="v2">The second triangle vertex.</param>
        /// <param name="v3">The third triangle vertex.</param>
        public bool InTriangle(global::Acid.Sharp.Vector2 v1, global::Acid.Sharp.Vector2 v2, global::Acid.Sharp.Vector2 v3)
        {
            if (ReferenceEquals(v1, null))
                throw new global::System.ArgumentNullException("v1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = v1.__Instance;
            if (ReferenceEquals(v2, null))
                throw new global::System.ArgumentNullException("v2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = v2.__Instance;
            if (ReferenceEquals(v3, null))
                throw new global::System.ArgumentNullException("v3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = v3.__Instance;
            var __ret = __Internal.InTriangle((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::Acid.Sharp.Vector2 SmoothDamp(global::Acid.Sharp.Vector2 target, global::Acid.Sharp.Vector2 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Vector2;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Vector2.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::Acid.Sharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator !=(global::Acid.Sharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Vector2 operator -(global::Acid.Sharp.Vector2 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Vector2(global::Acid.Sharp.Vector3 source)
        {
            return new global::Acid.Sharp.Vector2(source);
        }

        public static global::Acid.Sharp.Vector2 operator +(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator -(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator *(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator /(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator +(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator -(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator *(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator /(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator +(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator -(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator *(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator /(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 One
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Left
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LEFT@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Right
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RIGHT@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Up
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?UP@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Down
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DOWN@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 PositiveInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 NegativeInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return *__ret;
            }

            set
            {
                var __arg0 = &index;
                *global::Acid.Sharp.Vector2.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetY((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Converts from rectangular to spherical coordinates, this vector is in cartesian (x, y).</summary>
        public global::Acid.Sharp.Vector2 CartesianToPolar
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.CartesianToPolar((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }
        }

        /// <summary>Converts from spherical to rectangular coordinates, this vector is in polar (radius, theta).</summary>
        public global::Acid.Sharp.Vector2 PolarToCartesian
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.PolarToCartesian((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }
        }
    }
}

public unsafe partial class GLFWwindow
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native.ToPointer(), skipVTables);
    }

    internal static global::GLFWwindow __CreateInstance(global::GLFWwindow.__Internal native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native, skipVTables);
    }

    private static void* __CopyValue(global::GLFWwindow.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::GLFWwindow.__Internal));
        *(global::GLFWwindow.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private GLFWwindow(global::GLFWwindow.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected GLFWwindow(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class GLFWmonitor
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWmonitor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWmonitor>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::GLFWmonitor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::GLFWmonitor(native.ToPointer(), skipVTables);
    }

    internal static global::GLFWmonitor __CreateInstance(global::GLFWmonitor.__Internal native, bool skipVTables = false)
    {
        return new global::GLFWmonitor(native, skipVTables);
    }

    private static void* __CopyValue(global::GLFWmonitor.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::GLFWmonitor.__Internal));
        *(global::GLFWmonitor.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private GLFWmonitor(global::GLFWmonitor.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected GLFWmonitor(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for the creation, updating and destruction of the display.</summary>
    public unsafe partial class Display : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1936)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal uint m_windowWidth;

            [FieldOffset(12)]
            internal uint m_windowHeight;

            [FieldOffset(16)]
            internal uint m_fullscreenWidth;

            [FieldOffset(20)]
            internal uint m_fullscreenHeight;

            [FieldOffset(24)]
            internal float m_aspectRatio;

            [FieldOffset(28)]
            internal uint m_positionX;

            [FieldOffset(32)]
            internal uint m_positionY;

            [FieldOffset(40)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;

            [FieldOffset(72)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_iconPath;

            [FieldOffset(104)]
            internal byte m_antialiasing;

            [FieldOffset(105)]
            internal byte m_borderless;

            [FieldOffset(106)]
            internal byte m_resizable;

            [FieldOffset(107)]
            internal byte m_floating;

            [FieldOffset(108)]
            internal byte m_fullscreen;

            [FieldOffset(109)]
            internal byte m_closed;

            [FieldOffset(110)]
            internal byte m_focused;

            [FieldOffset(111)]
            internal byte m_iconified;

            [FieldOffset(112)]
            internal byte m_validationLayers;

            [FieldOffset(120)]
            internal global::System.IntPtr m_window;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceLayerList;

            [FieldOffset(152)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceExtensionList;

            [FieldOffset(176)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_deviceExtensionList;

            [FieldOffset(200)]
            internal global::System.IntPtr m_debugReportCallback;

            [FieldOffset(208)]
            internal global::System.IntPtr m_instance;

            [FieldOffset(216)]
            internal global::System.IntPtr m_surface;

         //   [FieldOffset(224)]
         //   internal global::VkSurfaceCapabilitiesKHR.__Internal m_surfaceCapabilities;

         //   [FieldOffset(276)]
         //   internal global::VkSurfaceFormatKHR.__Internal m_surfaceFormat;

            [FieldOffset(288)]
            internal global::System.IntPtr m_logicalDevice;

         //   [FieldOffset(296)]
         //   internal global::VkSampleCountFlagBits m_msaaSamples;

            [FieldOffset(304)]
            internal global::System.IntPtr m_physicalDevice;

         //   [FieldOffset(312)]
         //   internal global::VkPhysicalDeviceProperties.__Internal m_physicalDeviceProperties;

         //   [FieldOffset(1136)]
         //   internal global::VkPhysicalDeviceFeatures.__Internal m_physicalDeviceFeatures;

         //   [FieldOffset(1360)]
         //   internal global::VkPhysicalDeviceMemoryProperties.__Internal m_physicalDeviceMemoryProperties;

            [FieldOffset(1880)]
            internal uint m_supportedQueues;

            [FieldOffset(1884)]
            internal uint m_graphicsFamily;

            [FieldOffset(1888)]
            internal uint m_presentFamily;

            [FieldOffset(1892)]
            internal uint m_computeFamily;

            [FieldOffset(1896)]
            internal uint m_transferFamily;

            [FieldOffset(1904)]
            internal global::System.IntPtr m_graphicsQueue;

            [FieldOffset(1912)]
            internal global::System.IntPtr m_presentQueue;

            [FieldOffset(1920)]
            internal global::System.IntPtr m_computeQueue;

            [FieldOffset(1928)]
            internal global::System.IntPtr m_transferQueue;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Display@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Display@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@Display@acid@@QEAAXAEBI0@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, uint* width, uint* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Display@acid@@QEAAXAEBI0@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, uint* x, uint* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultGlfw@Display@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultGlfw(global::System.IntPtr @return, int* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CheckGlfw@Display@acid@@SAXAEBH@Z")]
            internal static extern void CheckGlfw(int* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Display@acid@@QEAAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWidth@Display@acid@@QEAAXAEBI@Z")]
            internal static extern void SetWidth(global::System.IntPtr instance, uint* width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Display@acid@@QEAAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@Display@acid@@QEAAXAEBI@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, uint* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDimensions@Display@acid@@QEAA?AVVector2@2@XZ")]
            internal static extern void GetDimensions(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@Display@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, global::System.IntPtr size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Display@acid@@QEAA?AVVector2@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Display@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTitle@Display@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetTitle(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTitle@Display@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetTitle(global::System.IntPtr instance, global::System.IntPtr title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIcon@Display@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetIcon(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIcon@Display@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetIcon(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAntialiasing@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetAntialiasing(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAntialiasing@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetAntialiasing(global::System.IntPtr instance, bool* antialiasing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsBorderless@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetBorderless(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBorderless@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetBorderless(global::System.IntPtr instance, bool* borderless);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsResizable@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetResizable(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetResizable@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetResizable(global::System.IntPtr instance, bool* resizable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFloating@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetFloating(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFloating@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetFloating(global::System.IntPtr instance, bool* floating);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFullscreen@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetFullscreen(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFullscreen@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetFullscreen(global::System.IntPtr instance, bool* fullscreen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIconified@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetIconified(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIconified@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetIconified(global::System.IntPtr instance, bool* iconify);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowWidth@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowHeight@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAspectRatio@Display@acid@@QEBAMXZ")]
            internal static extern float GetAspectRatio(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionX@Display@acid@@QEBAIXZ")]
            internal static extern uint GetPositionX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionY@Display@acid@@QEBAIXZ")]
            internal static extern uint GetPositionY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsClosed@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetClosed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFocused@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetFocused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindow@Display@acid@@QEBAPEAUGLFWwindow@@XZ")]
            internal static extern global::System.IntPtr GetWindow(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetGraphicsFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPresentFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetPresentFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComputeFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetComputeFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransferFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetTransferFamily(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Display __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Display(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Display __CreateInstance(global::Acid.Sharp.Display.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Display(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Display.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Display.__Internal));
            global::Acid.Sharp.Display.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Display(global::Acid.Sharp.Display.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Display(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Display()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Display");
        }

        public Display(global::Acid.Sharp.Display _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Display");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Display.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Acid.Sharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Acid.Sharp.Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Sets the window size to a new size.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <param name="height">The new height in pixels.</param>
        public void SetDimensions(uint width, uint height)
        {
            var __arg0 = &width;
            var __arg1 = &height;
            __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Sets the window position to a new position in pixels.</summary>
        /// <param name="x">The new x position in pixels.</param>
        /// <param name="y">The new y position in pixels.</param>
        public void SetPosition(uint x, uint y)
        {
            var __arg0 = &x;
            var __arg1 = &y;
            __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Display Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Display __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Display.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Display) global::Acid.Sharp.Display.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Display.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultGlfw(int result)
        {
            var __arg0 = &result;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultGlfw(new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static void CheckGlfw(int result)
        {
            var __arg0 = &result;
            __Internal.CheckGlfw(__arg0);
        }

        /// <summary>Gets the width of the window in pixels.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <remarks>Sets the width of the window in pixels.</remarks>
        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetWidth((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the height of the window in pixels.</summary>
        /// <param name="height">The new height in pixels.</param>
        /// <remarks>Sets the height of the window in pixels.</remarks>
        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetHeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the dimensions of the window in pixels.</summary>
        /// <param name="size">The new width in pixels.</param>
        /// <remarks>Sets the window size to a new size.</remarks>
        public global::Acid.Sharp.Vector2 Dimensions
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetDimensions((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the windows position in pixels.</summary>
        /// <param name="position">The new position in pixels.</param>
        /// <remarks>Sets the window position to a new position in pixels.</remarks>
        public global::Acid.Sharp.Vector2 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the window's title.</summary>
        /// <param name="title">The new title.</param>
        /// <remarks>Sets window title</remarks>
        public string Title
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetTitle((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

         //   set
         //   {
         //       var __allocator0 = new global::Std.Allocator<sbyte>();
         //       var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
         //       var __arg0 = __basicString0.__Instance;
         //       __Internal.SetTitle((__Instance + __PointerAdjustment), __arg0);
         //       __basicString0.Dispose(false);
         //       __allocator0.Dispose();
         //   }
        }

        /// <summary>Gets the window's icon file.</summary>
        /// <param name="filename">The new icon file.</param>
        /// <remarks>Sets window icon image.</remarks>
        public string Icon
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetIcon((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

         //   set
         //   {
         //       var __allocator0 = new global::Std.Allocator<sbyte>();
         //       var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
         //       var __arg0 = __basicString0.__Instance;
         //       __Internal.SetIcon((__Instance + __PointerAdjustment), __arg0);
         //       __basicString0.Dispose(false);
         //       __allocator0.Dispose();
         //   }
        }

        /// <summary>Gets if the window requests antialiased images.</summary>
        /// <param name="antialiasing">If the window should antialias.</param>
        /// <remarks>Requests the window to antialias.</remarks>
        public bool Antialiasing
        {
            get
            {
                var __ret = __Internal.GetAntialiasing((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetAntialiasing((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is borderless or not.</summary>
        /// <param name="borderless">Weather or not to be borderless.</param>
        /// <remarks>Sets the window to be borderless.</remarks>
        public bool Borderless
        {
            get
            {
                var __ret = __Internal.GetBorderless((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetBorderless((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is resizable or not.</summary>
        /// <param name="resizable">Weather or not to be resizable.</param>
        /// <remarks>Sets the window to be resizable.</remarks>
        public bool Resizable
        {
            get
            {
                var __ret = __Internal.GetResizable((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetResizable((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is floating or not, if floating the window will always display above other windows.</summary>
        /// <param name="floating">Weather or not to be floating.</param>
        /// <remarks>Sets the window to be floating.</remarks>
        public bool Floating
        {
            get
            {
                var __ret = __Internal.GetFloating((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFloating((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is fullscreen or not.</summary>
        /// <param name="fullscreen">Weather or not to be fullscreen.</param>
        /// <remarks>Sets the window to be fullscreen or windowed.</remarks>
        public bool Fullscreen
        {
            get
            {
                var __ret = __Internal.GetFullscreen((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFullscreen((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the windows is minimized.</summary>
        /// <param name="iconify">If the window will be set as iconified.</param>
        /// <remarks>Sets the window to be iconified (minimized).</remarks>
        public bool Iconified
        {
            get
            {
                var __ret = __Internal.GetIconified((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetIconified((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the non-fullscreen width of the window in pixels.</summary>
        public uint WindowWidth
        {
            get
            {
                var __ret = __Internal.GetWindowWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the non-fullscreen height of the window in pixels.</summary>
        public uint WindowHeight
        {
            get
            {
                var __ret = __Internal.GetWindowHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the aspect ratio between the windows width and height.</summary>
        public float AspectRatio
        {
            get
            {
                var __ret = __Internal.GetAspectRatio((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position in pixels.</summary>
        public uint PositionX
        {
            get
            {
                var __ret = __Internal.GetPositionX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position in pixels.</summary>
        public uint PositionY
        {
            get
            {
                var __ret = __Internal.GetPositionY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the window is closed.</summary>
        public bool Closed
        {
            get
            {
                var __ret = __Internal.GetClosed((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the window is selected.</summary>
        public bool Focused
        {
            get
            {
                var __ret = __Internal.GetFocused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::GLFWwindow Window
        {
            get
            {
                var __ret = __Internal.GetWindow((__Instance + __PointerAdjustment));
                global::GLFWwindow __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GLFWwindow) global::GLFWwindow.NativeToManagedMap[__ret];
                else __result0 = global::GLFWwindow.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint GraphicsFamily
        {
            get
            {
                var __ret = __Internal.GetGraphicsFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint PresentFamily
        {
            get
            {
                var __ret = __Internal.GetPresentFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint ComputeFamily
        {
            get
            {
                var __ret = __Internal.GetComputeFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint TransferFamily
        {
            get
            {
                var __ret = __Internal.GetTransferFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Acid.Sharp.Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Display) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Display
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackError@acid@@YAXHPEBD@Z")]
            internal static extern void CallbackError(int error, [MarshalAs(UnmanagedType.LPStr)] string description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackMonitor@acid@@YAXPEAUGLFWmonitor@@H@Z")]
            internal static extern void CallbackMonitor(global::System.IntPtr monitor, int @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackClose@acid@@YAXPEAUGLFWwindow@@@Z")]
            internal static extern void CallbackClose(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFocus@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackFocus(global::System.IntPtr window, int focused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackPosition@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackPosition(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackSize@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackSize(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackIconify@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackIconify(global::System.IntPtr window, int iconified);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFrame@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackFrame(global::System.IntPtr window, int width, int height);
        }

        public static void CallbackError(int error, string description)
        {
            __Internal.CallbackError(error, description);
        }

        public static void CallbackMonitor(global::GLFWmonitor monitor, int @event)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.CallbackMonitor(__arg0, @event);
        }

        public static void CallbackClose(global::GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackClose(__arg0);
        }

        public static void CallbackFocus(global::GLFWwindow window, int focused)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFocus(__arg0, focused);
        }

        public static void CallbackPosition(global::GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackPosition(__arg0, xpos, ypos);
        }

        public static void CallbackSize(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackSize(__arg0, width, height);
        }

        public static void CallbackIconify(global::GLFWwindow window, int iconified)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackIconify(__arg0, iconified);
        }

        public static void CallbackFrame(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFrame(__arg0, width, height);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr _0);
    }
}

namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IModule__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }
    }
}
