// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace Acid.Sharp
{
    /// <summary>Represents a time value stored in microseconds.</summary>
    public unsafe partial class Time : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal long m_microseconds;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Time@acid@@QEAA@AEB_J@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, long* microseconds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Time@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Seconds@Time@acid@@SA?AV12@AEBM@Z")]
            internal static extern void Seconds(global::System.IntPtr @return, float* amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Milliseconds@Time@acid@@SA?AV12@AEBH@Z")]
            internal static extern void Milliseconds(global::System.IntPtr @return, int* amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Microseconds@Time@acid@@SA?AV12@AEB_J@Z")]
            internal static extern void Microseconds(global::System.IntPtr @return, long* amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Time@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Time@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PTime@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GTime@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVTime@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVTime@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEBV10@AEB_J@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, long* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVTime@0@AEB_JAEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, long* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVTime@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVTime@0@AEBV10@AEB_J@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, long* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YAMAEBVTime@0@0@Z")]
            internal static extern float OperatorSlash(global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Lacid@@YA?AVTime@0@AEBV10@0@Z")]
            internal static extern void OperatorPercent(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AsSeconds@Time@acid@@QEBAMXZ")]
            internal static extern float AsSeconds(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AsMilliseconds@Time@acid@@QEBAHXZ")]
            internal static extern int AsMilliseconds(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AsMicroseconds@Time@acid@@QEBA_JXZ")]
            internal static extern long AsMicroseconds(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Time> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Time>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Time __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Time(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Time __CreateInstance(global::Acid.Sharp.Time.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Time(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Time.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Time.__Internal));
            *(global::Acid.Sharp.Time.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Time(global::Acid.Sharp.Time.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Time(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for time. This function is internal. To construct time values, use Time::Seconds, Time::Milliseconds or Time::Microseconds instead.</summary>
        /// <param name="microseconds">Number of microseconds.</param>
        public Time(long microseconds)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Time.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &microseconds;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Time(global::Acid.Sharp.Time _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Time.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Time.__Internal*) __Instance) = *((global::Acid.Sharp.Time.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Time __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Time;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Time.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Time __op, global::Acid.Sharp.Time other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Time operator -(global::Acid.Sharp.Time __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static explicit operator global::Acid.Sharp.Time(long microseconds)
        {
            return new global::Acid.Sharp.Time(ref *microseconds);
        }

        /// <summary>Constructs a time value from a number of seconds.</summary>
        /// <param name="amount">Number of seconds.</param>
        public static global::Acid.Sharp.Time Seconds(float amount)
        {
            var __arg0 = &amount;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.Seconds(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        /// <summary>Constructs a time value from a number of milliseconds.</summary>
        /// <param name="amount">Number of milliseconds.</param>
        public static global::Acid.Sharp.Time Milliseconds(int amount)
        {
            var __arg0 = &amount;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.Milliseconds(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        /// <summary>Constructs a time value from a number of microseconds.</summary>
        /// <param name="amount">Number of microseconds.</param>
        public static global::Acid.Sharp.Time Microseconds(long amount)
        {
            var __arg0 = &amount;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.Microseconds(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator +(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator -(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(global::Acid.Sharp.Time left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(global::Acid.Sharp.Time left, long right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(float left, global::Acid.Sharp.Time right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator *(long left, global::Acid.Sharp.Time right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator /(global::Acid.Sharp.Time left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time operator /(global::Acid.Sharp.Time left, long right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static float operator /(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = __Internal.OperatorSlash(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Time operator %(global::Acid.Sharp.Time left, global::Acid.Sharp.Time right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Time.__Internal();
            __Internal.OperatorPercent(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Time.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Time Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Time.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Time@acid@@2V12@B");
                return global::Acid.Sharp.Time.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Time NegativeInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Time.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Time@acid@@2V12@B");
                return global::Acid.Sharp.Time.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Time PositiveInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Time.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Time@acid@@2V12@B");
                return global::Acid.Sharp.Time.__CreateInstance(*__ptr);
            }
        }

        /// <summary>Return the time value as a number of seconds.</summary>
        public float AsSeconds
        {
            get
            {
                var __ret = __Internal.AsSeconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Return the time value as a number of milliseconds.</summary>
        public int AsMilliseconds
        {
            get
            {
                var __ret = __Internal.AsMilliseconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Return the time value as a number of microseconds.</summary>
        public long AsMicroseconds
        {
            get
            {
                var __ret = __Internal.AsMicroseconds((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A helper for C++ strings.</summary>
    public unsafe partial class String : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0String@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StartsWith@String@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool StartsWith(global::System.IntPtr str, global::System.IntPtr token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Contains@String@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(global::System.IntPtr str, global::System.IntPtr token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInteger@String@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetInteger(global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindCharPos@String@acid@@SAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBD@Z")]
            internal static extern int FindCharPos(global::System.IntPtr str, sbyte* c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Trim@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z")]
            internal static extern void Trim(global::System.IntPtr @return, global::System.IntPtr str, global::System.IntPtr whitespace);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Substring@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBI1@Z")]
            internal static extern void Substring(global::System.IntPtr @return, global::System.IntPtr str, uint* start, uint* end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveAll@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBD@Z")]
            internal static extern void RemoveAll(global::System.IntPtr @return, global::System.IntPtr str, sbyte* token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveLast@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@AEBD@Z")]
            internal static extern void RemoveLast(global::System.IntPtr @return, global::System.IntPtr str, sbyte* token);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ReplaceAll@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@00@Z")]
            internal static extern void ReplaceAll(global::System.IntPtr @return, global::System.IntPtr str, global::System.IntPtr token, global::System.IntPtr to);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ReplaceFirst@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@00@Z")]
            internal static extern void ReplaceFirst(global::System.IntPtr @return, global::System.IntPtr str, global::System.IntPtr token, global::System.IntPtr to);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Lowercase@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void Lowercase(global::System.IntPtr @return, global::System.IntPtr str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Uppercase@String@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void Uppercase(global::System.IntPtr @return, global::System.IntPtr str);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.String> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.String>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.String __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.String(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.String __CreateInstance(global::Acid.Sharp.String.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.String(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.String.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.String.__Internal));
            *(global::Acid.Sharp.String.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private String(global::Acid.Sharp.String.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected String(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public String()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.String.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public String(global::Acid.Sharp.String _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.String.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.String.__Internal*) __Instance) = *((global::Acid.Sharp.String.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.String __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if a string starts with a token.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static bool StartsWith(string str, string token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.StartsWith(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Gets if a string contains a token.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static bool Contains(string str, string token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.Contains(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Gets if a string is a integer.</summary>
        /// <param name="str">The string.</param>
        public static bool GetInteger(string str)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetInteger(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets the first char index in the string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="c">The char to look for.</param>
        public static int FindCharPos(string str, char c)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = (sbyte*) &c;
            var __ret = __Internal.FindCharPos(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Trims the left and right side of a string of whitespace.</summary>
        /// <param name="str">The string.</param>
        /// <param name="whitespace">The whitespace type.</param>
        public static string Trim(string str, string whitespace)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(whitespace, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Trim(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Takes a substring of a string between two bounds.</summary>
        /// <param name="str">The string.</param>
        /// <param name="start">The left bound.</param>
        /// <param name="end">The right bound.</param>
        public static string Substring(string str, uint start, uint end)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = &start;
            var __arg2 = &end;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Substring(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Removes all tokens from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static string RemoveAll(string str, char token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = (sbyte*) &token;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.RemoveAll(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Removes the last token from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        public static string RemoveLast(string str, char token)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = (sbyte*) &token;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.RemoveLast(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Replaces all tokens from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        /// <param name="to">The string to replace the tokens with.</param>
        public static string ReplaceAll(string str, string token, string to)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(to, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ReplaceAll(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Replaces the first token from a string.</summary>
        /// <param name="str">The string.</param>
        /// <param name="token">The token.</param>
        /// <param name="to">The string to replace the tokens with.</param>
        public static string ReplaceFirst(string str, string token, string to)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(token, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(to, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ReplaceFirst(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Lowercases a string.</summary>
        /// <param name="str">The string.</param>
        public static string Lowercase(string str)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Lowercase(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Uppercases a string.</summary>
        /// <param name="str">The string.</param>
        public static string Uppercase(string str)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Uppercase(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that is used to represent a tree of values, used in file-object serialization.</summary>
    public unsafe partial class Metadata : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [FieldOffset(64)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Metadata___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(88)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S0____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S0_ m_attributes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Metadata@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Metadata@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Metadata@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ClearChildren@Metadata@acid@@QEAAXXZ")]
            internal static extern void ClearChildren(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@Metadata@acid@@QEAAPEAV12@PEAV12@@Z")]
            internal static extern global::System.IntPtr AddChild(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveChild@Metadata@acid@@QEAA_NPEAV12@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindChild@Metadata@acid@@QEBAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N@Z")]
            internal static extern global::System.IntPtr FindChild(global::System.IntPtr instance, global::System.IntPtr name, bool* reportError);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindChildWithAttribute@Metadata@acid@@QEBAPEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@00AEB_N@Z")]
            internal static extern global::System.IntPtr FindChildWithAttribute(global::System.IntPtr instance, global::System.IntPtr childName, global::System.IntPtr attribute, global::System.IntPtr value, bool* reportError);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddAttribute@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void AddAttribute(global::System.IntPtr instance, global::System.IntPtr attribute, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveAttribute@Metadata@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveAttribute(global::System.IntPtr instance, global::System.IntPtr attribute);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindAttribute@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FindAttribute(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr attribute);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetString@Metadata@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetString@Metadata@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetString(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChildCount@Metadata@acid@@QEBAIXZ")]
            internal static extern uint GetChildCount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttributeCount@Metadata@acid@@QEBAIXZ")]
            internal static extern uint GetAttributeCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Metadata> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Metadata>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Metadata __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Metadata(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Metadata __CreateInstance(global::Acid.Sharp.Metadata.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Metadata(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Metadata.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Metadata.__Internal));
            global::Acid.Sharp.Metadata.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Metadata(global::Acid.Sharp.Metadata.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Metadata(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Metadata(string name, string value)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Metadata.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public Metadata(global::Acid.Sharp.Metadata _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Metadata.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Metadata __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void ClearChildren()
        {
            __Internal.ClearChildren((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.Metadata AddChild(global::Acid.Sharp.Metadata value)
        {
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            var __ret = __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.Metadata __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
            return __result0;
        }

        public bool RemoveChild(global::Acid.Sharp.Metadata child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            var __ret = __Internal.RemoveChild((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public global::Acid.Sharp.Metadata FindChild(string name, bool reportError)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = &reportError;
            var __ret = __Internal.FindChild((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.Metadata __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
            return __result0;
        }

        public global::Acid.Sharp.Metadata FindChildWithAttribute(string childName, string attribute, string value, bool reportError)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(childName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(value, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __arg3 = &reportError;
            var __ret = __Internal.FindChildWithAttribute((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            global::Acid.Sharp.Metadata __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
            return __result0;
        }

        public void AddAttribute(string attribute, string value)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.AddAttribute((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public bool RemoveAttribute(string attribute)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.RemoveAttribute((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public string FindAttribute(string attribute)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attribute, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FindAttribute((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        protected string MName
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.Metadata.__Internal*) __Instance)->m_name));
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                ((global::Acid.Sharp.Metadata.__Internal*)__Instance)->m_name = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }
        }

        protected string MValue
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.Metadata.__Internal*) __Instance)->m_value));
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                ((global::Acid.Sharp.Metadata.__Internal*)__Instance)->m_value = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string String
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetString((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public uint ChildCount
        {
            get
            {
                var __ret = __Internal.GetChildCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint AttributeCount
        {
            get
            {
                var __ret = __Internal.GetAttributeCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a 3-tuple vector.</summary>
    public unsafe partial class Vector3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector3._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* x, float* y, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBVVector2@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector3@acid@@QEAA@AEBVColour@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Cross@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Cross(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector3@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float* scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToQuaternion@Vector3@acid@@QEBA?AVQuaternion@2@XZ")]
            internal static extern void ToQuaternion(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector3@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector3@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProjectCubeToSphere@Vector3@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void ProjectCubeToSphere(global::System.IntPtr instance, global::System.IntPtr @return, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BaryCentric@Vector3@acid@@QEAAMAEBV12@00@Z")]
            internal static extern float BaryCentric(global::System.IntPtr instance, global::System.IntPtr p1, global::System.IntPtr p2, global::System.IntPtr p3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinVector@Vector3@acid@@SA?AV12@AEBV12@0@Z")]
            internal static extern void MinVector(global::System.IntPtr @return, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxVector@Vector3@acid@@SA?AV12@AEBV12@0@Z")]
            internal static extern void MaxVector(global::System.IntPtr @return, global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomPointOnCircle@Vector3@acid@@SA?AV12@AEBV12@AEBM@Z")]
            internal static extern void RandomPointOnCircle(global::System.IntPtr @return, global::System.IntPtr normal, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomUnitVectorWithinCone@Vector3@acid@@SA?AV12@AEBV12@AEBM@Z")]
            internal static extern void RandomUnitVectorWithinCone(global::System.IntPtr @return, global::System.IntPtr coneDirection, float* angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Vector3@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Vector3@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector3@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector3@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector3@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector3@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector3@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBV10@AEBVQuaternion@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr right, global::System.IntPtr left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBVVector3@0@AEBV10@@Z")]
            internal static extern void OperatorStar_2(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBVVector3@0@AEBV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AVector3@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector3@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector3@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float* x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector3@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector3@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Vector3@acid@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Vector3@acid@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector3@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector3@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector3@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector3@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CartesianToPolar@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void CartesianToPolar(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PolarToCartesian@Vector3@acid@@QEBA?AV12@XZ")]
            internal static extern void PolarToCartesian(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomUnitVector@Vector3@acid@@SA?AV12@XZ")]
            internal static extern void RandomUnitVector(global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector3._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector3._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[3];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Vector3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector3(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Vector3 __CreateInstance(global::Acid.Sharp.Vector3.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector3(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Vector3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            global::Acid.Sharp.Vector3.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector3(global::Acid.Sharp.Vector3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector3.</summary>
        public Vector3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        public Vector3(float x, float y, float z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &x;
            var __arg1 = &y;
            var __arg2 = &z;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        /// <param name="z">Start z.</param>
        public Vector3(global::Acid.Sharp.Vector2 source, float z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg1 = &z;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector3(global::Acid.Sharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector3(global::Acid.Sharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector3.</summary>
        /// <param name="source">Creates this vector out of a existing colour.</param>
        public Vector3(global::Acid.Sharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Vector3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 Add(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 Subtract(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 Multiply(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 Divide(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the cross product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 Cross(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Cross((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::Acid.Sharp.Vector3 Scale(float scalar)
        {
            var __arg0 = &scalar;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around the origin.</summary>
        /// <param name="rotation">The rotation amount.</param>
        public global::Acid.Sharp.Vector3 Rotate(global::Acid.Sharp.Vector3 rotation)
        {
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = rotation.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::Acid.Sharp.Vector3 Negate()
        {
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::Acid.Sharp.Vector3 Normalize()
        {
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Converts these euler angles to a quaternion.</summary>
        public global::Acid.Sharp.Quaternion ToQuaternion()
        {
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.ToQuaternion((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 DistanceVector(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::Acid.Sharp.Vector3 SmoothDamp(global::Acid.Sharp.Vector3 target, global::Acid.Sharp.Vector3 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Projects this cube coordinate onto a sphere.</summary>
        /// <param name="radius">The sphere radius.</param>
        public global::Acid.Sharp.Vector3 ProjectCubeToSphere(float radius)
        {
            var __arg0 = &radius;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.ProjectCubeToSphere((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets the height of this vector on a point off of a 3d triangle.</summary>
        /// <param name="p1">Point 1 on the triangle.</param>
        /// <param name="p2">Point 2 on the triangle.</param>
        /// <param name="p3">Point 3 on the triangle.</param>
        public float BaryCentric(global::Acid.Sharp.Vector3 p1, global::Acid.Sharp.Vector3 p2, global::Acid.Sharp.Vector3 p3)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            var __ret = __Internal.BaryCentric((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Vector3 __op, global::Acid.Sharp.Vector3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Vector3;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Vector3.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Vector3 __op, global::Acid.Sharp.Vector3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Vector3 __op, global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Vector3 __op, global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Vector3 __op, global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Vector3 __op, global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::Acid.Sharp.Vector3 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator !=(global::Acid.Sharp.Vector3 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Vector3 operator -(global::Acid.Sharp.Vector3 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Vector3(global::Acid.Sharp.Vector4 source)
        {
            return new global::Acid.Sharp.Vector3(source);
        }

        public static implicit operator global::Acid.Sharp.Vector3(global::Acid.Sharp.Colour source)
        {
            return new global::Acid.Sharp.Vector3(source);
        }

        /// <summary>Gets the lowest vector size.</summary>
        /// <param name="a">The first vector to get values from.</param>
        /// <param name="b">The second vector to get values from.</param>
        public static global::Acid.Sharp.Vector3 MinVector(global::Acid.Sharp.Vector3 a, global::Acid.Sharp.Vector3 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.MinVector(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets the maximum vector size.</summary>
        /// <param name="a">The first vector to get values from.</param>
        /// <param name="b">The second vector to get values from.</param>
        public static global::Acid.Sharp.Vector3 MaxVector(global::Acid.Sharp.Vector3 a, global::Acid.Sharp.Vector3 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.MaxVector(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Gets a random point from on a circle.</summary>
        /// <param name="normal">The circles normal.</param>
        /// <param name="radius">The circles radius.</param>
        public static global::Acid.Sharp.Vector3 RandomPointOnCircle(global::Acid.Sharp.Vector3 normal, float radius)
        {
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = normal.__Instance;
            var __arg1 = &radius;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.RandomPointOnCircle(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Generates a random unit vector from within a cone.</summary>
        /// <param name="coneDirection">The cones direction.</param>
        /// <param name="angle">The cones major angle.</param>
        public static global::Acid.Sharp.Vector3 RandomUnitVectorWithinCone(global::Acid.Sharp.Vector3 coneDirection, float angle)
        {
            if (ReferenceEquals(coneDirection, null))
                throw new global::System.ArgumentNullException("coneDirection", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = coneDirection.__Instance;
            var __arg1 = &angle;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.RandomUnitVectorWithinCone(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator +(global::Acid.Sharp.Vector3 left, global::Acid.Sharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator -(global::Acid.Sharp.Vector3 left, global::Acid.Sharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator *(global::Acid.Sharp.Vector3 left, global::Acid.Sharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator /(global::Acid.Sharp.Vector3 left, global::Acid.Sharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator +(float left, global::Acid.Sharp.Vector3 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator -(float left, global::Acid.Sharp.Vector3 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator *(float left, global::Acid.Sharp.Vector3 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator /(float left, global::Acid.Sharp.Vector3 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator +(global::Acid.Sharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator -(global::Acid.Sharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator *(global::Acid.Sharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator /(global::Acid.Sharp.Vector3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator *(global::Acid.Sharp.Vector3 right, global::Acid.Sharp.Quaternion left)
        {
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = right.__Instance;
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = left.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator *(global::Acid.Sharp.Vector3 left, global::Acid.Sharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorStar_2(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator /(global::Acid.Sharp.Vector3 left, global::Acid.Sharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 One
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 Left
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LEFT@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 Right
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RIGHT@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 Up
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?UP@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 Down
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DOWN@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 Front
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?FRONT@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 Back
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?BACK@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 PositiveInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector3 NegativeInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Vector3@acid@@2V12@B");
                return global::Acid.Sharp.Vector3.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return *__ret;
            }

            set
            {
                var __arg0 = &index;
                *global::Acid.Sharp.Vector3.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetY((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetZ((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Converts from rectangular to spherical coordinates, this vector is in cartesian (x, y, z).</summary>
        public global::Acid.Sharp.Vector3 CartesianToPolar
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.CartesianToPolar((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Converts from spherical to rectangular coordinates, this vector is in polar (radius, theta, phi).</summary>
        public global::Acid.Sharp.Vector3 PolarToCartesian
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.PolarToCartesian((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Generates a random unit vector.</summary>
        public static global::Acid.Sharp.Vector3 RandomUnitVector
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.RandomUnitVector(new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a 4-tuple vector.</summary>
    public unsafe partial class Vector4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector4._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* x, float* y, float* z, float* w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBVVector3@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float* w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector4@acid@@QEAA@AEBVColour@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector4@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float* scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector4@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector4@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector4@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector4@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Vector4@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Vector4@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector4@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector4@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector4@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector4@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector4@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBVVector4@0@AEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBVVector4@0@AEBV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AVector4@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float* x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetW@Vector4@acid@@QEBAMXZ")]
            internal static extern float GetW(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetW@Vector4@acid@@QEAAXAEBM@Z")]
            internal static extern void SetW(global::System.IntPtr instance, float* w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector4@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector4@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector4@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector4@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector4._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector4._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[4];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector4>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Vector4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector4(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Vector4 __CreateInstance(global::Acid.Sharp.Vector4.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector4(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Vector4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector4.__Internal));
            global::Acid.Sharp.Vector4.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector4(global::Acid.Sharp.Vector4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector4.</summary>
        public Vector4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        /// <param name="w">Start w.</param>
        public Vector4(float x, float y, float z, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &x;
            var __arg1 = &y;
            var __arg2 = &z;
            var __arg3 = &w;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        /// <param name="w">Start w.</param>
        public Vector4(global::Acid.Sharp.Vector3 source, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg1 = &w;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector4(global::Acid.Sharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector4.</summary>
        /// <param name="source">Creates this vector out of a existing colour.</param>
        public Vector4(global::Acid.Sharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Vector4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector4 Add(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector4 Subtract(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector4 Multiply(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector4 Divide(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::Acid.Sharp.Vector4 Scale(float scalar)
        {
            var __arg0 = &scalar;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::Acid.Sharp.Vector4 Negate()
        {
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::Acid.Sharp.Vector4 Normalize()
        {
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector4 DistanceVector(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::Acid.Sharp.Vector4 SmoothDamp(global::Acid.Sharp.Vector4 target, global::Acid.Sharp.Vector4 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Vector4 __op, global::Acid.Sharp.Vector4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Vector4;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Vector4.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Vector4 __op, global::Acid.Sharp.Vector4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Vector4 __op, global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Vector4 __op, global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Vector4 __op, global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Vector4 __op, global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::Acid.Sharp.Vector4 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator !=(global::Acid.Sharp.Vector4 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Vector4 operator -(global::Acid.Sharp.Vector4 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Vector4(global::Acid.Sharp.Colour source)
        {
            return new global::Acid.Sharp.Vector4(source);
        }

        public static global::Acid.Sharp.Vector4 operator +(global::Acid.Sharp.Vector4 left, global::Acid.Sharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator -(global::Acid.Sharp.Vector4 left, global::Acid.Sharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator *(global::Acid.Sharp.Vector4 left, global::Acid.Sharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator /(global::Acid.Sharp.Vector4 left, global::Acid.Sharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator +(float left, global::Acid.Sharp.Vector4 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator -(float left, global::Acid.Sharp.Vector4 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator *(float left, global::Acid.Sharp.Vector4 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator /(float left, global::Acid.Sharp.Vector4 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator +(global::Acid.Sharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator -(global::Acid.Sharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator *(global::Acid.Sharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 operator /(global::Acid.Sharp.Vector4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator *(global::Acid.Sharp.Vector4 left, global::Acid.Sharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator /(global::Acid.Sharp.Vector4 left, global::Acid.Sharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector4 Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Vector4@acid@@2V12@B");
                return global::Acid.Sharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector4 One
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Vector4@acid@@2V12@B");
                return global::Acid.Sharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector4 PositiveInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Vector4@acid@@2V12@B");
                return global::Acid.Sharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector4 NegativeInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Vector4@acid@@2V12@B");
                return global::Acid.Sharp.Vector4.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return *__ret;
            }

            set
            {
                var __arg0 = &index;
                *global::Acid.Sharp.Vector4.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetY((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetZ((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float W
        {
            get
            {
                var __ret = __Internal.GetW((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetW((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a row major 4x4 matrix.</summary>
    public unsafe partial class Matrix4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Matrix4._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* diagonal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix4@acid@@QEAA@QEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::Acid.Sharp.Vector4.__Internal[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix4@acid@@QEBA?AVVector4@2@AEBV32@@Z")]
            internal static extern void Multiply_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix4@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix4@acid@@QEBA?AVVector4@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Translate@Matrix4@acid@@QEBA?AV12@AEBVVector2@2@@Z")]
            internal static extern void Translate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Translate@Matrix4@acid@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Translate_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix4@acid@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix4@acid@@QEBA?AV12@AEBVVector4@2@@Z")]
            internal static extern void Scale_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Matrix4@acid@@QEBA?AV12@AEBMAEBVVector3@2@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float* angle, global::System.IntPtr axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix4@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubmatrix@Matrix4@acid@@QEBA?AVMatrix3@2@AEBH0@Z")]
            internal static extern void GetSubmatrix(global::System.IntPtr instance, global::System.IntPtr @return, int* row, int* col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@00@Z")]
            internal static extern void TransformationMatrix(global::System.IntPtr @return, global::System.IntPtr translation, global::System.IntPtr rotation, global::System.IntPtr scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TransformationMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@AEBVQuaternion@2@0@Z")]
            internal static extern void TransformationMatrix_1(global::System.IntPtr @return, global::System.IntPtr translation, global::System.IntPtr rotation, global::System.IntPtr scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PerspectiveMatrix@Matrix4@acid@@SA?AV12@AEBM000@Z")]
            internal static extern void PerspectiveMatrix(global::System.IntPtr @return, float* fov, float* aspectRatio, float* zNear, float* zFar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?OrthographicMatrix@Matrix4@acid@@SA?AV12@AEBM00000@Z")]
            internal static extern void OrthographicMatrix(global::System.IntPtr @return, float* left, float* right, float* bottom, float* top, float* near, float* far);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ViewMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@0@Z")]
            internal static extern void ViewMatrix(global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ViewMatrix@Matrix4@acid@@SA?AV12@AEBVVector3@2@AEBVQuaternion@2@@Z")]
            internal static extern void ViewMatrix_1(global::System.IntPtr @return, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WorldToScreenSpace@Matrix4@acid@@SA?AVVector3@2@AEBV32@AEBV12@1@Z")]
            internal static extern void WorldToScreenSpace(global::System.IntPtr @return, global::System.IntPtr worldSpace, global::System.IntPtr viewMatrix, global::System.IntPtr projectionMatrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LookAt@Matrix4@acid@@SA?AV12@AEBVVector3@2@00@Z")]
            internal static extern void LookAt(global::System.IntPtr @return, global::System.IntPtr camera, global::System.IntPtr @object, global::System.IntPtr up);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Matrix4@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Matrix4@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix4@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix4@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix4@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBV10@AEBVVector4@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBV10@AEBVVector4@0@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix4@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AMatrix4@acid@@QEAAAEAVVector4@1@AEBI@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix4@acid@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix4@acid@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix4@acid@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Matrix4._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Matrix4._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte m_rows[64];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Matrix4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Matrix4>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Matrix4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Matrix4(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Matrix4 __CreateInstance(global::Acid.Sharp.Matrix4.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Matrix4(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Matrix4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix4.__Internal));
            global::Acid.Sharp.Matrix4.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix4(global::Acid.Sharp.Matrix4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix4. The matrix is initialised to the identity.</summary>
        /// <param name="diagonal">The value set to the diagonals.</param>
        public Matrix4(float diagonal)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &diagonal;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix4(global::Acid.Sharp.Matrix4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a 16 element array.</param>
        public Matrix4(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 16)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor_1((__Instance + __PointerAdjustment), source);
        }

        /// <summary>Constructor for Matrix4.</summary>
        /// <param name="source">Creates this matrix out of a 4 vector array.</param>
        public Matrix4(global::Acid.Sharp.Vector4[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 4)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            global::Acid.Sharp.Vector4.__Internal[] __source;
            if (ReferenceEquals(source, null))
                __source = null;
            else
            {
                __source = new global::Acid.Sharp.Vector4.__Internal[source.Length];
                for (int i = 0; i < __source.Length; i++)
                {
                    var __element = source[i];
                    __source[i] = ReferenceEquals(__element, null) ? new global::Acid.Sharp.Vector4.__Internal() : *(global::Acid.Sharp.Vector4.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __source;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Matrix4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix4 Add(global::Acid.Sharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix4 Subtract(global::Acid.Sharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix4 Multiply(global::Acid.Sharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector4 Multiply(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Multiply_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix4 Divide(global::Acid.Sharp.Matrix4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector4 Transform(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector4.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
        }

        /// <summary>Translates this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::Acid.Sharp.Matrix4 Translate(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Translate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Translates this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::Acid.Sharp.Matrix4 Translate(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Translate_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Matrix4 Scale(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Matrix4 Scale(global::Acid.Sharp.Vector4 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Scale_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Rotates this matrix around the given axis the specified angle.</summary>
        /// <param name="angle">The angle, in radians.</param>
        /// <param name="axis">The vector representing the rotation axis.</param>
        public global::Acid.Sharp.Matrix4 Rotate(float angle, global::Acid.Sharp.Vector3 axis)
        {
            var __arg0 = &angle;
            if (ReferenceEquals(axis, null))
                throw new global::System.ArgumentNullException("axis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = axis.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::Acid.Sharp.Matrix4 Negate()
        {
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Gets the submatrix of this matrix.</summary>
        public global::Acid.Sharp.Matrix3 GetSubmatrix(int row, int col)
        {
            var __arg0 = &row;
            var __arg1 = &col;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.GetSubmatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Matrix4 __op, global::Acid.Sharp.Matrix4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Matrix4;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Matrix4.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Matrix4 __op, global::Acid.Sharp.Matrix4 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Matrix4 operator -(global::Acid.Sharp.Matrix4 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Matrix4(float diagonal)
        {
            return new global::Acid.Sharp.Matrix4(ref *diagonal);
        }

        public static explicit operator global::Acid.Sharp.Matrix4(float[] source)
        {
            return new global::Acid.Sharp.Matrix4(source);
        }

        public static explicit operator global::Acid.Sharp.Matrix4(global::Acid.Sharp.Vector4[] source)
        {
            return new global::Acid.Sharp.Matrix4(source);
        }

        /// <summary>Creates a new transformation matrix for a object in 3d space.</summary>
        /// <param name="translation">Translation amount the XYZ.</param>
        /// <param name="rotation">Rotation amount (Pitch, Yaw, Roll).</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::Acid.Sharp.Matrix4 TransformationMatrix(global::Acid.Sharp.Vector3 translation, global::Acid.Sharp.Vector3 rotation, global::Acid.Sharp.Vector3 scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scale.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.TransformationMatrix(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix for a object in 3d space.</summary>
        /// <param name="translation">Translation amount the XYZ.</param>
        /// <param name="rotation">Rotation amount.</param>
        /// <param name="scale">How much to scale the matrix.</param>
        public static global::Acid.Sharp.Matrix4 TransformationMatrix(global::Acid.Sharp.Vector3 translation, global::Acid.Sharp.Quaternion rotation, global::Acid.Sharp.Vector3 scale)
        {
            if (ReferenceEquals(translation, null))
                throw new global::System.ArgumentNullException("translation", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = translation.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scale.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.TransformationMatrix_1(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new perspective matrix.</summary>
        /// <param name="fov">The cameras FOV.</param>
        /// <param name="aspectRatio">The cameras aspect ratio.</param>
        /// <param name="zNear">The cameras near plane.</param>
        /// <param name="zFar">The cameras far plane.</param>
        public static global::Acid.Sharp.Matrix4 PerspectiveMatrix(float fov, float aspectRatio, float zNear, float zFar)
        {
            var __arg0 = &fov;
            var __arg1 = &aspectRatio;
            var __arg2 = &zNear;
            var __arg3 = &zFar;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.PerspectiveMatrix(new IntPtr(&__ret), __arg0, __arg1, __arg2, __arg3);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new orthographic matrix.</summary>
        /// <param name="left">The left plane.</param>
        /// <param name="right">The right plane.</param>
        /// <param name="bottom">The bottom plane.</param>
        /// <param name="top">The top plane.</param>
        /// <param name="near">The near plane.</param>
        /// <param name="far">The far plane.</param>
        /// <param name="destination">The destination matrix or nullptr if a new matrix is to be created.</param>
        public static global::Acid.Sharp.Matrix4 OrthographicMatrix(float left, float right, float bottom, float top, float near, float far)
        {
            var __arg0 = &left;
            var __arg1 = &right;
            var __arg2 = &bottom;
            var __arg3 = &top;
            var __arg4 = &near;
            var __arg5 = &far;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OrthographicMatrix(new IntPtr(&__ret), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new view matrix.</summary>
        /// <param name="position">The cameras position.</param>
        /// <param name="rotation">The cameras rotation.</param>
        public static global::Acid.Sharp.Matrix4 ViewMatrix(global::Acid.Sharp.Vector3 position, global::Acid.Sharp.Vector3 rotation)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.ViewMatrix(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Creates a new view matrix.</summary>
        /// <param name="position">The cameras position.</param>
        /// <param name="rotation">The cameras rotation.</param>
        public static global::Acid.Sharp.Matrix4 ViewMatrix(global::Acid.Sharp.Vector3 position, global::Acid.Sharp.Quaternion rotation)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.ViewMatrix_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Transforms a 3D world point into screen space.</summary>
        /// <param name="worldSpace">The point to get into screen space.</param>
        /// <param name="viewMatrix">The cameras view matrix.</param>
        /// <param name="projectionMatrix">The cameras projection matrix.</param>
        public static global::Acid.Sharp.Vector3 WorldToScreenSpace(global::Acid.Sharp.Vector3 worldSpace, global::Acid.Sharp.Matrix4 viewMatrix, global::Acid.Sharp.Matrix4 projectionMatrix)
        {
            if (ReferenceEquals(worldSpace, null))
                throw new global::System.ArgumentNullException("worldSpace", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = worldSpace.__Instance;
            if (ReferenceEquals(viewMatrix, null))
                throw new global::System.ArgumentNullException("viewMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = viewMatrix.__Instance;
            if (ReferenceEquals(projectionMatrix, null))
                throw new global::System.ArgumentNullException("projectionMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = projectionMatrix.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.WorldToScreenSpace(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Creates a new transformation matrix that has the camera looking at the target.</summary>
        /// <param name="camera">The source position.</param>
        /// <param name="object">The target position.</param>
        /// <param name="up">What view direction is up.</param>
        public static global::Acid.Sharp.Matrix4 LookAt(global::Acid.Sharp.Vector3 camera, global::Acid.Sharp.Vector3 @object, global::Acid.Sharp.Vector3 up)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = camera.__Instance;
            if (ReferenceEquals(@object, null))
                throw new global::System.ArgumentNullException("@object", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = @object.__Instance;
            if (ReferenceEquals(up, null))
                throw new global::System.ArgumentNullException("up", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = up.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.LookAt(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator +(global::Acid.Sharp.Matrix4 left, global::Acid.Sharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator -(global::Acid.Sharp.Matrix4 left, global::Acid.Sharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator *(global::Acid.Sharp.Matrix4 left, global::Acid.Sharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator /(global::Acid.Sharp.Matrix4 left, global::Acid.Sharp.Matrix4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator *(global::Acid.Sharp.Matrix4 left, global::Acid.Sharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator /(global::Acid.Sharp.Matrix4 left, global::Acid.Sharp.Vector4 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator *(float left, global::Acid.Sharp.Matrix4 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator /(float left, global::Acid.Sharp.Matrix4 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator *(global::Acid.Sharp.Matrix4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 operator /(global::Acid.Sharp.Matrix4 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix4 Identity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?IDENTITY@Matrix4@acid@@2V12@B");
                return global::Acid.Sharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Matrix4 Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Matrix4@acid@@2V12@B");
                return global::Acid.Sharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        public global::Acid.Sharp.Vector4 this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
            }

            set
            {
                var __arg0 = &index;
                *(global::Acid.Sharp.Vector4.__Internal*) global::Acid.Sharp.Matrix4.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector4.__Internal() : *(global::Acid.Sharp.Vector4.__Internal*) value.__Instance;
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::Acid.Sharp.Matrix4 Invert
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::Acid.Sharp.Matrix4 Transpose
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A vector like object of the form w + xi + yj + zk, where w, x, y, z are real numbers and i, j, k are imaginary units.</summary>
    public unsafe partial class Quaternion : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Quaternion._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* x, float* y, float* z, float* w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* pitch, float* yaw, float* roll);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBVVector3@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr source, float* w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Quaternion@acid@@QEAA@AEBVVector3@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr axisX, global::System.IntPtr axisY, global::System.IntPtr axisZ);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Quaternion@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void Multiply_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MultiplyInverse@Quaternion@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void MultiplyInverse(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Quaternion@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Slerp@Quaternion@acid@@QEAA?AV12@AEBV12@AEBM@Z")]
            internal static extern void Slerp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other, float* progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Quaternion@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float* scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Quaternion@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Quaternion@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToMatrix@Quaternion@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void ToMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToRotationMatrix@Quaternion@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void ToRotationMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToEuler@Quaternion@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void ToEuler(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Quaternion@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Quaternion@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Quaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Quaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PQuaternion@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Quaternion@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Quaternion@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GQuaternion@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Quaternion@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVQuaternion@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVQuaternion@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVQuaternion@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector3@0@AEBVQuaternion@0@AEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVQuaternion@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVQuaternion@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AQuaternion@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float* x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetZ@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetZ(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetZ@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetZ(global::System.IntPtr instance, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetW@Quaternion@acid@@QEBAMXZ")]
            internal static extern float GetW(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetW@Quaternion@acid@@QEAAXAEBM@Z")]
            internal static extern void SetW(global::System.IntPtr instance, float* w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Quaternion@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Quaternion@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Quaternion@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Quaternion@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Quaternion._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Quaternion._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal float m_x;

                    [FieldOffset(4)]
                    internal float m_y;

                    [FieldOffset(8)]
                    internal float m_z;

                    [FieldOffset(12)]
                    internal float m_w;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Quaternion> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Quaternion>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Quaternion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Quaternion(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Quaternion __CreateInstance(global::Acid.Sharp.Quaternion.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Quaternion(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Quaternion.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            global::Acid.Sharp.Quaternion.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Quaternion(global::Acid.Sharp.Quaternion.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Quaternion(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Quaternion.</summary>
        public Quaternion()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        /// <param name="z">Start z.</param>
        /// <param name="w">Start w.</param>
        public Quaternion(float x, float y, float z, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &x;
            var __arg1 = &y;
            var __arg2 = &z;
            var __arg3 = &w;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="pitch">Start pitch.</param>
        /// <param name="yaw">Start yaw.</param>
        /// <param name="roll">Start roll.</param>
        public Quaternion(float pitch, float yaw, float roll)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &pitch;
            var __arg1 = &yaw;
            var __arg2 = &roll;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this quaternion out of a existing vector (pitch, yaw roll).</param>
        /// <param name="w">Start w.</param>
        public Quaternion(global::Acid.Sharp.Vector3 source, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg1 = &w;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Quaternion(global::Acid.Sharp.Quaternion source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="source">Creates this vector out of a existing matrix.</param>
        public Quaternion(global::Acid.Sharp.Matrix4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Quaternion.</summary>
        /// <param name="axisX">The X axis.</param>
        /// <param name="axisY">The Y axis.</param>
        /// <param name="axisZ">The Z axis.</param>
        public Quaternion(global::Acid.Sharp.Vector3 axisX, global::Acid.Sharp.Vector3 axisY, global::Acid.Sharp.Vector3 axisZ)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Quaternion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(axisX, null))
                throw new global::System.ArgumentNullException("axisX", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = axisX.__Instance;
            if (ReferenceEquals(axisY, null))
                throw new global::System.ArgumentNullException("axisY", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = axisY.__Instance;
            if (ReferenceEquals(axisZ, null))
                throw new global::System.ArgumentNullException("axisZ", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = axisZ.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Quaternion __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this quaternion to another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public global::Acid.Sharp.Quaternion Add(global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this quaternion to another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public global::Acid.Sharp.Quaternion Subtract(global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this quaternion with another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public global::Acid.Sharp.Quaternion Multiply(global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this quaternion with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 Multiply(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Multiply_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this quaternion with the inverse of another quaternion. The value of both argument quaternions is persevered (this = left * right^-1).</summary>
        /// <param name="other">The other quaternion.</param>
        public global::Acid.Sharp.Quaternion MultiplyInverse(global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.MultiplyInverse((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Calculates the dot product of the this quaternion and another quaternion.</summary>
        /// <param name="other">The other quaternion.</param>
        public float Dot(global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the slerp between this quaternion and another quaternion, they must be normalized!</summary>
        /// <param name="other">The other quaternion.</param>
        /// <param name="progression">The progression.</param>
        public global::Acid.Sharp.Quaternion Slerp(global::Acid.Sharp.Quaternion other, float progression)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __arg1 = &progression;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.Slerp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Scales this quaternion by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::Acid.Sharp.Quaternion Scale(float scalar)
        {
            var __arg0 = &scalar;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Negates this quaternion.</summary>
        public global::Acid.Sharp.Quaternion Negate()
        {
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this quaternion.</summary>
        public global::Acid.Sharp.Quaternion Normalize()
        {
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to a 4x4 matrix.</summary>
        public global::Acid.Sharp.Matrix4 ToMatrix()
        {
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.ToMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to a 3x3 matrix representing the exact same rotation as this quaternion.</summary>
        public global::Acid.Sharp.Matrix4 ToRotationMatrix()
        {
            var __ret = new global::Acid.Sharp.Matrix4.__Internal();
            __Internal.ToRotationMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
        }

        /// <summary>Converts this quaternion to euler angles.</summary>
        public global::Acid.Sharp.Vector3 ToEuler()
        {
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.ToEuler((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Quaternion __op, global::Acid.Sharp.Quaternion other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Quaternion;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Quaternion.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Quaternion __op, global::Acid.Sharp.Quaternion other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Quaternion __op, global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Quaternion __op, global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Quaternion __op, global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Quaternion __op, global::Acid.Sharp.Quaternion other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::Acid.Sharp.Quaternion __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator !=(global::Acid.Sharp.Quaternion __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Quaternion operator -(global::Acid.Sharp.Quaternion __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Quaternion(global::Acid.Sharp.Matrix4 source)
        {
            return new global::Acid.Sharp.Quaternion(source);
        }

        public static global::Acid.Sharp.Quaternion operator +(global::Acid.Sharp.Quaternion left, global::Acid.Sharp.Quaternion right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Quaternion operator -(global::Acid.Sharp.Quaternion left, global::Acid.Sharp.Quaternion right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Quaternion operator *(global::Acid.Sharp.Quaternion left, global::Acid.Sharp.Quaternion right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 operator *(global::Acid.Sharp.Quaternion left, global::Acid.Sharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Quaternion operator *(float left, global::Acid.Sharp.Quaternion right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Quaternion operator *(global::Acid.Sharp.Quaternion left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Quaternion.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Quaternion Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Quaternion@acid@@2V12@B");
                return global::Acid.Sharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Quaternion One
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Quaternion@acid@@2V12@B");
                return global::Acid.Sharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Quaternion WOne
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?W_ONE@Quaternion@acid@@2V12@B");
                return global::Acid.Sharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Quaternion PositiveInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Quaternion@acid@@2V12@B");
                return global::Acid.Sharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Quaternion NegativeInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Quaternion.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Quaternion@acid@@2V12@B");
                return global::Acid.Sharp.Quaternion.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return *__ret;
            }

            set
            {
                var __arg0 = &index;
                *global::Acid.Sharp.Quaternion.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetY((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Z
        {
            get
            {
                var __ret = __Internal.GetZ((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetZ((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float W
        {
            get
            {
                var __ret = __Internal.GetW((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetW((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the length squared of this quaternion.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this quaternion.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this quaternion.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this quaternion.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class JointTransformData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_jointNameId;

            [FieldOffset(32)]
            internal global::Acid.Sharp.Matrix4.__Internal m_jointLocalTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransformData@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr jointNameId, global::System.IntPtr jointLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransformData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointTransformData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointNameId@JointTransformData@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetJointNameId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointLocalTransform@JointTransformData@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetJointLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JointTransformData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JointTransformData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.JointTransformData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JointTransformData(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.JointTransformData __CreateInstance(global::Acid.Sharp.JointTransformData.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JointTransformData(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.JointTransformData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransformData.__Internal));
            global::Acid.Sharp.JointTransformData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointTransformData(global::Acid.Sharp.JointTransformData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointTransformData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JointTransformData(string jointNameId, global::Acid.Sharp.Matrix4 jointLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransformData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(jointNameId, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(jointLocalTransform, null))
                throw new global::System.ArgumentNullException("jointLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = jointLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public JointTransformData(global::Acid.Sharp.JointTransformData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransformData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.JointTransformData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string JointNameId
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetJointNameId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::Acid.Sharp.Matrix4 JointLocalTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetJointLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents the local bone-space transform of a joint at a certain keyframe during an animation. This includes the position and rotation of the joint, relative to the parent joint (or relative to the model's origin if it's the root joint). The transform is stored as a position vector and a quaternion (rotation) so that these values can  be easily interpolated, a functionality that this class also provides.</summary>
    public unsafe partial class JointTransform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal global::Acid.Sharp.Quaternion.__Internal m_rotation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBVVector3@1@AEBVQuaternion@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBVJointTransformData@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointTransform@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@acid@@SA?AV12@AEBV12@0AEBM@Z")]
            internal static extern void Interpolate(global::System.IntPtr @return, global::System.IntPtr frameA, global::System.IntPtr frameB, float* progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@JointTransform@acid@@SA?AVVector3@2@AEBV32@0AEBM@Z")]
            internal static extern void Interpolate_1(global::System.IntPtr @return, global::System.IntPtr start, global::System.IntPtr end, float* progression);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@JointTransform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@JointTransform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@JointTransform@acid@@QEBA?AVQuaternion@2@XZ")]
            internal static extern void GetRotation(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRotation@JointTransform@acid@@QEAAXAEBVQuaternion@2@@Z")]
            internal static extern void SetRotation(global::System.IntPtr instance, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalTransform@JointTransform@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JointTransform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JointTransform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.JointTransform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JointTransform(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.JointTransform __CreateInstance(global::Acid.Sharp.JointTransform.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JointTransform(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.JointTransform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransform.__Internal));
            global::Acid.Sharp.JointTransform.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointTransform(global::Acid.Sharp.JointTransform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointTransform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="position">The position of the joint relative to the parent joint (local-space) at a certain keyframe.</param>
        /// <param name="rotation">The rotation of the joint relative to te parent joint (local-space) at a certain keyframe.</param>
        public JointTransform(global::Acid.Sharp.Vector3 position, global::Acid.Sharp.Quaternion rotation)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Creates a new joint transformation.</summary>
        /// <param name="localTransform">The joint's local-transform at a certain keyframe of an animation.</param>
        public JointTransform(global::Acid.Sharp.Matrix4 localTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public JointTransform(global::Acid.Sharp.JointTransformData data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public JointTransform(global::Acid.Sharp.JointTransform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointTransform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.JointTransform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static explicit operator global::Acid.Sharp.JointTransform(global::Acid.Sharp.Matrix4 localTransform)
        {
            return new global::Acid.Sharp.JointTransform(localTransform);
        }

        public static explicit operator global::Acid.Sharp.JointTransform(global::Acid.Sharp.JointTransformData data)
        {
            return new global::Acid.Sharp.JointTransform(data);
        }

        /// <summary>Interpolates between two transforms based on the progression value. The result is a new transform which is part way between the two original transforms. The translation can simply be linearly interpolated, but the rotation interpolation is slightly more complex, using a method called &quot;SLERP&quot; to spherically-linearly interpolate between 2 quaternions (rotations). This gives a much much better result than trying to linearly interpolate between Euler rotations.</summary>
        /// <param name="frameA">The previous transform</param>
        /// <param name="frameB">The next transform</param>
        /// <param name="progression">A number between 0 and 1 indicating how far between the two transforms to interpolate. A progression value of 0 would return a transform equal to &quot;frameA&quot;, a value of 1 would return a transform equal to &quot;frameB&quot;. Everything else gives a transform somewhere in-between the two.</param>
        public static global::Acid.Sharp.JointTransform Interpolate(global::Acid.Sharp.JointTransform frameA, global::Acid.Sharp.JointTransform frameB, float progression)
        {
            if (ReferenceEquals(frameA, null))
                throw new global::System.ArgumentNullException("frameA", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frameA.__Instance;
            if (ReferenceEquals(frameB, null))
                throw new global::System.ArgumentNullException("frameB", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = frameB.__Instance;
            var __arg2 = &progression;
            var __ret = new global::Acid.Sharp.JointTransform.__Internal();
            __Internal.Interpolate(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Acid.Sharp.JointTransform.__CreateInstance(__ret);
        }

        /// <summary>Linearly interpolates between two translations based on a &quot;progression&quot; value.</summary>
        /// <param name="start">The start translation.</param>
        /// <param name="end">The end translation.</param>
        /// <param name="progression">A value between 0 and 1 indicating how far to interpolate between the two translations.</param>
        public static global::Acid.Sharp.Vector3 Interpolate(global::Acid.Sharp.Vector3 start, global::Acid.Sharp.Vector3 end, float progression)
        {
            if (ReferenceEquals(start, null))
                throw new global::System.ArgumentNullException("start", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = start.__Instance;
            if (ReferenceEquals(end, null))
                throw new global::System.ArgumentNullException("end", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = end.__Instance;
            var __arg2 = &progression;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Interpolate_1(new IntPtr(&__ret), __arg0, __arg1, __arg2);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Quaternion Rotation
        {
            get
            {
                var __ret = new global::Acid.Sharp.Quaternion.__Internal();
                __Internal.GetRotation((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>In this method the local-space transform matrix is constructed by translating an identity matrix using the position variable and then applying the rotation. The rotation is applied by first converting the quaternion into a rotation matrix, which is then multiplied with the transform matrix.</summary>
        public global::Acid.Sharp.Matrix4 LocalTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class KeyframeData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_time;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_JointTransformData___N_std_S_allocator__S0_ m_jointTransforms;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0KeyframeData@acid@@QEAA@AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0KeyframeData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1KeyframeData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddJointTransform@KeyframeData@acid@@QEAAXAEBVJointTransformData@2@@Z")]
            internal static extern void AddJointTransform(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@KeyframeData@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetTime(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.KeyframeData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.KeyframeData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.KeyframeData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.KeyframeData(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.KeyframeData __CreateInstance(global::Acid.Sharp.KeyframeData.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.KeyframeData(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.KeyframeData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.KeyframeData.__Internal));
            global::Acid.Sharp.KeyframeData.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private KeyframeData(global::Acid.Sharp.KeyframeData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected KeyframeData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public KeyframeData(global::Acid.Sharp.Time time)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.KeyframeData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(time, null))
                throw new global::System.ArgumentNullException("time", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = time.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public KeyframeData(global::Acid.Sharp.KeyframeData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.KeyframeData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.KeyframeData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddJointTransform(global::Acid.Sharp.JointTransformData transform)
        {
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            __Internal.AddJointTransform((__Instance + __PointerAdjustment), __arg0);
        }

        public static explicit operator global::Acid.Sharp.KeyframeData(global::Acid.Sharp.Time time)
        {
            return new global::Acid.Sharp.KeyframeData(time);
        }

        public global::Acid.Sharp.Time Time
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTime((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents one keyframe of an animation. This contains the timestamp of the keyframe, which is the time (in seconds) from the start of the animation when this keyframe occurs.  It also contains the desired local-space transforms of all of the joints in the animated entity at this keyframe in the animation. The joint transforms are stored in a map, indexed by the name of the joint that they should be applied to.</summary>
    public unsafe partial class Keyframe : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_timeStamp;

            [FieldOffset(8)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_JointTransform___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_pose;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyframe@acid@@QEAA@AEBVKeyframeData@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyframe@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Keyframe@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeStamp@Keyframe@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetTimeStamp(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Keyframe> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Keyframe>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Keyframe __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Keyframe(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Keyframe __CreateInstance(global::Acid.Sharp.Keyframe.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Keyframe(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Keyframe.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Keyframe.__Internal));
            global::Acid.Sharp.Keyframe.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Keyframe(global::Acid.Sharp.Keyframe.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Keyframe(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new keyframe at a timestamp.</summary>
        /// <param name="data">The data to load the keyframe from.</param>
        public Keyframe(global::Acid.Sharp.KeyframeData data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Keyframe.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(data, null))
                throw new global::System.ArgumentNullException("data", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = data.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Keyframe(global::Acid.Sharp.Keyframe _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Keyframe.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Keyframe __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static explicit operator global::Acid.Sharp.Keyframe(global::Acid.Sharp.KeyframeData data)
        {
            return new global::Acid.Sharp.Keyframe(data);
        }

        /// <summary>Gets the time in seconds of the keyframe in the animation.</summary>
        public global::Acid.Sharp.Time TimeStamp
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTimeStamp((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents an animation that can be carried out by an animated entity. It contains the length of the animation in seconds, and a list of s.</summary>
    public unsafe partial class Animation : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Keyframe___N_std_S_allocator__S0_ m_keyframes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animation@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Animation@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@Animation@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetLength(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Animation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Animation>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Animation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Animation(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Animation __CreateInstance(global::Acid.Sharp.Animation.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Animation(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Animation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Animation.__Internal));
            global::Acid.Sharp.Animation.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Animation(global::Acid.Sharp.Animation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Animation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Animation(global::Acid.Sharp.Animation _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Animation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Animation __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the length of the animation.</summary>
        public global::Acid.Sharp.Time Length
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetLength((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class AnimationLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_libraryAnimations;

            [FieldOffset(8)]
            internal global::System.IntPtr m_libraryVisualScenes;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_lengthSeconds;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_KeyframeData___N_std_S_allocator__S0_ m_keyframeData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AnimationLoader@acid@@QEAA@PEAVMetadata@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr libraryAnimations, global::System.IntPtr libraryVisualScenes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AnimationLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AnimationLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLengthSeconds@AnimationLoader@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetLengthSeconds(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.AnimationLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.AnimationLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.AnimationLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AnimationLoader(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.AnimationLoader __CreateInstance(global::Acid.Sharp.AnimationLoader.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AnimationLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.AnimationLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AnimationLoader.__Internal));
            global::Acid.Sharp.AnimationLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AnimationLoader(global::Acid.Sharp.AnimationLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AnimationLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AnimationLoader(global::Acid.Sharp.Metadata libraryAnimations, global::Acid.Sharp.Metadata libraryVisualScenes)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AnimationLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(libraryAnimations, null) ? global::System.IntPtr.Zero : libraryAnimations.__Instance;
            var __arg1 = ReferenceEquals(libraryVisualScenes, null) ? global::System.IntPtr.Zero : libraryVisualScenes.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public AnimationLoader(global::Acid.Sharp.AnimationLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AnimationLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.AnimationLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.Time LengthSeconds
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetLengthSeconds((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a joint in a &quot;skeleton&quot;. It contains the index of the joint which determines where in the vertex shader uniform array the joint matrix for this joint is loaded up to. It also contains the name of the bone, and a list of all the child joints.  The &quot;animatedTransform&quot; matrix is the joint transform. This is the transform that gets loaded up to the vertex shader and is used to transform vertices. It is a model-space transform that transforms the joint from it's bind (original position, no animation applied) position to it's current position in the current pose. Changing this transform changes the position/rotation of the joint in the animated entity.  The two other matrices are transforms that are required to calculate the &quot;animatedTransform&quot; in the  class. It also has the local bind transform which is the original (no pose/animation applied) transform of the joint relative to the parent joint (in bone-space).  The &quot;localBindTransform&quot; is the original (bind) transform of the joint relative to its parent (in bone-space). The inverseBindTransform is that bind transform in model-space, but inversed.</summary>
    public unsafe partial class Joint : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 256)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_index;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Joint___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(64)]
            internal global::Acid.Sharp.Matrix4.__Internal m_localBindTransform;

            [FieldOffset(128)]
            internal global::Acid.Sharp.Matrix4.__Internal m_animatedTransform;

            [FieldOffset(192)]
            internal global::Acid.Sharp.Matrix4.__Internal m_inverseBindTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@acid@@QEAA@AEBIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint* index, global::System.IntPtr name, global::System.IntPtr bindLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joint@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joint@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateInverseBindTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void CalculateInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr parentBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@Joint@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@Joint@acid@@QEBAIXZ")]
            internal static extern uint GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIndex@Joint@acid@@QEAAXAEBI@Z")]
            internal static extern void SetIndex(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Joint@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@Joint@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalBindTransform@Joint@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetLocalBindTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLocalBindTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetLocalBindTransform(global::System.IntPtr instance, global::System.IntPtr localBindTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAnimatedTransform@Joint@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetAnimatedTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAnimatedTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetAnimatedTransform(global::System.IntPtr instance, global::System.IntPtr animatedTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInverseBindTransform@Joint@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInverseBindTransform@Joint@acid@@QEAAXAEBVMatrix4@2@@Z")]
            internal static extern void SetInverseBindTransform(global::System.IntPtr instance, global::System.IntPtr inverseBindTransform);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Joint> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Joint>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Joint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Joint(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Joint __CreateInstance(global::Acid.Sharp.Joint.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Joint(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Joint.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joint.__Internal));
            global::Acid.Sharp.Joint.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joint(global::Acid.Sharp.Joint.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new skeleton joint.</summary>
        /// <param name="index">The joint's index (ID).</param>
        /// <param name="name">The name of the joint. This is how the joint is named in the collada file, and so is used to identify which joint a joint transform in an animation keyframe refers to.</param>
        /// <param name="bindLocalTransform">The bone-space transform of the joint in the bind position.</param>
        public Joint(uint index, string name, global::Acid.Sharp.Matrix4 bindLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &index;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(bindLocalTransform, null))
                throw new global::System.ArgumentNullException("bindLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = bindLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public Joint(global::Acid.Sharp.Joint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Joint __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>This is called during set-up, after the joints hierarchy has been created. This calculates the model-space bind transform of this joint like so:</para>
        /// <para></para>
        /// <para></para>
        /// <para>{</para>
        /// </summary>
        public void CalculateInverseBindTransform(global::Acid.Sharp.Matrix4 parentBindTransform)
        {
            if (ReferenceEquals(parentBindTransform, null))
                throw new global::System.ArgumentNullException("parentBindTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = parentBindTransform.__Instance;
            __Internal.CalculateInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Adds a child joint to this joint. Used during the creation of the joint hierarchy. Joints can have multiple children, which is why they are stored in a list (e.g. a &quot;hand&quot; joint may have multiple &quot;finger&quot; children joints).</summary>
        /// <param name="child">The new child joint of this joint.</param>
        public void AddChild(global::Acid.Sharp.Joint child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public uint Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetIndex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::Acid.Sharp.Matrix4 LocalBindTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetLocalBindTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLocalBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>The animated transform is the transform that gets loaded up to the shader and is used to deform the vertices of the &quot;skin&quot;. It represents the transformation from the joint's bind position (in model-space) to the joint's desired animation pose (also in model-space). This matrix is calculated by taking the desired model-space transform of the joint and multiplying it by the inverse of the starting model-space transform of the joint.</summary>
        public global::Acid.Sharp.Matrix4 AnimatedTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetAnimatedTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAnimatedTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>This returns the inverted model-space bind transform. The bind transform is the original model-space transform of the joint (when no animation is applied). This returns the inverse of that, which is used to calculate the animated transform matrix which gets used to transform vertices in the shader.</summary>
        public global::Acid.Sharp.Matrix4 InverseBindTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetInverseBindTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetInverseBindTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>This class contains all the functionality to apply an animation to an animated entity. An Animator instance is associated with just one animated entity. It also keeps track of the running time (in seconds) of the current animation, along with a reference to the currently playing animation for the corresponding entity.  An Animator instance needs to be updated every frame, in order for it to keep updating the animation pose of the associated entity. The currently playing animation can be changed at any time using the doAnimation() method. The Animator will keep looping the current animation until a new animation is chosen.  The Animator calculates the desired current animation pose by interpolating between the previous and next keyframes of the animation (based on the current animation time). The Animator then updates the transforms all of the joints each frame to match the current desired animation pose.</summary>
    public unsafe partial class Animator : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_rootJoint;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_animationTime;

            [FieldOffset(16)]
            internal global::System.IntPtr m_currentAnimation;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animator@acid@@QEAA@PEAVJoint@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr rootJoint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Animator@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Animator@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IncreaseAnimationTime@Animator@acid@@QEAAXXZ")]
            internal static extern void IncreaseAnimationTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateProgression@Animator@acid@@QEAAMAEBVKeyframe@2@0@Z")]
            internal static extern float CalculateProgression(global::System.IntPtr instance, global::System.IntPtr previousFrame, global::System.IntPtr nextFrame);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DoAnimation@Animator@acid@@QEAAXPEAVAnimation@2@@Z")]
            internal static extern void DoAnimation(global::System.IntPtr instance, global::System.IntPtr animation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentAnimation@Animator@acid@@QEBAPEAVAnimation@2@XZ")]
            internal static extern global::System.IntPtr GetCurrentAnimation(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Animator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Animator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Animator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Animator(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Animator __CreateInstance(global::Acid.Sharp.Animator.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Animator(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Animator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Animator.__Internal));
            *(global::Acid.Sharp.Animator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Animator(global::Acid.Sharp.Animator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Animator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new animator.</summary>
        /// <param name="rootJoint">The root joint of the joint hierarchy which makes up the &quot;skeleton&quot; of the entity.</param>
        public Animator(global::Acid.Sharp.Joint rootJoint)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Animator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(rootJoint, null) ? global::System.IntPtr.Zero : rootJoint.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Animator(global::Acid.Sharp.Animator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Animator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Animator.__Internal*) __Instance) = *((global::Acid.Sharp.Animator.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Animator __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>This method should be called each frame to update the animation currently being played. This increases the animation time (and loops it back to zero if necessary), finds the pose that the entity should be in at that time of the animation, and then applied that pose to all the entity's joints.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        /// <summary>Increases the current animation time which allows the animation to progress. If the current animation has reached the end then the timer is reset, causing the animation to loop.</summary>
        public void IncreaseAnimationTime()
        {
            __Internal.IncreaseAnimationTime((__Instance + __PointerAdjustment));
        }

        /// <summary>Calculates how far between the previous and next keyframe the current animation time is, and returns it as a value between 0 and 1.</summary>
        /// <param name="previousFrame">The previous keyframe in the animation.</param>
        /// <param name="nextFrame">The next keyframe in the animation.</param>
        public float CalculateProgression(global::Acid.Sharp.Keyframe previousFrame, global::Acid.Sharp.Keyframe nextFrame)
        {
            if (ReferenceEquals(previousFrame, null))
                throw new global::System.ArgumentNullException("previousFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = previousFrame.__Instance;
            if (ReferenceEquals(nextFrame, null))
                throw new global::System.ArgumentNullException("nextFrame", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = nextFrame.__Instance;
            var __ret = __Internal.CalculateProgression((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Indicates that the entity should carry out the given animation. Resets the animation time so that the new animation starts from the beginning.</summary>
        /// <param name="animation">The new animation to carry out.</param>
        public void DoAnimation(global::Acid.Sharp.Animation animation)
        {
            var __arg0 = ReferenceEquals(animation, null) ? global::System.IntPtr.Zero : animation.__Instance;
            __Internal.DoAnimation((__Instance + __PointerAdjustment), __arg0);
        }

        public static explicit operator global::Acid.Sharp.Animator(global::Acid.Sharp.Joint rootJoint)
        {
            return new global::Acid.Sharp.Animator(rootJoint);
        }

        public global::Acid.Sharp.Animation CurrentAnimation
        {
            get
            {
                var __ret = __Internal.GetCurrentAnimation((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Animation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Animation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Animation) global::Acid.Sharp.Animation.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Animation.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class CommandBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::VkQueueFlagBits m_queueType;

            [FieldOffset(4)]
            internal global::VkCommandBufferLevel m_bufferLevel;

            [FieldOffset(8)]
            internal global::System.IntPtr m_commandBuffer;

            [FieldOffset(16)]
            internal byte m_running;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CommandBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1CommandBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Begin@CommandBuffer@acid@@QEAAXAEBI@Z")]
            internal static extern void Begin(global::System.IntPtr instance, uint* usage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?End@CommandBuffer@acid@@QEAAXXZ")]
            internal static extern void End(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@CommandBuffer@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRunning(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.CommandBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.CommandBuffer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.CommandBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.CommandBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.CommandBuffer __CreateInstance(global::Acid.Sharp.CommandBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.CommandBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.CommandBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.CommandBuffer.__Internal));
            *(global::Acid.Sharp.CommandBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CommandBuffer(global::Acid.Sharp.CommandBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CommandBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public CommandBuffer(global::Acid.Sharp.CommandBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.CommandBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.CommandBuffer.__Internal*) __Instance) = *((global::Acid.Sharp.CommandBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.CommandBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Begin(uint usage)
        {
            var __arg0 = &usage;
            __Internal.Begin((__Instance + __PointerAdjustment), __arg0);
        }

        public void End()
        {
            __Internal.End((__Instance + __PointerAdjustment));
        }

        public bool Running
        {
            get
            {
                var __ret = __Internal.GetRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A logging class used in Acid, will write output to a file one the application has closed.</summary>
    public unsafe partial class Log : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Log@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Out@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Out(global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Error@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Error(global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateLog@Log@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void CreateLog(global::System.IntPtr filename);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Log(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Log __CreateInstance(global::Acid.Sharp.Log.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Log.__Internal));
            *(global::Acid.Sharp.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::Acid.Sharp.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Log()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Log.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Log(global::Acid.Sharp.Log _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Log.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Log.__Internal*) __Instance) = *((global::Acid.Sharp.Log.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Log __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Outputs a message into the console.</summary>
        /// <param name="string">The string to output.</param>
        public static void Out(string @string)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(@string, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.Out(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Outputs a error into the console.</summary>
        /// <param name="string">The string to output.</param>
        public static void Error(string @string)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(@string, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.Error(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Outputs all logs into a file.</summary>
        /// <param name="filename">The filename to output into.</param>
        public static void CreateLog(string filename)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.CreateLog(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents when a module will update in the game loop.</summary>
    public enum ModuleUpdate
    {
        Always = 0,
        Pre = 1,
        Normal = 2,
        Post = 3,
        Render = 4
    }

    /// <summary>A interface used for defining engine modules.</summary>
    public unsafe abstract partial class IModule : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IModule@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IModule> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IModule>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IModule __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IModuleInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IModule __CreateInstance(global::Acid.Sharp.IModule.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IModuleInternal(native, skipVTables);
        }

        protected IModule(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IModule()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IModule");
        }

        protected IModule(global::Acid.Sharp.IModule _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IModule");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IModule.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the module.</summary>
        public abstract void Update();

        #region Virtual table interop

        // void Update() = 0
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IModule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IModuleInternal : global::Acid.Sharp.IModule, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IModule.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IModule.__Internal));
            *(global::Acid.Sharp.IModule.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IModuleInternal(global::Acid.Sharp.IModule.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IModuleInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>The update function for the module.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that contains and manages modules registered to a engine.</summary>
    public unsafe partial class ModuleRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map__f___N_std_S_unique_ptr____N_acid_S_IModule___N_std_S_default_delete__S1____N_std_S_less__f___N_std_S_allocator____N_std_S_pair__1f_S0_ m_modules;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleRegister@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModuleRegister@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FillRegister@ModuleRegister@acid@@QEAAXXZ")]
            internal static extern void FillRegister(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ContainsModule@ModuleRegister@acid@@QEBA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ContainsModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@ModuleRegister@acid@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::Acid.Sharp.ModuleUpdate* update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@ModuleRegister@acid@@QEAA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RunUpdate@ModuleRegister@acid@@QEBAXAEBW4ModuleUpdate@2@@Z")]
            internal static extern void RunUpdate(global::System.IntPtr instance, global::Acid.Sharp.ModuleUpdate* update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModuleCount@ModuleRegister@acid@@QEBAIXZ")]
            internal static extern uint GetModuleCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ModuleRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleRegister(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModuleRegister __CreateInstance(global::Acid.Sharp.ModuleRegister.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModuleRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleRegister.__Internal));
            global::Acid.Sharp.ModuleRegister.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModuleRegister(global::Acid.Sharp.ModuleRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleRegister(global::Acid.Sharp.ModuleRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ModuleRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Fills the module register with default modules.</summary>
        public void FillRegister()
        {
            __Internal.FillRegister((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if a module is contained in this registry.</summary>
        /// <param name="module">The module to find.</param>
        public bool ContainsModule(global::Acid.Sharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.ContainsModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        public global::Acid.Sharp.IModule RegisterModule(global::Acid.Sharp.IModule module, global::Acid.Sharp.ModuleUpdate* update)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update);
            global::Acid.Sharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IModule) global::Acid.Sharp.IModule.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="module">The module to deregister.</param>
        public bool DeregisterModule(global::Acid.Sharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Runs updates for all module update types.</summary>
        /// <param name="update">The modules update type.</param>
        public void RunUpdate(global::Acid.Sharp.ModuleUpdate* update)
        {
            __Internal.RunUpdate((__Instance + __PointerAdjustment), update);
        }

        public uint ModuleCount
        {
            get
            {
                var __ret = __Internal.GetModuleCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class for handing and calculating deltas.</summary>
    public unsafe partial class Delta : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_currentFrameTime;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_lastFrameTime;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_change;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_time;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Delta@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Delta@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChange@Delta@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetChange(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Delta@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetTime(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Delta> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Delta>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Delta __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Delta(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Delta __CreateInstance(global::Acid.Sharp.Delta.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Delta(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Delta.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Delta.__Internal));
            *(global::Acid.Sharp.Delta.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Delta(global::Acid.Sharp.Delta.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Delta(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new change handler.</summary>
        public Delta()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Delta(global::Acid.Sharp.Delta _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Delta.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Delta.__Internal*) __Instance) = *((global::Acid.Sharp.Delta.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Delta __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates change and times.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.Time Change
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetChange((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Time Time
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTime((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A timer implementation for events.</summary>
    public unsafe partial class Timer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_startTime;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_interval;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@acid@@QEAA@AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Timer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ResetStartTime@Timer@acid@@QEAAXXZ")]
            internal static extern void ResetStartTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterval@Timer@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetInterval(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInterval@Timer@acid@@QEAAXAEBVTime@2@@Z")]
            internal static extern void SetInterval(global::System.IntPtr instance, global::System.IntPtr interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPassedTime@Timer@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetPassedTime(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Timer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Timer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Timer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Timer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Timer __CreateInstance(global::Acid.Sharp.Timer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Timer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Timer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Timer.__Internal));
            *(global::Acid.Sharp.Timer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Timer(global::Acid.Sharp.Timer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Timer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new timer.</summary>
        /// <param name="interval">The time between events.</param>
        public Timer(global::Acid.Sharp.Time interval)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(interval, null))
                throw new global::System.ArgumentNullException("interval", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = interval.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Timer(global::Acid.Sharp.Timer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Timer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Timer.__Internal*) __Instance) = *((global::Acid.Sharp.Timer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Timer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds the intervals value to the start time.</summary>
        public void ResetStartTime()
        {
            __Internal.ResetStartTime((__Instance + __PointerAdjustment));
        }

        public static explicit operator global::Acid.Sharp.Timer(global::Acid.Sharp.Time interval)
        {
            return new global::Acid.Sharp.Timer(interval);
        }

        /// <summary>Gets what the interval is.</summary>
        /// <param name="interval">The new timer interval.</param>
        /// <remarks>Gets the timers interval (resets timer).</remarks>
        public global::Acid.Sharp.Time Interval
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetInterval((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetInterval((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets if the interval has been passes for the timer.</summary>
        public bool PassedTime
        {
            get
            {
                var __ret = __Internal.GetPassedTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class used to define how the engine will run updates and timings on modules.</summary>
    public unsafe partial class ModuleUpdater : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Delta.__Internal m_deltaUpdate;

            [FieldOffset(32)]
            internal global::Acid.Sharp.Delta.__Internal m_deltaRender;

            [FieldOffset(64)]
            internal global::Acid.Sharp.Timer.__Internal m_timerUpdate;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Timer.__Internal m_timerRender;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleUpdater@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModuleUpdater@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ModuleUpdater@acid@@QEAAXAEBVModuleRegister@2@@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr moduleRegister);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@ModuleUpdater@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDelta(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@ModuleUpdater@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDeltaRender(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleUpdater> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ModuleUpdater>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ModuleUpdater __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleUpdater(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModuleUpdater __CreateInstance(global::Acid.Sharp.ModuleUpdater.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModuleUpdater(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModuleUpdater.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleUpdater.__Internal));
            *(global::Acid.Sharp.ModuleUpdater.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ModuleUpdater(global::Acid.Sharp.ModuleUpdater.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModuleUpdater(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ModuleUpdater()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ModuleUpdater(global::Acid.Sharp.ModuleUpdater _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModuleUpdater.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.ModuleUpdater.__Internal*) __Instance) = *((global::Acid.Sharp.ModuleUpdater.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ModuleUpdater __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates all modules in order.</summary>
        public void Update(global::Acid.Sharp.ModuleRegister moduleRegister)
        {
            if (ReferenceEquals(moduleRegister, null))
                throw new global::System.ArgumentNullException("moduleRegister", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = moduleRegister.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public global::Acid.Sharp.Time Delta
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDelta((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public global::Acid.Sharp.Time DeltaRender
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDeltaRender((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Main class for Acid, manages modules and updates. After creating your Engine object call  to start.</summary>
    public unsafe partial class Engine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Time.__Internal m_timeOffset;

            [FieldOffset(8)]
            internal global::Acid.Sharp.ModuleRegister.__Internal m_moduleRegister;

            [FieldOffset(24)]
            internal global::Acid.Sharp.ModuleUpdater.__Internal m_moduleUpdater;

            [FieldOffset(120)]
            internal float m_fpsLimit;

            [FieldOffset(124)]
            internal byte m_initialized;

            [FieldOffset(125)]
            internal byte m_running;

            [FieldOffset(126)]
            internal byte m_error;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@acid@@QEAA@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool* emptyRegister);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Engine@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Engine@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Engine@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Run@Engine@acid@@QEAAHXZ")]
            internal static extern int Run(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RegisterModule@Engine@acid@@QEAAPEAVIModule@2@PEAV32@AEBW4ModuleUpdate@2@@Z")]
            internal static extern global::System.IntPtr RegisterModule(global::System.IntPtr instance, global::System.IntPtr module, global::Acid.Sharp.ModuleUpdate* update);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterModule@Engine@acid@@QEAA_NPEAVIModule@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterModule(global::System.IntPtr instance, global::System.IntPtr module);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RequestClose@Engine@acid@@QEAAXAEB_N@Z")]
            internal static extern void RequestClose(global::System.IntPtr instance, bool* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeOffset@Engine@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetTimeOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeOffset@Engine@acid@@QEAAXAEBVTime@2@@Z")]
            internal static extern void SetTimeOffset(global::System.IntPtr instance, global::System.IntPtr timeOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFpsLimit@Engine@acid@@QEBAMXZ")]
            internal static extern float GetFpsLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFpsLimit@Engine@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFpsLimit(global::System.IntPtr instance, float* fpsLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInitialized@Engine@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetInitialized(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInitialized@Engine@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetInitialized(global::System.IntPtr instance, bool* initialized);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelta@Engine@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDelta(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaRender@Engine@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetDeltaRender(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTime@Engine@acid@@SA?AVTime@2@XZ")]
            internal static extern void GetTime(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRunning@Engine@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRunning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDateTime@Engine@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetDateTime(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Engine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Engine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Engine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Engine(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Engine __CreateInstance(global::Acid.Sharp.Engine.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Engine(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Engine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Engine.__Internal));
            global::Acid.Sharp.Engine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Engine(global::Acid.Sharp.Engine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Engine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Carries out the setup for basic engine components and the engine. Call  after creating a instance.</summary>
        /// <param name="emptyRegister">If the module register will start empty.</param>
        public Engine(bool emptyRegister)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &emptyRegister;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Engine(global::Acid.Sharp.Engine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Engine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Engine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The update function for the updater.</summary>
        public int Run()
        {
            var __ret = __Internal.Run((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Registers a module with the register.</summary>
        /// <param name="module">The modules object.</param>
        /// <param name="update">The modules update type.</param>
        public global::Acid.Sharp.IModule RegisterModule(global::Acid.Sharp.IModule module, global::Acid.Sharp.ModuleUpdate* update)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.RegisterModule((__Instance + __PointerAdjustment), __arg0, update);
            global::Acid.Sharp.IModule __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IModule.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IModule) global::Acid.Sharp.IModule.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IModule.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deregisters a module.</summary>
        /// <param name="module">The module to deregister.</param>
        public bool DeregisterModule(global::Acid.Sharp.IModule module)
        {
            var __arg0 = ReferenceEquals(module, null) ? global::System.IntPtr.Zero : module.__Instance;
            var __ret = __Internal.DeregisterModule((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Requests the engine to delete and stop the game-loop.</summary>
        /// <param name="error">If a bad error occurred.</param>
        public void RequestClose(bool error)
        {
            var __arg0 = &error;
            __Internal.RequestClose((__Instance + __PointerAdjustment), __arg0);
        }

        public static explicit operator global::Acid.Sharp.Engine(bool emptyRegister)
        {
            return new global::Acid.Sharp.Engine(ref *emptyRegister);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Engine Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Engine __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Engine.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Engine) global::Acid.Sharp.Engine.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Engine.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the added/removed time for the engine.</summary>
        /// <param name="timeOffset">The new time offset.</param>
        /// <remarks>Sets the time offset for the engine.</remarks>
        public global::Acid.Sharp.Time TimeOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTimeOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTimeOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the fps limit.</summary>
        /// <param name="fpsLimit">The new fps limit.</param>
        /// <remarks>Sets the fps limit. -1 disables limits.</remarks>
        public float FpsLimit
        {
            get
            {
                var __ret = __Internal.GetFpsLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFpsLimit((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets if the engine has been initialized.</summary>
        /// <param name="initialized">If the engine has been initialized.</param>
        /// <remarks>Sets if the engine has been initialized.</remarks>
        public bool Initialized
        {
            get
            {
                var __ret = __Internal.GetInitialized((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetInitialized((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the delta (seconds) between updates.</summary>
        public global::Acid.Sharp.Time Delta
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDelta((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the delta (seconds) between renders.</summary>
        public global::Acid.Sharp.Time DeltaRender
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetDeltaRender((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the current time of the engine instance.</summary>
        public static global::Acid.Sharp.Time Time
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTime(new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets if the engine is running.</summary>
        public bool Running
        {
            get
            {
                var __ret = __Internal.GetRunning((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the current date time as a string. &quot;%d-%m-%Y %I:%M:%S&quot;</summary>
        public static string DateTime
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetDateTime(new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for managing files on engine updates.</summary>
    public unsafe partial class Files : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Files@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Files@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Files@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBaseDirectory@Files@acid@@SAXPEBD@Z")]
            internal static extern void SetBaseDirectory([MarshalAs(UnmanagedType.LPStr)] string argv0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddSearchPath@Files@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void AddSearchPath(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveSearchPath@Files@acid@@SAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void RemoveSearchPath(global::System.IntPtr path);
        }

        internal static new global::Acid.Sharp.Files __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Files(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Files __CreateInstance(global::Acid.Sharp.Files.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Files(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Files.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Files.__Internal));
            global::Acid.Sharp.Files.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Files(global::Acid.Sharp.Files.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Files(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Files()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Files.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Files");
        }

        public Files(global::Acid.Sharp.Files _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Files.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Files");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Files Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Files __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Files.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Files) global::Acid.Sharp.Files.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Files.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Sets the base directory for the search path, called before any calls to .</summary>
        /// <param name="argv0">The first argument passed to mail.</param>
        public static void SetBaseDirectory(string argv0)
        {
            __Internal.SetBaseDirectory(argv0);
        }

        /// <summary>Adds an file search path, ensure  is called once before.</summary>
        /// <param name="path">The path to add.</param>
        public static void AddSearchPath(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.AddSearchPath(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Removes a file search path.</summary>
        /// <param name="path">The path to remove.</param>
        public static void RemoveSearchPath(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.RemoveSearchPath(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Files) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public enum PipelineMode
    {
        Polygon = 0,
        Mrt = 1,
        Compute = 2
    }

    public enum PipelineDepth
    {
        None = 0,
        ReadWrite = 1,
        Read = 2,
        Write = 3
    }

    /// <summary>A object that represents position in the renderpass/subpass structure.</summary>
    public unsafe partial class GraphicsStage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_renderpass;

            [FieldOffset(4)]
            internal uint m_subpass;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GraphicsStage@acid@@QEAA@AEBI0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint* renderpass, uint* subpass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GraphicsStage@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8GraphicsStage@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9GraphicsStage@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MGraphicsStage@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderpass@GraphicsStage@acid@@QEBAIXZ")]
            internal static extern uint GetRenderpass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubpass@GraphicsStage@acid@@QEBAIXZ")]
            internal static extern uint GetSubpass(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.GraphicsStage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.GraphicsStage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.GraphicsStage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.GraphicsStage(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.GraphicsStage __CreateInstance(global::Acid.Sharp.GraphicsStage.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.GraphicsStage(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.GraphicsStage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GraphicsStage.__Internal));
            *(global::Acid.Sharp.GraphicsStage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GraphicsStage(global::Acid.Sharp.GraphicsStage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GraphicsStage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new graphics stage.</summary>
        /// <param name="renderpass">The renderpass.</param>
        /// <param name="subpass">The subpass.</param>
        public GraphicsStage(uint renderpass, uint subpass)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GraphicsStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &renderpass;
            var __arg1 = &subpass;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public GraphicsStage(global::Acid.Sharp.GraphicsStage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GraphicsStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.GraphicsStage.__Internal*) __Instance) = *((global::Acid.Sharp.GraphicsStage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.GraphicsStage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::Acid.Sharp.GraphicsStage __op, global::Acid.Sharp.GraphicsStage other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.GraphicsStage;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.GraphicsStage.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.GraphicsStage __op, global::Acid.Sharp.GraphicsStage other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.GraphicsStage __op, global::Acid.Sharp.GraphicsStage other)
        {
            return !(__op < other);
        }

        public static bool operator <(global::Acid.Sharp.GraphicsStage __op, global::Acid.Sharp.GraphicsStage other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public uint Renderpass
        {
            get
            {
                var __ret = __Internal.GetRenderpass((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Subpass
        {
            get
            {
                var __ret = __Internal.GetSubpass((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class VertexInput : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputBindingDescription___N_std_S_allocator__S0_ m_bindingDescriptions;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputAttributeDescription___N_std_S_allocator__S0_ m_attributeDescriptions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexInput@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexInput@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVertexInput@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@VertexInput@acid@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexInput> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexInput>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.VertexInput __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexInput(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexInput __CreateInstance(global::Acid.Sharp.VertexInput.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexInput(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexInput.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexInput.__Internal));
            global::Acid.Sharp.VertexInput.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexInput(global::Acid.Sharp.VertexInput.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexInput(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexInput(global::Acid.Sharp.VertexInput _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexInput.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.VertexInput __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator >(global::Acid.Sharp.VertexInput __op, global::Acid.Sharp.VertexInput other)
        {
            return !(__op < other);
        }

        public static bool operator <(global::Acid.Sharp.VertexInput __op, global::Acid.Sharp.VertexInput other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class DescriptorType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(4)]
            internal uint m_stage;

            [FieldOffset(8)]
            internal global::VkDescriptorSetLayoutBinding.__Internal m_descriptorSetLayoutBinding;

            [FieldOffset(32)]
            internal global::VkDescriptorPoolSize.__Internal m_descriptorPoolSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorType@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@DescriptorType@acid@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStage@DescriptorType@acid@@QEBAIXZ")]
            internal static extern uint GetStage(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.DescriptorType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.DescriptorType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.DescriptorType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DescriptorType(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DescriptorType __CreateInstance(global::Acid.Sharp.DescriptorType.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DescriptorType(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DescriptorType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorType.__Internal));
            *(global::Acid.Sharp.DescriptorType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DescriptorType(global::Acid.Sharp.DescriptorType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorType(global::Acid.Sharp.DescriptorType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.DescriptorType.__Internal*) __Instance) = *((global::Acid.Sharp.DescriptorType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.DescriptorType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Stage
        {
            get
            {
                var __ret = __Internal.GetStage((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class PipelineDefine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineDefine@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineDefine@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineDefine@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@PipelineDefine@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@PipelineDefine@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PipelineDefine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PipelineDefine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.PipelineDefine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineDefine(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.PipelineDefine __CreateInstance(global::Acid.Sharp.PipelineDefine.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineDefine(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.PipelineDefine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineDefine.__Internal));
            global::Acid.Sharp.PipelineDefine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineDefine(global::Acid.Sharp.PipelineDefine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineDefine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PipelineDefine(string name, string value)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineDefine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public PipelineDefine(global::Acid.Sharp.PipelineDefine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineDefine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.PipelineDefine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }

    public unsafe partial class PipelineCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_shaderStages;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_VertexInput___N_std_S_allocator__S0_ m_vertexInputs;

            [FieldOffset(48)]
            internal global::Acid.Sharp.PipelineMode m_pipelineMode;

            [FieldOffset(52)]
            internal global::Acid.Sharp.PipelineDepth m_depthMode;

            [FieldOffset(56)]
            internal global::VkPolygonMode m_polygonMode;

            [FieldOffset(60)]
            internal uint m_cullMode;

            [FieldOffset(64)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_PipelineDefine___N_std_S_allocator__S0_ m_defines;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineCreate@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineCreate@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipelineMode@PipelineCreate@acid@@QEBA?AW4PipelineMode@2@XZ")]
            internal static extern global::Acid.Sharp.PipelineMode GetPipelineMode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipelineDepth@PipelineCreate@acid@@QEBA?AW4PipelineDepth@2@XZ")]
            internal static extern global::Acid.Sharp.PipelineDepth GetPipelineDepth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCullMode@PipelineCreate@acid@@QEBAIXZ")]
            internal static extern uint GetCullMode(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PipelineCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PipelineCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.PipelineCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineCreate(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.PipelineCreate __CreateInstance(global::Acid.Sharp.PipelineCreate.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.PipelineCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineCreate.__Internal));
            global::Acid.Sharp.PipelineCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineCreate(global::Acid.Sharp.PipelineCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PipelineCreate(global::Acid.Sharp.PipelineCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.PipelineCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.PipelineMode PipelineMode
        {
            get
            {
                var __ret = __Internal.GetPipelineMode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.PipelineDepth PipelineDepth
        {
            get
            {
                var __ret = __Internal.GetPipelineDepth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint CullMode
        {
            get
            {
                var __ret = __Internal.GetCullMode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class ComputeCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_shaderStage;

            [FieldOffset(32)]
            internal uint m_width;

            [FieldOffset(36)]
            internal uint m_height;

            [FieldOffset(40)]
            internal uint m_workgroupSize;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_PipelineDefine___N_std_S_allocator__S0_ m_defines;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComputeCreate@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ComputeCreate@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShaderStage@ComputeCreate@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetShaderStage(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@ComputeCreate@acid@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@ComputeCreate@acid@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorkgroupSize@ComputeCreate@acid@@QEBAIXZ")]
            internal static extern uint GetWorkgroupSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ComputeCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ComputeCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ComputeCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ComputeCreate(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ComputeCreate __CreateInstance(global::Acid.Sharp.ComputeCreate.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ComputeCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ComputeCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComputeCreate.__Internal));
            global::Acid.Sharp.ComputeCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ComputeCreate(global::Acid.Sharp.ComputeCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComputeCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ComputeCreate(global::Acid.Sharp.ComputeCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComputeCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ComputeCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string ShaderStage
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetShaderStage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint WorkgroupSize
        {
            get
            {
                var __ret = __Internal.GetWorkgroupSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Glslang
{
    public unsafe partial class TProgram
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Glslang.TProgram> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Glslang.TProgram>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Glslang.TProgram __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Glslang.TProgram(native.ToPointer(), skipVTables);
        }

        internal static global::Glslang.TProgram __CreateInstance(global::Glslang.TProgram.__Internal native, bool skipVTables = false)
        {
            return new global::Glslang.TProgram(native, skipVTables);
        }

        private static void* __CopyValue(global::Glslang.TProgram.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Glslang.TProgram.__Internal));
            *(global::Glslang.TProgram.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TProgram(global::Glslang.TProgram.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TProgram(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }
}

namespace Acid.Sharp
{
    public enum UniformBlockType
    {
        BlockUniform = 0,
        BlockStorage = 1,
        BlockPush = 2
    }

    public unsafe partial class Uniform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_binding;

            [FieldOffset(36)]
            internal int m_offset;

            [FieldOffset(40)]
            internal int m_size;

            [FieldOffset(44)]
            internal int m_glType;

            [FieldOffset(48)]
            internal byte m_readOnly;

            [FieldOffset(49)]
            internal byte m_writeOnly;

            [FieldOffset(52)]
            internal uint m_stageFlags;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uniform@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH111AEB_N2AEBI@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, int* binding, int* offset, int* size, int* glType, bool* readOnly, bool* writeOnly, uint* stageFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uniform@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Uniform@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Uniform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Uniform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Uniform@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStageFlags@Uniform@acid@@QEBAIXZ")]
            internal static extern uint GetStageFlags(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStageFlags@Uniform@acid@@QEAAXAEBI@Z")]
            internal static extern void SetStageFlags(global::System.IntPtr instance, uint* stageFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Uniform@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffset@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlType@Uniform@acid@@QEBAHXZ")]
            internal static extern int GetGlType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsReadOnly@Uniform@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetReadOnly(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsWriteOnly@Uniform@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetWriteOnly(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Uniform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Uniform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Uniform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Uniform(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Uniform __CreateInstance(global::Acid.Sharp.Uniform.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Uniform(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Uniform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Uniform.__Internal));
            global::Acid.Sharp.Uniform.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Uniform(global::Acid.Sharp.Uniform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Uniform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Uniform(string name, int binding, int offset, int size, int glType, bool readOnly, bool writeOnly, uint stageFlags)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Uniform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = &binding;
            var __arg2 = &offset;
            var __arg3 = &size;
            var __arg4 = &glType;
            var __arg5 = &readOnly;
            var __arg6 = &writeOnly;
            var __arg7 = &stageFlags;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public Uniform(global::Acid.Sharp.Uniform _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Uniform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Uniform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::Acid.Sharp.Uniform __op, global::Acid.Sharp.Uniform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Uniform;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Uniform.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Uniform __op, global::Acid.Sharp.Uniform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public uint StageFlags
        {
            get
            {
                var __ret = __Internal.GetStageFlags((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStageFlags((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public int Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Offset
        {
            get
            {
                var __ret = __Internal.GetOffset((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int GlType
        {
            get
            {
                var __ret = __Internal.GetGlType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool ReadOnly
        {
            get
            {
                var __ret = __Internal.GetReadOnly((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool WriteOnly
        {
            get
            {
                var __ret = __Internal.GetWriteOnly((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class UniformBlock : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_binding;

            [FieldOffset(36)]
            internal int m_size;

            [FieldOffset(40)]
            internal uint m_stageFlags;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UniformBlockType m_type;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Uniform___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_uniforms;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBlock@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH1AEBIAEBW4UniformBlockType@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, int* binding, int* size, uint* stageFlags, global::Acid.Sharp.UniformBlockType* type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBlock@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UniformBlock@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddUniform@UniformBlock@acid@@QEAAXPEAVUniform@2@@Z")]
            internal static extern void AddUniform(global::System.IntPtr instance, global::System.IntPtr uniform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniform@UniformBlock@acid@@QEAAPEAVUniform@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetUniform(global::System.IntPtr instance, global::System.IntPtr uniformName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@UniformBlock@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStageFlags@UniformBlock@acid@@QEBAIXZ")]
            internal static extern uint GetStageFlags(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStageFlags@UniformBlock@acid@@QEAAXAEBI@Z")]
            internal static extern void SetStageFlags(global::System.IntPtr instance, uint* stageFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@UniformBlock@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@UniformBlock@acid@@QEBAHXZ")]
            internal static extern int GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@UniformBlock@acid@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetType@UniformBlock@acid@@QEBA?AW4UniformBlockType@2@XZ")]
            internal static extern global::Acid.Sharp.UniformBlockType GetType(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UniformBlock> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UniformBlock>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.UniformBlock __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UniformBlock(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UniformBlock __CreateInstance(global::Acid.Sharp.UniformBlock.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UniformBlock(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UniformBlock.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformBlock.__Internal));
            global::Acid.Sharp.UniformBlock.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UniformBlock(global::Acid.Sharp.UniformBlock.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UniformBlock(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UniformBlock(string name, int binding, int size, uint stageFlags, global::Acid.Sharp.UniformBlockType* type)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformBlock.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = &binding;
            var __arg2 = &size;
            var __arg3 = &stageFlags;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, type);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public UniformBlock(global::Acid.Sharp.UniformBlock _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformBlock.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UniformBlock __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddUniform(global::Acid.Sharp.Uniform uniform)
        {
            var __arg0 = ReferenceEquals(uniform, null) ? global::System.IntPtr.Zero : uniform.__Instance;
            __Internal.AddUniform((__Instance + __PointerAdjustment), __arg0);
        }

        public global::Acid.Sharp.Uniform GetUniform(string uniformName)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(uniformName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetUniform((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.Uniform __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Uniform.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Uniform) global::Acid.Sharp.Uniform.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Uniform.__CreateInstance(__ret);
            return __result0;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public uint StageFlags
        {
            get
            {
                var __ret = __Internal.GetStageFlags((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStageFlags((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public int Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.UniformBlockType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class VertexAttribute : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal int m_set;

            [FieldOffset(36)]
            internal int m_location;

            [FieldOffset(40)]
            internal int m_size;

            [FieldOffset(44)]
            internal int m_glType;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAttribute@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH111@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name, int* set, int* location, int* size, int* glType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAttribute@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexAttribute@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@VertexAttribute@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@VertexAttribute@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSet@VertexAttribute@acid@@QEBAHXZ")]
            internal static extern int GetSet(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocation@VertexAttribute@acid@@QEBAHXZ")]
            internal static extern int GetLocation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@VertexAttribute@acid@@QEBAHXZ")]
            internal static extern int GetSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlType@VertexAttribute@acid@@QEBAHXZ")]
            internal static extern int GetGlType(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexAttribute> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexAttribute>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.VertexAttribute __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexAttribute(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexAttribute __CreateInstance(global::Acid.Sharp.VertexAttribute.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexAttribute(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexAttribute.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAttribute.__Internal));
            global::Acid.Sharp.VertexAttribute.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAttribute(global::Acid.Sharp.VertexAttribute.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAttribute(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexAttribute(string name, int set, int location, int size, int glType)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAttribute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = &set;
            var __arg2 = &location;
            var __arg3 = &size;
            var __arg4 = &glType;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public VertexAttribute(global::Acid.Sharp.VertexAttribute _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAttribute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.VertexAttribute __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public int Set
        {
            get
            {
                var __ret = __Internal.GetSet((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Location
        {
            get
            {
                var __ret = __Internal.GetLocation((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int GlType
        {
            get
            {
                var __ret = __Internal.GetGlType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class ShaderProgram : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 200)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Uniform___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_uniforms;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UniformBlock___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_uniformBlocks;

            [FieldOffset(80)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_VertexAttribute___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_vertexAttributes;

            [FieldOffset(104)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_DescriptorType___N_std_S_allocator__S0_ m_descriptors;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____E_VkDescriptorType___N_std_S_allocator__S0_ m_descriptorTypes;

            [FieldOffset(152)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkVertexInputAttributeDescription___N_std_S_allocator__S0_ m_attributeDescriptions;

            [FieldOffset(176)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_notFoundNames;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShaderProgram@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShaderProgram@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ShaderProgram@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ReportedNotFound@ShaderProgram@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ReportedNotFound(global::System.IntPtr instance, global::System.IntPtr name, bool* reportIfFound);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProcessShader@ShaderProgram@acid@@QEAAXXZ")]
            internal static extern void ProcessShader(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorLocation@ShaderProgram@acid@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern int GetDescriptorLocation(global::System.IntPtr instance, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniform@ShaderProgram@acid@@QEAAPEAVUniform@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetUniform(global::System.IntPtr instance, global::System.IntPtr uniformName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniformBlock@ShaderProgram@acid@@QEAAPEAVUniformBlock@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetUniformBlock(global::System.IntPtr instance, global::System.IntPtr blockName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexAttribute@ShaderProgram@acid@@QEAAPEAVVertexAttribute@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetVertexAttribute(global::System.IntPtr instance, global::System.IntPtr attributeName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InsertDefineBlock@ShaderProgram@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@0@Z")]
            internal static extern void InsertDefineBlock(global::System.IntPtr @return, global::System.IntPtr shaderCode, global::System.IntPtr blockCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ProcessIncludes@ShaderProgram@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void ProcessIncludes(global::System.IntPtr @return, global::System.IntPtr shaderCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@ShaderProgram@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@ShaderProgram@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLastDescriptorBinding@ShaderProgram@acid@@QEBAIXZ")]
            internal static extern uint GetLastDescriptorBinding(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ShaderProgram> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ShaderProgram>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ShaderProgram __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ShaderProgram(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ShaderProgram __CreateInstance(global::Acid.Sharp.ShaderProgram.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ShaderProgram(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ShaderProgram.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShaderProgram.__Internal));
            global::Acid.Sharp.ShaderProgram.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShaderProgram(global::Acid.Sharp.ShaderProgram.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShaderProgram(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ShaderProgram(string name)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShaderProgram.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public ShaderProgram(global::Acid.Sharp.ShaderProgram _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShaderProgram.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ShaderProgram __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool ReportedNotFound(string name, bool reportIfFound)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = &reportIfFound;
            var __ret = __Internal.ReportedNotFound((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public void ProcessShader()
        {
            __Internal.ProcessShader((__Instance + __PointerAdjustment));
        }

        public int GetDescriptorLocation(string descriptor)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptor, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetDescriptorLocation((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public global::Acid.Sharp.Uniform GetUniform(string uniformName)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(uniformName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetUniform((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.Uniform __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Uniform.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Uniform) global::Acid.Sharp.Uniform.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Uniform.__CreateInstance(__ret);
            return __result0;
        }

        public global::Acid.Sharp.UniformBlock GetUniformBlock(string blockName)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(blockName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetUniformBlock((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.UniformBlock __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.UniformBlock.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.UniformBlock) global::Acid.Sharp.UniformBlock.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.UniformBlock.__CreateInstance(__ret);
            return __result0;
        }

        public global::Acid.Sharp.VertexAttribute GetVertexAttribute(string attributeName)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(attributeName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetVertexAttribute((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.VertexAttribute __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.VertexAttribute.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.VertexAttribute) global::Acid.Sharp.VertexAttribute.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.VertexAttribute.__CreateInstance(__ret);
            return __result0;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static explicit operator global::Acid.Sharp.ShaderProgram(string name)
        {
            return new global::Acid.Sharp.ShaderProgram(name);
        }

        public static string InsertDefineBlock(string shaderCode, string blockCode)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(shaderCode, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(blockCode, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.InsertDefineBlock(new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static string ProcessIncludes(string shaderCode)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(shaderCode, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ProcessIncludes(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint LastDescriptorBinding
        {
            get
            {
                var __ret = __Internal.GetLastDescriptorBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe abstract partial class IPipeline : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPipeline@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPipeline@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindPipeline@IPipeline@acid@@QEBAXAEBVCommandBuffer@2@@Z")]
            internal static extern void BindPipeline(global::System.IntPtr instance, global::System.IntPtr commandBuffer);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IPipeline> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IPipeline>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IPipeline __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IPipelineInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IPipeline __CreateInstance(global::Acid.Sharp.IPipeline.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IPipelineInternal(native, skipVTables);
        }

        protected IPipeline(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IPipeline()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IPipeline");
        }

        protected IPipeline(global::Acid.Sharp.IPipeline _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IPipeline");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IPipeline __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IPipeline.__Internal*) __Instance)->vfptr_IPipeline = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void BindPipeline(global::Acid.Sharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.BindPipeline((__Instance + __PointerAdjustment), __arg0);
        }

        public abstract global::Acid.Sharp.ShaderProgram ShaderProgram
        {
            get;
        }

        #region Virtual table interop

        // ShaderProgram *GetShaderProgram() const = 0
        private static global::Delegates.Func_IntPtr_IntPtr _GetShaderProgramDelegateInstance;

        private static global::System.IntPtr _GetShaderProgramDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ShaderProgram;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetShaderProgramDelegateInstance += _GetShaderProgramDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetShaderProgramDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IPipelineInternal : global::Acid.Sharp.IPipeline, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IPipeline.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPipeline.__Internal));
            *(global::Acid.Sharp.IPipeline.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IPipelineInternal(global::Acid.Sharp.IPipeline.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IPipelineInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override global::Acid.Sharp.ShaderProgram ShaderProgram
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetShaderProgramDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetShaderProgramDelegate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ShaderProgram __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ShaderProgram.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ShaderProgram) global::Acid.Sharp.ShaderProgram.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ShaderProgram.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class DescriptorSet : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_pipelineLayout;

            [FieldOffset(8)]
            internal global::VkPipelineBindPoint m_pipelineBindPoint;

            [FieldOffset(16)]
            internal global::System.IntPtr m_descriptorPool;

            [FieldOffset(24)]
            internal global::System.IntPtr m_descriptorSet;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorSet@acid@@QEAA@AEBVIPipeline@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorSet@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1DescriptorSet@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindDescriptor@DescriptorSet@acid@@QEAAXAEBVCommandBuffer@2@@Z")]
            internal static extern void BindDescriptor(global::System.IntPtr instance, global::System.IntPtr commandBuffer);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.DescriptorSet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.DescriptorSet>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.DescriptorSet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DescriptorSet(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DescriptorSet __CreateInstance(global::Acid.Sharp.DescriptorSet.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DescriptorSet(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DescriptorSet.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorSet.__Internal));
            *(global::Acid.Sharp.DescriptorSet.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DescriptorSet(global::Acid.Sharp.DescriptorSet.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorSet(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorSet(global::Acid.Sharp.IPipeline pipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorSet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pipeline.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public DescriptorSet(global::Acid.Sharp.DescriptorSet _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorSet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.DescriptorSet.__Internal*) __Instance) = *((global::Acid.Sharp.DescriptorSet.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.DescriptorSet __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void BindDescriptor(global::Acid.Sharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.BindDescriptor((__Instance + __PointerAdjustment), __arg0);
        }

        public static explicit operator global::Acid.Sharp.DescriptorSet(global::Acid.Sharp.IPipeline pipeline)
        {
            return new global::Acid.Sharp.DescriptorSet(pipeline);
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial interface IBuffer : IDisposable
    {
        void Dispose();

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToBuffer { get; }

        ulong Size { get; }
    }

    public unsafe partial class Buffer : global::Acid.Sharp.IBuffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong m_size;

            [FieldOffset(8)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(16)]
            internal global::System.IntPtr m_bufferMemory;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Buffer@acid@@QEAA@AEB_KAEBI1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong* size, uint* usage, uint* properties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Buffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Buffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindMemoryType@Buffer@acid@@SAIAEBI0@Z")]
            internal static extern uint FindMemoryType(uint* typeFilter, uint* requiredProperties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Buffer@acid@@QEBA_KXZ")]
            internal static extern ulong GetSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IBuffer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Buffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Buffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Buffer __CreateInstance(global::Acid.Sharp.Buffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Buffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Buffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Buffer.__Internal));
            *(global::Acid.Sharp.Buffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Buffer(global::Acid.Sharp.Buffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Buffer(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Buffer(ulong size, uint usage, uint properties)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &size;
            var __arg1 = &usage;
            var __arg2 = &properties;
            __Internal.ctor((__Instance), __arg0, __arg1, __arg2);
        }

        public Buffer(global::Acid.Sharp.IBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Buffer.__Internal*) __Instance) = *((global::Acid.Sharp.Buffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static uint FindMemoryType(uint typeFilter, uint requiredProperties)
        {
            var __arg0 = &typeFilter;
            var __arg1 = &requiredProperties;
            var __ret = __Internal.FindMemoryType(__arg0, __arg1);
            return __ret;
        }

        protected ulong MSize
        {
            get
            {
                return ((global::Acid.Sharp.Buffer.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::Acid.Sharp.Buffer.__Internal*)__Instance)->m_size = value;
            }
        }

        public global::System.IntPtr __PointerToBuffer
        {
            get
            {
                return __Instance + 0;
            }
        }

        public ulong Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class IndexBuffer : global::Acid.Sharp.Buffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong m_size;

            [FieldOffset(8)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(16)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(24)]
            internal global::VkIndexType m_indexType;

            [FieldOffset(28)]
            internal uint m_indexCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IndexBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IndexBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndexCount@IndexBuffer@acid@@QEBAIXZ")]
            internal static extern uint GetIndexCount(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.IndexBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IndexBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IndexBuffer __CreateInstance(global::Acid.Sharp.IndexBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IndexBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.IndexBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IndexBuffer.__Internal));
            *(global::Acid.Sharp.IndexBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IndexBuffer(global::Acid.Sharp.IndexBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IndexBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public IndexBuffer(global::Acid.Sharp.IndexBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IndexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.IndexBuffer.__Internal*) __Instance) = *((global::Acid.Sharp.IndexBuffer.__Internal*) _0.__Instance);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint IndexCount
        {
            get
            {
                var __ret = __Internal.GetIndexCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class VertexBuffer : global::Acid.Sharp.Buffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong m_size;

            [FieldOffset(8)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(16)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(24)]
            internal uint m_vertexCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexBuffer@acid@@QEAA@AEB_K0PEBX@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong* elementSize, ulong* vertexCount, global::System.IntPtr newData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexCount@VertexBuffer@acid@@QEBAIXZ")]
            internal static extern uint GetVertexCount(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.VertexBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexBuffer __CreateInstance(global::Acid.Sharp.VertexBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexBuffer.__Internal));
            *(global::Acid.Sharp.VertexBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VertexBuffer(global::Acid.Sharp.VertexBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexBuffer(ulong elementSize, ulong vertexCount, global::System.IntPtr newData)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &elementSize;
            var __arg1 = &vertexCount;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, newData);
        }

        public VertexBuffer(global::Acid.Sharp.VertexBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.VertexBuffer.__Internal*) __Instance) = *((global::Acid.Sharp.VertexBuffer.__Internal*) _0.__Instance);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint VertexCount
        {
            get
            {
                var __ret = __Internal.GetVertexCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A managed resource object.</summary>
    public unsafe abstract partial class IResource : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IResource@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IResource@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IResource> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IResource>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IResource __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IResourceInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IResource __CreateInstance(global::Acid.Sharp.IResource.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IResourceInternal(native, skipVTables);
        }

        protected IResource(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IResource()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IResource.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IResource");
        }

        protected IResource(global::Acid.Sharp.IResource _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IResource.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IResource");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IResource.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets a unique name (most likely a filename) associated with this resource object.</summary>
        public abstract string Filename
        {
            get;
        }

        #region Virtual table interop

        // std::string GetFilename() = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IResource) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IResourceInternal : global::Acid.Sharp.IResource, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IResource.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IResource.__Internal));
            *(global::Acid.Sharp.IResource.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IResourceInternal(global::Acid.Sharp.IResource.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IResourceInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets a unique name (most likely a filename) associated with this resource object.</summary>
        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe abstract partial class IVertex : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IVertex@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IVertex@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IVertex> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IVertex>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IVertex __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IVertexInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IVertex __CreateInstance(global::Acid.Sharp.IVertex.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IVertexInternal(native, skipVTables);
        }

        protected IVertex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IVertex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IVertex");
        }

        protected IVertex(global::Acid.Sharp.IVertex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IVertex");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IVertex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IVertex.__Internal*) __Instance)->vfptr_IVertex = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract global::Acid.Sharp.Vector3 Position
        {
            get;

            set;
        }

        #region Virtual table interop

        // Vector3 GetPosition() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) = 0
        private static global::Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IVertex) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::Acid.Sharp.Vector3) global::Acid.Sharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::Acid.Sharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IVertexInternal : global::Acid.Sharp.IVertex, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IVertex.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IVertex.__Internal));
            *(global::Acid.Sharp.IVertex.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IVertexInternal(global::Acid.Sharp.IVertex.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IVertexInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetPositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___SetPositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a OBJ model.</summary>
    public unsafe partial class Model : global::Acid.Sharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Model@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Model@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Model@acid@@QEAA_NAEBVCommandBuffer@2@AEBI@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, uint* instances);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMinExtents@Model@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetMinExtents(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxExtents@Model@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetMaxExtents(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Model@acid@@QEBAMXZ")]
            internal static extern float GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Model@acid@@QEBAMXZ")]
            internal static extern float GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepth@Model@acid@@QEBAMXZ")]
            internal static extern float GetDepth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@Model@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexBuffer@Model@acid@@QEBAPEAVVertexBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetVertexBuffer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndexBuffer@Model@acid@@QEBAPEAVIndexBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetIndexBuffer(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Model __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Model(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Model __CreateInstance(global::Acid.Sharp.Model.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Model(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Model.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Model.__Internal));
            global::Acid.Sharp.Model.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Model(global::Acid.Sharp.Model.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Model(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new empty model.</summary>
        public Model()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Model");
        }

        public Model(global::Acid.Sharp.Model _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Model.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Model");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Model.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool CmdRender(global::Acid.Sharp.CommandBuffer commandBuffer, uint instances)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            var __arg1 = &instances;
            var __ret = __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::Acid.Sharp.Vector3 MinExtents
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetMinExtents((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector3 MaxExtents
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetMaxExtents((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public float Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Depth
        {
            get
            {
                var __ret = __Internal.GetDepth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.VertexBuffer VertexBuffer
        {
            get
            {
                var __ret = __Internal.GetVertexBuffer((__Instance + __PointerAdjustment));
                global::Acid.Sharp.VertexBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.VertexBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.VertexBuffer) global::Acid.Sharp.VertexBuffer.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.VertexBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.IndexBuffer IndexBuffer
        {
            get
            {
                var __ret = __Internal.GetIndexBuffer((__Instance + __PointerAdjustment));
                global::Acid.Sharp.IndexBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.IndexBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.IndexBuffer) global::Acid.Sharp.IndexBuffer.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.IndexBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Model) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a 2-tuple vector.</summary>
    public unsafe partial class Vector2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector2._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Vector2@acid@@QEAA@AEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Angle@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Angle(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Dot@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Dot(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Vector2@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float* scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float* angle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rotate@Vector2@acid@@QEBA?AV12@AEBMAEBV12@@Z")]
            internal static extern void Rotate(global::System.IntPtr instance, global::System.IntPtr @return, float* angle, global::System.IntPtr rotationAxis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceSquared@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float DistanceSquared(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Distance@Vector2@acid@@QEBAMAEBV12@@Z")]
            internal static extern float Distance(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceVector@Vector2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void DistanceVector(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InTriangle@Vector2@acid@@QEBA_NAEBV12@00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InTriangle(global::System.IntPtr instance, global::System.IntPtr v1, global::System.IntPtr v2, global::System.IntPtr v3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Vector2@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Vector2@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Vector2@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PVector2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Vector2@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Vector2@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GVector2@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Vector2@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVVector2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBVVector2@0@AEBV10@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBVVector2@0@AEBV10@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AVector2@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetX@Vector2@acid@@QEBAMXZ")]
            internal static extern float GetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetX@Vector2@acid@@QEAAXAEBM@Z")]
            internal static extern void SetX(global::System.IntPtr instance, float* x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetY@Vector2@acid@@QEBAMXZ")]
            internal static extern float GetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetY@Vector2@acid@@QEAAXAEBM@Z")]
            internal static extern void SetY(global::System.IntPtr instance, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Vector2@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Vector2@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MaxComponent@Vector2@acid@@QEBAMXZ")]
            internal static extern float MaxComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?MinComponent@Vector2@acid@@QEBAMXZ")]
            internal static extern float MinComponent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CartesianToPolar@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void CartesianToPolar(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PolarToCartesian@Vector2@acid@@QEBA?AV12@XZ")]
            internal static extern void PolarToCartesian(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector2._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Vector2._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[2];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Vector2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Vector2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector2(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Vector2 __CreateInstance(global::Acid.Sharp.Vector2.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Vector2(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Vector2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            global::Acid.Sharp.Vector2.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Vector2(global::Acid.Sharp.Vector2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Vector2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Vector2.</summary>
        public Vector2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="x">Start x.</param>
        /// <param name="y">Start y.</param>
        public Vector2(float x, float y)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &x;
            var __arg1 = &y;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::Acid.Sharp.Vector2 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Vector2.</summary>
        /// <param name="source">Creates this vector out of a existing one.</param>
        public Vector2(global::Acid.Sharp.Vector3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Vector2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Vector2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Add(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Subtract(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Multiply(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Divide(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Calculates the angle between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Angle(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Angle((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the dot product of the this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Dot(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Dot((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::Acid.Sharp.Vector2 Scale(float scalar)
        {
            var __arg0 = &scalar;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around the origin.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        public global::Acid.Sharp.Vector2 Rotate(float angle)
        {
            var __arg0 = &angle;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Rotates this vector by a angle around a rotation axis.</summary>
        /// <param name="angle">The angle to rotate by, in radians.</param>
        /// <param name="rotationAxis">The point to rotate the vector around.</param>
        public global::Acid.Sharp.Vector2 Rotate(float angle, global::Acid.Sharp.Vector2 rotationAxis)
        {
            var __arg0 = &angle;
            if (ReferenceEquals(rotationAxis, null))
                throw new global::System.ArgumentNullException("rotationAxis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotationAxis.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Rotate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Negates this vector.</summary>
        public global::Acid.Sharp.Vector2 Negate()
        {
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::Acid.Sharp.Vector2 Normalize()
        {
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets the distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float DistanceSquared(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.DistanceSquared((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public float Distance(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.Distance((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the vector distance between this vector and another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 DistanceVector(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.DistanceVector((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Gets if this vector is in a triangle.</summary>
        /// <param name="v1">The first triangle vertex.</param>
        /// <param name="v2">The second triangle vertex.</param>
        /// <param name="v3">The third triangle vertex.</param>
        public bool InTriangle(global::Acid.Sharp.Vector2 v1, global::Acid.Sharp.Vector2 v2, global::Acid.Sharp.Vector2 v3)
        {
            if (ReferenceEquals(v1, null))
                throw new global::System.ArgumentNullException("v1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = v1.__Instance;
            if (ReferenceEquals(v2, null))
                throw new global::System.ArgumentNullException("v2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = v2.__Instance;
            if (ReferenceEquals(v3, null))
                throw new global::System.ArgumentNullException("v3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = v3.__Instance;
            var __ret = __Internal.InTriangle((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::Acid.Sharp.Vector2 SmoothDamp(global::Acid.Sharp.Vector2 target, global::Acid.Sharp.Vector2 rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Vector2;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Vector2.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Vector2 __op, global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::Acid.Sharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator !=(global::Acid.Sharp.Vector2 __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Vector2 operator -(global::Acid.Sharp.Vector2 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Vector2(global::Acid.Sharp.Vector3 source)
        {
            return new global::Acid.Sharp.Vector2(source);
        }

        public static global::Acid.Sharp.Vector2 operator +(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator -(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator *(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator /(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator +(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator -(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator *(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator /(float left, global::Acid.Sharp.Vector2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator +(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator -(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator *(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 operator /(global::Acid.Sharp.Vector2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator *(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator /(global::Acid.Sharp.Vector2 left, global::Acid.Sharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector2 Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 One
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ONE@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Left
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LEFT@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Right
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RIGHT@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Up
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?UP@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 Down
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DOWN@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 PositiveInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?POSITIVE_INFINITY@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Vector2 NegativeInfinity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Vector2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NEGATIVE_INFINITY@Vector2@acid@@2V12@B");
                return global::Acid.Sharp.Vector2.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return *__ret;
            }

            set
            {
                var __arg0 = &index;
                *global::Acid.Sharp.Vector2.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = value;
            }
        }

        public float X
        {
            get
            {
                var __ret = __Internal.GetX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Y
        {
            get
            {
                var __ret = __Internal.GetY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetY((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the maximum value in this vector.</summary>
        public float MaxComponent
        {
            get
            {
                var __ret = __Internal.MaxComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the lowest value in this vector.</summary>
        public float MinComponent
        {
            get
            {
                var __ret = __Internal.MinComponent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Converts from rectangular to spherical coordinates, this vector is in cartesian (x, y).</summary>
        public global::Acid.Sharp.Vector2 CartesianToPolar
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.CartesianToPolar((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }
        }

        /// <summary>Converts from spherical to rectangular coordinates, this vector is in polar (radius, theta).</summary>
        public global::Acid.Sharp.Vector2 PolarToCartesian
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.PolarToCartesian((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class VertexAnimated : global::Acid.Sharp.IVertex, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(20)]
            internal global::Acid.Sharp.Vector2.__Internal m_uv;

            [FieldOffset(28)]
            internal global::Acid.Sharp.Vector3.__Internal m_normal;

            [FieldOffset(40)]
            internal global::Acid.Sharp.Vector3.__Internal m_tangent;

            [FieldOffset(52)]
            internal global::Acid.Sharp.Vector3.__Internal m_jointId;

            [FieldOffset(64)]
            internal global::Acid.Sharp.Vector3.__Internal m_vertexWeight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimated@acid@@QEAA@AEBVVector3@1@AEBVVector2@1@0000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr uv, global::System.IntPtr normal, global::System.IntPtr tangent, global::System.IntPtr jointId, global::System.IntPtr vertexWeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimated@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@VertexAnimated@acid@@SA?AVVertexInput@2@AEBI@Z")]
            internal static extern void GetVertexInput(global::System.IntPtr @return, uint* binding);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUv@VertexAnimated@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetUv(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUv@VertexAnimated@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetUv(global::System.IntPtr instance, global::System.IntPtr uv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormal@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetNormal(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormal@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetNormal(global::System.IntPtr instance, global::System.IntPtr normal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTangent@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetTangent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTangent@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetTangent(global::System.IntPtr instance, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointId@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetJointId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJointId@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetJointId(global::System.IntPtr instance, global::System.IntPtr jointId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexWeight@VertexAnimated@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetVertexWeight(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVertexWeight@VertexAnimated@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetVertexWeight(global::System.IntPtr instance, global::System.IntPtr vertexWeight);
        }

        internal static new global::Acid.Sharp.VertexAnimated __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexAnimated(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexAnimated __CreateInstance(global::Acid.Sharp.VertexAnimated.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexAnimated(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexAnimated.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAnimated.__Internal));
            global::Acid.Sharp.VertexAnimated.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAnimated(global::Acid.Sharp.VertexAnimated.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAnimated(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public VertexAnimated(global::Acid.Sharp.Vector3 position, global::Acid.Sharp.Vector2 uv, global::Acid.Sharp.Vector3 normal, global::Acid.Sharp.Vector3 tangent, global::Acid.Sharp.Vector3 jointId, global::Acid.Sharp.Vector3 vertexWeight)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = normal.__Instance;
            if (ReferenceEquals(tangent, null))
                throw new global::System.ArgumentNullException("tangent", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = tangent.__Instance;
            if (ReferenceEquals(jointId, null))
                throw new global::System.ArgumentNullException("jointId", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = jointId.__Instance;
            if (ReferenceEquals(vertexWeight, null))
                throw new global::System.ArgumentNullException("vertexWeight", "Cannot be null because it is a C++ reference (&).");
            var __arg5 = vertexWeight.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
            SetupVTables(GetType().FullName == "Acid.Sharp.VertexAnimated");
        }

        public VertexAnimated(global::Acid.Sharp.VertexAnimated _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.VertexAnimated");
        }

        public static global::Acid.Sharp.VertexInput GetVertexInput(uint binding)
        {
            var __arg0 = &binding;
            var __ret = new global::Acid.Sharp.VertexInput.__Internal();
            __Internal.GetVertexInput(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.VertexInput.__CreateInstance(__ret);
        }

        public override global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetPositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___SetPositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector2 Uv
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetUv((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetUv((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Normal
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetNormal((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetNormal((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Tangent
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetTangent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTangent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 JointId
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetJointId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetJointId((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 VertexWeight
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetVertexWeight((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetVertexWeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // Vector3 GetPosition() const override { return m_position; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) override { m_position = position; }
        private static global::Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.VertexAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::Acid.Sharp.Vector3) global::Acid.Sharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::Acid.Sharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class VertexSkinData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_jointIds;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_weights;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexSkinData@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexSkinData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexSkinData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddJointEffect@VertexSkinData@acid@@QEAAXAEBIAEBM@Z")]
            internal static extern void AddJointEffect(global::System.IntPtr instance, uint* jointId, float* weight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LimitJointNumber@VertexSkinData@acid@@QEAAXAEBI@Z")]
            internal static extern void LimitJointNumber(global::System.IntPtr instance, uint* max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FillEmptyWeights@VertexSkinData@acid@@QEAAXAEBI@Z")]
            internal static extern void FillEmptyWeights(global::System.IntPtr instance, uint* max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveExcessJointIds@VertexSkinData@acid@@QEAAXAEBI@Z")]
            internal static extern void RemoveExcessJointIds(global::System.IntPtr instance, uint* max);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexSkinData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexSkinData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.VertexSkinData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexSkinData(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexSkinData __CreateInstance(global::Acid.Sharp.VertexSkinData.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexSkinData(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexSkinData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexSkinData.__Internal));
            global::Acid.Sharp.VertexSkinData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexSkinData(global::Acid.Sharp.VertexSkinData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexSkinData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexSkinData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexSkinData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public VertexSkinData(global::Acid.Sharp.VertexSkinData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexSkinData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.VertexSkinData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddJointEffect(uint jointId, float weight)
        {
            var __arg0 = &jointId;
            var __arg1 = &weight;
            __Internal.AddJointEffect((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public void LimitJointNumber(uint max)
        {
            var __arg0 = &max;
            __Internal.LimitJointNumber((__Instance + __PointerAdjustment), __arg0);
        }

        public void FillEmptyWeights(uint max)
        {
            var __arg0 = &max;
            __Internal.FillEmptyWeights((__Instance + __PointerAdjustment), __arg0);
        }

        public void RemoveExcessJointIds(uint max)
        {
            var __arg0 = &max;
            __Internal.RemoveExcessJointIds((__Instance + __PointerAdjustment), __arg0);
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class VertexAnimatedData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal int m_uvIndex;

            [FieldOffset(16)]
            internal int m_normalIndex;

            [FieldOffset(24)]
            internal global::System.IntPtr m_duplicateVertex;

            [FieldOffset(32)]
            internal int m_index;

            [FieldOffset(40)]
            internal global::Acid.Sharp.VertexSkinData.__Internal m_skinData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimatedData@acid@@QEAA@AEBHAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int* index, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexAnimatedData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexAnimatedData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasSameTextureAndNormal@VertexAnimatedData@acid@@QEBA_NAEBH0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSameTextureAndNormal(global::System.IntPtr instance, int* textureIndexOther, int* normalIndexOther);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUvIndex@VertexAnimatedData@acid@@QEBAHXZ")]
            internal static extern int GetUvIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUvIndex@VertexAnimatedData@acid@@QEAAXAEBH@Z")]
            internal static extern void SetUvIndex(global::System.IntPtr instance, int* uvIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormalIndex@VertexAnimatedData@acid@@QEBAHXZ")]
            internal static extern int GetNormalIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormalIndex@VertexAnimatedData@acid@@QEAAXAEBH@Z")]
            internal static extern void SetNormalIndex(global::System.IntPtr instance, int* normalIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDuplicateVertex@VertexAnimatedData@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetDuplicateVertex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDuplicateVertex@VertexAnimatedData@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetDuplicateVertex(global::System.IntPtr instance, global::System.IntPtr duplicateVertex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSkinData@VertexAnimatedData@acid@@QEBA?AVVertexSkinData@2@XZ")]
            internal static extern void GetSkinData(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSkinData@VertexAnimatedData@acid@@QEAAXAEBVVertexSkinData@2@@Z")]
            internal static extern void SetSkinData(global::System.IntPtr instance, global::System.IntPtr skinData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@VertexAnimatedData@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@VertexAnimatedData@acid@@QEBAHXZ")]
            internal static extern int GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSet@VertexAnimatedData@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexAnimatedData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexAnimatedData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.VertexAnimatedData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexAnimatedData(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexAnimatedData __CreateInstance(global::Acid.Sharp.VertexAnimatedData.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexAnimatedData(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexAnimatedData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAnimatedData.__Internal));
            global::Acid.Sharp.VertexAnimatedData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexAnimatedData(global::Acid.Sharp.VertexAnimatedData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexAnimatedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexAnimatedData(int index, global::Acid.Sharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAnimatedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &index;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public VertexAnimatedData(global::Acid.Sharp.VertexAnimatedData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexAnimatedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.VertexAnimatedData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool HasSameTextureAndNormal(int textureIndexOther, int normalIndexOther)
        {
            var __arg0 = &textureIndexOther;
            var __arg1 = &normalIndexOther;
            var __ret = __Internal.HasSameTextureAndNormal((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        public int UvIndex
        {
            get
            {
                var __ret = __Internal.GetUvIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetUvIndex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public int NormalIndex
        {
            get
            {
                var __ret = __Internal.GetNormalIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetNormalIndex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.VertexAnimatedData DuplicateVertex
        {
            get
            {
                var __ret = __Internal.GetDuplicateVertex((__Instance + __PointerAdjustment));
                global::Acid.Sharp.VertexAnimatedData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.VertexAnimatedData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.VertexAnimatedData) global::Acid.Sharp.VertexAnimatedData.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.VertexAnimatedData.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetDuplicateVertex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.VertexSkinData SkinData
        {
            get
            {
                var __ret = new global::Acid.Sharp.VertexSkinData.__Internal();
                __Internal.GetSkinData((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.VertexSkinData.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetSkinData((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public int Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool Set
        {
            get
            {
                var __ret = __Internal.GetSet((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class GeometryLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 152)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_meshData;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_VertexSkinData___N_std_S_allocator__S0_ m_vertexWeights;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_VertexAnimatedData___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_positionsList;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Vector2___N_std_S_allocator__S0_ m_uvsList;

            [FieldOffset(80)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Vector3___N_std_S_allocator__S0_ m_normalsList;

            [FieldOffset(104)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_VertexAnimated___N_std_S_allocator__S0_ m_vertices;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_indices;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GeometryLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1GeometryLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.GeometryLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.GeometryLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.GeometryLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.GeometryLoader(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.GeometryLoader __CreateInstance(global::Acid.Sharp.GeometryLoader.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.GeometryLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.GeometryLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GeometryLoader.__Internal));
            global::Acid.Sharp.GeometryLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private GeometryLoader(global::Acid.Sharp.GeometryLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GeometryLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public GeometryLoader(global::Acid.Sharp.GeometryLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GeometryLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.GeometryLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class JointData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_index;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_nameId;

            [FieldOffset(40)]
            internal global::Acid.Sharp.Matrix4.__Internal m_bindLocalTransform;

            [FieldOffset(104)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_JointData___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointData@acid@@QEAA@AEBIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMatrix4@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint* index, global::System.IntPtr nameId, global::System.IntPtr bindLocalTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JointData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JointData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@JointData@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@JointData@acid@@QEBAIXZ")]
            internal static extern uint GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNameId@JointData@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetNameId(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBindLocalTransform@JointData@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetBindLocalTransform(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JointData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JointData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.JointData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JointData(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.JointData __CreateInstance(global::Acid.Sharp.JointData.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JointData(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.JointData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointData.__Internal));
            global::Acid.Sharp.JointData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JointData(global::Acid.Sharp.JointData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JointData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JointData(uint index, string nameId, global::Acid.Sharp.Matrix4 bindLocalTransform)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &index;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(nameId, __allocator1);
            var __arg1 = __basicString1.__Instance;
            if (ReferenceEquals(bindLocalTransform, null))
                throw new global::System.ArgumentNullException("bindLocalTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = bindLocalTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public JointData(global::Acid.Sharp.JointData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JointData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.JointData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddChild(global::Acid.Sharp.JointData child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public uint Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string NameId
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetNameId((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::Acid.Sharp.Matrix4 BindLocalTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetBindLocalTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that holds many various math functions.</summary>
    public unsafe partial class Maths : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Maths@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Random@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float Random(float* min, float* max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomNormal@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float RandomNormal(float* standardDeviation, float* mean);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RandomLog@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float RandomLog(float* min, float* max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Radians@Maths@acid@@SAMAEBM@Z")]
            internal static extern float Radians(float* degrees);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Degrees@Maths@acid@@SAMAEBM@Z")]
            internal static extern float Degrees(float* radians);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WrapDegrees@Maths@acid@@SAMAEBM@Z")]
            internal static extern float WrapDegrees(float* degrees);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WrapRadians@Maths@acid@@SAMAEBM@Z")]
            internal static extern float WrapRadians(float* radians);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RoundToPlace@Maths@acid@@SAMAEBMAEBH@Z")]
            internal static extern float RoundToPlace(float* value, int* place);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Deadband@Maths@acid@@SAMAEBM0@Z")]
            internal static extern float Deadband(float* min, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AlmostEqual@Maths@acid@@SA_NAEBM00@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AlmostEqual(float* a, float* b, float* eps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float SmoothDamp(float* current, float* target, float* rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Lerp@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float Lerp(float* a, float* b, float* factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float Interpolate(float* a, float* b, float* blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InterpolateCosine@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float InterpolateCosine(float* a, float* b, float* blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothlyStep@Maths@acid@@SAMAEBM00@Z")]
            internal static extern float SmoothlyStep(float* edge0, float* edge1, float* x);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Maths> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Maths>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Maths __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Maths(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Maths __CreateInstance(global::Acid.Sharp.Maths.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Maths(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Maths.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Maths.__Internal));
            *(global::Acid.Sharp.Maths.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Maths(global::Acid.Sharp.Maths.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Maths(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Maths()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Maths.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Maths(global::Acid.Sharp.Maths _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Maths.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Maths.__Internal*) __Instance) = *((global::Acid.Sharp.Maths.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Maths __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Generates a random value from between a range.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        public static float Random(float min, float max)
        {
            var __arg0 = &min;
            var __arg1 = &max;
            var __ret = __Internal.Random(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Generates a single value from a normal distribution, using Box-Muller. https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform</summary>
        /// <param name="standardDeviation">The standards deviation of the distribution.</param>
        /// <param name="mean">The mean of the distribution.</param>
        public static float RandomNormal(float standardDeviation, float mean)
        {
            var __arg0 = &standardDeviation;
            var __arg1 = &mean;
            var __ret = __Internal.RandomNormal(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Creates a number between two numbers, logarithmic.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        public static float RandomLog(float min, float max)
        {
            var __arg0 = &min;
            var __arg1 = &max;
            var __ret = __Internal.RandomLog(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Converts degrees to radians.</summary>
        /// <param name="degrees">The degrees value.</param>
        public static float Radians(float degrees)
        {
            var __arg0 = &degrees;
            var __ret = __Internal.Radians(__arg0);
            return __ret;
        }

        /// <summary>Converts radians to degrees.</summary>
        /// <param name="radians">The radians value.</param>
        public static float Degrees(float radians)
        {
            var __arg0 = &radians;
            var __ret = __Internal.Degrees(__arg0);
            return __ret;
        }

        /// <summary>Normalizes a angle into the range of 0-360.</summary>
        /// <param name="degrees">The source angle.</param>
        public static float WrapDegrees(float degrees)
        {
            var __arg0 = &degrees;
            var __ret = __Internal.WrapDegrees(__arg0);
            return __ret;
        }

        /// <summary>Normalizes a angle into the range of 0-2PI.</summary>
        /// <param name="radians">The source angle.</param>
        public static float WrapRadians(float radians)
        {
            var __arg0 = &radians;
            var __ret = __Internal.WrapRadians(__arg0);
            return __ret;
        }

        /// <summary>Rounds a value to a amount of places after the decimal point.</summary>
        /// <param name="value">The value to round.</param>
        /// <param name="place">How many places after the decimal to round to.</param>
        public static float RoundToPlace(float value, int place)
        {
            var __arg0 = &value;
            var __arg1 = &place;
            var __ret = __Internal.RoundToPlace(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Used to floor the value if less than the min.</summary>
        /// <param name="min">The minimum value.</param>
        /// <param name="value">The value.</param>
        public static float Deadband(float min, float value)
        {
            var __arg0 = &min;
            var __arg1 = &value;
            var __ret = __Internal.Deadband(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Checks if two values are almost equal.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="eps">EPS is the measure of equality.</param>
        public static bool AlmostEqual(float a, float b, float eps)
        {
            var __arg0 = &a;
            var __arg1 = &b;
            var __arg2 = &eps;
            var __ret = __Internal.AlmostEqual(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Gradually changes a value to a target.</summary>
        /// <param name="current">The current value.</param>
        /// <param name="target">The target value.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public static float SmoothDamp(float current, float target, float rate)
        {
            var __arg0 = &current;
            var __arg1 = &target;
            var __arg2 = &rate;
            var __ret = __Internal.SmoothDamp(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Lerps two values by a factor.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="factor">The factor value.</param>
        public static float Lerp(float a, float b, float factor)
        {
            var __arg0 = &a;
            var __arg1 = &b;
            var __arg2 = &factor;
            var __ret = __Internal.Lerp(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Interpolates two values by a factor using linear interpolation.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="blend">The blend value.</param>
        public static float Interpolate(float a, float b, float blend)
        {
            var __arg0 = &a;
            var __arg1 = &b;
            var __arg2 = &blend;
            var __ret = __Internal.Interpolate(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Interpolates two values by a factor using cosine interpolation.</summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        /// <param name="blend">The blend value.</param>
        public static float InterpolateCosine(float a, float b, float blend)
        {
            var __arg0 = &a;
            var __arg1 = &b;
            var __arg2 = &blend;
            var __ret = __Internal.InterpolateCosine(__arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>A calculation that steps smoothly between two edges.</summary>
        /// <param name="edge0">The inner edge.</param>
        /// <param name="edge1">The outer edge.</param>
        /// <param name="x">The sample.</param>
        public static float SmoothlyStep(float edge0, float edge1, float x)
        {
            var __arg0 = &edge0;
            var __arg1 = &edge1;
            var __arg2 = &x;
            var __ret = __Internal.SmoothlyStep(__arg0, __arg1, __arg2);
            return __ret;
        }
    }

    public unsafe partial class Maths
    {
        public partial struct __Internal
        {
        }

        public static float Pi
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PI@acid@@3MB");
                return *__ptr;
            }
        }

        public static float DegToRad
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DEG_TO_RAD@acid@@3MB");
                return *__ptr;
            }
        }

        public static float RadToDeg
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RAD_TO_DEG@acid@@3MB");
                return *__ptr;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a RGBA colour.</summary>
    public unsafe partial class Colour : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Colour._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBM000@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* r, float* g, float* b, float* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr hex, float* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBVVector3@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source, float* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Colour@acid@@QEAA@AEBVVector4@1@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Colour@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Colour@acid@@QEBA?AV12@AEBM@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, float* scalar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Normalize@Colour@acid@@QEBA?AV12@XZ")]
            internal static extern void Normalize(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Interpolate@Colour@acid@@QEBA?AV12@AEBV12@M@Z")]
            internal static extern void Interpolate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other, float blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SmoothDamp@Colour@acid@@QEBA?AV12@AEBV12@0@Z")]
            internal static extern void SmoothDamp(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr target, global::System.IntPtr rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Colour@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Colour@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Colour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Colour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PColour@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Colour@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Colour@acid@@QEBA_NAEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Colour@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVColour@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVColour@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVColour@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVColour@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVColour@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, float* value, global::System.IntPtr left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVColour@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, float* value, global::System.IntPtr left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVColour@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* value, global::System.IntPtr left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVColour@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* value, global::System.IntPtr left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVColour@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVColour@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVColour@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVColour@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AColour@acid@@QEAAAEAMAEBI@Z")]
            internal static extern float* OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetR@Colour@acid@@QEBAMXZ")]
            internal static extern float GetR(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetR@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetR(global::System.IntPtr instance, float* r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetG@Colour@acid@@QEBAMXZ")]
            internal static extern float GetG(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetG@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetG(global::System.IntPtr instance, float* g);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetB@Colour@acid@@QEBAMXZ")]
            internal static extern float GetB(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetB@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetB(global::System.IntPtr instance, float* b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetA@Colour@acid@@QEBAMXZ")]
            internal static extern float GetA(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetA@Colour@acid@@QEAAXAEBM@Z")]
            internal static extern void SetA(global::System.IntPtr instance, float* a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LengthSquared@Colour@acid@@QEBAMXZ")]
            internal static extern float LengthSquared(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Length@Colour@acid@@QEBAMXZ")]
            internal static extern float Length(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUnit@Colour@acid@@QEBA?AV12@XZ")]
            internal static extern void GetUnit(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHex@Colour@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetHex(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Colour._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Colour._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed float m_elements[4];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Colour> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Colour>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Colour __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Colour(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Colour __CreateInstance(global::Acid.Sharp.Colour.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Colour(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Colour.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Colour.__Internal));
            global::Acid.Sharp.Colour.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Colour(global::Acid.Sharp.Colour.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Colour(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for colour.</summary>
        public Colour()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="r">The new R value.</param>
        /// <param name="g">The new G value.</param>
        /// <param name="b">The new B value.</param>
        /// <param name="a">The new A value.</param>
        public Colour(float r, float g, float b, float a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &r;
            var __arg1 = &g;
            var __arg2 = &b;
            var __arg3 = &a;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="hex">The new values from HEX.</param>
        /// <param name="a">The new A value.</param>
        public Colour(string hex, float a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(hex, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = &a;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing one.</param>
        public Colour(global::Acid.Sharp.Colour source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing vector.</param>
        /// <param name="a">The new A value.</param>
        public Colour(global::Acid.Sharp.Vector3 source, float a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg1 = &a;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Constructor for colour.</summary>
        /// <param name="source">Creates this colour out of a existing vector.</param>
        public Colour(global::Acid.Sharp.Vector4 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Colour.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Colour __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Colour Add(global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this vector to another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Colour Subtract(global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this vector with another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Colour Multiply(global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Divides this vector by another vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Colour Divide(global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Scales this vector by a scalar.</summary>
        /// <param name="scalar">The scalar value.</param>
        public global::Acid.Sharp.Colour Scale(float scalar)
        {
            var __arg0 = &scalar;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Normalizes this vector.</summary>
        public global::Acid.Sharp.Colour Normalize()
        {
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.Normalize((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Interpolates between this and another colour.</summary>
        /// <param name="other">The other colour.</param>
        /// <param name="blend">The blend factor.</param>
        public global::Acid.Sharp.Colour Interpolate(global::Acid.Sharp.Colour other, float blend)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.Interpolate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, blend);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        /// <summary>Gradually changes this vector to a target.</summary>
        /// <param name="target">The target vector.</param>
        /// <param name="rate">The rate to go from current to the target.</param>
        public global::Acid.Sharp.Colour SmoothDamp(global::Acid.Sharp.Colour target, global::Acid.Sharp.Colour rate)
        {
            if (ReferenceEquals(target, null))
                throw new global::System.ArgumentNullException("target", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = target.__Instance;
            if (ReferenceEquals(rate, null))
                throw new global::System.ArgumentNullException("rate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rate.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.SmoothDamp((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Colour __op, global::Acid.Sharp.Colour other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Colour;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Colour.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Colour __op, global::Acid.Sharp.Colour other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.Colour __op, global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.Colour __op, global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.Colour __op, global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.Colour __op, global::Acid.Sharp.Colour other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator ==(global::Acid.Sharp.Colour __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return __opNull && valueNull;
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator !=(global::Acid.Sharp.Colour __op, float value)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool valueNull = ReferenceEquals(value, null);
            if (__opNull || valueNull)
                return !(__opNull && valueNull);
            var __arg0 = __op.__Instance;
            var __arg1 = &value;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Colour(global::Acid.Sharp.Vector4 source)
        {
            return new global::Acid.Sharp.Colour(source);
        }

        public static global::Acid.Sharp.Colour operator +(global::Acid.Sharp.Colour left, global::Acid.Sharp.Colour right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator -(global::Acid.Sharp.Colour left, global::Acid.Sharp.Colour right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator *(global::Acid.Sharp.Colour left, global::Acid.Sharp.Colour right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator /(global::Acid.Sharp.Colour left, global::Acid.Sharp.Colour right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator +(float value, global::Acid.Sharp.Colour left)
        {
            var __arg0 = &value;
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = left.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator -(float value, global::Acid.Sharp.Colour left)
        {
            var __arg0 = &value;
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = left.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator *(float value, global::Acid.Sharp.Colour left)
        {
            var __arg0 = &value;
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = left.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator /(float value, global::Acid.Sharp.Colour left)
        {
            var __arg0 = &value;
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = left.__Instance;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator +(global::Acid.Sharp.Colour left, float value)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &value;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator -(global::Acid.Sharp.Colour left, float value)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &value;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator *(global::Acid.Sharp.Colour left, float value)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &value;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour operator /(global::Acid.Sharp.Colour left, float value)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &value;
            var __ret = new global::Acid.Sharp.Colour.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Colour.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Colour Clear
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?CLEAR@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Black
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?BLACK@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Grey
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?GREY@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Silver
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?SILVER@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour White
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?WHITE@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Maroon
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAROON@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Red
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?RED@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Olive
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?OLIVE@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Yellow
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?YELLOW@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Green
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?GREEN@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Lime
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LIME@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Teal
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?TEAL@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Aqua
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?AQUA@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Navy
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NAVY@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Blue
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?BLUE@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Purple
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PURPLE@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Colour Fuchsia
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Colour.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?FUCHSIA@Colour@acid@@2V12@B");
                return global::Acid.Sharp.Colour.__CreateInstance(*__ptr);
            }
        }

        public float this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return *__ret;
            }

            set
            {
                var __arg0 = &index;
                *global::Acid.Sharp.Colour.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = value;
            }
        }

        public float R
        {
            get
            {
                var __ret = __Internal.GetR((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetR((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float G
        {
            get
            {
                var __ret = __Internal.GetG((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetG((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float B
        {
            get
            {
                var __ret = __Internal.GetB((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetB((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float A
        {
            get
            {
                var __ret = __Internal.GetA((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetA((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the length squared of this vector.</summary>
        public float LengthSquared
        {
            get
            {
                var __ret = __Internal.LengthSquared((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the length of this vector.</summary>
        public float Length
        {
            get
            {
                var __ret = __Internal.Length((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets a colour representing the unit value of this colour.</summary>
        public global::Acid.Sharp.Colour Unit
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetUnit((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the hex code from this colour.</summary>
        public string Hex
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetHex((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class VertexModel : global::Acid.Sharp.IVertex, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IVertex;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(20)]
            internal global::Acid.Sharp.Vector2.__Internal m_uv;

            [FieldOffset(28)]
            internal global::Acid.Sharp.Vector3.__Internal m_normal;

            [FieldOffset(40)]
            internal global::Acid.Sharp.Vector3.__Internal m_tangent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModel@acid@@QEAA@AEBVVector3@1@AEBVVector2@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr uv, global::System.IntPtr normal, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModel@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVertexInput@VertexModel@acid@@SA?AVVertexInput@2@AEBI@Z")]
            internal static extern void GetVertexInput(global::System.IntPtr @return, uint* binding);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUv@VertexModel@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetUv(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUv@VertexModel@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetUv(global::System.IntPtr instance, global::System.IntPtr uv);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormal@VertexModel@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetNormal(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormal@VertexModel@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetNormal(global::System.IntPtr instance, global::System.IntPtr normal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTangent@VertexModel@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetTangent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTangent@VertexModel@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetTangent(global::System.IntPtr instance, global::System.IntPtr tangent);
        }

        internal static new global::Acid.Sharp.VertexModel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexModel(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexModel __CreateInstance(global::Acid.Sharp.VertexModel.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexModel(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexModel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexModel.__Internal));
            global::Acid.Sharp.VertexModel.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexModel(global::Acid.Sharp.VertexModel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexModel(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public VertexModel(global::Acid.Sharp.Vector3 position, global::Acid.Sharp.Vector2 uv, global::Acid.Sharp.Vector3 normal, global::Acid.Sharp.Vector3 tangent)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexModel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            if (ReferenceEquals(normal, null))
                throw new global::System.ArgumentNullException("normal", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = normal.__Instance;
            if (ReferenceEquals(tangent, null))
                throw new global::System.ArgumentNullException("tangent", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = tangent.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "Acid.Sharp.VertexModel");
        }

        public VertexModel(global::Acid.Sharp.VertexModel _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexModel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.VertexModel");
        }

        public static global::Acid.Sharp.VertexInput GetVertexInput(uint binding)
        {
            var __arg0 = &binding;
            var __ret = new global::Acid.Sharp.VertexInput.__Internal();
            __Internal.GetVertexInput(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.VertexInput.__CreateInstance(__ret);
        }

        public override global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetPositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
                var ___SetPositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                ___SetPositionDelegate((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector2 Uv
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetUv((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetUv((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Normal
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetNormal((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetNormal((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Tangent
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetTangent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTangent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // Vector3 GetPosition() const override { return m_position; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        // void SetPosition(const Vector3 &position) override { m_position = position; }
        private static global::Delegates.Action_IntPtr_IntPtr _SetPositionDelegateInstance;

        private static void _SetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr position)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.VertexModel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Vector3 __result0;
            if (position == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Vector3.NativeToManagedMap.ContainsKey(position))
                __result0 = (global::Acid.Sharp.Vector3) global::Acid.Sharp.Vector3.NativeToManagedMap[position];
            else __result0 = global::Acid.Sharp.Vector3.__CreateInstance(position);
            __target.Position = __result0;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _SetPositionDelegateInstance += _SetPositionDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetPositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that represents a functional component attached to game object.</summary>
    public unsafe partial class IComponent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IComponent@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IComponent@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGameObject@IComponent@acid@@QEBAPEAVGameObject@2@XZ")]
            internal static extern global::System.IntPtr GetGameObject(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGameObject@IComponent@acid@@QEAAXPEAVGameObject@2@@Z")]
            internal static extern void SetGameObject(global::System.IntPtr instance, global::System.IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsStarted@IComponent@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetStarted(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStarted@IComponent@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetStarted(global::System.IntPtr instance, bool* started);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsEnabled@IComponent@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetEnabled(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnabled@IComponent@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetEnabled(global::System.IntPtr instance, bool* enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRemoved@IComponent@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRemoved(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRemoved@IComponent@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetRemoved(global::System.IntPtr instance, bool* removed);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IComponent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IComponent>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IComponent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IComponent(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IComponent __CreateInstance(global::Acid.Sharp.IComponent.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IComponent(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.IComponent.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IComponent.__Internal));
            global::Acid.Sharp.IComponent.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private IComponent(global::Acid.Sharp.IComponent.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IComponent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public IComponent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IComponent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IComponent");
        }

        public IComponent(global::Acid.Sharp.IComponent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IComponent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IComponent");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IComponent.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Run when starting the component if  is false.</summary>
        public virtual void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Run when updating the game object this is attached to.</summary>
        public virtual void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Used to decode this component from a loaded data format.</summary>
        /// <param name="metadata">The metadata to decode from.</param>
        public virtual void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Used to encode this component into a data format.</summary>
        /// <param name="metadata">The metadata to encode into.</param>
        public virtual void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the game object this components is attached to.</summary>
        /// <param name="gameObject">The new game object this is attached to.</param>
        /// <remarks>Sets the game object this components is attached to.</remarks>
        public global::Acid.Sharp.GameObject GameObject
        {
            get
            {
                var __ret = __Internal.GetGameObject((__Instance + __PointerAdjustment));
                global::Acid.Sharp.GameObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetGameObject((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Started
        {
            get
            {
                var __ret = __Internal.GetStarted((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStarted((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Enabled
        {
            get
            {
                var __ret = __Internal.GetEnabled((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetEnabled((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Removed
        {
            get
            {
                var __ret = __Internal.GetRemoved((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRemoved((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Start() { }
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() { }
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) { }
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const { }
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IComponent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Mesh : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Std.SharedPtr.__Internal m_model;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mesh@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Mesh@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.Mesh __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Mesh(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Mesh __CreateInstance(global::Acid.Sharp.Mesh.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Mesh(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Mesh.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Mesh.__Internal));
            global::Acid.Sharp.Mesh.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Mesh(global::Acid.Sharp.Mesh.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mesh(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Mesh(global::Acid.Sharp.Mesh _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Mesh.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Mesh");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Mesh.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public virtual global::Acid.Sharp.VertexInput GetVertexInput(uint binding)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___GetVertexInputDelegate = (global::Delegates.Action_IntPtr_IntPtr_uintPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_uintPtr));
            var __arg0 = &binding;
            var __ret = new global::Acid.Sharp.VertexInput.__Internal();
            ___GetVertexInputDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.VertexInput.__CreateInstance(__ret);
        }

        public virtual void TrySetModel(string filename)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
            var ___TrySetModelDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            ___TrySetModelDelegate((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // VertexInput GetVertexInput(const uint32_t &binding = 0) const { return VertexModel::GetVertexInput(binding); }
        private static global::Delegates.Action_IntPtr_IntPtr_uintPtr _GetVertexInputDelegateInstance;

        private static void _GetVertexInputDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, uint* binding)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetVertexInput(binding);
            *(global::Acid.Sharp.VertexInput.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.VertexInput.__Internal() : *(global::Acid.Sharp.VertexInput.__Internal*) __ret.__Instance;
        }

        // void TrySetModel(const std::string &filename)
        private static global::Delegates.Action_IntPtr_IntPtr _TrySetModelDelegateInstance;

        private static void _TrySetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Mesh) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.TrySetModel(__stringRet0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetVertexInputDelegateInstance += _GetVertexInputDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetVertexInputDelegateInstance).ToPointer();
                _TrySetModelDelegateInstance += _TrySetModelDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_TrySetModelDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = _Thunks[4];
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                *(void**) (vfptr0 + 64) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class SkeletonLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_armatureData;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_boneOrder;

            [FieldOffset(32)]
            internal uint m_jointCount;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_JointData___N_std_S_default_delete__S0_ m_headJoint;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkeletonLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SkeletonLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJointCount@SkeletonLoader@acid@@QEBAIXZ")]
            internal static extern uint GetJointCount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeadJoint@SkeletonLoader@acid@@QEBAPEAVJointData@2@XZ")]
            internal static extern global::System.IntPtr GetHeadJoint(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SkeletonLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SkeletonLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.SkeletonLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SkeletonLoader(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SkeletonLoader __CreateInstance(global::Acid.Sharp.SkeletonLoader.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SkeletonLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SkeletonLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SkeletonLoader.__Internal));
            global::Acid.Sharp.SkeletonLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SkeletonLoader(global::Acid.Sharp.SkeletonLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SkeletonLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SkeletonLoader(global::Acid.Sharp.SkeletonLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SkeletonLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.SkeletonLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint JointCount
        {
            get
            {
                var __ret = __Internal.GetJointCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.JointData HeadJoint
        {
            get
            {
                var __ret = __Internal.GetHeadJoint((__Instance + __PointerAdjustment));
                global::Acid.Sharp.JointData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.JointData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.JointData) global::Acid.Sharp.JointData.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.JointData.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class SkinLoader : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_skinData;

            [FieldOffset(8)]
            internal uint m_maxWeights;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_jointOrder;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_VertexSkinData___N_std_S_allocator__S0_ m_verticesSkinData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkinLoader@acid@@QEAA@PEAVMetadata@1@AEBI@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr libraryControllers, uint* maxWeights);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SkinLoader@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SkinLoader@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SkinLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SkinLoader>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.SkinLoader __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SkinLoader(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SkinLoader __CreateInstance(global::Acid.Sharp.SkinLoader.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SkinLoader(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SkinLoader.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SkinLoader.__Internal));
            global::Acid.Sharp.SkinLoader.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SkinLoader(global::Acid.Sharp.SkinLoader.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SkinLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SkinLoader(global::Acid.Sharp.Metadata libraryControllers, uint maxWeights)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SkinLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(libraryControllers, null) ? global::System.IntPtr.Zero : libraryControllers.__Instance;
            var __arg1 = &maxWeights;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public SkinLoader(global::Acid.Sharp.SkinLoader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SkinLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.SkinLoader __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>This class represents an animated armature with a skin mesh.</summary>
    public unsafe partial class MeshAnimated : global::Acid.Sharp.Mesh, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(40)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(72)]
            internal global::Std.SharedPtr.__Internal m_model1;

            [FieldOffset(88)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Joint___N_std_S_default_delete__S0_ m_headJoint;

            [FieldOffset(96)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Animator___N_std_S_default_delete__S0_ m_animator;

            [FieldOffset(104)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Animation___N_std_S_default_delete__S0_ m_animation;

            [FieldOffset(112)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Matrix4___N_std_S_allocator__S0_ m_jointMatrices;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshAnimated@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshAnimated@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1MeshAnimated@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.MeshAnimated __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshAnimated(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.MeshAnimated __CreateInstance(global::Acid.Sharp.MeshAnimated.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshAnimated(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.MeshAnimated.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshAnimated.__Internal));
            global::Acid.Sharp.MeshAnimated.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshAnimated(global::Acid.Sharp.MeshAnimated.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshAnimated(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MeshAnimated(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshAnimated");
        }

        public MeshAnimated(global::Acid.Sharp.MeshAnimated _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshAnimated.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshAnimated");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.MeshAnimated.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public override global::Acid.Sharp.VertexInput GetVertexInput(uint binding)
        {
            return base.GetVertexInput(binding);
        }

        public override void TrySetModel(string filename)
        {
            base.TrySetModel(filename);
        }

        public static explicit operator global::Acid.Sharp.MeshAnimated(string filename)
        {
            return new global::Acid.Sharp.MeshAnimated(filename);
        }

        public static global::Acid.Sharp.Matrix4 Correction
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Matrix4.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?CORRECTION@MeshAnimated@acid@@2VMatrix4@2@B");
                return global::Acid.Sharp.Matrix4.__CreateInstance(*__ptr);
            }
        }

        public static uint MaxJoints
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAX_JOINTS@MeshAnimated@acid@@2IB");
                return *__ptr;
            }
        }

        public static uint MaxWeights
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAX_WEIGHTS@MeshAnimated@acid@@2IB");
                return *__ptr;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // VertexInput GetVertexInput(const uint32_t &binding = 0) const { return VertexAnimated::GetVertexInput(binding); }
        private static global::Delegates.Action_IntPtr_IntPtr_uintPtr _GetVertexInputDelegateInstance;

        private static void _GetVertexInputDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, uint* binding)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetVertexInput(binding);
            *(global::Acid.Sharp.VertexInput.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.VertexInput.__Internal() : *(global::Acid.Sharp.VertexInput.__Internal*) __ret.__Instance;
        }

        // void TrySetModel(const std::string &filename) override
        private static global::Delegates.Action_IntPtr_IntPtr _TrySetModelDelegateInstance;

        private static void _TrySetModelDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshAnimated) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.TrySetModel(__stringRet0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetVertexInputDelegateInstance += _GetVertexInputDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetVertexInputDelegateInstance).ToPointer();
                _TrySetModelDelegateInstance += _TrySetModelDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_TrySetModelDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = _Thunks[4];
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
                *(void**) (vfptr0 + 64) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class ALCdevice_struct
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCdevice_struct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCdevice_struct>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::ALCdevice_struct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::ALCdevice_struct(native.ToPointer(), skipVTables);
    }

    internal static global::ALCdevice_struct __CreateInstance(global::ALCdevice_struct.__Internal native, bool skipVTables = false)
    {
        return new global::ALCdevice_struct(native, skipVTables);
    }

    private static void* __CopyValue(global::ALCdevice_struct.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::ALCdevice_struct.__Internal));
        *(global::ALCdevice_struct.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private ALCdevice_struct(global::ALCdevice_struct.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected ALCdevice_struct(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class ALCcontext_struct
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCcontext_struct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ALCcontext_struct>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::ALCcontext_struct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::ALCcontext_struct(native.ToPointer(), skipVTables);
    }

    internal static global::ALCcontext_struct __CreateInstance(global::ALCcontext_struct.__Internal native, bool skipVTables = false)
    {
        return new global::ALCcontext_struct(native, skipVTables);
    }

    private static void* __CopyValue(global::ALCcontext_struct.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::ALCcontext_struct.__Internal));
        *(global::ALCcontext_struct.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private ALCcontext_struct(global::ALCcontext_struct.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected ALCcontext_struct(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public enum SoundType
    {
        General = 0,
        Effect = 1,
        Music = 2
    }

    /// <summary>A module used for loading, managing and playing a variety of different sound types.</summary>
    public unsafe partial class Audio : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::System.IntPtr m_alDevice;

            [FieldOffset(16)]
            internal global::System.IntPtr m_alContext;

            [FieldOffset(24)]
            internal float m_masterGain;

            [FieldOffset(32)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_acid_E_SoundType_f___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__f m_gains;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Audio@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Audio@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Audio@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Audio@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultAl@Audio@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultAl(global::System.IntPtr @return, int* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CheckAl@Audio@acid@@SAXAEBH@Z")]
            internal static extern void CheckAl(int* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTypeGain@Audio@acid@@QEBAMAEBW4SoundType@2@@Z")]
            internal static extern float GetTypeGain(global::System.IntPtr instance, global::Acid.Sharp.SoundType* type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTypeGain@Audio@acid@@QEAAXAEBW4SoundType@2@AEBM@Z")]
            internal static extern void SetTypeGain(global::System.IntPtr instance, global::Acid.Sharp.SoundType* type, float* volume);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMasterGain@Audio@acid@@QEBAMXZ")]
            internal static extern float GetMasterGain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMasterGain@Audio@acid@@QEAAXAEBM@Z")]
            internal static extern void SetMasterGain(global::System.IntPtr instance, float* masterGain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDevice@Audio@acid@@QEBAPEAUALCdevice_struct@@XZ")]
            internal static extern global::System.IntPtr GetDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContext@Audio@acid@@QEBAPEAUALCcontext_struct@@XZ")]
            internal static extern global::System.IntPtr GetContext(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Audio __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Audio(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Audio __CreateInstance(global::Acid.Sharp.Audio.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Audio(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Audio.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Audio.__Internal));
            global::Acid.Sharp.Audio.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Audio(global::Acid.Sharp.Audio.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Audio(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Audio()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Audio");
        }

        public Audio(global::Acid.Sharp.Audio _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Audio");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Audio.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public float GetTypeGain(global::Acid.Sharp.SoundType* type)
        {
            var __ret = __Internal.GetTypeGain((__Instance + __PointerAdjustment), type);
            return __ret;
        }

        public void SetTypeGain(global::Acid.Sharp.SoundType* type, float volume)
        {
            var __arg1 = &volume;
            __Internal.SetTypeGain((__Instance + __PointerAdjustment), type, __arg1);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Audio Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Audio __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Audio.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Audio) global::Acid.Sharp.Audio.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Audio.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultAl(int result)
        {
            var __arg0 = &result;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultAl(new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static void CheckAl(int result)
        {
            var __arg0 = &result;
            __Internal.CheckAl(__arg0);
        }

        public float MasterGain
        {
            get
            {
                var __ret = __Internal.GetMasterGain((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetMasterGain((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::ALCdevice_struct Device
        {
            get
            {
                var __ret = __Internal.GetDevice((__Instance + __PointerAdjustment));
                global::ALCdevice_struct __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ALCdevice_struct.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ALCdevice_struct) global::ALCdevice_struct.NativeToManagedMap[__ret];
                else __result0 = global::ALCdevice_struct.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::ALCcontext_struct Context
        {
            get
            {
                var __ret = __Internal.GetContext((__Instance + __PointerAdjustment));
                global::ALCcontext_struct __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ALCcontext_struct.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ALCcontext_struct) global::ALCcontext_struct.NativeToManagedMap[__ret];
                else __result0 = global::ALCcontext_struct.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Audio) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a sound buffer.</summary>
    public unsafe partial class SoundBuffer : global::Acid.Sharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal uint m_buffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SoundBuffer@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SoundBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SoundBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBuffer@SoundBuffer@acid@@QEBAIXZ")]
            internal static extern uint GetBuffer(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.SoundBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SoundBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SoundBuffer __CreateInstance(global::Acid.Sharp.SoundBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SoundBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SoundBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SoundBuffer.__Internal));
            global::Acid.Sharp.SoundBuffer.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SoundBuffer(global::Acid.Sharp.SoundBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new sound buffer.</summary>
        /// <param name="filename">The file to load the sound buffer from.</param>
        public SoundBuffer(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SoundBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.SoundBuffer");
        }

        public SoundBuffer(global::Acid.Sharp.SoundBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SoundBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.SoundBuffer");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.SoundBuffer.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static explicit operator global::Acid.Sharp.SoundBuffer(string filename)
        {
            return new global::Acid.Sharp.SoundBuffer(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint Buffer
        {
            get
            {
                var __ret = __Internal.GetBuffer((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SoundBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a loaded sound.</summary>
    public unsafe partial class Sound : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Std.SharedPtr.__Internal m_soundBuffer;

            [FieldOffset(40)]
            internal uint m_source;

            [FieldOffset(44)]
            internal global::Acid.Sharp.SoundType m_type;

            [FieldOffset(48)]
            internal float m_gain;

            [FieldOffset(52)]
            internal float m_pitch;

            [FieldOffset(56)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(68)]
            internal global::Acid.Sharp.Vector3.__Internal m_direction;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_velocity;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Sound@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBW4SoundType@1@AEB_N2AEBM3@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, global::Acid.Sharp.SoundType* type, bool* begin, bool* loop, float* gain, float* pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Sound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Sound@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Play@Sound@acid@@QEAAXAEB_N@Z")]
            internal static extern void Play(global::System.IntPtr instance, bool* loop);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Pause@Sound@acid@@QEAAXXZ")]
            internal static extern void Pause(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Resume@Sound@acid@@QEAAXXZ")]
            internal static extern void Resume(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Stop@Sound@acid@@QEAAXXZ")]
            internal static extern void Stop(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Sound@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDirection@Sound@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetDirection(global::System.IntPtr instance, global::System.IntPtr direction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVelocity@Sound@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetVelocity(global::System.IntPtr instance, global::System.IntPtr velocity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetType@Sound@acid@@QEBA?AW4SoundType@2@XZ")]
            internal static extern global::Acid.Sharp.SoundType GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetType@Sound@acid@@QEAAXAEBW4SoundType@2@@Z")]
            internal static extern void SetType(global::System.IntPtr instance, global::Acid.Sharp.SoundType* type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGain@Sound@acid@@QEBAMXZ")]
            internal static extern float GetGain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGain@Sound@acid@@QEAAXAEBM@Z")]
            internal static extern void SetGain(global::System.IntPtr instance, float* gain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPitch@Sound@acid@@QEBAMXZ")]
            internal static extern float GetPitch(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPitch@Sound@acid@@QEAAXAEBM@Z")]
            internal static extern void SetPitch(global::System.IntPtr instance, float* pitch);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPlaying@Sound@acid@@QEAA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetPlaying(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Sound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Sound(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Sound __CreateInstance(global::Acid.Sharp.Sound.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Sound(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Sound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Sound.__Internal));
            global::Acid.Sharp.Sound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Sound(global::Acid.Sharp.Sound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Sound(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Sound(string filename, global::Acid.Sharp.SoundType* type, bool begin, bool loop, float gain, float pitch)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg2 = &begin;
            var __arg3 = &loop;
            var __arg4 = &gain;
            var __arg5 = &pitch;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, type, __arg2, __arg3, __arg4, __arg5);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.Sound");
        }

        public Sound(global::Acid.Sharp.Sound _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Sound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Sound");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Sound.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public void Play(bool loop)
        {
            var __arg0 = &loop;
            __Internal.Play((__Instance + __PointerAdjustment), __arg0);
        }

        public void Pause()
        {
            __Internal.Pause((__Instance + __PointerAdjustment));
        }

        public void Resume()
        {
            __Internal.Resume((__Instance + __PointerAdjustment));
        }

        public void Stop()
        {
            __Internal.Stop((__Instance + __PointerAdjustment));
        }

        public void SetPosition(global::Acid.Sharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetDirection(global::Acid.Sharp.Vector3 direction)
        {
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = direction.__Instance;
            __Internal.SetDirection((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetVelocity(global::Acid.Sharp.Vector3 velocity)
        {
            if (ReferenceEquals(velocity, null))
                throw new global::System.ArgumentNullException("velocity", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = velocity.__Instance;
            __Internal.SetVelocity((__Instance + __PointerAdjustment), __arg0);
        }

        public global::Acid.Sharp.SoundType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetType((__Instance + __PointerAdjustment), &value);
            }
        }

        public float Gain
        {
            get
            {
                var __ret = __Internal.GetGain((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetGain((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Pitch
        {
            get
            {
                var __ret = __Internal.GetPitch((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetPitch((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Playing
        {
            get
            {
                var __ret = __Internal.GetPlaying((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Sound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Sound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Sound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Sound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class GLFWwindow
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWwindow>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::GLFWwindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native.ToPointer(), skipVTables);
    }

    internal static global::GLFWwindow __CreateInstance(global::GLFWwindow.__Internal native, bool skipVTables = false)
    {
        return new global::GLFWwindow(native, skipVTables);
    }

    private static void* __CopyValue(global::GLFWwindow.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::GLFWwindow.__Internal));
        *(global::GLFWwindow.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private GLFWwindow(global::GLFWwindow.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected GLFWwindow(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class GLFWmonitor
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWmonitor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::GLFWmonitor>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::GLFWmonitor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::GLFWmonitor(native.ToPointer(), skipVTables);
    }

    internal static global::GLFWmonitor __CreateInstance(global::GLFWmonitor.__Internal native, bool skipVTables = false)
    {
        return new global::GLFWmonitor(native, skipVTables);
    }

    private static void* __CopyValue(global::GLFWmonitor.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::GLFWmonitor.__Internal));
        *(global::GLFWmonitor.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private GLFWmonitor(global::GLFWmonitor.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected GLFWmonitor(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for the creation, updating and destruction of the display.</summary>
    public unsafe partial class Display : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1936)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal uint m_windowWidth;

            [FieldOffset(12)]
            internal uint m_windowHeight;

            [FieldOffset(16)]
            internal uint m_fullscreenWidth;

            [FieldOffset(20)]
            internal uint m_fullscreenHeight;

            [FieldOffset(24)]
            internal float m_aspectRatio;

            [FieldOffset(28)]
            internal uint m_positionX;

            [FieldOffset(32)]
            internal uint m_positionY;

            [FieldOffset(40)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_title;

            [FieldOffset(72)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_iconPath;

            [FieldOffset(104)]
            internal byte m_antialiasing;

            [FieldOffset(105)]
            internal byte m_borderless;

            [FieldOffset(106)]
            internal byte m_resizable;

            [FieldOffset(107)]
            internal byte m_floating;

            [FieldOffset(108)]
            internal byte m_fullscreen;

            [FieldOffset(109)]
            internal byte m_closed;

            [FieldOffset(110)]
            internal byte m_focused;

            [FieldOffset(111)]
            internal byte m_iconified;

            [FieldOffset(112)]
            internal byte m_validationLayers;

            [FieldOffset(120)]
            internal global::System.IntPtr m_window;

            [FieldOffset(128)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceLayerList;

            [FieldOffset(152)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_instanceExtensionList;

            [FieldOffset(176)]
            internal global::Std.Vector.__Internalc__N_std_S_vector___1C___N_std_S_allocator__S0_ m_deviceExtensionList;

            [FieldOffset(200)]
            internal global::System.IntPtr m_debugReportCallback;

            [FieldOffset(208)]
            internal global::System.IntPtr m_instance;

            [FieldOffset(216)]
            internal global::System.IntPtr m_surface;

            [FieldOffset(224)]
            internal global::VkSurfaceCapabilitiesKHR.__Internal m_surfaceCapabilities;

            [FieldOffset(276)]
            internal global::VkSurfaceFormatKHR.__Internal m_surfaceFormat;

            [FieldOffset(288)]
            internal global::System.IntPtr m_logicalDevice;

            [FieldOffset(296)]
            internal global::VkSampleCountFlagBits m_msaaSamples;

            [FieldOffset(304)]
            internal global::System.IntPtr m_physicalDevice;

            [FieldOffset(312)]
            internal global::VkPhysicalDeviceProperties.__Internal m_physicalDeviceProperties;

            [FieldOffset(1136)]
            internal global::VkPhysicalDeviceFeatures.__Internal m_physicalDeviceFeatures;

            [FieldOffset(1360)]
            internal global::VkPhysicalDeviceMemoryProperties.__Internal m_physicalDeviceMemoryProperties;

            [FieldOffset(1880)]
            internal uint m_supportedQueues;

            [FieldOffset(1884)]
            internal uint m_graphicsFamily;

            [FieldOffset(1888)]
            internal uint m_presentFamily;

            [FieldOffset(1892)]
            internal uint m_computeFamily;

            [FieldOffset(1896)]
            internal uint m_transferFamily;

            [FieldOffset(1904)]
            internal global::System.IntPtr m_graphicsQueue;

            [FieldOffset(1912)]
            internal global::System.IntPtr m_presentQueue;

            [FieldOffset(1920)]
            internal global::System.IntPtr m_computeQueue;

            [FieldOffset(1928)]
            internal global::System.IntPtr m_transferQueue;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Display@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Display@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Display@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@Display@acid@@QEAAXAEBI0@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, uint* width, uint* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Display@acid@@QEAAXAEBI0@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, uint* x, uint* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StringifyResultGlfw@Display@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBH@Z")]
            internal static extern void StringifyResultGlfw(global::System.IntPtr @return, int* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CheckGlfw@Display@acid@@SAXAEBH@Z")]
            internal static extern void CheckGlfw(int* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Display@acid@@QEAAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWidth@Display@acid@@QEAAXAEBI@Z")]
            internal static extern void SetWidth(global::System.IntPtr instance, uint* width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Display@acid@@QEAAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@Display@acid@@QEAAXAEBI@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, uint* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDimensions@Display@acid@@QEAA?AVVector2@2@XZ")]
            internal static extern void GetDimensions(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@Display@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, global::System.IntPtr size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Display@acid@@QEAA?AVVector2@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Display@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTitle@Display@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetTitle(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTitle@Display@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetTitle(global::System.IntPtr instance, global::System.IntPtr title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIcon@Display@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetIcon(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIcon@Display@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetIcon(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAntialiasing@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetAntialiasing(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAntialiasing@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetAntialiasing(global::System.IntPtr instance, bool* antialiasing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsBorderless@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetBorderless(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBorderless@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetBorderless(global::System.IntPtr instance, bool* borderless);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsResizable@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetResizable(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetResizable@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetResizable(global::System.IntPtr instance, bool* resizable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFloating@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetFloating(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFloating@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetFloating(global::System.IntPtr instance, bool* floating);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFullscreen@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetFullscreen(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFullscreen@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetFullscreen(global::System.IntPtr instance, bool* fullscreen);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIconified@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetIconified(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIconified@Display@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetIconified(global::System.IntPtr instance, bool* iconify);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowWidth@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindowHeight@Display@acid@@QEBAIXZ")]
            internal static extern uint GetWindowHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAspectRatio@Display@acid@@QEBAMXZ")]
            internal static extern float GetAspectRatio(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionX@Display@acid@@QEBAIXZ")]
            internal static extern uint GetPositionX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionY@Display@acid@@QEBAIXZ")]
            internal static extern uint GetPositionY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsClosed@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetClosed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFocused@Display@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetFocused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWindow@Display@acid@@QEBAPEAUGLFWwindow@@XZ")]
            internal static extern global::System.IntPtr GetWindow(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetGraphicsFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPresentFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetPresentFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComputeFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetComputeFamily(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransferFamily@Display@acid@@QEBAIXZ")]
            internal static extern uint GetTransferFamily(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Display __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Display(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Display __CreateInstance(global::Acid.Sharp.Display.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Display(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Display.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Display.__Internal));
            global::Acid.Sharp.Display.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Display(global::Acid.Sharp.Display.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Display(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Display()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Display");
        }

        public Display(global::Acid.Sharp.Display _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Display.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Display");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Display.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Sets the window size to a new size.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <param name="height">The new height in pixels.</param>
        public void SetDimensions(uint width, uint height)
        {
            var __arg0 = &width;
            var __arg1 = &height;
            __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Sets the window position to a new position in pixels.</summary>
        /// <param name="x">The new x position in pixels.</param>
        /// <param name="y">The new y position in pixels.</param>
        public void SetPosition(uint x, uint y)
        {
            var __arg0 = &x;
            var __arg1 = &y;
            __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Display Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Display __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Display.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Display) global::Acid.Sharp.Display.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Display.__CreateInstance(__ret);
            return __result0;
        }

        public static string StringifyResultGlfw(int result)
        {
            var __arg0 = &result;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.StringifyResultGlfw(new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static void CheckGlfw(int result)
        {
            var __arg0 = &result;
            __Internal.CheckGlfw(__arg0);
        }

        /// <summary>Gets the width of the window in pixels.</summary>
        /// <param name="width">The new width in pixels.</param>
        /// <remarks>Sets the width of the window in pixels.</remarks>
        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetWidth((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the height of the window in pixels.</summary>
        /// <param name="height">The new height in pixels.</param>
        /// <remarks>Sets the height of the window in pixels.</remarks>
        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetHeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the dimensions of the window in pixels.</summary>
        /// <param name="size">The new width in pixels.</param>
        /// <remarks>Sets the window size to a new size.</remarks>
        public global::Acid.Sharp.Vector2 Dimensions
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetDimensions((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the windows position in pixels.</summary>
        /// <param name="position">The new position in pixels.</param>
        /// <remarks>Sets the window position to a new position in pixels.</remarks>
        public global::Acid.Sharp.Vector2 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the window's title.</summary>
        /// <param name="title">The new title.</param>
        /// <remarks>Sets window title</remarks>
        public string Title
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetTitle((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetTitle((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the window's icon file.</summary>
        /// <param name="filename">The new icon file.</param>
        /// <remarks>Sets window icon image.</remarks>
        public string Icon
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetIcon((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetIcon((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets if the window requests antialiased images.</summary>
        /// <param name="antialiasing">If the window should antialias.</param>
        /// <remarks>Requests the window to antialias.</remarks>
        public bool Antialiasing
        {
            get
            {
                var __ret = __Internal.GetAntialiasing((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetAntialiasing((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is borderless or not.</summary>
        /// <param name="borderless">Weather or not to be borderless.</param>
        /// <remarks>Sets the window to be borderless.</remarks>
        public bool Borderless
        {
            get
            {
                var __ret = __Internal.GetBorderless((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetBorderless((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is resizable or not.</summary>
        /// <param name="resizable">Weather or not to be resizable.</param>
        /// <remarks>Sets the window to be resizable.</remarks>
        public bool Resizable
        {
            get
            {
                var __ret = __Internal.GetResizable((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetResizable((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is floating or not, if floating the window will always display above other windows.</summary>
        /// <param name="floating">Weather or not to be floating.</param>
        /// <remarks>Sets the window to be floating.</remarks>
        public bool Floating
        {
            get
            {
                var __ret = __Internal.GetFloating((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFloating((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets weather the window is fullscreen or not.</summary>
        /// <param name="fullscreen">Weather or not to be fullscreen.</param>
        /// <remarks>Sets the window to be fullscreen or windowed.</remarks>
        public bool Fullscreen
        {
            get
            {
                var __ret = __Internal.GetFullscreen((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFullscreen((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the windows is minimized.</summary>
        /// <param name="iconify">If the window will be set as iconified.</param>
        /// <remarks>Sets the window to be iconified (minimized).</remarks>
        public bool Iconified
        {
            get
            {
                var __ret = __Internal.GetIconified((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetIconified((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the non-fullscreen width of the window in pixels.</summary>
        public uint WindowWidth
        {
            get
            {
                var __ret = __Internal.GetWindowWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the non-fullscreen height of the window in pixels.</summary>
        public uint WindowHeight
        {
            get
            {
                var __ret = __Internal.GetWindowHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the aspect ratio between the windows width and height.</summary>
        public float AspectRatio
        {
            get
            {
                var __ret = __Internal.GetAspectRatio((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position in pixels.</summary>
        public uint PositionX
        {
            get
            {
                var __ret = __Internal.GetPositionX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the windows Y position in pixels.</summary>
        public uint PositionY
        {
            get
            {
                var __ret = __Internal.GetPositionY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the window is closed.</summary>
        public bool Closed
        {
            get
            {
                var __ret = __Internal.GetClosed((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the window is selected.</summary>
        public bool Focused
        {
            get
            {
                var __ret = __Internal.GetFocused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::GLFWwindow Window
        {
            get
            {
                var __ret = __Internal.GetWindow((__Instance + __PointerAdjustment));
                global::GLFWwindow __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::GLFWwindow.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::GLFWwindow) global::GLFWwindow.NativeToManagedMap[__ret];
                else __result0 = global::GLFWwindow.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint GraphicsFamily
        {
            get
            {
                var __ret = __Internal.GetGraphicsFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint PresentFamily
        {
            get
            {
                var __ret = __Internal.GetPresentFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint ComputeFamily
        {
            get
            {
                var __ret = __Internal.GetComputeFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint TransferFamily
        {
            get
            {
                var __ret = __Internal.GetTransferFamily((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Display) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Display
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackError@acid@@YAXHPEBD@Z")]
            internal static extern void CallbackError(int error, [MarshalAs(UnmanagedType.LPStr)] string description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackMonitor@acid@@YAXPEAUGLFWmonitor@@H@Z")]
            internal static extern void CallbackMonitor(global::System.IntPtr monitor, int @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackClose@acid@@YAXPEAUGLFWwindow@@@Z")]
            internal static extern void CallbackClose(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFocus@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackFocus(global::System.IntPtr window, int focused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackPosition@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackPosition(global::System.IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackSize@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackSize(global::System.IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackIconify@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackIconify(global::System.IntPtr window, int iconified);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackFrame@acid@@YAXPEAUGLFWwindow@@HH@Z")]
            internal static extern void CallbackFrame(global::System.IntPtr window, int width, int height);
        }

        public static void CallbackError(int error, string description)
        {
            __Internal.CallbackError(error, description);
        }

        public static void CallbackMonitor(global::GLFWmonitor monitor, int @event)
        {
            var __arg0 = ReferenceEquals(monitor, null) ? global::System.IntPtr.Zero : monitor.__Instance;
            __Internal.CallbackMonitor(__arg0, @event);
        }

        public static void CallbackClose(global::GLFWwindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackClose(__arg0);
        }

        public static void CallbackFocus(global::GLFWwindow window, int focused)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFocus(__arg0, focused);
        }

        public static void CallbackPosition(global::GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackPosition(__arg0, xpos, ypos);
        }

        public static void CallbackSize(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackSize(__arg0, width, height);
        }

        public static void CallbackIconify(global::GLFWwindow window, int iconified)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackIconify(__arg0, iconified);
        }

        public static void CallbackFrame(global::GLFWwindow window, int width, int height)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackFrame(__arg0, width, height);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A simple event listener and runner.</summary>
    public unsafe abstract partial class IEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IEvent@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IEvent@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IEvent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IEvent>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IEvent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IEventInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IEvent __CreateInstance(global::Acid.Sharp.IEvent.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IEventInternal(native, skipVTables);
        }

        protected IEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IEvent");
        }

        protected IEvent(global::Acid.Sharp.IEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IEvent.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IEvent");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IEvent.__Internal*) __Instance)->vfptr_IEvent = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Run when a event has occurred.</summary>
        public abstract void OnEvent();

        /// <summary>Gets if the event has occurred.</summary>
        public abstract bool EventTriggered
        {
            get;
        }

        /// <summary>Gets if the event is removed after it has run once.</summary>
        public abstract bool RemoveAfterEvent
        {
            get;
        }

        #region Virtual table interop

        // bool EventTriggered() = 0
        private static global::Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() = 0
        private static global::Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() = 0
        private static global::Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IEvent) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IEventInternal : global::Acid.Sharp.IEvent, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IEvent.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IEvent.__Internal));
            *(global::Acid.Sharp.IEvent.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IEventInternal(global::Acid.Sharp.IEvent.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IEventInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Run when a event has occurred.</summary>
        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___OnEventDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if the event has occurred.</summary>
        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___EventTriggeredDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the event is removed after it has run once.</summary>
        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___RemoveAfterEventDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for managing events on engine updates.</summary>
    public unsafe partial class Events : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IEvent___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_events;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Events@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Events@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Events@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Events@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddEvent@Events@acid@@QEAAPEAVIEvent@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddEvent(global::System.IntPtr instance, global::System.IntPtr @event);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveEvent@Events@acid@@QEAA_NPEAVIEvent@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveEvent(global::System.IntPtr instance, global::System.IntPtr @event);
        }

        internal static new global::Acid.Sharp.Events __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Events(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Events __CreateInstance(global::Acid.Sharp.Events.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Events(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Events.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Events.__Internal));
            global::Acid.Sharp.Events.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Events(global::Acid.Sharp.Events.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Events(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Events()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Events.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Events");
        }

        public Events(global::Acid.Sharp.Events _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Events.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Events");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Events.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Adds an event to the listening list.</summary>
        /// <param name="event">The event to add.</param>
        public global::Acid.Sharp.IEvent AddEvent(global::Acid.Sharp.IEvent @event)
        {
            var __arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = __Internal.AddEvent((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.IEvent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IEvent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IEvent) global::Acid.Sharp.IEvent.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IEvent.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Removes a event to the listening list.</summary>
        /// <param name="event">The event to remove.</param>
        public bool RemoveEvent(global::Acid.Sharp.IEvent @event)
        {
            var __arg0 = ReferenceEquals(@event, null) ? global::System.IntPtr.Zero : @event.__Instance;
            var __ret = __Internal.RemoveEvent((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Events Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Events __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Events.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Events) global::Acid.Sharp.Events.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Events.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Events) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that is the most basic implementation of the event interface.</summary>
    public unsafe partial class EventStandard : global::Acid.Sharp.IEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [FieldOffset(8)]
            internal global::Std.Function.__Internal m_triggered;

            [FieldOffset(72)]
            internal global::Std.Function.__Internal m_onEvent;

            [FieldOffset(136)]
            internal byte m_repeat;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0EventStandard@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1EventStandard@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.EventStandard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.EventStandard(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.EventStandard __CreateInstance(global::Acid.Sharp.EventStandard.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.EventStandard(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.EventStandard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.EventStandard.__Internal));
            global::Acid.Sharp.EventStandard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private EventStandard(global::Acid.Sharp.EventStandard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventStandard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public EventStandard(global::Acid.Sharp.EventStandard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.EventStandard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.EventStandard");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.EventStandard.__Internal*) __Instance)->vfptr_IEvent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___OnEventDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___EventTriggeredDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___RemoveAfterEventDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool EventTriggered() override
        private static global::Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() override
        private static global::Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() override { return !m_repeat; }
        private static global::Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.EventStandard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that runs a event after a time has passed.</summary>
    public unsafe partial class EventTime : global::Acid.Sharp.IEvent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IEvent;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Timer.__Internal m_timer;

            [FieldOffset(24)]
            internal global::Std.Function.__Internal m_onEvent;

            [FieldOffset(88)]
            internal byte m_repeat;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0EventTime@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1EventTime@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.EventTime __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.EventTime(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.EventTime __CreateInstance(global::Acid.Sharp.EventTime.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.EventTime(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.EventTime.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.EventTime.__Internal));
            global::Acid.Sharp.EventTime.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private EventTime(global::Acid.Sharp.EventTime.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected EventTime(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public EventTime(global::Acid.Sharp.EventTime _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.EventTime.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.EventTime");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IEvent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.EventTime.__Internal*) __Instance)->vfptr_IEvent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void OnEvent()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___OnEventDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___OnEventDelegate((__Instance + __PointerAdjustment));
        }

        public override bool EventTriggered
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___EventTriggeredDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___EventTriggeredDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override bool RemoveAfterEvent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___RemoveAfterEventDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___RemoveAfterEventDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool EventTriggered() override
        private static global::Delegates.Func_bool_IntPtr _EventTriggeredDelegateInstance;

        private static bool _EventTriggeredDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.EventTriggered;
            return __ret;
        }

        // void OnEvent() override
        private static global::Delegates.Action_IntPtr _OnEventDelegateInstance;

        private static void _OnEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnEvent();
        }

        // bool RemoveAfterEvent() override { return !m_repeat; }
        private static global::Delegates.Func_bool_IntPtr _RemoveAfterEventDelegateInstance;

        private static bool _RemoveAfterEventDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.EventTime) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RemoveAfterEvent;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _EventTriggeredDelegateInstance += _EventTriggeredDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_EventTriggeredDelegateInstance).ToPointer();
                _OnEventDelegateInstance += _OnEventDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnEventDelegateInstance).ToPointer();
                _RemoveAfterEventDelegateInstance += _RemoveAfterEventDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_RemoveAfterEventDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe abstract partial class IFile : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IFile@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IFile@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IFile> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IFile>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IFile __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IFileInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IFile __CreateInstance(global::Acid.Sharp.IFile.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IFileInternal(native, skipVTables);
        }

        protected IFile(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IFile()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IFile");
        }

        protected IFile(global::Acid.Sharp.IFile _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IFile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IFile");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IFile.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Load();

        public abstract void Save();

        public abstract void Clear();

        public abstract string Filename
        {
            get;

            set;
        }

        public abstract global::Acid.Sharp.Metadata Parent
        {
            get;
        }

        #region Virtual table interop

        // void Load() = 0
        private static global::Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() = 0
        private static global::Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() = 0
        private static global::Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) = 0
        private static global::Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        // Metadata *GetParent() const = 0
        private static global::Delegates.Func_IntPtr_IntPtr _GetParentDelegateInstance;

        private static global::System.IntPtr _GetParentDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IFile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Parent;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
                _GetParentDelegateInstance += _GetParentDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetParentDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IFileInternal : global::Acid.Sharp.IFile, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IFile.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IFile.__Internal));
            *(global::Acid.Sharp.IFile.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IFileInternal(global::Acid.Sharp.IFile.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IFileInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::Acid.Sharp.Metadata Parent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetParentDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetParentDelegate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Metadata __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class RowCsv : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_elements;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RowCsv@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RowCsv@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddElement@RowCsv@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void AddElement(global::System.IntPtr instance, global::System.IntPtr element);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ClearElements@RowCsv@acid@@QEAAXXZ")]
            internal static extern void ClearElements(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RowCsv> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RowCsv>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.RowCsv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RowCsv(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RowCsv __CreateInstance(global::Acid.Sharp.RowCsv.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RowCsv(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RowCsv.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RowCsv.__Internal));
            global::Acid.Sharp.RowCsv.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RowCsv(global::Acid.Sharp.RowCsv.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RowCsv(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RowCsv(global::Acid.Sharp.RowCsv _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RowCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.RowCsv __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddElement(string element)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(element, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.AddElement((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void ClearElements()
        {
            __Internal.ClearElements((__Instance + __PointerAdjustment));
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FileCsv : global::Acid.Sharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal sbyte m_delimiter;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_RowCsv___N_std_S_allocator__S0_ m_rows;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileCsv@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBD@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, sbyte* delimiter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileCsv@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FileCsv@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRow@FileCsv@acid@@QEAAAEAVRowCsv@2@AEBI@Z")]
            internal static extern global::System.IntPtr GetRow(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PushRow@FileCsv@acid@@QEAAXAEBVRowCsv@2@@Z")]
            internal static extern void PushRow(global::System.IntPtr instance, global::System.IntPtr row);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRow@FileCsv@acid@@QEAAXAEBVRowCsv@2@AEBI@Z")]
            internal static extern void SetRow(global::System.IntPtr instance, global::System.IntPtr row, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDelimiter@FileCsv@acid@@QEBADXZ")]
            internal static extern sbyte GetDelimiter(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDelimiter@FileCsv@acid@@QEAAXAEBD@Z")]
            internal static extern void SetDelimiter(global::System.IntPtr instance, sbyte* delimiter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRowCount@FileCsv@acid@@QEBA_KXZ")]
            internal static extern ulong GetRowCount(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.FileCsv __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileCsv(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FileCsv __CreateInstance(global::Acid.Sharp.FileCsv.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileCsv(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FileCsv.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileCsv.__Internal));
            global::Acid.Sharp.FileCsv.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileCsv(global::Acid.Sharp.FileCsv.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileCsv(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FileCsv(string filename, char delimiter)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = (sbyte*) &delimiter;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.FileCsv");
        }

        public FileCsv(global::Acid.Sharp.FileCsv _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileCsv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FileCsv");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FileCsv.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.RowCsv GetRow(uint index)
        {
            var __arg0 = &index;
            var __ret = __Internal.GetRow((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.RowCsv __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.RowCsv.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.RowCsv) global::Acid.Sharp.RowCsv.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.RowCsv.__CreateInstance(__ret);
            return __result0;
        }

        public void PushRow(global::Acid.Sharp.RowCsv row)
        {
            if (ReferenceEquals(row, null))
                throw new global::System.ArgumentNullException("row", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = row.__Instance;
            __Internal.PushRow((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetRow(global::Acid.Sharp.RowCsv row, uint index)
        {
            if (ReferenceEquals(row, null))
                throw new global::System.ArgumentNullException("row", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = row.__Instance;
            var __arg1 = &index;
            __Internal.SetRow((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public char Delimiter
        {
            get
            {
                var __ret = __Internal.GetDelimiter((__Instance + __PointerAdjustment));
                return global::System.Convert.ToChar(__ret);
            }

            set
            {
                var __arg0 = (sbyte*) &value;
                __Internal.SetDelimiter((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::Acid.Sharp.Metadata Parent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetParentDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetParentDelegate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Metadata __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
                return __result0;
            }
        }

        public ulong RowCount
        {
            get
            {
                var __ret = __Internal.GetRowCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Load() override
        private static global::Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) override { m_filename = filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        // Metadata *GetParent() const override { return nullptr; }
        private static global::Delegates.Func_IntPtr_IntPtr _GetParentDelegateInstance;

        private static global::System.IntPtr _GetParentDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileCsv) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Parent;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
                _GetParentDelegateInstance += _GetParentDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetParentDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class JsonSection : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_JsonSection___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_content;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JsonSection@acid@@QEAA@PEAV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr name, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0JsonSection@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1JsonSection@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@JsonSection@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@JsonSection@acid@@SAPEAVMetadata@2@AEBV12@PEAV32@AEB_N@Z")]
            internal static extern global::System.IntPtr Convert(global::System.IntPtr source, global::System.IntPtr parent, bool* isTopSection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@JsonSection@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@JsonSection@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContent@JsonSection@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetContent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetContent@JsonSection@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetContent(global::System.IntPtr instance, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@JsonSection@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JsonSection> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.JsonSection>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.JsonSection __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JsonSection(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.JsonSection __CreateInstance(global::Acid.Sharp.JsonSection.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.JsonSection(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.JsonSection.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JsonSection.__Internal));
            global::Acid.Sharp.JsonSection.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private JsonSection(global::Acid.Sharp.JsonSection.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected JsonSection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public JsonSection(global::Acid.Sharp.JsonSection parent, string name, string content)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JsonSection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(name, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(content, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public JsonSection(global::Acid.Sharp.JsonSection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.JsonSection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.JsonSection __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddChild(global::Acid.Sharp.JsonSection child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public static global::Acid.Sharp.Metadata Convert(global::Acid.Sharp.JsonSection source, global::Acid.Sharp.Metadata parent, bool isTopSection)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg1 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __arg2 = &isTopSection;
            var __ret = __Internal.Convert(__arg0, __arg1, __arg2);
            global::Acid.Sharp.Metadata __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
            return __result0;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Content
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetContent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetContent((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::Acid.Sharp.JsonSection Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::Acid.Sharp.JsonSection __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.JsonSection.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.JsonSection) global::Acid.Sharp.JsonSection.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.JsonSection.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FileJson : global::Acid.Sharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Metadata___N_std_S_default_delete__S0_ m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileJson@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileJson@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FileJson@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChild@FileJson@acid@@QEBAPEAVMetadata@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetChild(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::Acid.Sharp.FileJson __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileJson(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FileJson __CreateInstance(global::Acid.Sharp.FileJson.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileJson(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FileJson.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileJson.__Internal));
            global::Acid.Sharp.FileJson.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileJson(global::Acid.Sharp.FileJson.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileJson(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FileJson(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileJson.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.FileJson");
        }

        public FileJson(global::Acid.Sharp.FileJson _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileJson.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FileJson");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FileJson.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.Metadata GetChild(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetChild((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.Metadata __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
            return __result0;
        }

        public static explicit operator global::Acid.Sharp.FileJson(string filename)
        {
            return new global::Acid.Sharp.FileJson(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::Acid.Sharp.Metadata Parent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetParentDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetParentDelegate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Metadata __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Load() override
        private static global::Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) override { m_filename = filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        // Metadata *GetParent() const override { return m_parent.get(); }
        private static global::Delegates.Func_IntPtr_IntPtr _GetParentDelegateInstance;

        private static global::System.IntPtr _GetParentDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileJson) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Parent;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
                _GetParentDelegateInstance += _GetParentDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetParentDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FileXml : global::Acid.Sharp.IFile, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IFile;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Metadata___N_std_S_default_delete__S0_ m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileXml@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileXml@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FileXml@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChild@FileXml@acid@@QEBAPEAVMetadata@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetChild(global::System.IntPtr instance, global::System.IntPtr name);
        }

        internal static new global::Acid.Sharp.FileXml __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileXml(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FileXml __CreateInstance(global::Acid.Sharp.FileXml.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileXml(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FileXml.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileXml.__Internal));
            global::Acid.Sharp.FileXml.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FileXml(global::Acid.Sharp.FileXml.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileXml(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FileXml(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileXml.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.FileXml");
        }

        public FileXml(global::Acid.Sharp.FileXml _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileXml.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FileXml");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IFile __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FileXml.__Internal*) __Instance)->vfptr_IFile = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Load()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___LoadDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___LoadDelegate((__Instance + __PointerAdjustment));
        }

        public override void Save()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___SaveDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___SaveDelegate((__Instance + __PointerAdjustment));
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___ClearDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.Metadata GetChild(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetChild((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.Metadata __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
            return __result0;
        }

        public static explicit operator global::Acid.Sharp.FileXml(string filename)
        {
            return new global::Acid.Sharp.FileXml(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___SetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                ___SetFilenameDelegate((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public override global::Acid.Sharp.Metadata Parent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetParentDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetParentDelegate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Metadata __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Load() override
        private static global::Delegates.Action_IntPtr _LoadDelegateInstance;

        private static void _LoadDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Load();
        }

        // void Save() override
        private static global::Delegates.Action_IntPtr _SaveDelegateInstance;

        private static void _SaveDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Save();
        }

        // void Clear() override
        private static global::Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // std::string GetFilename() const override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // void SetFilename(const std::string &filename) override { m_filename = filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _SetFilenameDelegateInstance;

        private static void _SetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.Filename = __stringRet0;
        }

        // Metadata *GetParent() const override { return m_parent.get(); }
        private static global::Delegates.Func_IntPtr_IntPtr _GetParentDelegateInstance;

        private static global::System.IntPtr _GetParentDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FileXml) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Parent;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _LoadDelegateInstance += _LoadDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_LoadDelegateInstance).ToPointer();
                _SaveDelegateInstance += _SaveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SaveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _SetFilenameDelegateInstance += _SetFilenameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetFilenameDelegateInstance).ToPointer();
                _GetParentDelegateInstance += _GetParentDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetParentDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class XmlNode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_XmlNode___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_attributes;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_content;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0XmlNode@acid@@QEAA@PEAV01@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr attributes, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0XmlNode@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1XmlNode@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@XmlNode@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@XmlNode@acid@@SAPEAVMetadata@2@AEBV12@PEAV32@AEB_N@Z")]
            internal static extern global::System.IntPtr Convert(global::System.IntPtr source, global::System.IntPtr parent, bool* isTopSection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttributes@XmlNode@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetAttributes(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAttributes@XmlNode@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetAttributes(global::System.IntPtr instance, global::System.IntPtr attributes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContent@XmlNode@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetContent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetContent@XmlNode@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetContent(global::System.IntPtr instance, global::System.IntPtr content);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@XmlNode@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.XmlNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.XmlNode>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.XmlNode __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.XmlNode(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.XmlNode __CreateInstance(global::Acid.Sharp.XmlNode.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.XmlNode(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.XmlNode.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.XmlNode.__Internal));
            global::Acid.Sharp.XmlNode.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private XmlNode(global::Acid.Sharp.XmlNode.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected XmlNode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public XmlNode(global::Acid.Sharp.XmlNode parent, string attributes, string content)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.XmlNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(attributes, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(content, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public XmlNode(global::Acid.Sharp.XmlNode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.XmlNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.XmlNode __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddChild(global::Acid.Sharp.XmlNode child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public static global::Acid.Sharp.Metadata Convert(global::Acid.Sharp.XmlNode source, global::Acid.Sharp.Metadata parent, bool isTopSection)
        {
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            var __arg1 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            var __arg2 = &isTopSection;
            var __ret = __Internal.Convert(__arg0, __arg1, __arg2);
            global::Acid.Sharp.Metadata __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
            return __result0;
        }

        public string Attributes
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetAttributes((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetAttributes((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Content
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetContent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetContent((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::Acid.Sharp.XmlNode Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::Acid.Sharp.XmlNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.XmlNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.XmlNode) global::Acid.Sharp.XmlNode.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.XmlNode.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Simple data structure class holding information about a certain glyph in the font texture atlas. All sizes are for a font-size of 1.</summary>
    public unsafe partial class FontCharacter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_id;

            [FieldOffset(4)]
            internal float m_textureCoordX;

            [FieldOffset(8)]
            internal float m_textureCoordY;

            [FieldOffset(12)]
            internal float m_maxTextureCoordX;

            [FieldOffset(16)]
            internal float m_maxTextureCoordY;

            [FieldOffset(20)]
            internal float m_offsetX;

            [FieldOffset(24)]
            internal float m_offsetY;

            [FieldOffset(28)]
            internal float m_sizeX;

            [FieldOffset(32)]
            internal float m_sizeY;

            [FieldOffset(36)]
            internal float m_advanceX;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontCharacter@acid@@QEAA@AEBHAEBM11111111@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int* id, float* textureCoordX, float* textureCoordY, float* textureSizeX, float* textureSizeY, float* offsetX, float* offsetY, float* sizeX, float* sizeY, float* advanceX);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontCharacter@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetId@FontCharacter@acid@@QEBAHXZ")]
            internal static extern int GetId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureCoordX@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetTextureCoordX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureCoordY@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetTextureCoordY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxTextureCoordX@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetMaxTextureCoordX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxTextureCoordY@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetMaxTextureCoordY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffsetX@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetOffsetX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOffsetY@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetOffsetY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSizeX@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetSizeX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSizeY@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetSizeY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAdvanceX@FontCharacter@acid@@QEBAMXZ")]
            internal static extern float GetAdvanceX(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FontCharacter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FontCharacter>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.FontCharacter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontCharacter(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FontCharacter __CreateInstance(global::Acid.Sharp.FontCharacter.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontCharacter(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FontCharacter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontCharacter.__Internal));
            *(global::Acid.Sharp.FontCharacter.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FontCharacter(global::Acid.Sharp.FontCharacter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontCharacter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new character.</summary>
        /// <param name="sizeY">The height of the character's quad in screen space.</param>
        /// <param name="sizeX">The width of the character's quad in screen space.</param>
        /// <param name="offsetY">The y distance from the cursor to the top edge of the character's quad.</param>
        /// <param name="offsetX">The x distance from the cursor to the left edge of the character's quad.</param>
        /// <param name="advanceX">How far in pixels the cursor should advance after adding this character.</param>
        /// <param name="textureSizeX">The width of the character in the texture atlas.</param>
        /// <param name="textureSizeY">The height of the character in the texture atlas.</param>
        /// <param name="textureCoordY">The y texture coordinate for the top left corner of the character in the texture atlas.</param>
        /// <param name="textureCoordX">The x texture coordinate for the top left corner of the character in the texture atlas.</param>
        /// <param name="id">The ASCII value of the character.</param>
        public FontCharacter(int id, float textureCoordX, float textureCoordY, float textureSizeX, float textureSizeY, float offsetX, float offsetY, float sizeX, float sizeY, float advanceX)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontCharacter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &id;
            var __arg1 = &textureCoordX;
            var __arg2 = &textureCoordY;
            var __arg3 = &textureSizeX;
            var __arg4 = &textureSizeY;
            var __arg5 = &offsetX;
            var __arg6 = &offsetY;
            var __arg7 = &sizeX;
            var __arg8 = &sizeY;
            var __arg9 = &advanceX;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9);
        }

        public FontCharacter(global::Acid.Sharp.FontCharacter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontCharacter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.FontCharacter.__Internal*) __Instance) = *((global::Acid.Sharp.FontCharacter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FontCharacter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Id
        {
            get
            {
                var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float TextureCoordX
        {
            get
            {
                var __ret = __Internal.GetTextureCoordX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float TextureCoordY
        {
            get
            {
                var __ret = __Internal.GetTextureCoordY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float MaxTextureCoordX
        {
            get
            {
                var __ret = __Internal.GetMaxTextureCoordX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float MaxTextureCoordY
        {
            get
            {
                var __ret = __Internal.GetMaxTextureCoordY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float OffsetX
        {
            get
            {
                var __ret = __Internal.GetOffsetX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float OffsetY
        {
            get
            {
                var __ret = __Internal.GetOffsetY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float SizeX
        {
            get
            {
                var __ret = __Internal.GetSizeX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float SizeY
        {
            get
            {
                var __ret = __Internal.GetSizeY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float AdvanceX
        {
            get
            {
                var __ret = __Internal.GetAdvanceX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>During the loading of a text this represents one word in the text.</summary>
    public unsafe partial class FontWord : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_FontCharacter___N_std_S_allocator__S0_ m_characters;

            [FieldOffset(24)]
            internal float m_width;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontWord@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontWord@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontWord@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddCharacter@FontWord@acid@@QEAA_NAEBVFontCharacter@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddCharacter(global::System.IntPtr instance, global::System.IntPtr character, float* kerning);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@FontWord@acid@@QEBAMXZ")]
            internal static extern float GetWidth(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FontWord> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FontWord>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.FontWord __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontWord(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FontWord __CreateInstance(global::Acid.Sharp.FontWord.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontWord(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FontWord.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontWord.__Internal));
            global::Acid.Sharp.FontWord.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontWord(global::Acid.Sharp.FontWord.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontWord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new text word.</summary>
        public FontWord()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontWord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public FontWord(global::Acid.Sharp.FontWord _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontWord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FontWord __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds a character to the end of the current word and increases the screen-space width of the word.</summary>
        /// <param name="character">The character to be added.</param>
        /// <param name="kerning">The character kerning.</param>
        public bool AddCharacter(global::Acid.Sharp.FontCharacter character, float kerning)
        {
            if (ReferenceEquals(character, null))
                throw new global::System.ArgumentNullException("character", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = character.__Instance;
            var __arg1 = &kerning;
            var __ret = __Internal.AddCharacter((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        public float Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a line of text during the loading of a text.</summary>
    public unsafe partial class FontLine : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_maxLength;

            [FieldOffset(4)]
            internal float m_spaceSize;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_FontWord___N_std_S_allocator__S0_ m_words;

            [FieldOffset(32)]
            internal float m_currentWordsLength;

            [FieldOffset(36)]
            internal float m_currentLineLength;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontLine@acid@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* spaceWidth, float* maxLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontLine@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontLine@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddWord@FontLine@acid@@QEAA_NAEBVFontWord@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddWord(global::System.IntPtr instance, global::System.IntPtr word);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxLength@FontLine@acid@@QEBAMXZ")]
            internal static extern float GetMaxLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpaceSize@FontLine@acid@@QEBAMXZ")]
            internal static extern float GetSpaceSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentWordsLength@FontLine@acid@@QEBAMXZ")]
            internal static extern float GetCurrentWordsLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentLineLength@FontLine@acid@@QEBAMXZ")]
            internal static extern float GetCurrentLineLength(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FontLine> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FontLine>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.FontLine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontLine(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FontLine __CreateInstance(global::Acid.Sharp.FontLine.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontLine(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FontLine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontLine.__Internal));
            global::Acid.Sharp.FontLine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontLine(global::Acid.Sharp.FontLine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontLine(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new text line.</summary>
        /// <param name="spaceWidth">The screen-space width of a space character.</param>
        /// <param name="maxLength">The screen-space maximum length of a line.</param>
        public FontLine(float spaceWidth, float maxLength)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &spaceWidth;
            var __arg1 = &maxLength;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public FontLine(global::Acid.Sharp.FontLine _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FontLine __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attempt to add a word to the line. If the line can fit the word in without reaching the maximum line length then the word is added and the line length increased.</summary>
        /// <param name="word">The word to try to add.</param>
        public bool AddWord(global::Acid.Sharp.FontWord word)
        {
            if (ReferenceEquals(word, null))
                throw new global::System.ArgumentNullException("word", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = word.__Instance;
            var __ret = __Internal.AddWord((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public float MaxLength
        {
            get
            {
                var __ret = __Internal.GetMaxLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float SpaceSize
        {
            get
            {
                var __ret = __Internal.GetSpaceSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float CurrentWordsLength
        {
            get
            {
                var __ret = __Internal.GetCurrentWordsLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float CurrentLineLength
        {
            get
            {
                var __ret = __Internal.GetCurrentLineLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Provides functionality for getting the values from a font file.</summary>
    public unsafe partial class FontMetafile : global::Acid.Sharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.Map.__Internalc__N_std_S_map__I___N_acid_S_FontCharacter___N_std_S_less__I___N_std_S_allocator____N_std_S_pair__1I_S0_ m_metadata;

            [FieldOffset(24)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S0____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S0_ m_values;

            [FieldOffset(40)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(72)]
            internal float m_verticalPerPixelSize;

            [FieldOffset(76)]
            internal float m_horizontalPerPixelSize;

            [FieldOffset(80)]
            internal int m_imageWidth;

            [FieldOffset(84)]
            internal float m_spaceWidth;

            [FieldOffset(88)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__I___N_std_S_allocator__I m_padding;

            [FieldOffset(112)]
            internal int m_paddingWidth;

            [FieldOffset(116)]
            internal int m_paddingHeight;

            [FieldOffset(120)]
            internal float m_maxSizeY;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontMetafile@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontMetafile@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontMetafile@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpaceWidth@FontMetafile@acid@@QEBAMXZ")]
            internal static extern float GetSpaceWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxSizeY@FontMetafile@acid@@QEBAMXZ")]
            internal static extern float GetMaxSizeY(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.FontMetafile __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontMetafile(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FontMetafile __CreateInstance(global::Acid.Sharp.FontMetafile.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontMetafile(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FontMetafile.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontMetafile.__Internal));
            global::Acid.Sharp.FontMetafile.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontMetafile(global::Acid.Sharp.FontMetafile.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontMetafile(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new meta file.</summary>
        /// <param name="filename">The font file to load from.</param>
        public FontMetafile(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontMetafile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.FontMetafile");
        }

        public FontMetafile(global::Acid.Sharp.FontMetafile _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontMetafile.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FontMetafile");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FontMetafile.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static explicit operator global::Acid.Sharp.FontMetafile(string filename)
        {
            return new global::Acid.Sharp.FontMetafile(filename);
        }

        public static uint PadTop
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PAD_TOP@FontMetafile@acid@@2IB");
                return *__ptr;
            }
        }

        public static uint PadLeft
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PAD_LEFT@FontMetafile@acid@@2IB");
                return *__ptr;
            }
        }

        public static uint PadBottom
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PAD_BOTTOM@FontMetafile@acid@@2IB");
                return *__ptr;
            }
        }

        public static uint PadRight
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?PAD_RIGHT@FontMetafile@acid@@2IB");
                return *__ptr;
            }
        }

        public static int DesiredPadding
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DESIRED_PADDING@FontMetafile@acid@@2HB");
                return *__ptr;
            }
        }

        public static string Splitter
        {
            get
            {
                var __ptr = (global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?SPLITTER@FontMetafile@acid@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B");
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(*__ptr);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public static string NumberSeparator
        {
            get
            {
                var __ptr = (global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NUMBER_SEPARATOR@FontMetafile@acid@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B");
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(*__ptr);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public static float LineHeight
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LINE_HEIGHT@FontMetafile@acid@@2MB");
                return *__ptr;
            }
        }

        public static int SpaceAscii
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?SPACE_ASCII@FontMetafile@acid@@2HB");
                return *__ptr;
            }
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public float SpaceWidth
        {
            get
            {
                var __ret = __Internal.GetSpaceWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float MaxSizeY
        {
            get
            {
                var __ret = __Internal.GetMaxSizeY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FontMetafile) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial interface IIDescriptor : IDisposable
    {
        void Dispose();

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToIDescriptor { get; }
    }

    public unsafe abstract partial class IDescriptor : global::Acid.Sharp.IIDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDescriptor@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDescriptor@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IIDescriptor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IIDescriptor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IDescriptor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IDescriptorInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IDescriptor __CreateInstance(global::Acid.Sharp.IDescriptor.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IDescriptorInternal(native, skipVTables);
        }

        protected IDescriptor(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        protected IDescriptor()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance));
        }

        protected IDescriptor(global::Acid.Sharp.IIDescriptor _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToIDescriptor;
            __Internal.cctor((__Instance), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IIDescriptor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr __PointerToIDescriptor
        {
            get
            {
                return __Instance + 0;
            }
        }
    }

    public unsafe partial class IDescriptorInternal : global::Acid.Sharp.IDescriptor, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IDescriptor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IDescriptor.__Internal));
            *(global::Acid.Sharp.IDescriptor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IDescriptorInternal(global::Acid.Sharp.IDescriptor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IDescriptorInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a loaded texture.</summary>
    public unsafe partial class Texture : global::Acid.Sharp.IResource, global::Acid.Sharp.IIDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 152)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(16)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(48)]
            internal global::VkFilter m_filter;

            [FieldOffset(52)]
            internal global::VkSamplerAddressMode m_addressMode;

            [FieldOffset(56)]
            internal byte m_anisotropic;

            [FieldOffset(60)]
            internal uint m_mipLevels;

            [FieldOffset(64)]
            internal global::VkSampleCountFlagBits m_samples;

            [FieldOffset(68)]
            internal global::VkImageLayout m_imageLayout;

            [FieldOffset(72)]
            internal uint m_components;

            [FieldOffset(76)]
            internal uint m_width;

            [FieldOffset(80)]
            internal uint m_height;

            [FieldOffset(88)]
            internal global::System.IntPtr m_image;

            [FieldOffset(96)]
            internal global::System.IntPtr m_deviceMemory;

            [FieldOffset(104)]
            internal global::System.IntPtr m_imageView;

            [FieldOffset(112)]
            internal global::System.IntPtr m_sampler;

            [FieldOffset(120)]
            internal global::VkFormat m_format;

            [FieldOffset(128)]
            internal global::VkDescriptorImageInfo.__Internal m_imageInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Texture@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Texture@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMipLevels@Texture@acid@@QEBAIXZ")]
            internal static extern uint GetMipLevels(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?LoadPixels@Texture@acid@@SAPEAEAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAI11@Z")]
            internal static extern byte* LoadPixels(global::System.IntPtr filename, uint* width, uint* height, uint* components);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WritePixels@Texture@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEBXAEBH22@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WritePixels(global::System.IntPtr filename, global::System.IntPtr data, int* width, int* height, int* components);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeletePixels@Texture@acid@@SAXPEAE@Z")]
            internal static extern void DeletePixels(byte* pixels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMipLevels@Texture@acid@@SAIAEBI0@Z")]
            internal static extern uint GetMipLevels(uint* width, uint* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPixels@Texture@acid@@QEAAPEAEXZ")]
            internal static extern byte* GetPixels(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPixels@Texture@acid@@QEAAXPEAE@Z")]
            internal static extern void SetPixels(global::System.IntPtr instance, byte* pixels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAnisotropic@Texture@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetAnisotropic(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComponents@Texture@acid@@QEBAIXZ")]
            internal static extern uint GetComponents(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Texture@acid@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Texture@acid@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Texture __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Texture(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Texture __CreateInstance(global::Acid.Sharp.Texture.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Texture(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Texture.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Texture.__Internal));
            global::Acid.Sharp.Texture.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Texture(global::Acid.Sharp.Texture.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Texture(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8) };
        }

        public Texture(global::Acid.Sharp.Texture _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Texture.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Texture");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Texture.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            ((global::Acid.Sharp.Texture.__Internal*) __Instance)->vfptr_IDescriptor = new global::System.IntPtr(__OriginalVTables[1]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint GetMipLevels()
        {
            var __ret = __Internal.GetMipLevels((__Instance + __PointerAdjustment));
            return __ret;
        }

        public static byte* LoadPixels(string filename, ref uint width, ref uint height, ref uint components)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            fixed (uint* __refParamPtr1 = &width)
            {
                var __arg1 = __refParamPtr1;
                fixed (uint* __refParamPtr2 = &height)
                {
                    var __arg2 = __refParamPtr2;
                    fixed (uint* __refParamPtr3 = &components)
                    {
                        var __arg3 = __refParamPtr3;
                        var __ret = __Internal.LoadPixels(__arg0, __arg1, __arg2, __arg3);
                        __basicString0.Dispose(false);
                        __allocator0.Dispose();
                        return __ret;
                    }
                }
            }
        }

        public static bool WritePixels(string filename, global::System.IntPtr data, int width, int height, int components)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg2 = &width;
            var __arg3 = &height;
            var __arg4 = &components;
            var __ret = __Internal.WritePixels(__arg0, data, __arg2, __arg3, __arg4);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public static void DeletePixels(byte* pixels)
        {
            __Internal.DeletePixels(pixels);
        }

        public static uint GetMipLevels(uint width, uint height)
        {
            var __arg0 = &width;
            var __arg1 = &height;
            var __ret = __Internal.GetMipLevels(__arg0, __arg1);
            return __ret;
        }

        public global::System.IntPtr __PointerToIDescriptor
        {
            get
            {
                return __Instance + 8;
            }
        }

        /// <summary>Gets a copy of the textures pixels from memory, after usage is finished remember to delete the result.</summary>
        /// <param name="pixels">The pixels to copy to the image.</param>
        /// <remarks>Copies the pixels into this textures memory.</remarks>
        public byte* Pixels
        {
            get
            {
                var __ret = __Internal.GetPixels((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPixels((__Instance + __PointerAdjustment), value);
            }
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public bool Anisotropic
        {
            get
            {
                var __ret = __Internal.GetAnisotropic((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Components
        {
            get
            {
                var __ret = __Internal.GetComponents((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Texture) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[2];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                var vfptr1 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[1] = vfptr1.ToPointer();
                *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 0);
                *(void**) (vfptr1 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 8);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
            *(void**) (__Instance + 8) = __ManagedVTables[1];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A loader capable of loading font data into a instance of a text mesh.</summary>
    public unsafe partial class FontType : global::Acid.Sharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::Std.SharedPtr.__Internal m_texture;

            [FieldOffset(56)]
            internal global::Std.SharedPtr.__Internal m_metadata;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontType@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, global::System.IntPtr fontStyle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FontType@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FontType@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FontType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontType(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FontType __CreateInstance(global::Acid.Sharp.FontType.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FontType(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FontType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontType.__Internal));
            global::Acid.Sharp.FontType.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FontType(global::Acid.Sharp.FontType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FontType(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new text loader.</summary>
        /// <param name="filename">The family file path that the texture atlases and character infos are contained in.</param>
        /// <param name="fontStyle">The style selected to load as this type.</param>
        public FontType(string filename, string fontStyle)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(fontStyle, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.FontType");
        }

        public FontType(global::Acid.Sharp.FontType _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FontType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FontType");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FontType.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_name; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FontType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents the region of space in the modeled world that may appear on the screen.</summary>
    public unsafe partial class Frustum : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_std_S_array__f_Vk4_Vk6 m_frustum;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Frustum@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Frustum@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Frustum@acid@@QEAAXAEBVMatrix4@2@0@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr view, global::System.IntPtr projection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PointInFrustum@Frustum@acid@@QEBA_NAEBVVector3@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PointInFrustum(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SphereInFrustum@Frustum@acid@@QEBA_NAEBVVector3@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SphereInFrustum(global::System.IntPtr instance, global::System.IntPtr position, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CubeInFrustum@Frustum@acid@@QEBA_NAEBVVector3@2@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CubeInFrustum(global::System.IntPtr instance, global::System.IntPtr min, global::System.IntPtr max);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Frustum> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Frustum>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Frustum __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Frustum(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Frustum __CreateInstance(global::Acid.Sharp.Frustum.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Frustum(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Frustum.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Frustum.__Internal));
            *(global::Acid.Sharp.Frustum.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Frustum(global::Acid.Sharp.Frustum.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Frustum(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new frustum.</summary>
        public Frustum()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Frustum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Frustum(global::Acid.Sharp.Frustum _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Frustum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Frustum.__Internal*) __Instance) = *((global::Acid.Sharp.Frustum.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Frustum __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates a frustum from the view and projection matrix.</summary>
        /// <param name="view">The view matrix.</param>
        /// <param name="projection">The projection matrix.</param>
        public void Update(global::Acid.Sharp.Matrix4 view, global::Acid.Sharp.Matrix4 projection)
        {
            if (ReferenceEquals(view, null))
                throw new global::System.ArgumentNullException("view", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = view.__Instance;
            if (ReferenceEquals(projection, null))
                throw new global::System.ArgumentNullException("projection", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = projection.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Is the point contained in the frustum?</summary>
        /// <param name="position">The points position.</param>
        public bool PointInFrustum(global::Acid.Sharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = __Internal.PointInFrustum((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Is the sphere contained in the frustum?</summary>
        /// <param name="position">The points position.</param>
        /// <param name="radius">The spheres radius.</param>
        public bool SphereInFrustum(global::Acid.Sharp.Vector3 position, float radius)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __arg1 = &radius;
            var __ret = __Internal.SphereInFrustum((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Is the cube contained partially in the frustum?</summary>
        /// <param name="min">The point 1st position.</param>
        /// <param name="max">The point 2nd position.</param>
        public bool CubeInFrustum(global::Acid.Sharp.Vector3 min, global::Acid.Sharp.Vector3 max)
        {
            if (ReferenceEquals(min, null))
                throw new global::System.ArgumentNullException("min", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = min.__Instance;
            if (ReferenceEquals(max, null))
                throw new global::System.ArgumentNullException("max", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = max.__Instance;
            var __ret = __Internal.CubeInFrustum((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a 3 dimensional ray.</summary>
    public unsafe partial class Ray : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 348)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_useMouse;

            [FieldOffset(4)]
            internal global::Acid.Sharp.Vector2.__Internal m_screenStart;

            [FieldOffset(12)]
            internal global::Acid.Sharp.Matrix4.__Internal m_viewMatrix;

            [FieldOffset(76)]
            internal global::Acid.Sharp.Matrix4.__Internal m_projectionMatrix;

            [FieldOffset(140)]
            internal global::Acid.Sharp.Vector2.__Internal m_normalizedCoords;

            [FieldOffset(148)]
            internal global::Acid.Sharp.Vector4.__Internal m_clipCoords;

            [FieldOffset(164)]
            internal global::Acid.Sharp.Vector4.__Internal m_eyeCoords;

            [FieldOffset(180)]
            internal global::Acid.Sharp.Matrix4.__Internal m_invertedProjection;

            [FieldOffset(244)]
            internal global::Acid.Sharp.Matrix4.__Internal m_invertedView;

            [FieldOffset(308)]
            internal global::Acid.Sharp.Vector4.__Internal m_rayWorld;

            [FieldOffset(324)]
            internal global::Acid.Sharp.Vector3.__Internal m_origin;

            [FieldOffset(336)]
            internal global::Acid.Sharp.Vector3.__Internal m_currentRay;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ray@acid@@QEAA@AEB_NAEBVVector2@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool* useMouse, global::System.IntPtr screenStart);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ray@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Ray@acid@@QEAAXAEBVVector3@2@AEBVVector2@2@AEBVMatrix4@2@2@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr currentPosition, global::System.IntPtr mousePosition, global::System.IntPtr viewMatrix, global::System.IntPtr projectionMatrix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPointOnRay@Ray@acid@@QEBA?AVVector3@2@AEBM@Z")]
            internal static extern void GetPointOnRay(global::System.IntPtr instance, global::System.IntPtr @return, float* distance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ConvertToScreenSpace@Ray@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void ConvertToScreenSpace(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOrigin@Ray@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetOrigin(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurrentRay@Ray@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetCurrentRay(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Ray> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Ray>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Ray __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Ray(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Ray __CreateInstance(global::Acid.Sharp.Ray.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Ray(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Ray.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Ray.__Internal));
            global::Acid.Sharp.Ray.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Ray(global::Acid.Sharp.Ray.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Ray(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new 3D ray.</summary>
        /// <param name="useMouse">If the ray will use the mouse coords or to start from screenStart.</param>
        /// <param name="screenStart">If useMouse is false then this will be used as the rays start.</param>
        public Ray(bool useMouse, global::Acid.Sharp.Vector2 screenStart)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &useMouse;
            if (ReferenceEquals(screenStart, null))
                throw new global::System.ArgumentNullException("screenStart", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = screenStart.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public Ray(global::Acid.Sharp.Ray _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Ray.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Ray __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the ray to a new position.</summary>
        /// <param name="currentPosition">The new position.</param>
        /// <param name="currentPosition">The mouses xy screen space position.</param>
        /// <param name="viewMatrix">The cameras view matrix.</param>
        /// <param name="projectionMatrix">The projection view matrix.</param>
        public void Update(global::Acid.Sharp.Vector3 currentPosition, global::Acid.Sharp.Vector2 mousePosition, global::Acid.Sharp.Matrix4 viewMatrix, global::Acid.Sharp.Matrix4 projectionMatrix)
        {
            if (ReferenceEquals(currentPosition, null))
                throw new global::System.ArgumentNullException("currentPosition", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = currentPosition.__Instance;
            if (ReferenceEquals(mousePosition, null))
                throw new global::System.ArgumentNullException("mousePosition", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = mousePosition.__Instance;
            if (ReferenceEquals(viewMatrix, null))
                throw new global::System.ArgumentNullException("viewMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = viewMatrix.__Instance;
            if (ReferenceEquals(projectionMatrix, null))
                throw new global::System.ArgumentNullException("projectionMatrix", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = projectionMatrix.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Gets a point on the ray.</summary>
        /// <param name="distance">Distance down the ray to sample.</param>
        public global::Acid.Sharp.Vector3 GetPointOnRay(float distance)
        {
            var __arg0 = &distance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.GetPointOnRay((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Converts a position from world space to screen space.</summary>
        /// <param name="position">The position to convert.</param>
        public global::Acid.Sharp.Vector3 ConvertToScreenSpace(global::Acid.Sharp.Vector3 position)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.ConvertToScreenSpace((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public global::Acid.Sharp.Vector3 Origin
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetOrigin((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector3 CurrentRay
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetCurrentRay((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>This class is used throughout the engine wherever the camera is involved, so that the engine doesn't rely at all on the camera's implementation.</summary>
    public unsafe abstract partial class ICamera : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ICamera;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ICamera@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ICamera@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ICamera> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ICamera>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ICamera __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ICameraInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ICamera __CreateInstance(global::Acid.Sharp.ICamera.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ICameraInternal(native, skipVTables);
        }

        protected ICamera(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected ICamera()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ICamera.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.ICamera");
        }

        protected ICamera(global::Acid.Sharp.ICamera _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ICamera.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ICamera");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ICamera __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ICamera.__Internal*) __Instance)->vfptr_ICamera = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Checks inputs and carries out smooth camera movement. Called before every frame.</summary>
        public abstract void Update();

        /// <summary>Prepares the camera for the reflection render pass.</summary>
        /// <param name="height">The height of the horizontal plane to be reflected over.</param>
        public abstract void ReflectView(float height);

        /// <summary>Gets the distance of the near pane of the view frustum.</summary>
        public abstract float NearPlane
        {
            get;
        }

        /// <summary>Gets the distance of the view frustum's far plane.</summary>
        public abstract float FarPlane
        {
            get;
        }

        /// <summary>Gets the field of view angle for the view frustum.</summary>
        public abstract float Fov
        {
            get;
        }

        /// <summary>Gets the view frustum created by the current camera position and rotation.</summary>
        public abstract global::Acid.Sharp.Frustum ViewFrustum
        {
            get;
        }

        /// <summary>Gets the ray that extends from the cameras position though the screen.</summary>
        public abstract global::Acid.Sharp.Ray ViewRay
        {
            get;
        }

        /// <summary>Gets the view matrix created by the current camera position and rotation.</summary>
        public abstract global::Acid.Sharp.Matrix4 ViewMatrix
        {
            get;
        }

        /// <summary>Gets the projection matrix used in the current scene render.</summary>
        public abstract global::Acid.Sharp.Matrix4 ProjectionMatrix
        {
            get;
        }

        /// <summary>Gets the cameras 3D position in the world.</summary>
        public abstract global::Acid.Sharp.Vector3 Position
        {
            get;
        }

        /// <summary>Gets the cameras 3D velocity in the world.</summary>
        public abstract global::Acid.Sharp.Vector3 Velocity
        {
            get;
        }

        /// <summary>Gets the cameras 3D rotation in the world, where x=pitch, y=yaw, z=roll.</summary>
        public abstract global::Acid.Sharp.Vector3 Rotation
        {
            get;
        }

        #region Virtual table interop

        // void Update() = 0
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void ReflectView(const float &height) = 0
        private static global::Delegates.Action_IntPtr_floatPtr _ReflectViewDelegateInstance;

        private static void _ReflectViewDelegateHook(global::System.IntPtr instance, float* height)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ReflectView(height);
        }

        // float GetNearPlane() const = 0
        private static global::Delegates.Func_float_IntPtr _GetNearPlaneDelegateInstance;

        private static float _GetNearPlaneDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.NearPlane;
            return __ret;
        }

        // float GetFarPlane() const = 0
        private static global::Delegates.Func_float_IntPtr _GetFarPlaneDelegateInstance;

        private static float _GetFarPlaneDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.FarPlane;
            return __ret;
        }

        // float GetFov() const = 0
        private static global::Delegates.Func_float_IntPtr _GetFovDelegateInstance;

        private static float _GetFovDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Fov;
            return __ret;
        }

        // Frustum GetViewFrustum() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetViewFrustumDelegateInstance;

        private static void _GetViewFrustumDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewFrustum;
            *(global::Acid.Sharp.Frustum.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Frustum.__Internal() : *(global::Acid.Sharp.Frustum.__Internal*) __ret.__Instance;
        }

        // Ray GetViewRay() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetViewRayDelegateInstance;

        private static void _GetViewRayDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewRay;
            *(global::Acid.Sharp.Ray.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Ray.__Internal() : *(global::Acid.Sharp.Ray.__Internal*) __ret.__Instance;
        }

        // Matrix4 GetViewMatrix() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetViewMatrixDelegateInstance;

        private static void _GetViewMatrixDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ViewMatrix;
            *(global::Acid.Sharp.Matrix4.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Matrix4.__Internal() : *(global::Acid.Sharp.Matrix4.__Internal*) __ret.__Instance;
        }

        // Matrix4 GetProjectionMatrix() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetProjectionMatrixDelegateInstance;

        private static void _GetProjectionMatrixDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ProjectionMatrix;
            *(global::Acid.Sharp.Matrix4.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Matrix4.__Internal() : *(global::Acid.Sharp.Matrix4.__Internal*) __ret.__Instance;
        }

        // Vector3 GetPosition() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetPositionDelegateInstance;

        private static void _GetPositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Position;
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetVelocity() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetVelocityDelegateInstance;

        private static void _GetVelocityDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Velocity;
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        // Vector3 GetRotation() const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GetRotationDelegateInstance;

        private static void _GetRotationDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ICamera) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Rotation;
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[12];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _ReflectViewDelegateInstance += _ReflectViewDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_ReflectViewDelegateInstance).ToPointer();
                _GetNearPlaneDelegateInstance += _GetNearPlaneDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetNearPlaneDelegateInstance).ToPointer();
                _GetFarPlaneDelegateInstance += _GetFarPlaneDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetFarPlaneDelegateInstance).ToPointer();
                _GetFovDelegateInstance += _GetFovDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetFovDelegateInstance).ToPointer();
                _GetViewFrustumDelegateInstance += _GetViewFrustumDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetViewFrustumDelegateInstance).ToPointer();
                _GetViewRayDelegateInstance += _GetViewRayDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_GetViewRayDelegateInstance).ToPointer();
                _GetViewMatrixDelegateInstance += _GetViewMatrixDelegateHook;
                _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_GetViewMatrixDelegateInstance).ToPointer();
                _GetProjectionMatrixDelegateInstance += _GetProjectionMatrixDelegateHook;
                _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_GetProjectionMatrixDelegateInstance).ToPointer();
                _GetPositionDelegateInstance += _GetPositionDelegateHook;
                _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_GetPositionDelegateInstance).ToPointer();
                _GetVelocityDelegateInstance += _GetVelocityDelegateHook;
                _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_GetVelocityDelegateInstance).ToPointer();
                _GetRotationDelegateInstance += _GetRotationDelegateHook;
                _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_GetRotationDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
                *(void**) (vfptr0 + 56) = _Thunks[6];
                *(void**) (vfptr0 + 64) = _Thunks[7];
                *(void**) (vfptr0 + 72) = _Thunks[8];
                *(void**) (vfptr0 + 80) = _Thunks[9];
                *(void**) (vfptr0 + 88) = _Thunks[10];
                *(void**) (vfptr0 + 96) = _Thunks[11];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ICameraInternal : global::Acid.Sharp.ICamera, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.ICamera.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ICamera.__Internal));
            *(global::Acid.Sharp.ICamera.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ICameraInternal(global::Acid.Sharp.ICamera.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ICameraInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Checks inputs and carries out smooth camera movement. Called before every frame.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Prepares the camera for the reflection render pass.</summary>
        /// <param name="height">The height of the horizontal plane to be reflected over.</param>
        public override void ReflectView(float height)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___ReflectViewDelegate = (global::Delegates.Action_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_floatPtr));
            var __arg0 = &height;
            ___ReflectViewDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the distance of the near pane of the view frustum.</summary>
        public override float NearPlane
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetNearPlaneDelegate = (global::Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr));
                var __ret = ___GetNearPlaneDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the distance of the view frustum's far plane.</summary>
        public override float FarPlane
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
                var ___GetFarPlaneDelegate = (global::Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr));
                var __ret = ___GetFarPlaneDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the field of view angle for the view frustum.</summary>
        public override float Fov
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetFovDelegate = (global::Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr));
                var __ret = ___GetFovDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the view frustum created by the current camera position and rotation.</summary>
        public override global::Acid.Sharp.Frustum ViewFrustum
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
                var ___GetViewFrustumDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Frustum.__Internal();
                ___GetViewFrustumDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Frustum.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the ray that extends from the cameras position though the screen.</summary>
        public override global::Acid.Sharp.Ray ViewRay
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___GetViewRayDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Ray.__Internal();
                ___GetViewRayDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Ray.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the view matrix created by the current camera position and rotation.</summary>
        public override global::Acid.Sharp.Matrix4 ViewMatrix
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 8);
                var ___GetViewMatrixDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                ___GetViewMatrixDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the projection matrix used in the current scene render.</summary>
        public override global::Acid.Sharp.Matrix4 ProjectionMatrix
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 9 * 8);
                var ___GetProjectionMatrixDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                ___GetProjectionMatrixDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the cameras 3D position in the world.</summary>
        public override global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
                var ___GetPositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                ___GetPositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the cameras 3D velocity in the world.</summary>
        public override global::Acid.Sharp.Vector3 Velocity
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 11 * 8);
                var ___GetVelocityDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                ___GetVelocityDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the cameras 3D rotation in the world, where x=pitch, y=yaw, z=roll.</summary>
        public override global::Acid.Sharp.Vector3 Rotation
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 12 * 8);
                var ___GetRotationDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                ___GetRotationDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a sub-renderer in the engine.</summary>
    public unsafe abstract partial class IRenderer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IRenderer@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IRenderer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsEnabled@IRenderer@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetEnabled(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnabled@IRenderer@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetEnabled(global::System.IntPtr instance, bool* enable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsStage@IRenderer@acid@@QEBA?AVGraphicsStage@2@XZ")]
            internal static extern void GetGraphicsStage(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IRenderer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IRenderer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IRenderer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IRendererInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IRenderer __CreateInstance(global::Acid.Sharp.IRenderer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IRendererInternal(native, skipVTables);
        }

        protected IRenderer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new renderer.</summary>
        /// <param name="graphicsStage">The graphics stage this renderer will be used in.</param>
        protected IRenderer(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IRenderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IRenderer");
        }

        protected IRenderer(global::Acid.Sharp.IRenderer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IRenderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IRenderer");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IRenderer.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Called when the renderer is needed to be rendered.</summary>
        /// <param name="clipPlane">The current clip plane.</param>
        /// <param name="camera">The camera to be used when rendering.</param>
        public abstract void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera);

        public bool Enabled
        {
            get
            {
                var __ret = __Internal.GetEnabled((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetEnabled((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.GraphicsStage GraphicsStage
        {
            get
            {
                var __ret = new global::Acid.Sharp.GraphicsStage.__Internal();
                __Internal.GetGraphicsStage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.GraphicsStage.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) = 0
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IRenderer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IRendererInternal : global::Acid.Sharp.IRenderer, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IRenderer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IRenderer.__Internal));
            *(global::Acid.Sharp.IRenderer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IRendererInternal(global::Acid.Sharp.IRenderer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IRendererInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Called when the renderer is needed to be rendered.</summary>
        /// <param name="clipPlane">The current clip plane.</param>
        /// <param name="camera">The camera to be used when rendering.</param>
        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a Vulkan pipeline.</summary>
    public unsafe partial class Pipeline : global::Acid.Sharp.IPipeline, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 664)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPipeline;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal global::Acid.Sharp.PipelineCreate.__Internal m_pipelineCreate;

            [FieldOffset(104)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_ShaderProgram___N_std_S_default_delete__S0_ m_shaderProgram;

            [FieldOffset(112)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____E_VkDynamicState___N_std_S_allocator__S0_ m_dynamicStates;

            [FieldOffset(136)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkShaderModule_T___N_std_S_allocator__S0_ m_modules;

            [FieldOffset(160)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkPipelineShaderStageCreateInfo___N_std_S_allocator__S0_ m_stages;

            [FieldOffset(184)]
            internal global::System.IntPtr m_descriptorSetLayout;

            [FieldOffset(192)]
            internal global::System.IntPtr m_descriptorPool;

            [FieldOffset(200)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(208)]
            internal global::System.IntPtr m_pipelineLayout;

            [FieldOffset(216)]
            internal global::VkPipelineBindPoint m_pipelineBindPoint;

            [FieldOffset(224)]
            internal global::VkPipelineInputAssemblyStateCreateInfo.__Internal m_inputAssemblyState;

            [FieldOffset(256)]
            internal global::VkPipelineRasterizationStateCreateInfo.__Internal m_rasterizationState;

            [FieldOffset(320)]
            internal global::Std.Array.__Internalc__N_std_S_array____S_VkPipelineColorBlendAttachmentState_Vk1 m_blendAttachmentStates;

            [FieldOffset(352)]
            internal global::VkPipelineColorBlendStateCreateInfo.__Internal m_colourBlendState;

            [FieldOffset(408)]
            internal global::VkPipelineDepthStencilStateCreateInfo.__Internal m_depthStencilState;

            [FieldOffset(512)]
            internal global::VkPipelineViewportStateCreateInfo.__Internal m_viewportState;

            [FieldOffset(560)]
            internal global::VkPipelineMultisampleStateCreateInfo.__Internal m_multisampleState;

            [FieldOffset(608)]
            internal global::VkPipelineDynamicStateCreateInfo.__Internal m_dynamicState;

            [FieldOffset(640)]
            internal global::VkPipelineTessellationStateCreateInfo.__Internal m_tessellationState;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Pipeline@acid@@QEAA@AEBVGraphicsStage@1@AEBVPipelineCreate@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, global::System.IntPtr pipelineCreate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Pipeline@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Pipeline@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepthStencil@Pipeline@acid@@QEBAPEAVDepthStencil@2@AEBH@Z")]
            internal static extern global::System.IntPtr GetDepthStencil(global::System.IntPtr instance, int* stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTexture@Pipeline@acid@@QEBAPEAVTexture@2@AEBIAEBH@Z")]
            internal static extern global::System.IntPtr GetTexture(global::System.IntPtr instance, uint* index, int* stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Pipeline@acid@@QEBAIAEBH@Z")]
            internal static extern uint GetWidth(global::System.IntPtr instance, int* stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Pipeline@acid@@QEBAIAEBH@Z")]
            internal static extern uint GetHeight(global::System.IntPtr instance, int* stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipelineCreate@Pipeline@acid@@QEBA?AVPipelineCreate@2@XZ")]
            internal static extern void GetPipelineCreate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsStage@Pipeline@acid@@QEBA?AVGraphicsStage@2@XZ")]
            internal static extern void GetGraphicsStage(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        internal static new global::Acid.Sharp.Pipeline __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Pipeline(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Pipeline __CreateInstance(global::Acid.Sharp.Pipeline.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Pipeline(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Pipeline.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Pipeline.__Internal));
            global::Acid.Sharp.Pipeline.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Pipeline(global::Acid.Sharp.Pipeline.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Pipeline(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new pipeline.</summary>
        /// <param name="graphicsStage">The pipelines graphics stage.</param>
        /// <param name="pipelineCreate">The pipelines creation info.</param>
        public Pipeline(global::Acid.Sharp.GraphicsStage graphicsStage, global::Acid.Sharp.PipelineCreate pipelineCreate)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Pipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            if (ReferenceEquals(pipelineCreate, null))
                throw new global::System.ArgumentNullException("pipelineCreate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipelineCreate.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.Pipeline");
        }

        public Pipeline(global::Acid.Sharp.Pipeline _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Pipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Pipeline");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IPipeline __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Pipeline.__Internal*) __Instance)->vfptr_IPipeline = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.DepthStencil GetDepthStencil(int stage)
        {
            var __arg0 = &stage;
            var __ret = __Internal.GetDepthStencil((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.DepthStencil __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.DepthStencil.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.DepthStencil) global::Acid.Sharp.DepthStencil.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.DepthStencil.__CreateInstance(__ret);
            return __result0;
        }

        public global::Acid.Sharp.Texture GetTexture(uint index, int stage)
        {
            var __arg0 = &index;
            var __arg1 = &stage;
            var __ret = __Internal.GetTexture((__Instance + __PointerAdjustment), __arg0, __arg1);
            global::Acid.Sharp.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Texture) global::Acid.Sharp.Texture.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Texture.__CreateInstance(__ret);
            return __result0;
        }

        public uint GetWidth(int stage)
        {
            var __arg0 = &stage;
            var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public uint GetHeight(int stage)
        {
            var __arg0 = &stage;
            var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override global::Acid.Sharp.ShaderProgram ShaderProgram
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetShaderProgramDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetShaderProgramDelegate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ShaderProgram __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ShaderProgram.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ShaderProgram) global::Acid.Sharp.ShaderProgram.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ShaderProgram.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.PipelineCreate PipelineCreate
        {
            get
            {
                var __ret = new global::Acid.Sharp.PipelineCreate.__Internal();
                __Internal.GetPipelineCreate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.PipelineCreate.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.GraphicsStage GraphicsStage
        {
            get
            {
                var __ret = new global::Acid.Sharp.GraphicsStage.__Internal();
                __Internal.GetGraphicsStage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.GraphicsStage.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ShaderProgram *GetShaderProgram() const override { return m_shaderProgram.get(); }
        private static global::Delegates.Func_IntPtr_IntPtr _GetShaderProgramDelegateInstance;

        private static global::System.IntPtr _GetShaderProgramDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Pipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ShaderProgram;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetShaderProgramDelegateInstance += _GetShaderProgramDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetShaderProgramDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class UniformBuffer : global::Acid.Sharp.IDescriptor, global::Acid.Sharp.IBuffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal global::VkDescriptorBufferInfo.__Internal m_bufferInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBuffer@acid@@QEAA@AEB_K@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong* size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UniformBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UniformBuffer@acid@@QEAAXPEBX@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr newData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Buffer@acid@@QEBA_KXZ")]
            internal static extern ulong GetSize(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.UniformBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UniformBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UniformBuffer __CreateInstance(global::Acid.Sharp.UniformBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UniformBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UniformBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformBuffer.__Internal));
            global::Acid.Sharp.UniformBuffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UniformBuffer(global::Acid.Sharp.UniformBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UniformBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UniformBuffer(ulong size)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &size;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public UniformBuffer(global::Acid.Sharp.UniformBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IIDescriptor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update(global::System.IntPtr newData)
        {
            __Internal.Update((__Instance + __PointerAdjustment), newData);
        }

        public static explicit operator global::Acid.Sharp.UniformBuffer(ulong size)
        {
            return new global::Acid.Sharp.UniformBuffer(ref *size);
        }

        protected ulong MSize
        {
            get
            {
                return ((global::Acid.Sharp.UniformBuffer.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::Acid.Sharp.UniformBuffer.__Internal*)__Instance)->m_size = value;
            }
        }

        public global::System.IntPtr __PointerToBuffer
        {
            get
            {
                return __Instance + 8;
            }
        }

        public ulong Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + 8));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that handles a uniform buffer.</summary>
    public unsafe partial class UniformHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_multipipeline;

            [FieldOffset(8)]
            internal global::System.IntPtr m_uniformBlock;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_UniformBuffer___N_std_S_default_delete__S0_ m_uniformBuffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_data;

            [FieldOffset(32)]
            internal byte m_changed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformHandler@acid@@QEAA@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool* multipipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformHandler@acid@@QEAA@PEAVUniformBlock@1@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr uniformBlock, bool* multipipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UniformHandler@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UniformHandler@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UniformHandler@acid@@QEAA_NPEAVUniformBlock@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Update(global::System.IntPtr instance, global::System.IntPtr uniformBlock);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUniformBuffer@UniformHandler@acid@@QEBAPEAVUniformBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetUniformBuffer(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UniformHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UniformHandler>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.UniformHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UniformHandler(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UniformHandler __CreateInstance(global::Acid.Sharp.UniformHandler.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UniformHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UniformHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformHandler.__Internal));
            *(global::Acid.Sharp.UniformHandler.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UniformHandler(global::Acid.Sharp.UniformHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UniformHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UniformHandler(bool multipipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &multipipeline;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public UniformHandler(global::Acid.Sharp.UniformBlock uniformBlock, bool multipipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(uniformBlock, null) ? global::System.IntPtr.Zero : uniformBlock.__Instance;
            var __arg1 = &multipipeline;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public UniformHandler(global::Acid.Sharp.UniformHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UniformHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.UniformHandler.__Internal*) __Instance) = *((global::Acid.Sharp.UniformHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UniformHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Update(global::Acid.Sharp.UniformBlock uniformBlock)
        {
            var __arg0 = ReferenceEquals(uniformBlock, null) ? global::System.IntPtr.Zero : uniformBlock.__Instance;
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public static explicit operator global::Acid.Sharp.UniformHandler(bool multipipeline)
        {
            return new global::Acid.Sharp.UniformHandler(ref *multipipeline);
        }

        public global::Acid.Sharp.UniformBuffer UniformBuffer
        {
            get
            {
                var __ret = __Internal.GetUniformBuffer((__Instance + __PointerAdjustment));
                global::Acid.Sharp.UniformBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.UniformBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.UniformBuffer) global::Acid.Sharp.UniformBuffer.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.UniformBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a driver that changes over time.</summary>
    public unsafe abstract partial class IDriver : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_actualTime;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_currentTime;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDriver@acid@@QEAA@AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IDriver@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@IDriver@acid@@QEAAMAEBVTime@2@@Z")]
            internal static extern float Update(global::System.IntPtr instance, global::System.IntPtr delta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@IDriver@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetLength(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLength@IDriver@acid@@QEAAXAEBVTime@2@@Z")]
            internal static extern void SetLength(global::System.IntPtr instance, global::System.IntPtr length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetActualTime@IDriver@acid@@IEBA?AVTime@2@XZ")]
            internal static extern void GetActualTime(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IDriver> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IDriver>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IDriver __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IDriverInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IDriver __CreateInstance(global::Acid.Sharp.IDriver.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IDriverInternal(native, skipVTables);
        }

        protected IDriver(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new driver with a length.</summary>
        /// <param name="length">The drivers length.</param>
        protected IDriver(global::Acid.Sharp.Time length)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IDriver.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(length, null))
                throw new global::System.ArgumentNullException("length", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = length.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IDriver");
        }

        protected IDriver(global::Acid.Sharp.IDriver _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IDriver.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IDriver");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IDriver __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IDriver.__Internal*) __Instance)->vfptr_IDriver = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the driver with the passed time.</summary>
        /// <param name="delta">The time between the last update.</param>
        public float Update(global::Acid.Sharp.Time delta)
        {
            if (ReferenceEquals(delta, null))
                throw new global::System.ArgumentNullException("delta", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = delta.__Instance;
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Calculates the new value.</summary>
        /// <param name="time">The time into the drivers life.</param>
        protected abstract float Calculate(float factor);

        /// <summary>Gets the length.</summary>
        /// <param name="length">The new length.</param>
        /// <remarks>Sets the length.</remarks>
        public global::Acid.Sharp.Time Length
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetLength((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLength((__Instance + __PointerAdjustment), __arg0);
            }
        }

        protected global::Acid.Sharp.Time ActualTime
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetActualTime((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // float Calculate(const float &factor) = 0
        private static global::Delegates.Func_float_IntPtr_floatPtr _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float* factor)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IDriver) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(factor);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IDriverInternal : global::Acid.Sharp.IDriver, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IDriver.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IDriver.__Internal));
            *(global::Acid.Sharp.IDriver.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IDriverInternal(global::Acid.Sharp.IDriver.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IDriverInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Calculates the new value.</summary>
        /// <param name="time">The time into the drivers life.</param>
        protected override float Calculate(float factor)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___CalculateDelegate = (global::Delegates.Func_float_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr_floatPtr));
            var __arg0 = &factor;
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class StorageBuffer : global::Acid.Sharp.IDescriptor, global::Acid.Sharp.IBuffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal global::VkDescriptorBufferInfo.__Internal m_bufferInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StorageBuffer@acid@@QEAA@AEB_K@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong* size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StorageBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1StorageBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@StorageBuffer@acid@@QEAAXPEBX@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr newData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Buffer@acid@@QEBA_KXZ")]
            internal static extern ulong GetSize(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.StorageBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.StorageBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.StorageBuffer __CreateInstance(global::Acid.Sharp.StorageBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.StorageBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.StorageBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.StorageBuffer.__Internal));
            global::Acid.Sharp.StorageBuffer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private StorageBuffer(global::Acid.Sharp.StorageBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StorageBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public StorageBuffer(ulong size)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.StorageBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &size;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public StorageBuffer(global::Acid.Sharp.StorageBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.StorageBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IIDescriptor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update(global::System.IntPtr newData)
        {
            __Internal.Update((__Instance + __PointerAdjustment), newData);
        }

        public static explicit operator global::Acid.Sharp.StorageBuffer(ulong size)
        {
            return new global::Acid.Sharp.StorageBuffer(ref *size);
        }

        protected ulong MSize
        {
            get
            {
                return ((global::Acid.Sharp.StorageBuffer.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::Acid.Sharp.StorageBuffer.__Internal*)__Instance)->m_size = value;
            }
        }

        public global::System.IntPtr __PointerToBuffer
        {
            get
            {
                return __Instance + 8;
            }
        }

        public ulong Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + 8));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that handles a storage buffer.</summary>
    public unsafe partial class StorageHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_multipipeline;

            [FieldOffset(8)]
            internal global::System.IntPtr m_uniformBlock;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_StorageBuffer___N_std_S_default_delete__S0_ m_storageBuffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_data;

            [FieldOffset(32)]
            internal byte m_changed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StorageHandler@acid@@QEAA@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool* multipipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StorageHandler@acid@@QEAA@PEAVUniformBlock@1@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr uniformBlock, bool* multipipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StorageHandler@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1StorageHandler@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@StorageHandler@acid@@QEAA_NPEAVUniformBlock@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Update(global::System.IntPtr instance, global::System.IntPtr uniformBlock);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStorageBuffer@StorageHandler@acid@@QEBAPEAVStorageBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetStorageBuffer(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.StorageHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.StorageHandler>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.StorageHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.StorageHandler(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.StorageHandler __CreateInstance(global::Acid.Sharp.StorageHandler.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.StorageHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.StorageHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.StorageHandler.__Internal));
            *(global::Acid.Sharp.StorageHandler.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StorageHandler(global::Acid.Sharp.StorageHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StorageHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public StorageHandler(bool multipipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.StorageHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &multipipeline;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public StorageHandler(global::Acid.Sharp.UniformBlock uniformBlock, bool multipipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.StorageHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(uniformBlock, null) ? global::System.IntPtr.Zero : uniformBlock.__Instance;
            var __arg1 = &multipipeline;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public StorageHandler(global::Acid.Sharp.StorageHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.StorageHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.StorageHandler.__Internal*) __Instance) = *((global::Acid.Sharp.StorageHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.StorageHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Update(global::Acid.Sharp.UniformBlock uniformBlock)
        {
            var __arg0 = ReferenceEquals(uniformBlock, null) ? global::System.IntPtr.Zero : uniformBlock.__Instance;
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public static explicit operator global::Acid.Sharp.StorageHandler(bool multipipeline)
        {
            return new global::Acid.Sharp.StorageHandler(ref *multipipeline);
        }

        public global::Acid.Sharp.StorageBuffer StorageBuffer
        {
            get
            {
                var __ret = __Internal.GetStorageBuffer((__Instance + __PointerAdjustment));
                global::Acid.Sharp.StorageBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.StorageBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.StorageBuffer) global::Acid.Sharp.StorageBuffer.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.StorageBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that handles a push constant.</summary>
    public unsafe partial class PushHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_multipipeline;

            [FieldOffset(8)]
            internal global::System.IntPtr m_uniformBlock;

            [FieldOffset(16)]
            internal global::System.IntPtr m_data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PushHandler@acid@@QEAA@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool* multipipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PushHandler@acid@@QEAA@PEAVUniformBlock@1@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr uniformBlock, bool* multipipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PushHandler@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PushHandler@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@PushHandler@acid@@QEAA_NPEAVUniformBlock@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Update(global::System.IntPtr instance, global::System.IntPtr uniformBlock);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindPush@PushHandler@acid@@QEAAXAEBVCommandBuffer@2@AEBVPipeline@2@@Z")]
            internal static extern void BindPush(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PushHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PushHandler>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.PushHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PushHandler(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.PushHandler __CreateInstance(global::Acid.Sharp.PushHandler.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PushHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.PushHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PushHandler.__Internal));
            *(global::Acid.Sharp.PushHandler.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PushHandler(global::Acid.Sharp.PushHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PushHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PushHandler(bool multipipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PushHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &multipipeline;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public PushHandler(global::Acid.Sharp.UniformBlock uniformBlock, bool multipipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PushHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(uniformBlock, null) ? global::System.IntPtr.Zero : uniformBlock.__Instance;
            var __arg1 = &multipipeline;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public PushHandler(global::Acid.Sharp.PushHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PushHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.PushHandler.__Internal*) __Instance) = *((global::Acid.Sharp.PushHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.PushHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Update(global::Acid.Sharp.UniformBlock uniformBlock)
        {
            var __arg0 = ReferenceEquals(uniformBlock, null) ? global::System.IntPtr.Zero : uniformBlock.__Instance;
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void BindPush(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Pipeline pipeline)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            __Internal.BindPush((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public static explicit operator global::Acid.Sharp.PushHandler(bool multipipeline)
        {
            return new global::Acid.Sharp.PushHandler(ref *multipipeline);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that handles a descriptor set.</summary>
    public unsafe partial class DescriptorsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_shaderProgram;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_DescriptorSet___N_std_S_default_delete__S0_ m_descriptorSet;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_acid_S_IDescriptor___N_std_S_allocator__S0_ m_descriptors;

            [FieldOffset(40)]
            internal byte m_changed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorsHandler@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorsHandler@acid@@QEAA@AEBVIPipeline@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DescriptorsHandler@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1DescriptorsHandler@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVIDescriptor@2@@Z")]
            internal static extern void Push(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVIDescriptor@2@@Z")]
            internal static extern void Push1(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVUniformHandler@2@@Z")]
            internal static extern void Push_1(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr uniformHandler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVUniformHandler@2@@Z")]
            internal static extern void Push1_1(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr uniformHandler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVStorageHandler@2@@Z")]
            internal static extern void Push_2(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr storageHandler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVStorageHandler@2@@Z")]
            internal static extern void Push1_2(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr storageHandler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVPushHandler@2@@Z")]
            internal static extern void Push_3(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr pushHandler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Push@DescriptorsHandler@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAVPushHandler@2@@Z")]
            internal static extern void Push1_3(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr pushHandler);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@DescriptorsHandler@acid@@QEAA_NAEBVIPipeline@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Update(global::System.IntPtr instance, global::System.IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindDescriptor@DescriptorsHandler@acid@@QEAAXAEBVCommandBuffer@2@@Z")]
            internal static extern void BindDescriptor(global::System.IntPtr instance, global::System.IntPtr commandBuffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorSet@DescriptorsHandler@acid@@QEBAPEAVDescriptorSet@2@XZ")]
            internal static extern global::System.IntPtr GetDescriptorSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.DescriptorsHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.DescriptorsHandler>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.DescriptorsHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DescriptorsHandler(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DescriptorsHandler __CreateInstance(global::Acid.Sharp.DescriptorsHandler.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DescriptorsHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DescriptorsHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorsHandler.__Internal));
            global::Acid.Sharp.DescriptorsHandler.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DescriptorsHandler(global::Acid.Sharp.DescriptorsHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DescriptorsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DescriptorsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public DescriptorsHandler(global::Acid.Sharp.IPipeline pipeline)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pipeline.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public DescriptorsHandler(global::Acid.Sharp.DescriptorsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DescriptorsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.DescriptorsHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Push(string descriptorName, global::Acid.Sharp.IIDescriptor descriptor)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(descriptor, null) ? global::System.IntPtr.Zero : descriptor.__PointerToIDescriptor;
            __Internal.Push((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push1(string descriptorName, global::Acid.Sharp.IIDescriptor descriptor)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(descriptor, null))
                throw new global::System.ArgumentNullException("descriptor", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = descriptor.__PointerToIDescriptor;
            __Internal.Push1((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push(string descriptorName, global::Acid.Sharp.UniformHandler uniformHandler)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(uniformHandler, null) ? global::System.IntPtr.Zero : uniformHandler.__Instance;
            __Internal.Push_1((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push1(string descriptorName, global::Acid.Sharp.UniformHandler uniformHandler)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(uniformHandler, null))
                throw new global::System.ArgumentNullException("uniformHandler", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uniformHandler.__Instance;
            __Internal.Push1_1((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push(string descriptorName, global::Acid.Sharp.StorageHandler storageHandler)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(storageHandler, null) ? global::System.IntPtr.Zero : storageHandler.__Instance;
            __Internal.Push_2((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push1(string descriptorName, global::Acid.Sharp.StorageHandler storageHandler)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(storageHandler, null))
                throw new global::System.ArgumentNullException("storageHandler", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = storageHandler.__Instance;
            __Internal.Push1_2((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push(string descriptorName, global::Acid.Sharp.PushHandler pushHandler)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(pushHandler, null) ? global::System.IntPtr.Zero : pushHandler.__Instance;
            __Internal.Push_3((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public void Push1(string descriptorName, global::Acid.Sharp.PushHandler pushHandler)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(pushHandler, null))
                throw new global::System.ArgumentNullException("pushHandler", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pushHandler.__Instance;
            __Internal.Push1_3((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public bool Update(global::Acid.Sharp.IPipeline pipeline)
        {
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pipeline.__Instance;
            var __ret = __Internal.Update((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void BindDescriptor(global::Acid.Sharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            __Internal.BindDescriptor((__Instance + __PointerAdjustment), __arg0);
        }

        public static explicit operator global::Acid.Sharp.DescriptorsHandler(global::Acid.Sharp.IPipeline pipeline)
        {
            return new global::Acid.Sharp.DescriptorsHandler(pipeline);
        }

        public global::Acid.Sharp.DescriptorSet DescriptorSet
        {
            get
            {
                var __ret = __Internal.GetDescriptorSet((__Instance + __PointerAdjustment));
                global::Acid.Sharp.DescriptorSet __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.DescriptorSet.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.DescriptorSet) global::Acid.Sharp.DescriptorSet.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.DescriptorSet.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    public enum MouseButton
    {
        _1 = 0,
        _2 = 1,
        _3 = 2,
        _4 = 3,
        _5 = 4,
        _6 = 5,
        _7 = 6,
        _8 = 7,
        Left = 0,
        Right = 1,
        Middle = 2,
        BeginRange = 0,
        EndRange = 7,
        RangeSize = 8,
        MaxEnum = 2147483647
    }

    /// <summary>A module used for the creation, updating and destruction of the mouse.</summary>
    public unsafe partial class Mouse : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array__b_Vk7 m_mouseButtons;

            [FieldOffset(16)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_mousePath;

            [FieldOffset(48)]
            internal float m_lastMousePositionX;

            [FieldOffset(52)]
            internal float m_lastMousePositionY;

            [FieldOffset(56)]
            internal float m_mousePositionX;

            [FieldOffset(60)]
            internal float m_mousePositionY;

            [FieldOffset(64)]
            internal float m_mouseDeltaX;

            [FieldOffset(68)]
            internal float m_mouseDeltaY;

            [FieldOffset(72)]
            internal float m_mouseDeltaWheel;

            [FieldOffset(76)]
            internal byte m_displaySelected;

            [FieldOffset(77)]
            internal byte m_lastCursorDisabled;

            [FieldOffset(78)]
            internal byte m_cursorDisabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mouse@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Mouse@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Mouse@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Mouse@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCursorHidden@Mouse@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetCursorHidden(global::System.IntPtr instance, bool* disabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetButton@Mouse@acid@@QEBA_NAEBW4MouseButton@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetButton(global::System.IntPtr instance, global::Acid.Sharp.MouseButton* mouseButton);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Mouse@acid@@QEAAXAEBM0@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, float* cursorX, float* cursorY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCustomMouse@Mouse@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetCustomMouse(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCustomMouse@Mouse@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetCustomMouse(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionX@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetPositionX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionY@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetPositionY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaX@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetDeltaX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaY@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetDeltaY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDeltaWheel@Mouse@acid@@QEBAMXZ")]
            internal static extern float GetDeltaWheel(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsDisplaySelected@Mouse@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetDisplaySelected(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsCursorDisabled@Mouse@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetCursorDisabled(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Mouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Mouse(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Mouse __CreateInstance(global::Acid.Sharp.Mouse.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Mouse(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Mouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Mouse.__Internal));
            global::Acid.Sharp.Mouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Mouse(global::Acid.Sharp.Mouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Mouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Mouse()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Mouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Mouse");
        }

        public Mouse(global::Acid.Sharp.Mouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Mouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Mouse");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Mouse.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Sets if the operating systems cursor is hidden whilst in the display.</summary>
        /// <param name="disabled">If the system cursor should be disabled or hidden when not shown.</param>
        public void SetCursorHidden(bool disabled)
        {
            var __arg0 = &disabled;
            __Internal.SetCursorHidden((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets whether or not a particular mouse button is currently pressed. Actions: WSI_ACTION_PRESS, WSI_ACTION_RELEASE, WSI_ACTION_REPEAT</summary>
        /// <param name="mouseButton">The mouse button to test.</param>
        public bool GetButton(global::Acid.Sharp.MouseButton* mouseButton)
        {
            var __ret = __Internal.GetButton((__Instance + __PointerAdjustment), mouseButton);
            return __ret;
        }

        /// <summary>Sets the mouse position.</summary>
        /// <param name="cursorX">The x position in screenspace.</param>
        /// <param name="cursorY">The y position in screenspace.</param>
        public void SetPosition(float cursorX, float cursorY)
        {
            var __arg0 = &cursorX;
            var __arg1 = &cursorY;
            __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Mouse Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Mouse __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Mouse.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Mouse) global::Acid.Sharp.Mouse.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Mouse.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the mouses custom mouse file.</summary>
        /// <param name="filename">The new custom mouse file.</param>
        /// <remarks>Sets the custom mouse file.</remarks>
        public string CustomMouse
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetCustomMouse((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetCustomMouse((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the mouses screen x position.</summary>
        public float PositionX
        {
            get
            {
                var __ret = __Internal.GetPositionX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses screen y position.</summary>
        public float PositionY
        {
            get
            {
                var __ret = __Internal.GetPositionY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses delta x.</summary>
        public float DeltaX
        {
            get
            {
                var __ret = __Internal.GetDeltaX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses delta y.</summary>
        public float DeltaY
        {
            get
            {
                var __ret = __Internal.GetDeltaY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the mouses wheel delta.</summary>
        public float DeltaWheel
        {
            get
            {
                var __ret = __Internal.GetDeltaWheel((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the display is selected.</summary>
        public bool DisplaySelected
        {
            get
            {
                var __ret = __Internal.GetDisplaySelected((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>If the cursor is hidden, the mouse is the display locked if true.</summary>
        public bool CursorDisabled
        {
            get
            {
                var __ret = __Internal.GetCursorDisabled((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Mouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Mouse
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackScroll@acid@@YAXPEAUGLFWwindow@@NN@Z")]
            internal static extern void CallbackScroll(global::System.IntPtr window, double xoffset, double yoffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackMouseButton@acid@@YAXPEAUGLFWwindow@@HHH@Z")]
            internal static extern void CallbackMouseButton(global::System.IntPtr window, int button, int action, int mods);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackCursorPos@acid@@YAXPEAUGLFWwindow@@NN@Z")]
            internal static extern void CallbackCursorPos(global::System.IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackCursorEnter@acid@@YAXPEAUGLFWwindow@@H@Z")]
            internal static extern void CallbackCursorEnter(global::System.IntPtr window, int entered);
        }

        public static void CallbackScroll(global::GLFWwindow window, double xoffset, double yoffset)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackScroll(__arg0, xoffset, yoffset);
        }

        public static void CallbackMouseButton(global::GLFWwindow window, int button, int action, int mods)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackMouseButton(__arg0, button, action, mods);
        }

        public static void CallbackCursorPos(global::GLFWwindow window, double xpos, double ypos)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackCursorPos(__arg0, xpos, ypos);
        }

        public static void CallbackCursorEnter(global::GLFWwindow window, int entered)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackCursorEnter(__arg0, entered);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds position, rotation, and scale components.</summary>
    public unsafe partial class Transform : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal global::Acid.Sharp.Vector3.__Internal m_rotation;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Vector3.__Internal m_scaling;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@AEBVVector3@1@00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation, global::System.IntPtr scaling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Transform@acid@@QEAA@AEBVVector3@1@0AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr rotation, float* scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Transform@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Transform@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Transform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Transform@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Transform@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Transform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Transform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@Transform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetRotation(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRotation@Transform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetRotation(global::System.IntPtr instance, global::System.IntPtr rotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScaling@Transform@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetScaling(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaling@Transform@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetScaling(global::System.IntPtr instance, global::System.IntPtr scaling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorldMatrix@Transform@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetWorldMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModelMatrix@Transform@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetModelMatrix(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Transform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Transform>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Transform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Transform(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Transform __CreateInstance(global::Acid.Sharp.Transform.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Transform(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Transform.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Transform.__Internal));
            global::Acid.Sharp.Transform.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Transform(global::Acid.Sharp.Transform.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Transform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Transform.</summary>
        public Transform()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="source">Creates this vector out of a transform.</param>
        public Transform(global::Acid.Sharp.Transform source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scaling">The scaling.</param>
        public Transform(global::Acid.Sharp.Vector3 position, global::Acid.Sharp.Vector3 rotation, global::Acid.Sharp.Vector3 scaling)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            if (ReferenceEquals(scaling, null))
                throw new global::System.ArgumentNullException("scaling", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = scaling.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        /// <summary>Constructor for Transform.</summary>
        /// <param name="position">The position.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="scale">The scale.</param>
        public Transform(global::Acid.Sharp.Vector3 position, global::Acid.Sharp.Vector3 rotation, float scale)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Transform.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            if (ReferenceEquals(rotation, null))
                throw new global::System.ArgumentNullException("rotation", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rotation.__Instance;
            var __arg2 = &scale;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Transform __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Transform __op, global::Acid.Sharp.Transform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Transform;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Transform.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Transform __op, global::Acid.Sharp.Transform other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static global::Acid.Sharp.Transform Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Transform.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Transform@acid@@2V12@B");
                return global::Acid.Sharp.Transform.__CreateInstance(*__ptr);
            }
        }

        public global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Rotation
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetRotation((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Scaling
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetScaling((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScaling((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Matrix4 WorldMatrix
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetWorldMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Matrix4 ModelMatrix
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetModelMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A rectangle made of a position and dimension.</summary>
    public unsafe partial class UiBound : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector2.__Internal m_position;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Vector2.__Internal m_reference;

            [FieldOffset(16)]
            internal byte m_aspectPosition;

            [FieldOffset(17)]
            internal byte m_aspectSize;

            [FieldOffset(20)]
            internal global::Acid.Sharp.Vector2.__Internal m_dimensions;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@acid@@QEAA@AEBVVector2@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEB_N20@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr position, global::System.IntPtr reference, bool* aspectPosition, bool* aspectSize, global::System.IntPtr dimensions);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiBound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FindPivot@UiBound@acid@@SA?AVVector2@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void FindPivot(global::System.IntPtr @return, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8UiBound@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9UiBound@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@UiBound@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@UiBound@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetReference@UiBound@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetReference(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetReference@UiBound@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetReference(global::System.IntPtr instance, global::System.IntPtr reference);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectPosition@UiBound@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetAspectPosition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectPosition@UiBound@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectPosition(global::System.IntPtr instance, bool* aspectPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAspectSize@UiBound@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetAspectSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAspectSize@UiBound@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetAspectSize(global::System.IntPtr instance, bool* aspectSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDimensions@UiBound@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetDimensions(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDimensions@UiBound@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetDimensions(global::System.IntPtr instance, global::System.IntPtr dimensions);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiBound> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiBound>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.UiBound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiBound(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiBound __CreateInstance(global::Acid.Sharp.UiBound.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiBound(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiBound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiBound.__Internal));
            global::Acid.Sharp.UiBound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiBound(global::Acid.Sharp.UiBound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiBound(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for rectangle.</summary>
        /// <param name="position">The object screen position.</param>
        /// <param name="reference">The reference pivot vertex (TopLeft, TopCentre, TopRight, CentreLeft, Centre, CentreRight, BottomLeft, BottomCentre, BottomRight).</param>
        /// <param name="aspectPosition">The if the x position will change with display width.</param>
        /// <param name="aspectSize">The if the width will scale with display width.</param>
        /// <param name="dimensions">The object dimensions.</param>
        public UiBound(global::Acid.Sharp.Vector2 position, string reference, bool aspectPosition, bool aspectSize, global::Acid.Sharp.Vector2 dimensions)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(reference, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __arg2 = &aspectPosition;
            var __arg3 = &aspectSize;
            if (ReferenceEquals(dimensions, null))
                throw new global::System.ArgumentNullException("dimensions", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = dimensions.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public UiBound(global::Acid.Sharp.UiBound _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiBound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiBound __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::Acid.Sharp.UiBound __op, global::Acid.Sharp.UiBound other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.UiBound;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.UiBound.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.UiBound __op, global::Acid.Sharp.UiBound other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Vector2 FindPivot(string key)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(key, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.FindPivot(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        public global::Acid.Sharp.Vector2 MPosition
        {
            get
            {
                return global::Acid.Sharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.UiBound.__Internal*) __Instance)->m_position));
            }

            set
            {
                ((global::Acid.Sharp.UiBound.__Internal*)__Instance)->m_position = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector2.__Internal() : *(global::Acid.Sharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::Acid.Sharp.Vector2 MReference
        {
            get
            {
                return global::Acid.Sharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.UiBound.__Internal*) __Instance)->m_reference));
            }

            set
            {
                ((global::Acid.Sharp.UiBound.__Internal*)__Instance)->m_reference = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector2.__Internal() : *(global::Acid.Sharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public bool MAspectPosition
        {
            get
            {
                return ((global::Acid.Sharp.UiBound.__Internal*) __Instance)->m_aspectPosition != 0;
            }

            set
            {
                ((global::Acid.Sharp.UiBound.__Internal*)__Instance)->m_aspectPosition = (byte) (value ? 1 : 0);
            }
        }

        public bool MAspectSize
        {
            get
            {
                return ((global::Acid.Sharp.UiBound.__Internal*) __Instance)->m_aspectSize != 0;
            }

            set
            {
                ((global::Acid.Sharp.UiBound.__Internal*)__Instance)->m_aspectSize = (byte) (value ? 1 : 0);
            }
        }

        public global::Acid.Sharp.Vector2 MDimensions
        {
            get
            {
                return global::Acid.Sharp.Vector2.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.UiBound.__Internal*) __Instance)->m_dimensions));
            }

            set
            {
                ((global::Acid.Sharp.UiBound.__Internal*)__Instance)->m_dimensions = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector2.__Internal() : *(global::Acid.Sharp.Vector2.__Internal*) value.__Instance;
            }
        }

        public global::Acid.Sharp.Vector2 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector2 Reference
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetReference((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetReference((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool AspectPosition
        {
            get
            {
                var __ret = __Internal.GetAspectPosition((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetAspectPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool AspectSize
        {
            get
            {
                var __ret = __Internal.GetAspectSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetAspectSize((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector2 Dimensions
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetDimensions((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDimensions((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A representation of a object this is rendered to a screen. This object is contained in a parent and has children. The screen object has a few values that allow for it to be positioned and scaled, along with other variables that are used when rendering. This class can be extended to create a representation for GUI textures, fonts, etc.</summary>
    public unsafe partial class UiObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 256)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiObject@acid@@QEAA@PEAV01@AEBVUiBound@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr rectangle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiObject@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiObject@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@UiObject@acid@@QEAAXPEAV12@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveChild@UiObject@acid@@QEAA_NPEAV12@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@UiObject@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetParent@UiObject@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetParent(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsVisible@UiObject@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetVisible(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetVisible@UiObject@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetVisible(global::System.IntPtr instance, bool* visible);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRectangle@UiObject@acid@@QEAAAEAVUiBound@2@XZ")]
            internal static extern global::System.IntPtr GetRectangle(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRectangle@UiObject@acid@@QEAAXAEBVUiBound@2@@Z")]
            internal static extern void SetRectangle(global::System.IntPtr instance, global::System.IntPtr rectangle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScissor@UiObject@acid@@QEBA?AVVector4@2@XZ")]
            internal static extern void GetScissor(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScissor@UiObject@acid@@QEAAXAEBVVector4@2@@Z")]
            internal static extern void SetScissor(global::System.IntPtr instance, global::System.IntPtr scissor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPositionOffset@UiObject@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetPositionOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPositionOffset@UiObject@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetPositionOffset(global::System.IntPtr instance, global::System.IntPtr positionOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsLockRotation@UiObject@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetLockRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLockRotation@UiObject@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetLockRotation(global::System.IntPtr instance, bool* lockRotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAlphaDriver@UiObject@acid@@QEBAPEAVIDriver@2@XZ")]
            internal static extern global::System.IntPtr GetAlphaDriver(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAlphaDriver@UiObject@acid@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetAlphaDriver(global::System.IntPtr instance, global::System.IntPtr alphaDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScaleDriver@UiObject@acid@@QEBAPEAVIDriver@2@XZ")]
            internal static extern global::System.IntPtr GetScaleDriver(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaleDriver@UiObject@acid@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetScaleDriver(global::System.IntPtr instance, global::System.IntPtr scaleDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScreenTransform@UiObject@acid@@QEBA?AVVector4@2@XZ")]
            internal static extern void GetScreenTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModelMatrix@UiObject@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetModelMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAlpha@UiObject@acid@@QEBAMXZ")]
            internal static extern float GetAlpha(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@UiObject@acid@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.UiObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiObject(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiObject __CreateInstance(global::Acid.Sharp.UiObject.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiObject(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiObject.__Internal));
            global::Acid.Sharp.UiObject.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiObject(global::Acid.Sharp.UiObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new screen object.</summary>
        /// <param name="parent">The parent screen object.</param>
        /// <param name="rectangle">The rectangle that will represent the bounds of the ui object.</param>
        public UiObject(global::Acid.Sharp.UiObject parent, global::Acid.Sharp.UiBound rectangle)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(rectangle, null))
                throw new global::System.ArgumentNullException("rectangle", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rectangle.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiObject");
        }

        public UiObject(global::Acid.Sharp.UiObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiObject");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.UiObject.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the implementation.</summary>
        public virtual void UpdateObject()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateObjectDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateObjectDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Adds a child to this objects children.</summary>
        /// <param name="child">The child to add.</param>
        public void AddChild(global::Acid.Sharp.UiObject child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Disowns a child from this objects children.</summary>
        /// <param name="child">The child to disown.</param>
        public bool RemoveChild(global::Acid.Sharp.UiObject child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            var __ret = __Internal.RemoveChild((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the parent object.</summary>
        /// <param name="parent">The new parent object.</param>
        /// <remarks>Removes this object from the previous parent and attaches it to another parent.</remarks>
        public global::Acid.Sharp.UiObject Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::Acid.Sharp.UiObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.UiObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.UiObject) global::Acid.Sharp.UiObject.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.UiObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetParent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Visible
        {
            get
            {
                var __ret = __Internal.GetVisible((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetVisible((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.UiBound Rectangle
        {
            get
            {
                var __ret = __Internal.GetRectangle((__Instance + __PointerAdjustment));
                global::Acid.Sharp.UiBound __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.UiBound.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.UiBound) global::Acid.Sharp.UiBound.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.UiBound.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetRectangle((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector4 Scissor
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector4.__Internal();
                __Internal.GetScissor((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScissor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector2 PositionOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetPositionOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPositionOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool LockRotation
        {
            get
            {
                var __ret = __Internal.GetLockRotation((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetLockRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.IDriver AlphaDriver
        {
            get
            {
                var __ret = __Internal.GetAlphaDriver((__Instance + __PointerAdjustment));
                global::Acid.Sharp.IDriver __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.IDriver.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.IDriver) global::Acid.Sharp.IDriver.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.IDriver.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetAlphaDriver((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.IDriver ScaleDriver
        {
            get
            {
                var __ret = __Internal.GetScaleDriver((__Instance + __PointerAdjustment));
                global::Acid.Sharp.IDriver __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.IDriver.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.IDriver) global::Acid.Sharp.IDriver.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.IDriver.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetScaleDriver((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the ui object screen space transform.</summary>
        public global::Acid.Sharp.Vector4 ScreenTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector4.__Internal();
                __Internal.GetScreenTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector4.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Matrix4 ModelMatrix
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetModelMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        public float Alpha
        {
            get
            {
                var __ret = __Internal.GetAlpha((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void UpdateObject()
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A enum that represents how the text will be justified.</summary>
    public enum TextJustify
    {
        Left = 0,
        Centre = 1,
        Right = 2,
        Fully = 3
    }

    /// <summary>A object the represents a text in a GUI.</summary>
    public unsafe partial class Text : global::Acid.Sharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 528)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [FieldOffset(256)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(304)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformObject;

            [FieldOffset(344)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Model___N_std_S_default_delete__S0_ m_model;

            [FieldOffset(352)]
            internal uint m_numberLines;

            [FieldOffset(360)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_string;

            [FieldOffset(392)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_newString;

            [FieldOffset(424)]
            internal global::Acid.Sharp.TextJustify m_justify;

            [FieldOffset(432)]
            internal global::Std.SharedPtr.__Internal m_fontType;

            [FieldOffset(448)]
            internal float m_maxWidth;

            [FieldOffset(452)]
            internal float m_kerning;

            [FieldOffset(456)]
            internal float m_leading;

            [FieldOffset(460)]
            internal global::Acid.Sharp.Colour.__Internal m_textColour;

            [FieldOffset(476)]
            internal global::Acid.Sharp.Colour.__Internal m_borderColour;

            [FieldOffset(492)]
            internal byte m_solidBorder;

            [FieldOffset(493)]
            internal byte m_glowBorder;

            [FieldOffset(496)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_glowDriver;

            [FieldOffset(504)]
            internal float m_glowSize;

            [FieldOffset(512)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_borderDriver;

            [FieldOffset(520)]
            internal float m_borderSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Text@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Text@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Text@acid@@QEAA_NAEBVCommandBuffer@2@AEBVPipeline@2@AEAVUniformHandler@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline, global::System.IntPtr uniformScene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveBorder@Text@acid@@QEAAXXZ")]
            internal static extern void RemoveBorder(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateEdgeStart@Text@acid@@QEAAMXZ")]
            internal static extern float CalculateEdgeStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CalculateAntialiasSize@Text@acid@@QEAAMXZ")]
            internal static extern float CalculateAntialiasSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetString@Text@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetString@Text@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetString(global::System.IntPtr instance, global::System.IntPtr newString);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxWidth@Text@acid@@QEBAMXZ")]
            internal static extern float GetMaxWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMaxWidth@Text@acid@@QEAAXAEBM@Z")]
            internal static extern void SetMaxWidth(global::System.IntPtr instance, float* maxWidth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetKerning@Text@acid@@QEBAMXZ")]
            internal static extern float GetKerning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetKerning@Text@acid@@QEAAXAEBM@Z")]
            internal static extern void SetKerning(global::System.IntPtr instance, float* kerning);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLeading@Text@acid@@QEBAMXZ")]
            internal static extern float GetLeading(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLeading@Text@acid@@QEAAXAEBM@Z")]
            internal static extern void SetLeading(global::System.IntPtr instance, float* leading);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextColour@Text@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetTextColour(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTextColour@Text@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetTextColour(global::System.IntPtr instance, global::System.IntPtr textColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBorderColour@Text@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetBorderColour(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBorderColour@Text@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetBorderColour(global::System.IntPtr instance, global::System.IntPtr borderColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBorderDriver@Text@acid@@QEBAPEAVIDriver@2@XZ")]
            internal static extern global::System.IntPtr GetBorderDriver(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBorderDriver@Text@acid@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetBorderDriver(global::System.IntPtr instance, global::System.IntPtr borderDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlowDriver@Text@acid@@QEBAPEAVIDriver@2@XZ")]
            internal static extern global::System.IntPtr GetGlowDriver(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGlowDriver@Text@acid@@QEAAXPEAVIDriver@2@@Z")]
            internal static extern void SetGlowDriver(global::System.IntPtr instance, global::System.IntPtr glowDriver);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetModel@Text@acid@@QEBAPEAVModel@2@XZ")]
            internal static extern global::System.IntPtr GetModel(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNumberLines@Text@acid@@QEBAIXZ")]
            internal static extern uint GetNumberLines(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextJustify@Text@acid@@QEBA?AW4TextJustify@2@XZ")]
            internal static extern global::Acid.Sharp.TextJustify GetTextJustify(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTotalBorderSize@Text@acid@@QEAAMXZ")]
            internal static extern float GetTotalBorderSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGlowSize@Text@acid@@QEAAMXZ")]
            internal static extern float GetGlowSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsLoaded@Text@acid@@QEAA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetLoaded(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Text __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Text(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Text __CreateInstance(global::Acid.Sharp.Text.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Text(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Text.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Text.__Internal));
            global::Acid.Sharp.Text.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Text(global::Acid.Sharp.Text.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Text(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Text(global::Acid.Sharp.Text _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Text.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Text");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Text.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public bool CmdRender(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Pipeline pipeline, global::Acid.Sharp.UniformHandler uniformScene)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            if (ReferenceEquals(uniformScene, null))
                throw new global::System.ArgumentNullException("uniformScene", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = uniformScene.__Instance;
            var __ret = __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Disables both solid borders and glow borders.</summary>
        public void RemoveBorder()
        {
            __Internal.RemoveBorder((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets the distance field edge before antialias.</summary>
        public float CalculateEdgeStart()
        {
            var __ret = __Internal.CalculateEdgeStart((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Gets the distance field antialias distance.</summary>
        public float CalculateAntialiasSize()
        {
            var __ret = __Internal.CalculateAntialiasSize((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Gets the string of text represented.</summary>
        /// <param name="newString">The new text,</param>
        /// <remarks>Changed the current string in this text.</remarks>
        public string String
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetString((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        /// <summary>Gets the maximum length of a line of this text.</summary>
        /// <param name="maxWidth">The new maximum length.</param>
        /// <remarks>Sets the maximum length of a line of this text.</remarks>
        public float MaxWidth
        {
            get
            {
                var __ret = __Internal.GetMaxWidth((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetMaxWidth((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the kerning (type character spacing multiplier) of this text.</summary>
        /// <param name="kerning">The new kerning.</param>
        /// <remarks>Sets the kerning (type character spacing multiplier) of this text.</remarks>
        public float Kerning
        {
            get
            {
                var __ret = __Internal.GetKerning((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetKerning((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the leading (vertical line spacing multiplier) of this text.</summary>
        /// <param name="leading">The new leading.</param>
        /// <remarks>Sets the leading (vertical line spacing multiplier) of this text.</remarks>
        public float Leading
        {
            get
            {
                var __ret = __Internal.GetLeading((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetLeading((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the colour of the text.</summary>
        /// <param name="textColour">The new colour of the text.</param>
        /// <remarks>Sets the colour of the text.</remarks>
        public global::Acid.Sharp.Colour TextColour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetTextColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTextColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the border colour of the text. This is used with border and glow drivers.</summary>
        /// <param name="borderColour">The new border colour of the text.</param>
        /// <remarks>Sets the border colour of the text. This is used with border and glow drivers.</remarks>
        public global::Acid.Sharp.Colour BorderColour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetBorderColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetBorderColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.IDriver BorderDriver
        {
            get
            {
                var __ret = __Internal.GetBorderDriver((__Instance + __PointerAdjustment));
                global::Acid.Sharp.IDriver __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.IDriver.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.IDriver) global::Acid.Sharp.IDriver.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.IDriver.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetBorderDriver((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.IDriver GlowDriver
        {
            get
            {
                var __ret = __Internal.GetGlowDriver((__Instance + __PointerAdjustment));
                global::Acid.Sharp.IDriver __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.IDriver.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.IDriver) global::Acid.Sharp.IDriver.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.IDriver.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetGlowDriver((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the text model, which contains all the vertex data for the quads on which the text will be rendered.</summary>
        public global::Acid.Sharp.Model Model
        {
            get
            {
                var __ret = __Internal.GetModel((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Model __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Model.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Model) global::Acid.Sharp.Model.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Model.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the number of lines in this text.</summary>
        public uint NumberLines
        {
            get
            {
                var __ret = __Internal.GetNumberLines((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets how the text should justify.</summary>
        public global::Acid.Sharp.TextJustify TextJustify
        {
            get
            {
                var __ret = __Internal.GetTextJustify((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the calculated border size.</summary>
        public float TotalBorderSize
        {
            get
            {
                var __ret = __Internal.GetTotalBorderSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets the size of the glow.</summary>
        public float GlowSize
        {
            get
            {
                var __ret = __Internal.GetGlowSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Gets if the text has been loaded to a model.</summary>
        public bool Loaded
        {
            get
            {
                var __ret = __Internal.GetLoaded((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void UpdateObject() override
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Text) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class RendererFonts : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 728)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(688)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformScene;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererFonts@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererFonts@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RendererFonts@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.RendererFonts __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererFonts(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RendererFonts __CreateInstance(global::Acid.Sharp.RendererFonts.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererFonts(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RendererFonts.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererFonts.__Internal));
            global::Acid.Sharp.RendererFonts.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererFonts(global::Acid.Sharp.RendererFonts.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererFonts(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public RendererFonts(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererFonts.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererFonts");
        }

        public RendererFonts(global::Acid.Sharp.RendererFonts _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererFonts.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererFonts");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.RendererFonts.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.RendererFonts(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.RendererFonts(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.RendererFonts) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A object the represents a texture in a GUI.</summary>
    public unsafe partial class Gui : global::Acid.Sharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 408)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [FieldOffset(256)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(304)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformObject;

            [FieldOffset(344)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(360)]
            internal global::Std.SharedPtr.__Internal m_texture;

            [FieldOffset(376)]
            internal uint m_numberOfRows;

            [FieldOffset(380)]
            internal uint m_selectedRow;

            [FieldOffset(384)]
            internal global::Acid.Sharp.Vector2.__Internal m_atlasOffset;

            [FieldOffset(392)]
            internal global::Acid.Sharp.Colour.__Internal m_colourOffset;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Gui@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Gui@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Gui@acid@@QEAA_NAEBVCommandBuffer@2@AEBVPipeline@2@AEAVUniformHandler@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline, global::System.IntPtr uniformScene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNumberOfRows@Gui@acid@@QEBAIXZ")]
            internal static extern uint GetNumberOfRows(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNumberOfRows@Gui@acid@@QEAAXAEBI@Z")]
            internal static extern void SetNumberOfRows(global::System.IntPtr instance, uint* numberOfRows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSelectedRow@Gui@acid@@QEBAIXZ")]
            internal static extern uint GetSelectedRow(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSelectedRow@Gui@acid@@QEAAXAEBI@Z")]
            internal static extern void SetSelectedRow(global::System.IntPtr instance, uint* selectedRow);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColourOffset@Gui@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetColourOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColourOffset@Gui@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetColourOffset(global::System.IntPtr instance, global::System.IntPtr colourOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAtlasOffset@Gui@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetAtlasOffset(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        internal static new global::Acid.Sharp.Gui __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Gui(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Gui __CreateInstance(global::Acid.Sharp.Gui.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Gui(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Gui.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Gui.__Internal));
            global::Acid.Sharp.Gui.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Gui(global::Acid.Sharp.Gui.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Gui(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Gui(global::Acid.Sharp.Gui _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Gui.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Gui");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Gui.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public bool CmdRender(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Pipeline pipeline, global::Acid.Sharp.UniformHandler uniformScene)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            if (ReferenceEquals(uniformScene, null))
                throw new global::System.ArgumentNullException("uniformScene", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = uniformScene.__Instance;
            var __ret = __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        public uint NumberOfRows
        {
            get
            {
                var __ret = __Internal.GetNumberOfRows((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetNumberOfRows((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public uint SelectedRow
        {
            get
            {
                var __ret = __Internal.GetSelectedRow((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetSelectedRow((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Colour ColourOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetColourOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColourOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector2 AtlasOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetAtlasOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // void UpdateObject() override
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Gui) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class RendererGuis : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 728)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(688)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformScene;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererGuis@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererGuis@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RendererGuis@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.RendererGuis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererGuis(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RendererGuis __CreateInstance(global::Acid.Sharp.RendererGuis.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererGuis(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RendererGuis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererGuis.__Internal));
            global::Acid.Sharp.RendererGuis.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererGuis(global::Acid.Sharp.RendererGuis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererGuis(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public RendererGuis(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererGuis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererGuis");
        }

        public RendererGuis(global::Acid.Sharp.RendererGuis _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererGuis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererGuis");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.RendererGuis.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.RendererGuis(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.RendererGuis(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.RendererGuis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A helper for file creation, loading, writing, and more.</summary>
    public unsafe partial class FileSystem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FileSystem@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Exists@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Exists(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsFile@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetFile(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsDirectory@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetDirectory(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsReadable@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetReadable(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsWriteable@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetWriteable(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Create@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Create(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Delete@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Delete(global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WriteTextFile@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WriteTextFile(global::System.IntPtr filename, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ClearFile@FileSystem@acid@@SA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ClearFile(global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ParentDirectory@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void ParentDirectory(global::System.IntPtr @return, global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FileName@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FileName(global::System.IntPtr @return, global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FileSuffix@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern void FileSuffix(global::System.IntPtr @return, global::System.IntPtr path);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorkingDirectory@FileSystem@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetWorkingDirectory(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FileSystem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FileSystem>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.FileSystem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileSystem(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FileSystem __CreateInstance(global::Acid.Sharp.FileSystem.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FileSystem(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FileSystem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileSystem.__Internal));
            *(global::Acid.Sharp.FileSystem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FileSystem(global::Acid.Sharp.FileSystem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FileSystem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FileSystem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public FileSystem(global::Acid.Sharp.FileSystem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FileSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.FileSystem.__Internal*) __Instance) = *((global::Acid.Sharp.FileSystem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FileSystem __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if a file exists.</summary>
        /// <param name="filename">The filename.</param>
        public static bool Exists(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Exists(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets if a path is a file exists.</summary>
        /// <param name="path">The path.</param>
        public static bool GetFile(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetFile(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets if a path is a directory exists.</summary>
        /// <param name="path">The path.</param>
        public static bool GetDirectory(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetDirectory(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets if a path is readable.</summary>
        /// <param name="path">The path.</param>
        public static bool GetReadable(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetReadable(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets if a path is writeable.</summary>
        /// <param name="path">The path.</param>
        public static bool GetWriteable(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetWriteable(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates a path, will create folders and files.</summary>
        /// <param name="path">The path.</param>
        public static bool Create(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Create(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Deletes the last element in a path (file or directory).</summary>
        /// <param name="path">The path.</param>
        public static bool Delete(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Delete(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Writes to a text file from a string.</summary>
        /// <param name="filename">The filename.</param>
        /// <param name="data">The text data.</param>
        public static bool WriteTextFile(string filename, string data)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(data, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.WriteTextFile(__arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Clears the contents from a file.</summary>
        /// <param name="filename">The filename.</param>
        public static bool ClearFile(string filename)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.ClearFile(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets the parent directory of a path.</summary>
        /// <param name="path">The path to get the parent directory of.</param>
        public static string ParentDirectory(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ParentDirectory(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the file name from a path.</summary>
        /// <param name="path">The path to get the name of.</param>
        public static string FileName(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FileName(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the file suffix (extension) from a path.</summary>
        /// <param name="path">The path to get the suffix of.</param>
        public static string FileSuffix(string path)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(path, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.FileSuffix(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static char Separator
        {
            get
            {
                var __ptr = (sbyte*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?SEPARATOR@FileSystem@acid@@2DB");
                return global::System.Convert.ToChar(*__ptr);
            }
        }

        public static char AltSeparator
        {
            get
            {
                var __ptr = (sbyte*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ALT_SEPARATOR@FileSystem@acid@@2DB");
                return global::System.Convert.ToChar(*__ptr);
            }
        }

        /// <summary>Gets the current working directory.</summary>
        public static string WorkingDirectory
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetWorkingDirectory(new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Interface for an axis based input device.</summary>
    public unsafe abstract partial class IAxis : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IAxis@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IAxis@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IAxis> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IAxis>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IAxis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IAxisInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IAxis __CreateInstance(global::Acid.Sharp.IAxis.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IAxisInternal(native, skipVTables);
        }

        protected IAxis(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IAxis()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IAxis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IAxis");
        }

        protected IAxis(global::Acid.Sharp.IAxis _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IAxis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IAxis");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IAxis.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the current value along the axis. -1 is smallest input, 1 is largest input.</summary>
        public abstract float Amount
        {
            get;
        }

        #region Virtual table interop

        // float GetAmount() const = 0
        private static global::Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IAxis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IAxisInternal : global::Acid.Sharp.IAxis, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IAxis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IAxis.__Internal));
            *(global::Acid.Sharp.IAxis.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IAxisInternal(global::Acid.Sharp.IAxis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IAxisInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets the current value along the axis. -1 is smallest input, 1 is largest input.</summary>
        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Interface for a binary input device.</summary>
    public unsafe abstract partial class IButton : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IButton@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IButton@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IButton> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IButton>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IButtonInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IButton __CreateInstance(global::Acid.Sharp.IButton.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IButtonInternal(native, skipVTables);
        }

        protected IButton(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IButton()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IButton");
        }

        protected IButton(global::Acid.Sharp.IButton _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IButton");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IButton.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if the key is down and was not down before. Key press recognized as one click.</summary>
        public abstract bool WasDown();

        /// <summary>Returns whether this button is currently pressed.</summary>
        public abstract bool Down
        {
            get;
        }

        #region Virtual table interop

        // bool IsDown() const = 0
        private static global::Delegates.Func_bool_IntPtr _GetDownDelegateInstance;

        private static bool _GetDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Down;
            return __ret;
        }

        // bool WasDown() = 0
        private static global::Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetDownDelegateInstance += _GetDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IButtonInternal : global::Acid.Sharp.IButton, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IButton.__Internal));
            *(global::Acid.Sharp.IButton.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IButtonInternal(global::Acid.Sharp.IButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IButtonInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets if the key is down and was not down before. Key press recognized as one click.</summary>
        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Returns whether this button is currently pressed.</summary>
        public override bool Down
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___GetDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Axis composed of two buttons.</summary>
    public unsafe partial class AxisButton : global::Acid.Sharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IButton___N_std_S_default_delete__S0_ m_negative;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IButton___N_std_S_default_delete__S0_ m_positive;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisButton@acid@@QEAA@PEAVIButton@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr negative, global::System.IntPtr positive);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisButton@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AxisButton@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.AxisButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AxisButton(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.AxisButton __CreateInstance(global::Acid.Sharp.AxisButton.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AxisButton(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.AxisButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AxisButton.__Internal));
            global::Acid.Sharp.AxisButton.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisButton(global::Acid.Sharp.AxisButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisButton(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new axis button.</summary>
        /// <param name="negative">When this button is down, the axis is negative.</param>
        /// <param name="positive">When this button is down, the axis is positive.</param>
        public AxisButton(global::Acid.Sharp.IButton negative, global::Acid.Sharp.IButton positive)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AxisButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(negative, null) ? global::System.IntPtr.Zero : negative.__Instance;
            var __arg1 = ReferenceEquals(positive, null) ? global::System.IntPtr.Zero : positive.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.AxisButton");
        }

        public AxisButton(global::Acid.Sharp.AxisButton _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AxisButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.AxisButton");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.AxisButton.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // float GetAmount() const override
        private static global::Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.AxisButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Axis composed of multiple other axes.</summary>
    public unsafe partial class AxisCompound : global::Acid.Sharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IAxis___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_axes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisCompound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AxisCompound@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.AxisCompound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AxisCompound(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.AxisCompound __CreateInstance(global::Acid.Sharp.AxisCompound.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AxisCompound(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.AxisCompound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AxisCompound.__Internal));
            global::Acid.Sharp.AxisCompound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisCompound(global::Acid.Sharp.AxisCompound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisCompound(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public AxisCompound(global::Acid.Sharp.AxisCompound _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AxisCompound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.AxisCompound");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.AxisCompound.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // float GetAmount() const override
        private static global::Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.AxisCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public enum JoystickPort
    {
        Joystick1 = 0,
        Joystick2 = 1,
        Joystick3 = 2,
        Joystick4 = 3,
        Joystick5 = 4,
        Joystick6 = 5,
        Joystick7 = 6,
        Joystick8 = 7,
        Joystick9 = 8,
        Joystick10 = 9,
        Joystick11 = 10,
        Joystick12 = 11,
        Joystick13 = 12,
        Joystick14 = 13,
        Joystick15 = 14,
        Joystick16 = 15,
        JoystickBeginRange = 0,
        JoystickEndRange = 15,
        JoystickRangeSize = 16,
        JoystickMaxEnum = 2147483647
    }

    /// <summary>A definition for a managed joystick.</summary>
    public unsafe partial class Joystick : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.JoystickPort m_port;

            [FieldOffset(4)]
            internal byte m_connected;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::System.IntPtr m_axes;

            [FieldOffset(48)]
            internal global::System.IntPtr m_buttons;

            [FieldOffset(56)]
            internal uint m_axeCount;

            [FieldOffset(60)]
            internal uint m_buttonCount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joystick@acid@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joystick@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Joystick> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Joystick>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Joystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Joystick(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Joystick __CreateInstance(global::Acid.Sharp.Joystick.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Joystick(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Joystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joystick.__Internal));
            global::Acid.Sharp.Joystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joystick(global::Acid.Sharp.Joystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joystick(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Joystick(global::Acid.Sharp.Joystick _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Joystick()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Joystick __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.JoystickPort MPort
        {
            get
            {
                return ((global::Acid.Sharp.Joystick.__Internal*) __Instance)->m_port;
            }

            set
            {
                ((global::Acid.Sharp.Joystick.__Internal*)__Instance)->m_port = value;
            }
        }

        public bool MConnected
        {
            get
            {
                return ((global::Acid.Sharp.Joystick.__Internal*) __Instance)->m_connected != 0;
            }

            set
            {
                ((global::Acid.Sharp.Joystick.__Internal*)__Instance)->m_connected = (byte) (value ? 1 : 0);
            }
        }

        public string MName
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.Joystick.__Internal*) __Instance)->m_name));
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                ((global::Acid.Sharp.Joystick.__Internal*)__Instance)->m_name = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
            }
        }

        public float* MAxes
        {
            get
            {
                return (float*) ((global::Acid.Sharp.Joystick.__Internal*) __Instance)->m_axes;
            }

            set
            {
                ((global::Acid.Sharp.Joystick.__Internal*)__Instance)->m_axes = (global::System.IntPtr) value;
            }
        }

        public byte* MButtons
        {
            get
            {
                return (byte*) ((global::Acid.Sharp.Joystick.__Internal*) __Instance)->m_buttons;
            }

            set
            {
                ((global::Acid.Sharp.Joystick.__Internal*)__Instance)->m_buttons = (global::System.IntPtr) value;
            }
        }

        public uint MAxeCount
        {
            get
            {
                return ((global::Acid.Sharp.Joystick.__Internal*) __Instance)->m_axeCount;
            }

            set
            {
                ((global::Acid.Sharp.Joystick.__Internal*)__Instance)->m_axeCount = value;
            }
        }

        public uint MButtonCount
        {
            get
            {
                return ((global::Acid.Sharp.Joystick.__Internal*) __Instance)->m_buttonCount;
            }

            set
            {
                ((global::Acid.Sharp.Joystick.__Internal*)__Instance)->m_buttonCount = value;
            }
        }
    }

    /// <summary>A module used for the creation, updating and destruction of the joysticks.</summary>
    public unsafe partial class Joysticks : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 968)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_acid_S_Joystick_Vk15 m_connected;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joysticks@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Joysticks@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Joysticks@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Joysticks@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsConnected@Joysticks@acid@@QEBA_NAEBW4JoystickPort@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetConnected(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Joysticks@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBW4JoystickPort@2@@Z")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return, global::Acid.Sharp.JoystickPort* port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetButton@Joysticks@acid@@QEBA_NAEBW4JoystickPort@2@AEBI@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetButton(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* port, uint* button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxis@Joysticks@acid@@QEBAMAEBW4JoystickPort@2@AEBI@Z")]
            internal static extern float GetAxis(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* port, uint* axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCountButtons@Joysticks@acid@@QEBAIAEBW4JoystickPort@2@@Z")]
            internal static extern uint GetCountButtons(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCountAxes@Joysticks@acid@@QEBAIAEBW4JoystickPort@2@@Z")]
            internal static extern uint GetCountAxes(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* port);
        }

        internal static new global::Acid.Sharp.Joysticks __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Joysticks(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Joysticks __CreateInstance(global::Acid.Sharp.Joysticks.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Joysticks(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Joysticks.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joysticks.__Internal));
            global::Acid.Sharp.Joysticks.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Joysticks(global::Acid.Sharp.Joysticks.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Joysticks(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Joysticks()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joysticks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Joysticks");
        }

        public Joysticks(global::Acid.Sharp.Joysticks _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Joysticks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Joysticks");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Joysticks.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Determines if the joystick is connected</summary>
        /// <param name="port">The joystick to check connection with.</param>
        public bool GetConnected(global::Acid.Sharp.JoystickPort* port)
        {
            var __ret = __Internal.GetConnected((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets the name of the joystick.</summary>
        /// <param name="port">The joystick to get the name of.</param>
        public string GetName(global::Acid.Sharp.JoystickPort* port)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret), port);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the whether a button on a joystick is pressed.</summary>
        /// <param name="port">The joystick to get the button from.</param>
        /// <param name="button">The button of interest.</param>
        public bool GetButton(global::Acid.Sharp.JoystickPort* port, uint button)
        {
            var __arg1 = &button;
            var __ret = __Internal.GetButton((__Instance + __PointerAdjustment), port, __arg1);
            return __ret;
        }

        /// <summary>Gets the value of a joysticks axis.</summary>
        /// <param name="port">The joystick to get the axis from.</param>
        /// <param name="axis">The axis of interest.</param>
        public float GetAxis(global::Acid.Sharp.JoystickPort* port, uint axis)
        {
            var __arg1 = &axis;
            var __ret = __Internal.GetAxis((__Instance + __PointerAdjustment), port, __arg1);
            return __ret;
        }

        /// <summary>Gets the number of buttons the joystick offers.</summary>
        /// <param name="port">The joystick to the the button count from.</param>
        public uint GetCountButtons(global::Acid.Sharp.JoystickPort* port)
        {
            var __ret = __Internal.GetCountButtons((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets the number of axes the joystick offers.</summary>
        /// <param name="port">The joystick to the the axis count from.</param>
        public uint GetCountAxes(global::Acid.Sharp.JoystickPort* port)
        {
            var __ret = __Internal.GetCountAxes((__Instance + __PointerAdjustment), port);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Joysticks Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Joysticks __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Joysticks.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Joysticks) global::Acid.Sharp.Joysticks.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Joysticks.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Joysticks) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Axis from a joystick.</summary>
    public unsafe partial class AxisJoystick : global::Acid.Sharp.IAxis, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IAxis;

            [FieldOffset(8)]
            internal global::Acid.Sharp.JoystickPort m_joystick;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_axes;

            [FieldOffset(40)]
            internal byte m_reverse;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0AxisJoystick@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1AxisJoystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@AxisJoystick@acid@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::Acid.Sharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@AxisJoystick@acid@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* joystickPort);
        }

        internal static new global::Acid.Sharp.AxisJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AxisJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.AxisJoystick __CreateInstance(global::Acid.Sharp.AxisJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.AxisJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.AxisJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AxisJoystick.__Internal));
            global::Acid.Sharp.AxisJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private AxisJoystick(global::Acid.Sharp.AxisJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AxisJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public AxisJoystick(global::Acid.Sharp.AxisJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.AxisJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.AxisJoystick");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IAxis __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.AxisJoystick.__Internal*) __Instance)->vfptr_IAxis = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), &value);
            }
        }

        public override float Amount
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetAmountDelegate = (global::Delegates.Func_float_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr));
                var __ret = ___GetAmountDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // float GetAmount() const override
        private static global::Delegates.Func_float_IntPtr _GetAmountDelegateInstance;

        private static float _GetAmountDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.AxisJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Amount;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetAmountDelegateInstance += _GetAmountDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetAmountDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Handles multiple buttons at once.</summary>
    public unsafe partial class ButtonCompound : global::Acid.Sharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IButton___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_buttons;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonCompound@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonCompound@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ButtonCompound __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonCompound(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ButtonCompound __CreateInstance(global::Acid.Sharp.ButtonCompound.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonCompound(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ButtonCompound.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonCompound.__Internal));
            global::Acid.Sharp.ButtonCompound.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonCompound(global::Acid.Sharp.ButtonCompound.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonCompound(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonCompound(global::Acid.Sharp.ButtonCompound _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonCompound.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ButtonCompound");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ButtonCompound.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool Down
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___GetDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::Delegates.Func_bool_IntPtr _GetDownDelegateInstance;

        private static bool _GetDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Down;
            return __ret;
        }

        // bool WasDown() override
        private static global::Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonCompound) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetDownDelegateInstance += _GetDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Button from a joystick.</summary>
    public unsafe partial class ButtonJoystick : global::Acid.Sharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Acid.Sharp.JoystickPort m_joystick;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_buttons;

            [FieldOffset(40)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonJoystick@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonJoystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@ButtonJoystick@acid@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::Acid.Sharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@ButtonJoystick@acid@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* joystickPort);
        }

        internal static new global::Acid.Sharp.ButtonJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ButtonJoystick __CreateInstance(global::Acid.Sharp.ButtonJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ButtonJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonJoystick.__Internal));
            global::Acid.Sharp.ButtonJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonJoystick(global::Acid.Sharp.ButtonJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonJoystick(global::Acid.Sharp.ButtonJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ButtonJoystick");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ButtonJoystick.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public global::Acid.Sharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), &value);
            }
        }

        public override bool Down
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___GetDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::Delegates.Func_bool_IntPtr _GetDownDelegateInstance;

        private static bool _GetDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Down;
            return __ret;
        }

        // bool WasDown() override
        private static global::Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetDownDelegateInstance += _GetDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public enum Key
    {
        Unknown = -1,
        Space = 32,
        Apostrophe = 39,
        Comma = 44,
        Minus = 45,
        Period = 46,
        Slash = 47,
        _0 = 48,
        _1 = 49,
        _2 = 50,
        _3 = 51,
        _4 = 52,
        _5 = 53,
        _6 = 54,
        _7 = 55,
        _8 = 56,
        _9 = 57,
        Semicolon = 59,
        Equal = 61,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        LeftBracket = 91,
        Backslash = 92,
        RightBracket = 93,
        GraveAccent = 96,
        World1 = 161,
        World2 = 162,
        Escape = 256,
        Enter = 257,
        Tab = 258,
        Backspace = 259,
        Insert = 260,
        Delete = 261,
        Right = 262,
        Left = 263,
        Down = 264,
        Up = 265,
        PageUp = 266,
        PageDown = 267,
        Home = 268,
        End = 269,
        CapsLock = 280,
        ScrollLock = 281,
        NumLock = 282,
        PrintScreen = 283,
        Pause = 284,
        F1 = 290,
        F2 = 291,
        F3 = 292,
        F4 = 293,
        F5 = 294,
        F6 = 295,
        F7 = 296,
        F8 = 297,
        F9 = 298,
        F10 = 299,
        F11 = 300,
        F12 = 301,
        F13 = 302,
        F14 = 303,
        F15 = 304,
        F16 = 305,
        F17 = 306,
        F18 = 307,
        F19 = 308,
        F20 = 309,
        F21 = 310,
        F22 = 311,
        F23 = 312,
        F24 = 313,
        F25 = 314,
        Pad0 = 320,
        Pad1 = 321,
        Pad2 = 322,
        Pad3 = 323,
        Pad4 = 324,
        Pad5 = 325,
        Pad6 = 326,
        Pad7 = 327,
        Pad8 = 328,
        Pad9 = 329,
        PadDecimal = 330,
        PadDivide = 331,
        PadMultiply = 332,
        PadSubtract = 333,
        PadAdd = 334,
        PadEnter = 335,
        PadEqual = 336,
        LeftShift = 340,
        LeftControl = 341,
        LeftAlt = 342,
        LeftSuper = 343,
        RightShift = 344,
        RightControl = 345,
        RightAlt = 346,
        RightSuper = 347,
        Menu = 348,
        BeginRange = -1,
        EndRange = 348,
        RangeSize = 350,
        MaxEnum = 2147483647
    }

    /// <summary>A module used for the creation, updating and destruction of the keyboard keys.</summary>
    public unsafe partial class Keyboard : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 360)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array__b_Vk348 m_keyboardKeys;

            [FieldOffset(356)]
            internal sbyte m_char;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyboard@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Keyboard@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Keyboard@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetKey@Keyboard@acid@@QEBA_NAEBW4Key@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetKey(global::System.IntPtr instance, global::Acid.Sharp.Key* key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChar@Keyboard@acid@@QEBADXZ")]
            internal static extern sbyte GetChar(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Keyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Keyboard(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Keyboard __CreateInstance(global::Acid.Sharp.Keyboard.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Keyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Keyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Keyboard.__Internal));
            global::Acid.Sharp.Keyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Keyboard(global::Acid.Sharp.Keyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Keyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Keyboard()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Keyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Keyboard");
        }

        public Keyboard(global::Acid.Sharp.Keyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Keyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Keyboard");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets whether or not a particular key is currently pressed. Actions: WSI_ACTION_PRESS, WSI_ACTION_RELEASE, WSI_ACTION_REPEAT</summary>
        /// <param name="key">The key to test.</param>
        public bool GetKey(global::Acid.Sharp.Key* key)
        {
            var __ret = __Internal.GetKey((__Instance + __PointerAdjustment), key);
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Keyboard Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Keyboard __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Keyboard.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Keyboard) global::Acid.Sharp.Keyboard.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Keyboard.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the current user input, ASCII Dec value.</summary>
        public char Char
        {
            get
            {
                var __ret = __Internal.GetChar((__Instance + __PointerAdjustment));
                return global::System.Convert.ToChar(__ret);
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Keyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Keyboard
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackKey@acid@@YAXPEAUGLFWwindow@@HHHH@Z")]
            internal static extern void CallbackKey(global::System.IntPtr window, int key, int scancode, int action, int mods);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CallbackChar@acid@@YAXPEAUGLFWwindow@@I@Z")]
            internal static extern void CallbackChar(global::System.IntPtr window, uint codepoint);
        }

        public static void CallbackKey(global::GLFWwindow window, int key, int scancode, int action, int mods)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackKey(__arg0, key, scancode, action, mods);
        }

        public static void CallbackChar(global::GLFWwindow window, uint codepoint)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CallbackChar(__arg0, codepoint);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Keys from a keyboard.</summary>
    public unsafe partial class ButtonKeyboard : global::Acid.Sharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_E_Key___N_std_S_allocator__S0_ m_keys;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonKeyboard@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonKeyboard@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ButtonKeyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonKeyboard(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ButtonKeyboard __CreateInstance(global::Acid.Sharp.ButtonKeyboard.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonKeyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ButtonKeyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonKeyboard.__Internal));
            global::Acid.Sharp.ButtonKeyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonKeyboard(global::Acid.Sharp.ButtonKeyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonKeyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonKeyboard(global::Acid.Sharp.ButtonKeyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonKeyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ButtonKeyboard");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ButtonKeyboard.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool Down
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___GetDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::Delegates.Func_bool_IntPtr _GetDownDelegateInstance;

        private static bool _GetDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Down;
            return __ret;
        }

        // bool WasDown() override
        private static global::Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetDownDelegateInstance += _GetDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Button from a mouse.</summary>
    public unsafe partial class ButtonMouse : global::Acid.Sharp.IButton, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IButton;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_E_MouseButton___N_std_S_allocator__S0_ m_buttons;

            [FieldOffset(32)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ButtonMouse@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ButtonMouse@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ButtonMouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonMouse(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ButtonMouse __CreateInstance(global::Acid.Sharp.ButtonMouse.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ButtonMouse(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ButtonMouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonMouse.__Internal));
            global::Acid.Sharp.ButtonMouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ButtonMouse(global::Acid.Sharp.ButtonMouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ButtonMouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ButtonMouse(global::Acid.Sharp.ButtonMouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ButtonMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ButtonMouse");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IButton __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ButtonMouse.__Internal*) __Instance)->vfptr_IButton = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override bool WasDown()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___WasDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
            var __ret = ___WasDownDelegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public override bool Down
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetDownDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___GetDownDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // bool IsDown() const override
        private static global::Delegates.Func_bool_IntPtr _GetDownDelegateInstance;

        private static bool _GetDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Down;
            return __ret;
        }

        // bool WasDown() override
        private static global::Delegates.Func_bool_IntPtr _WasDownDelegateInstance;

        private static bool _WasDownDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ButtonMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.WasDown();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetDownDelegateInstance += _GetDownDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetDownDelegateInstance).ToPointer();
                _WasDownDelegateInstance += _WasDownDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_WasDownDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a hazy fog in the world.</summary>
    public unsafe partial class Fog : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Colour.__Internal m_colour;

            [FieldOffset(16)]
            internal float m_density;

            [FieldOffset(20)]
            internal float m_gradient;

            [FieldOffset(24)]
            internal float m_lowerLimit;

            [FieldOffset(28)]
            internal float m_upperLimit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Fog@acid@@QEAA@AEBVColour@1@AEBM111@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr colour, float* density, float* gradient, float* lowerLimit, float* upperLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Fog@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Fog@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Fog@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Fog@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColour@Fog@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetColour(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColour@Fog@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetColour(global::System.IntPtr instance, global::System.IntPtr colour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDensity@Fog@acid@@QEBAMXZ")]
            internal static extern float GetDensity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDensity@Fog@acid@@QEAAXAEBM@Z")]
            internal static extern void SetDensity(global::System.IntPtr instance, float* density);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGradient@Fog@acid@@QEBAMXZ")]
            internal static extern float GetGradient(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGradient@Fog@acid@@QEAAXAEBM@Z")]
            internal static extern void SetGradient(global::System.IntPtr instance, float* gradient);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLowerLimit@Fog@acid@@QEBAMXZ")]
            internal static extern float GetLowerLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLowerLimit@Fog@acid@@QEAAXAEBM@Z")]
            internal static extern void SetLowerLimit(global::System.IntPtr instance, float* lowerLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUpperLimit@Fog@acid@@QEBAMXZ")]
            internal static extern float GetUpperLimit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUpperLimit@Fog@acid@@QEAAXAEBM@Z")]
            internal static extern void SetUpperLimit(global::System.IntPtr instance, float* upperLimit);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Fog> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Fog>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Fog __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Fog(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Fog __CreateInstance(global::Acid.Sharp.Fog.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Fog(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Fog.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Fog.__Internal));
            global::Acid.Sharp.Fog.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Fog(global::Acid.Sharp.Fog.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Fog(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Fog.</summary>
        /// <param name="colour">The colour of the Fog.</param>
        /// <param name="density">How dense the Fog will be.</param>
        /// <param name="gradient">The gradient of the Fog.</param>
        /// <param name="lowerLimit">At what height will the skybox Fog begin to appear.</param>
        /// <param name="upperLimit">At what height will there be skybox no Fog.</param>
        public Fog(global::Acid.Sharp.Colour colour, float density, float gradient, float lowerLimit, float upperLimit)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Fog.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(colour, null))
                throw new global::System.ArgumentNullException("colour", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = colour.__Instance;
            var __arg1 = &density;
            var __arg2 = &gradient;
            var __arg3 = &lowerLimit;
            var __arg4 = &upperLimit;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
        }

        /// <summary>Constructor for Fog.</summary>
        /// <param name="source">Creates this fog out of a existing one.</param>
        public Fog(global::Acid.Sharp.Fog source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Fog.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Fog __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public global::Acid.Sharp.Colour Colour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Density
        {
            get
            {
                var __ret = __Internal.GetDensity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetDensity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Gradient
        {
            get
            {
                var __ret = __Internal.GetGradient((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetGradient((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float LowerLimit
        {
            get
            {
                var __ret = __Internal.GetLowerLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetLowerLimit((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float UpperLimit
        {
            get
            {
                var __ret = __Internal.GetUpperLimit((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetUpperLimit((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a point light, contains a colour, position and attenuation.</summary>
    public unsafe partial class Light : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Colour.__Internal m_colour;

            [FieldOffset(40)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(52)]
            internal float m_radius;

            [FieldOffset(56)]
            internal global::Acid.Sharp.Vector3.__Internal m_localOffset;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Light@acid@@QEAA@AEBVColour@1@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr colour, float* radius, global::System.IntPtr localOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Light@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColour@Light@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetColour(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColour@Light@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetColour(global::System.IntPtr instance, global::System.IntPtr colour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@Light@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@Light@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalOffset@Light@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetLocalOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLocalOffset@Light@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLocalOffset(global::System.IntPtr instance, global::System.IntPtr localOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Light@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        internal static new global::Acid.Sharp.Light __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Light(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Light __CreateInstance(global::Acid.Sharp.Light.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Light(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Light.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Light.__Internal));
            global::Acid.Sharp.Light.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Light(global::Acid.Sharp.Light.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Light(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new point light.</summary>
        /// <param name="colour">The colour of the light.</param>
        /// <param name="radius">How far the light will have influence (-1 sets this to a directional light).</param>
        /// <param name="localOffset">The parent offset of the light.</param>
        public Light(global::Acid.Sharp.Colour colour, float radius, global::Acid.Sharp.Vector3 localOffset)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Light.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(colour, null))
                throw new global::System.ArgumentNullException("colour", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = colour.__Instance;
            var __arg1 = &radius;
            if (ReferenceEquals(localOffset, null))
                throw new global::System.ArgumentNullException("localOffset", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = localOffset.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.Light");
        }

        /// <summary>Creates a new point light from a source object.</summary>
        /// <param name="source">The source light object.</param>
        public Light(global::Acid.Sharp.Light source)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Light.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Light");
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public global::Acid.Sharp.Colour Colour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 LocalOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetLocalOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLocalOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Light) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public enum AttachmentType
    {
        Image = 0,
        Depth = 1,
        Swapchain = 2
    }

    /// <summary>A object that represents an attachment in a renderpass.</summary>
    public unsafe partial class Attachment : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(40)]
            internal global::Acid.Sharp.AttachmentType m_type;

            [FieldOffset(44)]
            internal global::VkFormat m_format;

            [FieldOffset(48)]
            internal byte m_multisampled;

            [FieldOffset(52)]
            internal global::Acid.Sharp.Colour.__Internal m_clearColour;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Attachment@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Attachment@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@Attachment@acid@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@Attachment@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetType@Attachment@acid@@QEBA?AW4AttachmentType@2@XZ")]
            internal static extern global::Acid.Sharp.AttachmentType GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsMultisampled@Attachment@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetMultisampled(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetClearColour@Attachment@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetClearColour(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Attachment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Attachment>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Attachment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Attachment(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Attachment __CreateInstance(global::Acid.Sharp.Attachment.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Attachment(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Attachment.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Attachment.__Internal));
            global::Acid.Sharp.Attachment.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Attachment(global::Acid.Sharp.Attachment.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Attachment(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Attachment(global::Acid.Sharp.Attachment _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Attachment.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Attachment __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::Acid.Sharp.AttachmentType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool Multisampled
        {
            get
            {
                var __ret = __Internal.GetMultisampled((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.Colour ClearColour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetClearColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class SubpassType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_binding;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_attachmentBindings;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SubpassType@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SubpassType@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBinding@SubpassType@acid@@QEBAIXZ")]
            internal static extern uint GetBinding(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SubpassType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SubpassType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.SubpassType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SubpassType(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SubpassType __CreateInstance(global::Acid.Sharp.SubpassType.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SubpassType(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SubpassType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SubpassType.__Internal));
            global::Acid.Sharp.SubpassType.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SubpassType(global::Acid.Sharp.SubpassType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SubpassType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SubpassType(global::Acid.Sharp.SubpassType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SubpassType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.SubpassType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Binding
        {
            get
            {
                var __ret = __Internal.GetBinding((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class RenderpassCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Attachment___N_std_S_allocator__S0_ m_images;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_SubpassType___N_std_S_allocator__S0_ m_subpasses;

            [FieldOffset(48)]
            internal uint m_width;

            [FieldOffset(52)]
            internal uint m_height;

            [FieldOffset(56)]
            internal float m_scale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RenderpassCreate@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RenderpassCreate@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@RenderpassCreate@acid@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWidth@RenderpassCreate@acid@@QEAAXAEBI@Z")]
            internal static extern void SetWidth(global::System.IntPtr instance, uint* width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@RenderpassCreate@acid@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@RenderpassCreate@acid@@QEAAXAEBI@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, uint* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@RenderpassCreate@acid@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScale@RenderpassCreate@acid@@QEAAXAEBM@Z")]
            internal static extern void SetScale(global::System.IntPtr instance, float* scale);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RenderpassCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RenderpassCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.RenderpassCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RenderpassCreate(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RenderpassCreate __CreateInstance(global::Acid.Sharp.RenderpassCreate.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RenderpassCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RenderpassCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RenderpassCreate.__Internal));
            global::Acid.Sharp.RenderpassCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RenderpassCreate(global::Acid.Sharp.RenderpassCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RenderpassCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RenderpassCreate(global::Acid.Sharp.RenderpassCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RenderpassCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.RenderpassCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetWidth((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetHeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetScale((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Renderpass : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_renderPass;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkAttachmentDescription___N_std_S_allocator__S0_ m_attachments;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkSubpassDescription___N_std_S_allocator__S0_ m_subpasses;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____S_VkSubpassDependency___N_std_S_allocator__S0_ m_dependencies;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Renderpass@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Renderpass@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Renderpass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Renderpass>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Renderpass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Renderpass(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Renderpass __CreateInstance(global::Acid.Sharp.Renderpass.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Renderpass(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Renderpass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Renderpass.__Internal));
            global::Acid.Sharp.Renderpass.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Renderpass(global::Acid.Sharp.Renderpass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Renderpass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Renderpass(global::Acid.Sharp.Renderpass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Renderpass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Renderpass __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class DepthStencil : global::Acid.Sharp.IDescriptor, global::Acid.Sharp.IBuffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(8)]
            internal ulong m_size;

            [FieldOffset(16)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(24)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(32)]
            internal uint m_width;

            [FieldOffset(36)]
            internal uint m_height;

            [FieldOffset(40)]
            internal global::System.IntPtr m_image;

            [FieldOffset(48)]
            internal global::System.IntPtr m_imageView;

            [FieldOffset(56)]
            internal global::System.IntPtr m_sampler;

            [FieldOffset(64)]
            internal global::VkFormat m_format;

            [FieldOffset(72)]
            internal global::VkDescriptorImageInfo.__Internal m_imageInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DepthStencil@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1DepthStencil@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@DepthStencil@acid@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@DepthStencil@acid@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSize@Buffer@acid@@QEBA_KXZ")]
            internal static extern ulong GetSize(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.DepthStencil __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DepthStencil(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DepthStencil __CreateInstance(global::Acid.Sharp.DepthStencil.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DepthStencil(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DepthStencil.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DepthStencil.__Internal));
            global::Acid.Sharp.DepthStencil.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DepthStencil(global::Acid.Sharp.DepthStencil.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DepthStencil(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DepthStencil(global::Acid.Sharp.DepthStencil _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DepthStencil.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IIDescriptor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        protected ulong MSize
        {
            get
            {
                return ((global::Acid.Sharp.DepthStencil.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::Acid.Sharp.DepthStencil.__Internal*)__Instance)->m_size = value;
            }
        }

        public global::System.IntPtr __PointerToBuffer
        {
            get
            {
                return __Instance + 8;
            }
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public ulong Size
        {
            get
            {
                var __ret = __Internal.GetSize((__Instance + 8));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Swapchain : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::VkPresentModeKHR m_presentMode;

            [FieldOffset(8)]
            internal global::System.IntPtr m_swapchain;

            [FieldOffset(16)]
            internal uint m_swapchainImageCount;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkImage_T___N_std_S_allocator__S0_ m_swapchainImages;

            [FieldOffset(48)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkImageView_T___N_std_S_allocator__S0_ m_swapchainImageViews;

            [FieldOffset(72)]
            internal global::VkExtent2D.__Internal m_extent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Swapchain@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Swapchain@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetImageCount@Swapchain@acid@@QEBAIXZ")]
            internal static extern uint GetImageCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Swapchain> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Swapchain>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Swapchain __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Swapchain(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Swapchain __CreateInstance(global::Acid.Sharp.Swapchain.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Swapchain(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Swapchain.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Swapchain.__Internal));
            global::Acid.Sharp.Swapchain.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Swapchain(global::Acid.Sharp.Swapchain.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Swapchain(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Swapchain(global::Acid.Sharp.Swapchain _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Swapchain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Swapchain __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ImageCount
        {
            get
            {
                var __ret = __Internal.GetImageCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Framebuffers : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Texture___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_imageAttachments;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____S_VkFramebuffer_T___N_std_S_allocator__S0_ m_framebuffers;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Framebuffers@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Framebuffers@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttachment@Framebuffers@acid@@QEBAPEAVTexture@2@AEBI@Z")]
            internal static extern global::System.IntPtr GetAttachment(global::System.IntPtr instance, uint* index);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Framebuffers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Framebuffers>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Framebuffers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Framebuffers(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Framebuffers __CreateInstance(global::Acid.Sharp.Framebuffers.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Framebuffers(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Framebuffers.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Framebuffers.__Internal));
            global::Acid.Sharp.Framebuffers.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Framebuffers(global::Acid.Sharp.Framebuffers.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Framebuffers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Framebuffers(global::Acid.Sharp.Framebuffers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Framebuffers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Framebuffers __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.Texture GetAttachment(uint index)
        {
            var __arg0 = &index;
            var __ret = __Internal.GetAttachment((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.Texture __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Texture) global::Acid.Sharp.Texture.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Texture.__CreateInstance(__ret);
            return __result0;
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class RenderStage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 368)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_stageIndex;

            [FieldOffset(8)]
            internal global::Acid.Sharp.RenderpassCreate.__Internal m_renderpassCreate;

            [FieldOffset(72)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Renderpass___N_std_S_default_delete__S0_ m_renderpass;

            [FieldOffset(80)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_DepthStencil___N_std_S_default_delete__S0_ m_depthStencil;

            [FieldOffset(88)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Framebuffers___N_std_S_default_delete__S0_ m_framebuffers;

            [FieldOffset(96)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(112)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____U_VkClearValue___N_std_S_allocator__S0_ m_clearValues;

            [FieldOffset(136)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i m_subpassAttachmentCount;

            [FieldOffset(160)]
            internal global::Std.Optional.__Internal m_depthAttachment;

            [FieldOffset(240)]
            internal global::Std.Optional.__Internal m_swapchainAttachment;

            [FieldOffset(320)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__b___N_std_S_allocator__b m_subpassMultisampled;

            [FieldOffset(352)]
            internal byte m_fitDisplaySize;

            [FieldOffset(356)]
            internal uint m_lastWidth;

            [FieldOffset(360)]
            internal uint m_lastHeight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RenderStage@acid@@QEAA@AEBIAEBVRenderpassCreate@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint* stageIndex, global::System.IntPtr renderpassCreate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RenderStage@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RenderStage@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Rebuild@RenderStage@acid@@QEAAXAEBVSwapchain@2@@Z")]
            internal static extern void Rebuild(global::System.IntPtr instance, global::System.IntPtr swapchain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttachment@RenderStage@acid@@QEBAPEAVIDescriptor@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetAttachment(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttachmentCount@RenderStage@acid@@QEBAIAEBI@Z")]
            internal static extern uint GetAttachmentCount(global::System.IntPtr instance, uint* subpass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsMultisampled@RenderStage@acid@@QEBA_NAEBI@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetMultisampled(global::System.IntPtr instance, uint* subpass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SubpassCount@RenderStage@acid@@QEBAIXZ")]
            internal static extern uint SubpassCount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@RenderStage@acid@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@RenderStage@acid@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderpassCreate@RenderStage@acid@@QEAAAEAVRenderpassCreate@2@XZ")]
            internal static extern global::System.IntPtr GetRenderpassCreate(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderpass@RenderStage@acid@@QEBAPEAVRenderpass@2@XZ")]
            internal static extern global::System.IntPtr GetRenderpass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepthStencil@RenderStage@acid@@QEBAPEAVDepthStencil@2@XZ")]
            internal static extern global::System.IntPtr GetDepthStencil(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFramebuffers@RenderStage@acid@@QEBAPEAVFramebuffers@2@XZ")]
            internal static extern global::System.IntPtr GetFramebuffers(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasDepth@RenderStage@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasDepth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasSwapchain@RenderStage@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSwapchain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FitDisplaySize@RenderStage@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool FitDisplaySize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RenderStage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RenderStage>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.RenderStage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RenderStage(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RenderStage __CreateInstance(global::Acid.Sharp.RenderStage.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RenderStage(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RenderStage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RenderStage.__Internal));
            global::Acid.Sharp.RenderStage.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RenderStage(global::Acid.Sharp.RenderStage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RenderStage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RenderStage(uint stageIndex, global::Acid.Sharp.RenderpassCreate renderpassCreate)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RenderStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &stageIndex;
            if (ReferenceEquals(renderpassCreate, null))
                throw new global::System.ArgumentNullException("renderpassCreate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = renderpassCreate.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public RenderStage(global::Acid.Sharp.RenderStage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RenderStage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.RenderStage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Rebuild(global::Acid.Sharp.Swapchain swapchain)
        {
            if (ReferenceEquals(swapchain, null))
                throw new global::System.ArgumentNullException("swapchain", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = swapchain.__Instance;
            __Internal.Rebuild((__Instance + __PointerAdjustment), __arg0);
        }

        public global::Acid.Sharp.IIDescriptor GetAttachment(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetAttachment((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.IIDescriptor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IDescriptor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IIDescriptor) global::Acid.Sharp.IDescriptor.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IDescriptor.__CreateInstance(__ret);
            return __result0;
        }

        public uint GetAttachmentCount(uint subpass)
        {
            var __arg0 = &subpass;
            var __ret = __Internal.GetAttachmentCount((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public bool GetMultisampled(uint subpass)
        {
            var __arg0 = &subpass;
            var __ret = __Internal.GetMultisampled((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public uint SubpassCount
        {
            get
            {
                var __ret = __Internal.SubpassCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.RenderpassCreate RenderpassCreate
        {
            get
            {
                var __ret = __Internal.GetRenderpassCreate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.RenderpassCreate __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.RenderpassCreate.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.RenderpassCreate) global::Acid.Sharp.RenderpassCreate.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.RenderpassCreate.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.Renderpass Renderpass
        {
            get
            {
                var __ret = __Internal.GetRenderpass((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Renderpass __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Renderpass.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Renderpass) global::Acid.Sharp.Renderpass.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Renderpass.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.DepthStencil DepthStencil
        {
            get
            {
                var __ret = __Internal.GetDepthStencil((__Instance + __PointerAdjustment));
                global::Acid.Sharp.DepthStencil __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.DepthStencil.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.DepthStencil) global::Acid.Sharp.DepthStencil.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.DepthStencil.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.Framebuffers Framebuffers
        {
            get
            {
                var __ret = __Internal.GetFramebuffers((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Framebuffers __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Framebuffers.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Framebuffers) global::Acid.Sharp.Framebuffers.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Framebuffers.__CreateInstance(__ret);
                return __result0;
            }
        }

        public bool HasDepth
        {
            get
            {
                var __ret = __Internal.HasDepth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool HasSwapchain
        {
            get
            {
                var __ret = __Internal.HasSwapchain((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool FitDisplaySize
        {
            get
            {
                var __ret = __Internal.FitDisplaySize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a material pipeline.</summary>
    public unsafe partial class PipelineMaterial : global::Acid.Sharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 152)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(48)]
            internal global::Acid.Sharp.PipelineCreate.__Internal m_pipelineCreate;

            [FieldOffset(136)]
            internal global::System.IntPtr m_renderStage;

            [FieldOffset(144)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Pipeline___N_std_S_default_delete__S0_ m_pipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineMaterial@acid@@QEAA@AEBVGraphicsStage@1@AEBVPipelineCreate@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, global::System.IntPtr pipelineCreate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineMaterial@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineMaterial@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?BindPipeline@PipelineMaterial@acid@@QEAA_NAEBVCommandBuffer@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BindPipeline(global::System.IntPtr instance, global::System.IntPtr commandBuffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGraphicsStage@PipelineMaterial@acid@@QEBA?AVGraphicsStage@2@XZ")]
            internal static extern void GetGraphicsStage(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipelineCreate@PipelineMaterial@acid@@QEBA?AVPipelineCreate@2@XZ")]
            internal static extern void GetPipelineCreate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipeline@PipelineMaterial@acid@@QEAAPEAVPipeline@2@XZ")]
            internal static extern global::System.IntPtr GetPipeline(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.PipelineMaterial __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineMaterial(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.PipelineMaterial __CreateInstance(global::Acid.Sharp.PipelineMaterial.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineMaterial(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.PipelineMaterial.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineMaterial.__Internal));
            global::Acid.Sharp.PipelineMaterial.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineMaterial(global::Acid.Sharp.PipelineMaterial.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineMaterial(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new material pipeline.</summary>
        /// <param name="graphicsStage">Stage the pipeline will be executed on.</param>
        /// <param name="pipelineCreate">Information used to define pipeline properties.</param>
        public PipelineMaterial(global::Acid.Sharp.GraphicsStage graphicsStage, global::Acid.Sharp.PipelineCreate pipelineCreate)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineMaterial.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            if (ReferenceEquals(pipelineCreate, null))
                throw new global::System.ArgumentNullException("pipelineCreate", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipelineCreate.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.PipelineMaterial");
        }

        public PipelineMaterial(global::Acid.Sharp.PipelineMaterial _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineMaterial.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.PipelineMaterial");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.PipelineMaterial.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool BindPipeline(global::Acid.Sharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            var __ret = __Internal.BindPipeline((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::Acid.Sharp.GraphicsStage GraphicsStage
        {
            get
            {
                var __ret = new global::Acid.Sharp.GraphicsStage.__Internal();
                __Internal.GetGraphicsStage((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.GraphicsStage.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.PipelineCreate PipelineCreate
        {
            get
            {
                var __ret = new global::Acid.Sharp.PipelineCreate.__Internal();
                __Internal.GetPipelineCreate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.PipelineCreate.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Pipeline Pipeline
        {
            get
            {
                var __ret = __Internal.GetPipeline((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Pipeline __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Pipeline.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Pipeline) global::Acid.Sharp.Pipeline.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Pipeline.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.PipelineMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a material shader.</summary>
    public unsafe abstract partial class IMaterial : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IMaterial@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IMaterial@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::Acid.Sharp.IMaterial __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IMaterialInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IMaterial __CreateInstance(global::Acid.Sharp.IMaterial.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IMaterialInternal(native, skipVTables);
        }

        protected IMaterial(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IMaterial()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IMaterial.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IMaterial");
        }

        protected IMaterial(global::Acid.Sharp.IMaterial _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IMaterial.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IMaterial");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IMaterial.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override abstract void Start();

        public override abstract void Update();

        public override abstract void Decode(global::Acid.Sharp.Metadata metadata);

        public override abstract void Encode(global::Acid.Sharp.Metadata metadata);

        public abstract void PushUniforms(global::Acid.Sharp.UniformHandler uniformObject);

        public abstract void PushDescriptors(global::Acid.Sharp.DescriptorsHandler descriptorSet);

        #region Virtual table interop

        // void Start() override = 0
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override = 0
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override = 0
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override = 0
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // void PushUniforms(UniformHandler &uniformObject) = 0
        private static global::Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::Acid.Sharp.UniformHandler) global::Acid.Sharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::Acid.Sharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler &descriptorSet) = 0
        private static global::Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IMaterial) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::Acid.Sharp.DescriptorsHandler) global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::Acid.Sharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IMaterialInternal : global::Acid.Sharp.IMaterial, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IMaterial.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IMaterial.__Internal));
            *(global::Acid.Sharp.IMaterial.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IMaterialInternal(global::Acid.Sharp.IMaterial.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IMaterialInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::Acid.Sharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___PushUniformsDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(uniformObject, null))
                throw new global::System.ArgumentNullException("uniformObject", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::Acid.Sharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushDescriptorsDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(descriptorSet, null))
                throw new global::System.ArgumentNullException("descriptorSet", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents the default material shader.</summary>
    public unsafe partial class MaterialDefault : global::Acid.Sharp.IMaterial, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal byte m_animated;

            [FieldOffset(28)]
            internal global::Acid.Sharp.Colour.__Internal m_baseDiffuse;

            [FieldOffset(48)]
            internal global::Std.SharedPtr.__Internal m_diffuseTexture;

            [FieldOffset(64)]
            internal float m_metallic;

            [FieldOffset(68)]
            internal float m_roughness;

            [FieldOffset(72)]
            internal global::Std.SharedPtr.__Internal m_materialTexture;

            [FieldOffset(88)]
            internal global::Std.SharedPtr.__Internal m_normalTexture;

            [FieldOffset(104)]
            internal byte m_castsShadows;

            [FieldOffset(105)]
            internal byte m_ignoreLighting;

            [FieldOffset(106)]
            internal byte m_ignoreFog;

            [FieldOffset(112)]
            internal global::Std.SharedPtr.__Internal m_material;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialDefault@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1MaterialDefault@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIgnoreLighting@MaterialDefault@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetIgnoreLighting(global::System.IntPtr instance, bool* ignoreLighting);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIgnoreFog@MaterialDefault@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetIgnoreFog(global::System.IntPtr instance, bool* ignoreFog);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBaseDiffuse@MaterialDefault@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetBaseDiffuse(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBaseDiffuse@MaterialDefault@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetBaseDiffuse(global::System.IntPtr instance, global::System.IntPtr baseDiffuse);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMetallic@MaterialDefault@acid@@QEBAMXZ")]
            internal static extern float GetMetallic(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMetallic@MaterialDefault@acid@@QEAAXAEBM@Z")]
            internal static extern void SetMetallic(global::System.IntPtr instance, float* metallic);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRoughness@MaterialDefault@acid@@QEBAMXZ")]
            internal static extern float GetRoughness(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRoughness@MaterialDefault@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRoughness(global::System.IntPtr instance, float* roughness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CastsShadows@MaterialDefault@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CastsShadows(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCastsShadows@MaterialDefault@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetCastsShadows(global::System.IntPtr instance, bool* castsShadows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIgnoringLighting@MaterialDefault@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetIgnoringLighting(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsIgnoringFog@MaterialDefault@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetIgnoringFog(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.MaterialDefault __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MaterialDefault(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.MaterialDefault __CreateInstance(global::Acid.Sharp.MaterialDefault.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MaterialDefault(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.MaterialDefault.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MaterialDefault.__Internal));
            global::Acid.Sharp.MaterialDefault.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MaterialDefault(global::Acid.Sharp.MaterialDefault.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialDefault(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MaterialDefault(global::Acid.Sharp.MaterialDefault _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MaterialDefault.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.MaterialDefault");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.MaterialDefault.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::Acid.Sharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___PushUniformsDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(uniformObject, null))
                throw new global::System.ArgumentNullException("uniformObject", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::Acid.Sharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushDescriptorsDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(descriptorSet, null))
                throw new global::System.ArgumentNullException("descriptorSet", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetIgnoreLighting(bool ignoreLighting)
        {
            var __arg0 = &ignoreLighting;
            __Internal.SetIgnoreLighting((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetIgnoreFog(bool ignoreFog)
        {
            var __arg0 = &ignoreFog;
            __Internal.SetIgnoreFog((__Instance + __PointerAdjustment), __arg0);
        }

        public global::Acid.Sharp.Colour BaseDiffuse
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetBaseDiffuse((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetBaseDiffuse((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Metallic
        {
            get
            {
                var __ret = __Internal.GetMetallic((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetMetallic((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Roughness
        {
            get
            {
                var __ret = __Internal.GetRoughness((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRoughness((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool CastsShadows
        {
            get
            {
                var __ret = __Internal.CastsShadows((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetCastsShadows((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool IgnoringLighting
        {
            get
            {
                var __ret = __Internal.GetIgnoringLighting((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IgnoringFog
        {
            get
            {
                var __ret = __Internal.GetIgnoringFog((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // void PushUniforms(UniformHandler &uniformObject) override
        private static global::Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::Acid.Sharp.UniformHandler) global::Acid.Sharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::Acid.Sharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler &descriptorSet) override
        private static global::Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::Acid.Sharp.DescriptorsHandler) global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::Acid.Sharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that smoothly increases its value.</summary>
    public unsafe partial class SmoothFloat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_agility;

            [FieldOffset(4)]
            internal float m_target;

            [FieldOffset(8)]
            internal float m_actual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SmoothFloat@acid@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* initialValue, float* agility);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SmoothFloat@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@SmoothFloat@acid@@QEAAXAEBVTime@2@@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr delta);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IncreaseTarget@SmoothFloat@acid@@QEAAXAEBM@Z")]
            internal static extern void IncreaseTarget(global::System.IntPtr instance, float* increase);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@SmoothFloat@acid@@QEBAMXZ")]
            internal static extern float Get(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTarget@SmoothFloat@acid@@QEBAMXZ")]
            internal static extern float GetTarget(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTarget@SmoothFloat@acid@@QEAAXAEBM@Z")]
            internal static extern void SetTarget(global::System.IntPtr instance, float* target);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SmoothFloat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SmoothFloat>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.SmoothFloat __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SmoothFloat(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SmoothFloat __CreateInstance(global::Acid.Sharp.SmoothFloat.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SmoothFloat(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SmoothFloat.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SmoothFloat.__Internal));
            *(global::Acid.Sharp.SmoothFloat.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SmoothFloat(global::Acid.Sharp.SmoothFloat.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SmoothFloat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new smooth float.</summary>
        /// <param name="initialValue">The initial value.</param>
        /// <param name="agility">The agility for increasing actual.</param>
        public SmoothFloat(float initialValue, float agility)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SmoothFloat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &initialValue;
            var __arg1 = &agility;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public SmoothFloat(global::Acid.Sharp.SmoothFloat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SmoothFloat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.SmoothFloat.__Internal*) __Instance) = *((global::Acid.Sharp.SmoothFloat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.SmoothFloat __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the driver with the passed time.</summary>
        /// <param name="delta">The time between the last update.</param>
        public void Update(global::Acid.Sharp.Time delta)
        {
            if (ReferenceEquals(delta, null))
                throw new global::System.ArgumentNullException("delta", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = delta.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Increases the smooth floats target.</summary>
        /// <param name="increase">How much to increase the target by.</param>
        public void IncreaseTarget(float increase)
        {
            var __arg0 = &increase;
            __Internal.IncreaseTarget((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Gets the currently calculated value.</summary>
        public float Get()
        {
            var __ret = __Internal.Get((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Gets the smooth floats current target.</summary>
        /// <param name="target">The new target.</param>
        /// <remarks>Sets the target for the smooth float.</remarks>
        public float Target
        {
            get
            {
                var __ret = __Internal.GetTarget((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetTarget((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a row major 2x2 matrix.</summary>
    public unsafe partial class Matrix2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Matrix2._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* diagonal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix2@acid@@QEAA@QEBVVector2@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::Acid.Sharp.Vector2.__Internal[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix2@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix2@acid@@QEBA?AVVector2@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix2@acid@@QEBA?AV12@AEBVVector2@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix2@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubmatrix@Matrix2@acid@@QEBAMAEBH0@Z")]
            internal static extern float GetSubmatrix(global::System.IntPtr instance, int* row, int* col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Matrix2@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Matrix2@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix2@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix2@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix2@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBV10@AEBVVector2@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBV10@AEBVVector2@0@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix2@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AMatrix2@acid@@QEAAAEAVVector2@1@AEBI@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix2@acid@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix2@acid@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix2@acid@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Matrix2._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Matrix2._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte m_rows[16];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Matrix2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Matrix2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Matrix2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Matrix2(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Matrix2 __CreateInstance(global::Acid.Sharp.Matrix2.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Matrix2(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Matrix2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix2.__Internal));
            global::Acid.Sharp.Matrix2.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix2(global::Acid.Sharp.Matrix2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix2. The matrix is initialised to the identity.</summary>
        /// <param name="diagonal">The value set to the diagonals.</param>
        public Matrix2(float diagonal)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &diagonal;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix2(global::Acid.Sharp.Matrix2 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a 4 element array.</param>
        public Matrix2(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 4)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor_1((__Instance + __PointerAdjustment), source);
        }

        /// <summary>Constructor for Matrix2.</summary>
        /// <param name="source">Creates this matrix out of a 2 vector array.</param>
        public Matrix2(global::Acid.Sharp.Vector2[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 2)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            global::Acid.Sharp.Vector2.__Internal[] __source;
            if (ReferenceEquals(source, null))
                __source = null;
            else
            {
                __source = new global::Acid.Sharp.Vector2.__Internal[source.Length];
                for (int i = 0; i < __source.Length; i++)
                {
                    var __element = source[i];
                    __source[i] = ReferenceEquals(__element, null) ? new global::Acid.Sharp.Vector2.__Internal() : *(global::Acid.Sharp.Vector2.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __source;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Matrix2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix2 Add(global::Acid.Sharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix2 Subtract(global::Acid.Sharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix2 Multiply(global::Acid.Sharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix2 Divide(global::Acid.Sharp.Matrix2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector2 Transform(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector2.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Matrix2 Scale(global::Acid.Sharp.Vector2 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::Acid.Sharp.Matrix2 Negate()
        {
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        /// <summary>Gets the submatrix of this matrix.</summary>
        public float GetSubmatrix(int row, int col)
        {
            var __arg0 = &row;
            var __arg1 = &col;
            var __ret = __Internal.GetSubmatrix((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Matrix2 __op, global::Acid.Sharp.Matrix2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Matrix2;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Matrix2.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Matrix2 __op, global::Acid.Sharp.Matrix2 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Matrix2 operator -(global::Acid.Sharp.Matrix2 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Matrix2(float diagonal)
        {
            return new global::Acid.Sharp.Matrix2(ref *diagonal);
        }

        public static explicit operator global::Acid.Sharp.Matrix2(float[] source)
        {
            return new global::Acid.Sharp.Matrix2(source);
        }

        public static explicit operator global::Acid.Sharp.Matrix2(global::Acid.Sharp.Vector2[] source)
        {
            return new global::Acid.Sharp.Matrix2(source);
        }

        public static global::Acid.Sharp.Matrix2 operator +(global::Acid.Sharp.Matrix2 left, global::Acid.Sharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator -(global::Acid.Sharp.Matrix2 left, global::Acid.Sharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator *(global::Acid.Sharp.Matrix2 left, global::Acid.Sharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator /(global::Acid.Sharp.Matrix2 left, global::Acid.Sharp.Matrix2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator *(global::Acid.Sharp.Matrix2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator /(global::Acid.Sharp.Matrix2 left, global::Acid.Sharp.Vector2 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator *(float left, global::Acid.Sharp.Matrix2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator /(float left, global::Acid.Sharp.Matrix2 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator *(global::Acid.Sharp.Matrix2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 operator /(global::Acid.Sharp.Matrix2 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix2 Identity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Matrix2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?IDENTITY@Matrix2@acid@@2V12@B");
                return global::Acid.Sharp.Matrix2.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Matrix2 Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Matrix2.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Matrix2@acid@@2V12@B");
                return global::Acid.Sharp.Matrix2.__CreateInstance(*__ptr);
            }
        }

        public global::Acid.Sharp.Vector2 this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                var __arg0 = &index;
                *(global::Acid.Sharp.Vector2.__Internal*) global::Acid.Sharp.Matrix2.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector2.__Internal() : *(global::Acid.Sharp.Vector2.__Internal*) value.__Instance;
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::Acid.Sharp.Matrix2 Invert
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix2.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::Acid.Sharp.Matrix2 Transpose
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix2.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Holds a row major 3x3 matrix.</summary>
    public unsafe partial class Matrix3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Matrix3._.__Internal _;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* diagonal);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@QEBM@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, float[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Matrix3@acid@@QEAA@QEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::Acid.Sharp.Vector3.__Internal[] source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Add(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Subtract@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Subtract(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Multiply(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Multiply@Matrix3@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void Multiply_1(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Divide@Matrix3@acid@@QEBA?AV12@AEBV12@@Z")]
            internal static extern void Divide(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transform@Matrix3@acid@@QEBA?AVVector3@2@AEBV32@@Z")]
            internal static extern void Transform(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Scale@Matrix3@acid@@QEBA?AV12@AEBVVector3@2@@Z")]
            internal static extern void Scale(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Negate@Matrix3@acid@@QEBA?AV12@XZ")]
            internal static extern void Negate(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSubmatrix@Matrix3@acid@@QEBA?AVMatrix2@2@AEBH0@Z")]
            internal static extern void GetSubmatrix(global::System.IntPtr instance, global::System.IntPtr @return, int* row, int* col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Matrix3@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Matrix3@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8Matrix3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9Matrix3@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??GMatrix3@acid@@QEBA?AV01@XZ")]
            internal static extern void OperatorMinus(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@Matrix3@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Hacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorPlus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Gacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorMinus(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBV10@0@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBV10@AEBVVector3@0@@Z")]
            internal static extern void OperatorStar_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBV10@AEBVVector3@0@@Z")]
            internal static extern void OperatorSlash_1(global::System.IntPtr @return, global::System.IntPtr left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBMAEBV10@@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, float* left, global::System.IntPtr right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Dacid@@YA?AVMatrix3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorStar(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??Kacid@@YA?AVMatrix3@0@AEBV10@AEBM@Z")]
            internal static extern void OperatorSlash(global::System.IntPtr @return, global::System.IntPtr left, float* right);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??AMatrix3@acid@@QEAAAEAVVector3@1@AEBI@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Invert@Matrix3@acid@@QEBA?AV12@XZ")]
            internal static extern void Invert(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Transpose@Matrix3@acid@@QEBA?AV12@XZ")]
            internal static extern void Transpose(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Determinant@Matrix3@acid@@QEBAMXZ")]
            internal static extern float Determinant(global::System.IntPtr instance);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 36)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Acid.Sharp.Matrix3._.__.__Internal __;

                [FieldOffset(0)]
                internal global::Acid.Sharp.Matrix3._.__.__Internal __1;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal fixed byte m_rows[36];
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Matrix3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Matrix3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Matrix3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Matrix3(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Matrix3 __CreateInstance(global::Acid.Sharp.Matrix3.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Matrix3(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Matrix3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix3.__Internal));
            global::Acid.Sharp.Matrix3.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Matrix3(global::Acid.Sharp.Matrix3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Matrix3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Constructor for Matrix3. The matrix is initialised to the identity.</summary>
        /// <param name="diagonal">The value set to the diagonals.</param>
        public Matrix3(float diagonal)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &diagonal;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a existing one.</param>
        public Matrix3(global::Acid.Sharp.Matrix3 source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(source, null))
                throw new global::System.ArgumentNullException("source", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = source.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a 9 element array.</param>
        public Matrix3(float[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 9)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            __Internal.ctor_1((__Instance + __PointerAdjustment), source);
        }

        /// <summary>Constructor for Matrix3.</summary>
        /// <param name="source">Creates this matrix out of a 3 vector array.</param>
        public Matrix3(global::Acid.Sharp.Vector3[] source)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Matrix3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (source == null || source.Length != 3)
                throw new ArgumentOutOfRangeException("source", "The dimensions of the provided array don't match the required size.");
            global::Acid.Sharp.Vector3.__Internal[] __source;
            if (ReferenceEquals(source, null))
                __source = null;
            else
            {
                __source = new global::Acid.Sharp.Vector3.__Internal[source.Length];
                for (int i = 0; i < __source.Length; i++)
                {
                    var __element = source[i];
                    __source[i] = ReferenceEquals(__element, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __source;
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Matrix3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix3 Add(global::Acid.Sharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.Add((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Subtracts this matrix to another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix3 Subtract(global::Acid.Sharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.Subtract((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix3 Multiply(global::Acid.Sharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.Multiply((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Multiplies this matrix by a vector.</summary>
        /// <param name="other">The vector.</param>
        public global::Acid.Sharp.Vector3 Multiply(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Multiply_1((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Divides this matrix by another matrix.</summary>
        /// <param name="other">The other matrix.</param>
        public global::Acid.Sharp.Matrix3 Divide(global::Acid.Sharp.Matrix3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.Divide((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Transforms this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Vector3 Transform(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            __Internal.Transform((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        /// <summary>Scales this matrix by a vector.</summary>
        /// <param name="other">The other vector.</param>
        public global::Acid.Sharp.Matrix3 Scale(global::Acid.Sharp.Vector3 other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.Scale((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Inverts this matrix.</summary>
        public global::Acid.Sharp.Matrix3 Negate()
        {
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.Negate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        /// <summary>Gets the submatrix of this matrix.</summary>
        public global::Acid.Sharp.Matrix2 GetSubmatrix(int row, int col)
        {
            var __arg0 = &row;
            var __arg1 = &col;
            var __ret = new global::Acid.Sharp.Matrix2.__Internal();
            __Internal.GetSubmatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix2.__CreateInstance(__ret);
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static bool operator ==(global::Acid.Sharp.Matrix3 __op, global::Acid.Sharp.Matrix3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.Matrix3;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.Matrix3.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.Matrix3 __op, global::Acid.Sharp.Matrix3 other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static global::Acid.Sharp.Matrix3 operator -(global::Acid.Sharp.Matrix3 __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorMinus(__arg0, new IntPtr(&__ret));
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static implicit operator global::Acid.Sharp.Matrix3(float diagonal)
        {
            return new global::Acid.Sharp.Matrix3(ref *diagonal);
        }

        public static explicit operator global::Acid.Sharp.Matrix3(float[] source)
        {
            return new global::Acid.Sharp.Matrix3(source);
        }

        public static explicit operator global::Acid.Sharp.Matrix3(global::Acid.Sharp.Vector3[] source)
        {
            return new global::Acid.Sharp.Matrix3(source);
        }

        public static global::Acid.Sharp.Matrix3 operator +(global::Acid.Sharp.Matrix3 left, global::Acid.Sharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorPlus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator -(global::Acid.Sharp.Matrix3 left, global::Acid.Sharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorMinus(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator *(global::Acid.Sharp.Matrix3 left, global::Acid.Sharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator /(global::Acid.Sharp.Matrix3 left, global::Acid.Sharp.Matrix3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator *(global::Acid.Sharp.Matrix3 left, global::Acid.Sharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorStar_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator /(global::Acid.Sharp.Matrix3 left, global::Acid.Sharp.Vector3 right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorSlash_1(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator *(float left, global::Acid.Sharp.Matrix3 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator /(float left, global::Acid.Sharp.Matrix3 right)
        {
            var __arg0 = &left;
            if (ReferenceEquals(right, null))
                throw new global::System.ArgumentNullException("right", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = right.__Instance;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator *(global::Acid.Sharp.Matrix3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorStar(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 operator /(global::Acid.Sharp.Matrix3 left, float right)
        {
            if (ReferenceEquals(left, null))
                throw new global::System.ArgumentNullException("left", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = left.__Instance;
            var __arg1 = &right;
            var __ret = new global::Acid.Sharp.Matrix3.__Internal();
            __Internal.OperatorSlash(new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Matrix3 Identity
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Matrix3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?IDENTITY@Matrix3@acid@@2V12@B");
                return global::Acid.Sharp.Matrix3.__CreateInstance(*__ptr);
            }
        }

        public static global::Acid.Sharp.Matrix3 Zero
        {
            get
            {
                var __ptr = (global::Acid.Sharp.Matrix3.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ZERO@Matrix3@acid@@2V12@B");
                return global::Acid.Sharp.Matrix3.__CreateInstance(*__ptr);
            }
        }

        public global::Acid.Sharp.Vector3 this[uint index]
        {
            get
            {
                var __arg0 = &index;
                var __ret = __Internal.OperatorSubscript((__Instance + __PointerAdjustment), __arg0);
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                var __arg0 = &index;
                *(global::Acid.Sharp.Vector3.__Internal*) global::Acid.Sharp.Matrix3.__Internal.OperatorSubscript((__Instance + __PointerAdjustment), &index) = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) value.__Instance;
            }
        }

        /// <summary>Negates this matrix.</summary>
        public global::Acid.Sharp.Matrix3 Invert
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix3.__Internal();
                __Internal.Invert((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
            }
        }

        /// <summary>Transposes this matrix.</summary>
        public global::Acid.Sharp.Matrix3 Transpose
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix3.__Internal();
                __Internal.Transpose((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix3.__CreateInstance(__ret);
            }
        }

        /// <summary>Takes the determinant of this matrix.</summary>
        public float Determinant
        {
            get
            {
                var __ret = __Internal.Determinant((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A bounce driver that uses a sine wave.</summary>
    public unsafe partial class DriverBounce : global::Acid.Sharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_actualTime;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_currentTime;

            [FieldOffset(32)]
            internal float m_start;

            [FieldOffset(36)]
            internal float m_end;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverBounce@acid@@QEAA@AEBM0AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* start, float* end, global::System.IntPtr length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverBounce@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStart@DriverBounce@acid@@QEBAMXZ")]
            internal static extern float GetStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStart@DriverBounce@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStart(global::System.IntPtr instance, float* start);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetEnd@DriverBounce@acid@@QEBAMXZ")]
            internal static extern float GetEnd(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnd@DriverBounce@acid@@QEAAXAEBM@Z")]
            internal static extern void SetEnd(global::System.IntPtr instance, float* end);
        }

        internal static new global::Acid.Sharp.DriverBounce __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverBounce(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DriverBounce __CreateInstance(global::Acid.Sharp.DriverBounce.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverBounce(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DriverBounce.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverBounce.__Internal));
            global::Acid.Sharp.DriverBounce.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverBounce(global::Acid.Sharp.DriverBounce.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverBounce(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new sine wave driver.</summary>
        /// <param name="start">The start value.</param>
        /// <param name="end">The end value.</param>
        /// <param name="length">The length between two waves.</param>
        public DriverBounce(float start, float end, global::Acid.Sharp.Time length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverBounce.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &start;
            var __arg1 = &end;
            if (ReferenceEquals(length, null))
                throw new global::System.ArgumentNullException("length", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = length.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverBounce");
        }

        public DriverBounce(global::Acid.Sharp.DriverBounce _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverBounce.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverBounce");
        }

        protected override float Calculate(float factor)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___CalculateDelegate = (global::Delegates.Func_float_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr_floatPtr));
            var __arg0 = &factor;
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the start time.</summary>
        /// <param name="start">The new start time.</param>
        /// <remarks>Sets the start time.</remarks>
        public float Start
        {
            get
            {
                var __ret = __Internal.GetStart((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStart((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the end time.</summary>
        /// <param name="end">The new end time.</param>
        /// <remarks>Sets the end time.</remarks>
        public float End
        {
            get
            {
                var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetEnd((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // float Calculate(const float &factor) override
        private static global::Delegates.Func_float_IntPtr_floatPtr _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float* factor)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.DriverBounce) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(factor);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A driver that has a constant value.</summary>
    public unsafe partial class DriverConstant : global::Acid.Sharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_actualTime;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_currentTime;

            [FieldOffset(32)]
            internal float m_constant;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverConstant@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* constant);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverConstant@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetConstant@DriverConstant@acid@@QEBAMXZ")]
            internal static extern float GetConstant(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetConstant@DriverConstant@acid@@QEAAXAEBM@Z")]
            internal static extern void SetConstant(global::System.IntPtr instance, float* constant);
        }

        internal static new global::Acid.Sharp.DriverConstant __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverConstant(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DriverConstant __CreateInstance(global::Acid.Sharp.DriverConstant.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverConstant(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DriverConstant.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverConstant.__Internal));
            global::Acid.Sharp.DriverConstant.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverConstant(global::Acid.Sharp.DriverConstant.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverConstant(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new constant driver.</summary>
        /// <param name="constant">The constant value.</param>
        public DriverConstant(float constant)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &constant;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverConstant");
        }

        public DriverConstant(global::Acid.Sharp.DriverConstant _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverConstant.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverConstant");
        }

        protected override float Calculate(float factor)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___CalculateDelegate = (global::Delegates.Func_float_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr_floatPtr));
            var __arg0 = &factor;
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public static explicit operator global::Acid.Sharp.DriverConstant(float constant)
        {
            return new global::Acid.Sharp.DriverConstant(ref *constant);
        }

        /// <summary>Gets the constant.</summary>
        /// <param name="constant">The new constant.</param>
        /// <remarks>Sets the constant.</remarks>
        public float Constant
        {
            get
            {
                var __ret = __Internal.GetConstant((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetConstant((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // float Calculate(const float &factor) override
        private static global::Delegates.Func_float_IntPtr_floatPtr _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float* factor)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.DriverConstant) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(factor);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A driver that fades from start to end.</summary>
    public unsafe partial class DriverFade : global::Acid.Sharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_actualTime;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_currentTime;

            [FieldOffset(32)]
            internal float m_start;

            [FieldOffset(36)]
            internal float m_end;

            [FieldOffset(40)]
            internal float m_peak;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverFade@acid@@QEAA@AEBM00AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* start, float* end, float* peak, global::System.IntPtr length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverFade@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStart@DriverFade@acid@@QEBAMXZ")]
            internal static extern float GetStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStart@DriverFade@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStart(global::System.IntPtr instance, float* start);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetEnd@DriverFade@acid@@QEBAMXZ")]
            internal static extern float GetEnd(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnd@DriverFade@acid@@QEAAXAEBM@Z")]
            internal static extern void SetEnd(global::System.IntPtr instance, float* end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPeak@DriverFade@acid@@QEBAMXZ")]
            internal static extern float GetPeak(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPeak@DriverFade@acid@@QEAAXAEBM@Z")]
            internal static extern void SetPeak(global::System.IntPtr instance, float* peak);
        }

        internal static new global::Acid.Sharp.DriverFade __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverFade(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DriverFade __CreateInstance(global::Acid.Sharp.DriverFade.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverFade(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DriverFade.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverFade.__Internal));
            global::Acid.Sharp.DriverFade.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverFade(global::Acid.Sharp.DriverFade.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverFade(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new fade driver.</summary>
        /// <param name="start">The fade start interval (0.0-1.0).</param>
        /// <param name="end">The fade end interval (0.0-1.0).</param>
        /// <param name="peak">The peak value.</param>
        /// <param name="length">The time taken to get to the end.</param>
        public DriverFade(float start, float end, float peak, global::Acid.Sharp.Time length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverFade.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &start;
            var __arg1 = &end;
            var __arg2 = &peak;
            if (ReferenceEquals(length, null))
                throw new global::System.ArgumentNullException("length", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = length.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverFade");
        }

        public DriverFade(global::Acid.Sharp.DriverFade _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverFade.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverFade");
        }

        protected override float Calculate(float factor)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___CalculateDelegate = (global::Delegates.Func_float_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr_floatPtr));
            var __arg0 = &factor;
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the start interval.</summary>
        /// <param name="start">The new start interval.</param>
        /// <remarks>Sets the start interval (0.0-1.0).</remarks>
        public float Start
        {
            get
            {
                var __ret = __Internal.GetStart((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStart((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the end interval.</summary>
        /// <param name="end">The new end interval.</param>
        /// <remarks>Sets the end interval (0.0-1.0).</remarks>
        public float End
        {
            get
            {
                var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetEnd((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the peak value.</summary>
        /// <param name="peak">The new peak value.</param>
        /// <remarks>Sets the peak value.</remarks>
        public float Peak
        {
            get
            {
                var __ret = __Internal.GetPeak((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetPeak((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // float Calculate(const float &factor) override
        private static global::Delegates.Func_float_IntPtr_floatPtr _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float* factor)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.DriverFade) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(factor);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A driver that linearly increases its value.</summary>
    public unsafe partial class DriverLinear : global::Acid.Sharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_actualTime;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_currentTime;

            [FieldOffset(32)]
            internal float m_start;

            [FieldOffset(36)]
            internal float m_end;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverLinear@acid@@QEAA@AEBM0AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* startValue, float* endValue, global::System.IntPtr length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverLinear@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStart@DriverLinear@acid@@QEBAMXZ")]
            internal static extern float GetStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStart@DriverLinear@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStart(global::System.IntPtr instance, float* start);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetEnd@DriverLinear@acid@@QEBAMXZ")]
            internal static extern float GetEnd(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnd@DriverLinear@acid@@QEAAXAEBM@Z")]
            internal static extern void SetEnd(global::System.IntPtr instance, float* end);
        }

        internal static new global::Acid.Sharp.DriverLinear __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverLinear(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DriverLinear __CreateInstance(global::Acid.Sharp.DriverLinear.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverLinear(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DriverLinear.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverLinear.__Internal));
            global::Acid.Sharp.DriverLinear.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverLinear(global::Acid.Sharp.DriverLinear.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverLinear(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new linear driver.</summary>
        /// <param name="startValue">The start value.</param>
        /// <param name="endValue">The end value.</param>
        /// <param name="length">The time to go between values.</param>
        public DriverLinear(float startValue, float endValue, global::Acid.Sharp.Time length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverLinear.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &startValue;
            var __arg1 = &endValue;
            if (ReferenceEquals(length, null))
                throw new global::System.ArgumentNullException("length", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = length.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverLinear");
        }

        public DriverLinear(global::Acid.Sharp.DriverLinear _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverLinear.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverLinear");
        }

        protected override float Calculate(float factor)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___CalculateDelegate = (global::Delegates.Func_float_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr_floatPtr));
            var __arg0 = &factor;
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the start time.</summary>
        /// <param name="start">The new start time.</param>
        /// <remarks>Sets the start time.</remarks>
        public float Start
        {
            get
            {
                var __ret = __Internal.GetStart((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStart((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the end time.</summary>
        /// <param name="end">The new end time.</param>
        /// <remarks>Sets the end time.</remarks>
        public float End
        {
            get
            {
                var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetEnd((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // float Calculate(const float &factor) override
        private static global::Delegates.Func_float_IntPtr_floatPtr _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float* factor)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.DriverLinear) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(factor);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A driver that uses a sine wave.</summary>
    public unsafe partial class DriverSinwave : global::Acid.Sharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_actualTime;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_currentTime;

            [FieldOffset(32)]
            internal float m_min;

            [FieldOffset(36)]
            internal float m_max;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSinwave@acid@@QEAA@AEBM0AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* min, float* max, global::System.IntPtr length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSinwave@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMin@DriverSinwave@acid@@QEBAMXZ")]
            internal static extern float GetMin(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMin@DriverSinwave@acid@@QEAAXAEBM@Z")]
            internal static extern void SetMin(global::System.IntPtr instance, float* min);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMax@DriverSinwave@acid@@QEBAMXZ")]
            internal static extern float GetMax(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMax@DriverSinwave@acid@@QEAAXAEBM@Z")]
            internal static extern void SetMax(global::System.IntPtr instance, float* max);
        }

        internal static new global::Acid.Sharp.DriverSinwave __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverSinwave(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DriverSinwave __CreateInstance(global::Acid.Sharp.DriverSinwave.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverSinwave(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DriverSinwave.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverSinwave.__Internal));
            global::Acid.Sharp.DriverSinwave.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverSinwave(global::Acid.Sharp.DriverSinwave.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverSinwave(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new sine wave driver.</summary>
        /// <param name="min">The min value.</param>
        /// <param name="max">The max value.</param>
        /// <param name="length">The length between two waves.</param>
        public DriverSinwave(float min, float max, global::Acid.Sharp.Time length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverSinwave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &min;
            var __arg1 = &max;
            if (ReferenceEquals(length, null))
                throw new global::System.ArgumentNullException("length", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = length.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverSinwave");
        }

        public DriverSinwave(global::Acid.Sharp.DriverSinwave _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverSinwave.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverSinwave");
        }

        protected override float Calculate(float factor)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___CalculateDelegate = (global::Delegates.Func_float_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr_floatPtr));
            var __arg0 = &factor;
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the min value.</summary>
        /// <param name="min">The new min value.</param>
        /// <remarks>Sets the min value.</remarks>
        public float Min
        {
            get
            {
                var __ret = __Internal.GetMin((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetMin((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the max value.</summary>
        /// <param name="max">The new max value.</param>
        /// <remarks>Sets the max value.</remarks>
        public float Max
        {
            get
            {
                var __ret = __Internal.GetMax((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetMax((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // float Calculate(const float &factor) override
        private static global::Delegates.Func_float_IntPtr_floatPtr _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float* factor)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.DriverSinwave) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(factor);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A driver that slides to its destination using cosine interpolation.</summary>
    public unsafe partial class DriverSlide : global::Acid.Sharp.IDriver, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IDriver;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Time.__Internal m_length;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_actualTime;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Time.__Internal m_currentTime;

            [FieldOffset(32)]
            internal float m_start;

            [FieldOffset(36)]
            internal float m_end;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSlide@acid@@QEAA@AEBM0AEBVTime@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* start, float* end, global::System.IntPtr length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0DriverSlide@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStart@DriverSlide@acid@@QEBAMXZ")]
            internal static extern float GetStart(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStart@DriverSlide@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStart(global::System.IntPtr instance, float* start);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetEnd@DriverSlide@acid@@QEBAMXZ")]
            internal static extern float GetEnd(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetEnd@DriverSlide@acid@@QEAAXAEBM@Z")]
            internal static extern void SetEnd(global::System.IntPtr instance, float* end);
        }

        internal static new global::Acid.Sharp.DriverSlide __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverSlide(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.DriverSlide __CreateInstance(global::Acid.Sharp.DriverSlide.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.DriverSlide(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.DriverSlide.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverSlide.__Internal));
            global::Acid.Sharp.DriverSlide.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DriverSlide(global::Acid.Sharp.DriverSlide.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DriverSlide(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new slide driver.</summary>
        /// <param name="start">The start value.</param>
        /// <param name="end">The end value.</param>
        /// <param name="length">The time to get to the end value.</param>
        public DriverSlide(float start, float end, global::Acid.Sharp.Time length)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverSlide.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &start;
            var __arg1 = &end;
            if (ReferenceEquals(length, null))
                throw new global::System.ArgumentNullException("length", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = length.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverSlide");
        }

        public DriverSlide(global::Acid.Sharp.DriverSlide _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.DriverSlide.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.DriverSlide");
        }

        protected override float Calculate(float factor)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___CalculateDelegate = (global::Delegates.Func_float_IntPtr_floatPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_float_IntPtr_floatPtr));
            var __arg0 = &factor;
            var __ret = ___CalculateDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the start time.</summary>
        /// <param name="start">The new start time.</param>
        /// <remarks>Sets the start time.</remarks>
        public float Start
        {
            get
            {
                var __ret = __Internal.GetStart((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStart((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the end time.</summary>
        /// <param name="end">The new end time.</param>
        /// <remarks>Sets the end time.</remarks>
        public float End
        {
            get
            {
                var __ret = __Internal.GetEnd((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetEnd((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // float Calculate(const float &factor) override
        private static global::Delegates.Func_float_IntPtr_floatPtr _CalculateDelegateInstance;

        private static float _CalculateDelegateHook(global::System.IntPtr instance, float* factor)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.DriverSlide) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Calculate(factor);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CalculateDelegateInstance += _CalculateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CalculateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class MeshRender : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshRender@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshRender@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1MeshRender@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@MeshRender@acid@@QEAA_NAEBVCommandBuffer@2@AEAVUniformHandler@2@AEBVGraphicsStage@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr uniformScene, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MMeshRender@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);
        }

        internal static new global::Acid.Sharp.MeshRender __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshRender(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.MeshRender __CreateInstance(global::Acid.Sharp.MeshRender.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshRender(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.MeshRender.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshRender.__Internal));
            global::Acid.Sharp.MeshRender.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshRender(global::Acid.Sharp.MeshRender.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshRender(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MeshRender()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshRender");
        }

        public MeshRender(global::Acid.Sharp.MeshRender _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshRender");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.MeshRender.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public bool CmdRender(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.UniformHandler uniformScene, global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(uniformScene, null))
                throw new global::System.ArgumentNullException("uniformScene", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uniformScene.__Instance;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = graphicsStage.__Instance;
            var __ret = __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.MeshRender __op, global::Acid.Sharp.MeshRender other)
        {
            return !(__op < other);
        }

        public static bool operator <(global::Acid.Sharp.MeshRender __op, global::Acid.Sharp.MeshRender other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public enum MeshSort
    {
        None = 0,
        Front = 1,
        Back = 2
    }

    public unsafe partial class RendererMeshes : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.MeshSort m_meshSort;

            [FieldOffset(32)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformScene;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererMeshes@acid@@QEAA@AEBVGraphicsStage@1@AEBW4MeshSort@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, global::Acid.Sharp.MeshSort* meshSort);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererMeshes@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RendererMeshes@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.RendererMeshes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererMeshes(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RendererMeshes __CreateInstance(global::Acid.Sharp.RendererMeshes.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererMeshes(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RendererMeshes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererMeshes.__Internal));
            global::Acid.Sharp.RendererMeshes.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererMeshes(global::Acid.Sharp.RendererMeshes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererMeshes(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public RendererMeshes(global::Acid.Sharp.GraphicsStage graphicsStage, global::Acid.Sharp.MeshSort* meshSort)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererMeshes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, meshSort);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererMeshes");
        }

        public RendererMeshes(global::Acid.Sharp.RendererMeshes _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererMeshes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererMeshes");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.RendererMeshes.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.RendererMeshes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class VertexModelData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(12)]
            internal int m_uvIndex;

            [FieldOffset(16)]
            internal int m_normalIndex;

            [FieldOffset(24)]
            internal global::System.IntPtr m_duplicateVertex;

            [FieldOffset(32)]
            internal uint m_index;

            [FieldOffset(36)]
            internal float m_length;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Vector3___N_std_S_allocator__S0_ m_tangents;

            [FieldOffset(64)]
            internal global::Acid.Sharp.Vector3.__Internal m_averagedTangent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModelData@acid@@QEAA@AEBIAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint* index, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0VertexModelData@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1VertexModelData@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddTangent@VertexModelData@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void AddTangent(global::System.IntPtr instance, global::System.IntPtr tangent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AverageTangents@VertexModelData@acid@@QEAAXXZ")]
            internal static extern void AverageTangents(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasSameTextureAndNormal@VertexModelData@acid@@QEBA_NAEBH0@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSameTextureAndNormal(global::System.IntPtr instance, int* textureIndexOther, int* normalIndexOther);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetUvIndex@VertexModelData@acid@@QEBAHXZ")]
            internal static extern int GetUvIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUvIndex@VertexModelData@acid@@QEAAXAEBH@Z")]
            internal static extern void SetUvIndex(global::System.IntPtr instance, int* uvIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNormalIndex@VertexModelData@acid@@QEBAHXZ")]
            internal static extern int GetNormalIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNormalIndex@VertexModelData@acid@@QEAAXAEBH@Z")]
            internal static extern void SetNormalIndex(global::System.IntPtr instance, int* normalIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDuplicateVertex@VertexModelData@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetDuplicateVertex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDuplicateVertex@VertexModelData@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetDuplicateVertex(global::System.IntPtr instance, global::System.IntPtr duplicateVertex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@VertexModelData@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetIndex@VertexModelData@acid@@QEBAIXZ")]
            internal static extern uint GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@VertexModelData@acid@@QEBAMXZ")]
            internal static extern float GetLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAverageTangent@VertexModelData@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetAverageTangent(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSet@VertexModelData@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetSet(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexModelData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.VertexModelData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.VertexModelData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexModelData(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.VertexModelData __CreateInstance(global::Acid.Sharp.VertexModelData.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.VertexModelData(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.VertexModelData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexModelData.__Internal));
            global::Acid.Sharp.VertexModelData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VertexModelData(global::Acid.Sharp.VertexModelData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VertexModelData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VertexModelData(uint index, global::Acid.Sharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexModelData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &index;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public VertexModelData(global::Acid.Sharp.VertexModelData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.VertexModelData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.VertexModelData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddTangent(global::Acid.Sharp.Vector3 tangent)
        {
            if (ReferenceEquals(tangent, null))
                throw new global::System.ArgumentNullException("tangent", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = tangent.__Instance;
            __Internal.AddTangent((__Instance + __PointerAdjustment), __arg0);
        }

        public void AverageTangents()
        {
            __Internal.AverageTangents((__Instance + __PointerAdjustment));
        }

        public bool HasSameTextureAndNormal(int textureIndexOther, int normalIndexOther)
        {
            var __arg0 = &textureIndexOther;
            var __arg1 = &normalIndexOther;
            var __ret = __Internal.HasSameTextureAndNormal((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        public int UvIndex
        {
            get
            {
                var __ret = __Internal.GetUvIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetUvIndex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public int NormalIndex
        {
            get
            {
                var __ret = __Internal.GetNormalIndex((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetNormalIndex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.VertexModelData DuplicateVertex
        {
            get
            {
                var __ret = __Internal.GetDuplicateVertex((__Instance + __PointerAdjustment));
                global::Acid.Sharp.VertexModelData __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.VertexModelData.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.VertexModelData) global::Acid.Sharp.VertexModelData.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.VertexModelData.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetDuplicateVertex((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public uint Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.Vector3 AverageTangent
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetAverageTangent((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public bool Set
        {
            get
            {
                var __ret = __Internal.GetSet((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a loaded OBJ model.</summary>
    public unsafe partial class ModelObj : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelObj@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelObj@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModelObj@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ModelObj __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelObj(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModelObj __CreateInstance(global::Acid.Sharp.ModelObj.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelObj(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModelObj.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelObj.__Internal));
            global::Acid.Sharp.ModelObj.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModelObj(global::Acid.Sharp.ModelObj.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModelObj(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new OBJ model.</summary>
        /// <param name="filename">The file to load the model from.</param>
        public ModelObj(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelObj.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelObj");
        }

        public ModelObj(global::Acid.Sharp.ModelObj _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelObj.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelObj");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ModelObj.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static explicit operator global::Acid.Sharp.ModelObj(string filename)
        {
            return new global::Acid.Sharp.ModelObj(filename);
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ModelObj) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class MeshPattern : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [FieldOffset(112)]
            internal float m_sideLength;

            [FieldOffset(116)]
            internal float m_squareSize;

            [FieldOffset(120)]
            internal uint m_vertexCount;

            [FieldOffset(124)]
            internal float m_textureScale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshPattern@acid@@QEAA@AEBM0AEBI0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* sideLength, float* squareSize, uint* vertexCount, float* textureScale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshPattern@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1MeshPattern@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GenerateMesh@MeshPattern@acid@@IEAAXXZ")]
            internal static extern void GenerateMesh(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.MeshPattern __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshPattern(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.MeshPattern __CreateInstance(global::Acid.Sharp.MeshPattern.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshPattern(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.MeshPattern.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshPattern.__Internal));
            global::Acid.Sharp.MeshPattern.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshPattern(global::Acid.Sharp.MeshPattern.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshPattern(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MeshPattern(float sideLength, float squareSize, uint vertexCount, float textureScale)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshPattern.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &sideLength;
            var __arg1 = &squareSize;
            var __arg2 = &vertexCount;
            var __arg3 = &textureScale;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshPattern");
        }

        public MeshPattern(global::Acid.Sharp.MeshPattern _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshPattern.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshPattern");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.MeshPattern.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        protected void GenerateMesh()
        {
            __Internal.GenerateMesh((__Instance + __PointerAdjustment));
        }

        protected virtual global::Acid.Sharp.VertexModel GetVertex(uint col, uint row)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetVertexDelegate = (global::Delegates.Action_IntPtr_IntPtr_uintPtr_uintPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_uintPtr_uintPtr));
            var __arg0 = &col;
            var __arg1 = &row;
            var __ret = new global::Acid.Sharp.VertexModel.__Internal();
            ___GetVertexDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.VertexModel.__CreateInstance(__ret);
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshPattern) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // VertexModel GetVertex(const uint32_t &col, const uint32_t &row)
        private static global::Delegates.Action_IntPtr_IntPtr_uintPtr_uintPtr _GetVertexDelegateInstance;

        private static void _GetVertexDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, uint* col, uint* row)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshPattern) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetVertex(col, row);
            *(global::Acid.Sharp.VertexModel.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.VertexModel.__Internal() : *(global::Acid.Sharp.VertexModel.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _GetVertexDelegateInstance += _GetVertexDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetVertexDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class MeshSimple : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [FieldOffset(112)]
            internal float m_sideLength;

            [FieldOffset(116)]
            internal float m_squareSize;

            [FieldOffset(120)]
            internal uint m_vertexCount;

            [FieldOffset(124)]
            internal float m_textureScale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshSimple@acid@@QEAA@AEBM0AEBI0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* sideLength, float* squareSize, uint* vertexCount, float* textureScale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MeshSimple@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1MeshSimple@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GenerateMesh@MeshSimple@acid@@IEAAXXZ")]
            internal static extern void GenerateMesh(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.MeshSimple __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshSimple(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.MeshSimple __CreateInstance(global::Acid.Sharp.MeshSimple.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MeshSimple(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.MeshSimple.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshSimple.__Internal));
            global::Acid.Sharp.MeshSimple.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MeshSimple(global::Acid.Sharp.MeshSimple.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MeshSimple(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MeshSimple(float sideLength, float squareSize, uint vertexCount, float textureScale)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshSimple.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &sideLength;
            var __arg1 = &squareSize;
            var __arg2 = &vertexCount;
            var __arg3 = &textureScale;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshSimple");
        }

        public MeshSimple(global::Acid.Sharp.MeshSimple _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MeshSimple.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.MeshSimple");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.MeshSimple.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        protected void GenerateMesh()
        {
            __Internal.GenerateMesh((__Instance + __PointerAdjustment));
        }

        protected virtual global::Acid.Sharp.VertexModel GetVertex(uint col, uint row)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetVertexDelegate = (global::Delegates.Action_IntPtr_IntPtr_uintPtr_uintPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_uintPtr_uintPtr));
            var __arg0 = &col;
            var __arg1 = &row;
            var __ret = new global::Acid.Sharp.VertexModel.__Internal();
            ___GetVertexDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.VertexModel.__CreateInstance(__ret);
        }

        protected float MSideLength
        {
            get
            {
                return ((global::Acid.Sharp.MeshSimple.__Internal*) __Instance)->m_sideLength;
            }

            set
            {
                ((global::Acid.Sharp.MeshSimple.__Internal*)__Instance)->m_sideLength = value;
            }
        }

        protected float MSquareSize
        {
            get
            {
                return ((global::Acid.Sharp.MeshSimple.__Internal*) __Instance)->m_squareSize;
            }

            set
            {
                ((global::Acid.Sharp.MeshSimple.__Internal*)__Instance)->m_squareSize = value;
            }
        }

        protected uint MVertexCount
        {
            get
            {
                return ((global::Acid.Sharp.MeshSimple.__Internal*) __Instance)->m_vertexCount;
            }

            set
            {
                ((global::Acid.Sharp.MeshSimple.__Internal*)__Instance)->m_vertexCount = value;
            }
        }

        protected float MTextureScale
        {
            get
            {
                return ((global::Acid.Sharp.MeshSimple.__Internal*) __Instance)->m_textureScale;
            }

            set
            {
                ((global::Acid.Sharp.MeshSimple.__Internal*)__Instance)->m_textureScale = value;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshSimple) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        // VertexModel GetVertex(const uint32_t &col, const uint32_t &row)
        private static global::Delegates.Action_IntPtr_IntPtr_uintPtr_uintPtr _GetVertexDelegateInstance;

        private static void _GetVertexDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, uint* col, uint* row)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MeshSimple) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetVertex(col, row);
            *(global::Acid.Sharp.VertexModel.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.VertexModel.__Internal() : *(global::Acid.Sharp.VertexModel.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
                _GetVertexDelegateInstance += _GetVertexDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetVertexDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ModelCube : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelCube@acid@@QEAA@AEBM00@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* width, float* height, float* depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelCube@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModelCube@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ModelCube __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelCube(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModelCube __CreateInstance(global::Acid.Sharp.ModelCube.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelCube(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModelCube.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelCube.__Internal));
            global::Acid.Sharp.ModelCube.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModelCube(global::Acid.Sharp.ModelCube.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModelCube(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ModelCube(float width, float height, float depth)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelCube.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &width;
            var __arg1 = &height;
            var __arg2 = &depth;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelCube");
        }

        public ModelCube(global::Acid.Sharp.ModelCube _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelCube.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelCube");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ModelCube.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ModelCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ModelCylinder : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelCylinder@acid@@QEAA@AEBM00AEBI1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* radiusBase, float* radiusTop, float* height, uint* slices, uint* stacks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelCylinder@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModelCylinder@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ModelCylinder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelCylinder(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModelCylinder __CreateInstance(global::Acid.Sharp.ModelCylinder.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelCylinder(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModelCylinder.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelCylinder.__Internal));
            global::Acid.Sharp.ModelCylinder.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModelCylinder(global::Acid.Sharp.ModelCylinder.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModelCylinder(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ModelCylinder(float radiusBase, float radiusTop, float height, uint slices, uint stacks)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelCylinder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &radiusBase;
            var __arg1 = &radiusTop;
            var __arg2 = &height;
            var __arg3 = &slices;
            var __arg4 = &stacks;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelCylinder");
        }

        public ModelCylinder(global::Acid.Sharp.ModelCylinder _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelCylinder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelCylinder");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ModelCylinder.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ModelCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ModelDisk : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelDisk@acid@@QEAA@AEBM0AEBI1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* innerRadius, float* outerRadius, uint* slices, uint* loops);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelDisk@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModelDisk@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ModelDisk __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelDisk(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModelDisk __CreateInstance(global::Acid.Sharp.ModelDisk.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelDisk(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModelDisk.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelDisk.__Internal));
            global::Acid.Sharp.ModelDisk.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModelDisk(global::Acid.Sharp.ModelDisk.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModelDisk(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ModelDisk(float innerRadius, float outerRadius, uint slices, uint loops)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelDisk.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &innerRadius;
            var __arg1 = &outerRadius;
            var __arg2 = &slices;
            var __arg3 = &loops;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelDisk");
        }

        public ModelDisk(global::Acid.Sharp.ModelDisk _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelDisk.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelDisk");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ModelDisk.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ModelDisk) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ModelRectangle : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelRectangle@acid@@QEAA@AEBM0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* width, float* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelRectangle@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModelRectangle@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ModelRectangle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelRectangle(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModelRectangle __CreateInstance(global::Acid.Sharp.ModelRectangle.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelRectangle(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModelRectangle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelRectangle.__Internal));
            global::Acid.Sharp.ModelRectangle.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModelRectangle(global::Acid.Sharp.ModelRectangle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModelRectangle(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ModelRectangle(float width, float height)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelRectangle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &width;
            var __arg1 = &height;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelRectangle");
        }

        public ModelRectangle(global::Acid.Sharp.ModelRectangle _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelRectangle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelRectangle");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ModelRectangle.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ModelRectangle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ModelSphere : global::Acid.Sharp.Model, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_VertexBuffer___N_std_S_default_delete__S0_ m_vertexBuffer;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IndexBuffer___N_std_S_default_delete__S0_ m_indexBuffer;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__f___N_std_S_allocator__f m_pointCloud;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(92)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [FieldOffset(104)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelSphere@acid@@QEAA@AEBI0AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint* latitudeBands, uint* longitudeBands, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ModelSphere@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ModelSphere@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.ModelSphere __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelSphere(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ModelSphere __CreateInstance(global::Acid.Sharp.ModelSphere.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ModelSphere(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ModelSphere.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelSphere.__Internal));
            global::Acid.Sharp.ModelSphere.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ModelSphere(global::Acid.Sharp.ModelSphere.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ModelSphere(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ModelSphere(uint latitudeBands, uint longitudeBands, float radius)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &latitudeBands;
            var __arg1 = &longitudeBands;
            var __arg2 = &radius;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelSphere");
        }

        public ModelSphere(global::Acid.Sharp.ModelSphere _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ModelSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ModelSphere");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ModelSphere.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ModelSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class SockaddrIn
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SockaddrIn> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SockaddrIn>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::SockaddrIn __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::SockaddrIn(native.ToPointer(), skipVTables);
    }

    internal static global::SockaddrIn __CreateInstance(global::SockaddrIn.__Internal native, bool skipVTables = false)
    {
        return new global::SockaddrIn(native, skipVTables);
    }

    private static void* __CopyValue(global::SockaddrIn.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::SockaddrIn.__Internal));
        *(global::SockaddrIn.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private SockaddrIn(global::SockaddrIn.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected SockaddrIn(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    /// <summary>Status codes that may be returned by socket functions.</summary>
    public enum SocketStatus
    {

        Done = 0,

        NotReady = 1,

        Partial = 2,

        Disconnected = 3,

        Error = 4
    }

    /// <summary>Types of protocols that the socket can use.</summary>
    public enum SocketType
    {

        Tcp = 0,

        Udp = 1
    }

    /// <summary>Base class for all the socket types.</summary>
    public unsafe partial class Socket : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Socket;

            [FieldOffset(8)]
            internal global::Acid.Sharp.SocketType m_type;

            [FieldOffset(16)]
            internal ulong m_socket;

            [FieldOffset(24)]
            internal byte m_isBlocking;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Socket@acid@@IEAA@W4SocketType@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::Acid.Sharp.SocketType type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Socket@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateAddress@Socket@acid@@SA?AUsockaddr_in@@IG@Z")]
            internal static extern global::SockaddrIn.__Internal CreateAddress(uint address, ushort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CloseSocketHandle@Socket@acid@@SAX_K@Z")]
            internal static extern void CloseSocketHandle(ulong sock);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHandleBlocking@Socket@acid@@SAX_K_N@Z")]
            internal static extern void SetHandleBlocking(ulong sock, bool block);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Create@Socket@acid@@IEAAXXZ")]
            internal static extern void Create(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Create@Socket@acid@@IEAAX_K@Z")]
            internal static extern void Create(global::System.IntPtr instance, ulong handle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Close@Socket@acid@@IEAAXXZ")]
            internal static extern void Close(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsBlocking@Socket@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetBlocking(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBlocking@Socket@acid@@QEAAX_N@Z")]
            internal static extern void SetBlocking(global::System.IntPtr instance, bool blocking);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InvalidSocketHandle@Socket@acid@@SA_KXZ")]
            internal static extern ulong InvalidSocketHandle();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetErrorStatus@Socket@acid@@SA?AW4SocketStatus@2@XZ")]
            internal static extern global::Acid.Sharp.SocketStatus GetErrorStatus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHandle@Socket@acid@@IEBA_KXZ")]
            internal static extern ulong GetHandle(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Socket> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Socket>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Socket __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Socket(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Socket __CreateInstance(global::Acid.Sharp.Socket.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Socket(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Socket.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Socket.__Internal));
            global::Acid.Sharp.Socket.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Socket(global::Acid.Sharp.Socket.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Socket(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Default constructor. This constructor can only be accessed by derived classes.</summary>
        /// <param name="type">Type of the socket (TCP or UDP).</param>
        protected Socket(global::Acid.Sharp.SocketType type)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Socket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), type);
            SetupVTables(GetType().FullName == "Acid.Sharp.Socket");
        }

        public Socket(global::Acid.Sharp.Socket _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Socket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Socket");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Socket __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Socket.__Internal*) __Instance)->vfptr_Socket = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Create the internal representation of the socket. This function can only be accessed by derived classes.</summary>
        protected void Create()
        {
            __Internal.Create((__Instance + __PointerAdjustment));
        }

        /// <summary>Create the internal representation of the socket from a socket handle. This function can only be accessed by derived classes.</summary>
        /// <param name="handle">OS-specific handle of the socket to wrap.</param>
        protected void Create(ulong handle)
        {
            __Internal.Create((__Instance + __PointerAdjustment), handle);
        }

        /// <summary>Close the socket gracefully. This function can only be accessed by derived classes.</summary>
        protected void Close()
        {
            __Internal.Close((__Instance + __PointerAdjustment));
        }

        /// <summary>Create an internal sockaddr_in address.</summary>
        /// <param name="address">Target address.</param>
        /// <param name="port">Target port.</param>
        public static global::SockaddrIn CreateAddress(uint address, ushort port)
        {
            var __ret = __Internal.CreateAddress(address, port);
            return global::SockaddrIn.__CreateInstance(__ret);
        }

        /// <summary>Close and destroy a socket.</summary>
        /// <param name="sock">Handle of the socket to close.</param>
        public static void CloseSocketHandle(ulong sock)
        {
            __Internal.CloseSocketHandle(sock);
        }

        /// <summary>Set a socket as blocking or non-blocking.</summary>
        /// <param name="sock">Handle of the socket.</param>
        /// <param name="block">New blocking state of the socket.</param>
        public static void SetHandleBlocking(ulong sock, bool block)
        {
            __Internal.SetHandleBlocking(sock, block);
        }

        /// <summary>Tell whether the socket is in blocking or non-blocking mode.</summary>
        /// <param name="blocking">True to set the socket as blocking, false for non-blocking.</param>
        /// <remarks>Set the blocking state of the socket. In blocking mode, calls will not return until they have completed their task. For example, a call to Receive in blocking mode won't return until some data was actually received. In non-blocking mode, calls will always return immediately, using the return code to signal whether there was data available or not. By default, all sockets are blocking.</remarks>
        public bool Blocking
        {
            get
            {
                var __ret = __Internal.GetBlocking((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetBlocking((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Return the value of the invalid socket.</summary>
        public static ulong InvalidSocketHandle
        {
            get
            {
                var __ret = __Internal.InvalidSocketHandle();
                return __ret;
            }
        }

        /// <summary>Get the last socket error status.</summary>
        public static global::Acid.Sharp.SocketStatus ErrorStatus
        {
            get
            {
                var __ret = __Internal.GetErrorStatus();
                return __ret;
            }
        }

        /// <summary>Return the internal handle of the socket. The returned handle may be invalid if the socket was not created yet (or already destroyed). This function can only be accessed by derived classes.</summary>
        protected ulong Handle
        {
            get
            {
                var __ret = __Internal.GetHandle((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~Socket()
        private static global::Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Socket) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Structure holding the data of a pending packet.</summary>
    public unsafe partial class PendingPacket : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_size;

            [FieldOffset(8)]
            internal ulong m_sizeReceived;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__C___N_std_S_allocator__C m_data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PendingPacket@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PendingPacket@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PendingPacket@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PendingPacket> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.PendingPacket>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.PendingPacket __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PendingPacket(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.PendingPacket __CreateInstance(global::Acid.Sharp.PendingPacket.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PendingPacket(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.PendingPacket.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PendingPacket.__Internal));
            global::Acid.Sharp.PendingPacket.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PendingPacket(global::Acid.Sharp.PendingPacket.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PendingPacket(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PendingPacket()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PendingPacket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public PendingPacket(global::Acid.Sharp.PendingPacket _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PendingPacket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.PendingPacket __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint MSize
        {
            get
            {
                return ((global::Acid.Sharp.PendingPacket.__Internal*) __Instance)->m_size;
            }

            set
            {
                ((global::Acid.Sharp.PendingPacket.__Internal*)__Instance)->m_size = value;
            }
        }

        public ulong MSizeReceived
        {
            get
            {
                return ((global::Acid.Sharp.PendingPacket.__Internal*) __Instance)->m_sizeReceived;
            }

            set
            {
                ((global::Acid.Sharp.PendingPacket.__Internal*)__Instance)->m_sizeReceived = value;
            }
        }
    }

    /// <summary>Specialized socket using the TCP protocol</summary>
    public unsafe partial class TcpSocket : global::Acid.Sharp.Socket, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Socket;

            [FieldOffset(8)]
            internal global::Acid.Sharp.SocketType m_type;

            [FieldOffset(16)]
            internal ulong m_socket;

            [FieldOffset(24)]
            internal byte m_isBlocking;

            [FieldOffset(32)]
            internal global::Acid.Sharp.PendingPacket.__Internal m_pendingPacket;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TcpSocket@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TcpSocket@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Connect@TcpSocket@acid@@QEAA?AW4SocketStatus@2@AEBVIpAddress@2@GVTime@2@@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Connect(global::System.IntPtr instance, global::System.IntPtr remoteAddress, ushort remotePort, global::Acid.Sharp.Time.__Internal timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Disconnect@TcpSocket@acid@@QEAAXXZ")]
            internal static extern void Disconnect(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Send@TcpSocket@acid@@QEAA?AW4SocketStatus@2@PEBX_K@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Send(global::System.IntPtr instance, global::System.IntPtr data, ulong size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Send@TcpSocket@acid@@QEAA?AW4SocketStatus@2@PEBX_KAEA_K@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Send(global::System.IntPtr instance, global::System.IntPtr data, ulong size, ulong* sent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Receive@TcpSocket@acid@@QEAA?AW4SocketStatus@2@PEAX_KAEA_K@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Receive(global::System.IntPtr instance, global::System.IntPtr data, ulong size, ulong* received);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Send@TcpSocket@acid@@QEAA?AW4SocketStatus@2@AEAVPacket@2@@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Send(global::System.IntPtr instance, global::System.IntPtr packet);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Receive@TcpSocket@acid@@QEAA?AW4SocketStatus@2@AEAVPacket@2@@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Receive(global::System.IntPtr instance, global::System.IntPtr packet);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalPort@TcpSocket@acid@@QEBAGXZ")]
            internal static extern ushort GetLocalPort(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRemoteAddress@TcpSocket@acid@@QEBA?AVIpAddress@2@XZ")]
            internal static extern void GetRemoteAddress(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRemotePort@TcpSocket@acid@@QEBAGXZ")]
            internal static extern ushort GetRemotePort(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.TcpSocket __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.TcpSocket(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.TcpSocket __CreateInstance(global::Acid.Sharp.TcpSocket.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.TcpSocket(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.TcpSocket.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.TcpSocket.__Internal));
            global::Acid.Sharp.TcpSocket.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private TcpSocket(global::Acid.Sharp.TcpSocket.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TcpSocket(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Default constructor.</summary>
        public TcpSocket()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.TcpSocket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.TcpSocket");
        }

        public TcpSocket(global::Acid.Sharp.TcpSocket _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.TcpSocket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.TcpSocket");
        }

        /// <summary>Connect the socket to a remote peer. In blocking mode, this function may take a while, especially if the remote peer is not reachable. The last parameter allows you to stop trying to connect after a given timeout. If the socket is already connected, the connection is forcibly disconnected before attempting to connect again.</summary>
        /// <param name="remoteAddress">Address of the remote peer.</param>
        /// <param name="remotePort">Port of the remote peer.</param>
        /// <param name="timeout">Optional maximum time to wait.</param>
        public global::Acid.Sharp.SocketStatus Connect(global::Acid.Sharp.IpAddress remoteAddress, ushort remotePort, global::Acid.Sharp.Time timeout)
        {
            if (ReferenceEquals(remoteAddress, null))
                throw new global::System.ArgumentNullException("remoteAddress", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = remoteAddress.__Instance;
            var __arg2 = ReferenceEquals(timeout, null) ? new global::Acid.Sharp.Time.__Internal() : *(global::Acid.Sharp.Time.__Internal*) timeout.__Instance;
            var __ret = __Internal.Connect((__Instance + __PointerAdjustment), __arg0, remotePort, __arg2);
            return __ret;
        }

        /// <summary>Disconnect the socket from its remote peer. This function gracefully closes the connection. If the socket is not connected, this function has no effect.</summary>
        public void Disconnect()
        {
            __Internal.Disconnect((__Instance + __PointerAdjustment));
        }

        /// <summary>
        /// <para>Send raw data to the remote peer.</para>
        /// <para>To be able to handle partial sends over non-blocking sockets,</para>
        /// <para>use the send(const void*, std::size_t, std::size_t&amp;) overload instead.</para>
        /// <para>This function will fail if the socket is not connected.</para>
        /// <para></para>
        /// <para>name=&quot;data&quot;&gt; Pointer to the sequence of bytes to send.</para>
        /// <para>name=&quot;size&quot;&gt; Number of bytes to send.</para>
        /// <para>Status code.</para>
        /// </summary>
        public global::Acid.Sharp.SocketStatus Send(global::System.IntPtr data, ulong size)
        {
            var __ret = __Internal.Send((__Instance + __PointerAdjustment), data, size);
            return __ret;
        }

        /// <summary>Send raw data to the remote peer. This function will fail if the socket is not connected.</summary>
        /// <param name="data">Pointer to the sequence of bytes to send.</param>
        /// <param name="size">Number of bytes to send.</param>
        /// <param name="sent">The number of bytes sent will be written here.</param>
        public global::Acid.Sharp.SocketStatus Send(global::System.IntPtr data, ulong size, ref ulong sent)
        {
            fixed (ulong* __refParamPtr2 = &sent)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.Send((__Instance + __PointerAdjustment), data, size, __arg2);
                return __ret;
            }
        }

        /// <summary>Receive raw data from the remote peer. In blocking mode, this function will wait until some bytes are actually received. This function will fail if the socket is not connected.</summary>
        /// <param name="data">Pointer to the array to fill with the received bytes.</param>
        /// <param name="size">Maximum number of bytes that can be received.</param>
        /// <param name="received">This variable is filled with the actual number of bytes received.</param>
        public global::Acid.Sharp.SocketStatus Receive(global::System.IntPtr data, ulong size, ref ulong received)
        {
            fixed (ulong* __refParamPtr2 = &received)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.Receive((__Instance + __PointerAdjustment), data, size, __arg2);
                return __ret;
            }
        }

        /// <summary>Send a formatted packet of data to the remote peer. In non-blocking mode, if this function returns SOCKET_STATUS_PARTIAL, you \em must retry sending the same unmodified packet before sending anything else in order to guarantee the packet arrives at the remote peer uncorrupted. This function will fail if the socket is not connected.</summary>
        /// <param name="packet">Packet to send.</param>
        public global::Acid.Sharp.SocketStatus Send(global::Acid.Sharp.Packet packet)
        {
            if (ReferenceEquals(packet, null))
                throw new global::System.ArgumentNullException("packet", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = packet.__Instance;
            var __ret = __Internal.Send((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Receive a formatted packet of data from the remote peer. In blocking mode, this function will wait until the whole packet has been received. This function will fail if the socket is not connected.</summary>
        /// <param name="packet">Packet to fill with the received data.</param>
        public global::Acid.Sharp.SocketStatus Receive(global::Acid.Sharp.Packet packet)
        {
            if (ReferenceEquals(packet, null))
                throw new global::System.ArgumentNullException("packet", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = packet.__Instance;
            var __ret = __Internal.Receive((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Get the port to which the socket is bound locally. If the socket is not connected, this function returns 0.</summary>
        public ushort LocalPort
        {
            get
            {
                var __ret = __Internal.GetLocalPort((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the address of the connected peer. It the socket is not connected, this function returns IpAddress::NONE.</summary>
        public global::Acid.Sharp.IpAddress RemoteAddress
        {
            get
            {
                var __ret = new global::Acid.Sharp.IpAddress.__Internal();
                __Internal.GetRemoteAddress((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.IpAddress.__CreateInstance(__ret);
            }
        }

        /// <summary>Get the port of the connected peer to which the socket is connected. If the socket is not connected, this function returns 0.</summary>
        public ushort RemotePort
        {
            get
            {
                var __ret = __Internal.GetRemotePort((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // TcpSocket
        private static global::Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.TcpSocket) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Encapsulate an IPv4 network address.</summary>
    public unsafe partial class IpAddress : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_address;

            [FieldOffset(4)]
            internal byte m_valid;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IpAddress@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IpAddress@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr address);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IpAddress@acid@@QEAA@EEEE@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, byte byte0, byte byte1, byte byte2, byte byte3);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IpAddress@acid@@QEAA@I@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint address);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IpAddress@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToString@IpAddress@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void ToString(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ToInteger@IpAddress@acid@@QEBAIXZ")]
            internal static extern uint ToInteger(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPublicAddress@IpAddress@acid@@SA?AV12@VTime@2@@Z")]
            internal static extern void GetPublicAddress(global::System.IntPtr @return, global::Acid.Sharp.Time.__Internal timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8IpAddress@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??9IpAddress@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MIpAddress@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??NIpAddress@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLessEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??OIpAddress@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??PIpAddress@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreaterEqual(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalAddress@IpAddress@acid@@SA?AV12@XZ")]
            internal static extern void GetLocalAddress(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IpAddress> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IpAddress>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IpAddress __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IpAddress(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IpAddress __CreateInstance(global::Acid.Sharp.IpAddress.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IpAddress(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.IpAddress.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IpAddress.__Internal));
            *(global::Acid.Sharp.IpAddress.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IpAddress(global::Acid.Sharp.IpAddress.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IpAddress(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Default constructor, this constructor creates an empty (invalid) address.</summary>
        public IpAddress()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IpAddress.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Construct the address from a string. Here \a address can be either a decimal address (ex: &quot;192.168.1.56&quot;) or a network name (ex: &quot;localhost&quot;).</summary>
        /// <param name="address">IP address or network name.</param>
        public IpAddress(string address)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IpAddress.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(address, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Construct the address from 4 bytes. Calling IpAddress(a, b, c, d) is equivalent to calling IpAddress(&quot;a.b.c.d&quot;), but safer as it doesn't have to parse a string to get the address components.</summary>
        /// <param name="byte0">First byte of the address.</param>
        /// <param name="byte1">Second byte of the address.</param>
        /// <param name="byte2">Third byte of the address.</param>
        /// <param name="byte3">Fourth byte of the address.</param>
        public IpAddress(byte byte0, byte byte1, byte byte2, byte byte3)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IpAddress.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), byte0, byte1, byte2, byte3);
        }

        /// <summary>Construct the address from a 32-bits integer. This constructor uses the internal representation of the address directly. It should be used for optimization purposes, and only if you got that representation from IpAddress::toInteger().</summary>
        /// <param name="address">4 bytes of the address packed into a 32-bits integer.</param>
        public IpAddress(uint address)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IpAddress.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), address);
        }

        public IpAddress(global::Acid.Sharp.IpAddress _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IpAddress.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.IpAddress.__Internal*) __Instance) = *((global::Acid.Sharp.IpAddress.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IpAddress __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Get a string representation of the address. The returned string is the decimal representation of the IP address (like &quot;192.168.1.56&quot;), even if it was constructed from a host name.</summary>
        public string ToString()
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.ToString((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Get an integer representation of the address The returned number is the internal representation of the address, and should be used for optimization purposes only (like sending the address through a socket). The integer produced by this function can then be converted back to a IpAddress with the proper constructor.</summary>
        public uint ToInteger()
        {
            var __ret = __Internal.ToInteger((__Instance + __PointerAdjustment));
            return __ret;
        }

        public static bool operator ==(global::Acid.Sharp.IpAddress __op, global::Acid.Sharp.IpAddress other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::Acid.Sharp.IpAddress;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::Acid.Sharp.IpAddress.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::Acid.Sharp.IpAddress __op, global::Acid.Sharp.IpAddress other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::Acid.Sharp.IpAddress __op, global::Acid.Sharp.IpAddress other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <=(global::Acid.Sharp.IpAddress __op, global::Acid.Sharp.IpAddress other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLessEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::Acid.Sharp.IpAddress __op, global::Acid.Sharp.IpAddress other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >=(global::Acid.Sharp.IpAddress __op, global::Acid.Sharp.IpAddress other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
            return __ret;
        }

        public static explicit operator global::Acid.Sharp.IpAddress(string address)
        {
            return new global::Acid.Sharp.IpAddress(address);
        }

        public static explicit operator global::Acid.Sharp.IpAddress(uint address)
        {
            return new global::Acid.Sharp.IpAddress(address);
        }

        /// <summary>Get the computer's public address The public address is the address of the computer from the internet point of view, i.e. something like 89.54.1.169. It is necessary for communications over the world wide web. The only way to get a public address is to ask it to a distant website; as a consequence, this function depends on both your network connection and the server, and may be very slow. You should use it as few as possible. Because this function depends on the network connection and on a distant server, you may use a time limit if you don't want your program to be possibly stuck waiting in case there is a problem; this limit is deactivated by default.</summary>
        /// <param name="timeout">Maximum time to wait.</param>
        public static global::Acid.Sharp.IpAddress GetPublicAddress(global::Acid.Sharp.Time timeout)
        {
            var __arg0 = ReferenceEquals(timeout, null) ? new global::Acid.Sharp.Time.__Internal() : *(global::Acid.Sharp.Time.__Internal*) timeout.__Instance;
            var __ret = new global::Acid.Sharp.IpAddress.__Internal();
            __Internal.GetPublicAddress(new IntPtr(&__ret), __arg0);
            return global::Acid.Sharp.IpAddress.__CreateInstance(__ret);
        }


        public static global::Acid.Sharp.IpAddress None
        {
            get
            {
                var __ptr = (global::Acid.Sharp.IpAddress.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NONE@IpAddress@acid@@2V12@B");
                return global::Acid.Sharp.IpAddress.__CreateInstance(*__ptr);
            }
        }


        public static global::Acid.Sharp.IpAddress Any
        {
            get
            {
                var __ptr = (global::Acid.Sharp.IpAddress.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?ANY@IpAddress@acid@@2V12@B");
                return global::Acid.Sharp.IpAddress.__CreateInstance(*__ptr);
            }
        }


        public static global::Acid.Sharp.IpAddress LocalHost
        {
            get
            {
                var __ptr = (global::Acid.Sharp.IpAddress.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?LOCAL_HOST@IpAddress@acid@@2V12@B");
                return global::Acid.Sharp.IpAddress.__CreateInstance(*__ptr);
            }
        }


        public static global::Acid.Sharp.IpAddress Broadcast
        {
            get
            {
                var __ptr = (global::Acid.Sharp.IpAddress.__Internal*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?BROADCAST@IpAddress@acid@@2V12@B");
                return global::Acid.Sharp.IpAddress.__CreateInstance(*__ptr);
            }
        }

        /// <summary>Get the computer's local address. The local address is the address of the computer from the LAN point of view, i.e. something like 192.168.1.56. It is meaningful only for communications over the local network. Unlike getPublicAddress, this function is fast and may be used safely anywhere.</summary>
        public static global::Acid.Sharp.IpAddress LocalAddress
        {
            get
            {
                var __ret = new global::Acid.Sharp.IpAddress.__Internal();
                __Internal.GetLocalAddress(new IntPtr(&__ret));
                return global::Acid.Sharp.IpAddress.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Enumeration of transfer modes.</summary>
    public enum FtpTransferMode
    {

        FtpModeBinary = 0,

        FtpModeAscii = 1,

        FtpModeEbcdic = 2
    }

    /// <summary>Utility class for exchanging datas with the server on the data channel.</summary>
    public unsafe partial class FtpDataChannel : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_ftp;

            [FieldOffset(8)]
            internal global::Acid.Sharp.TcpSocket.__Internal m_dataSocket;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpDataChannel@acid@@QEAA@AEAVFtp@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr owner);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpDataChannel@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FtpDataChannel@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Open@FtpDataChannel@acid@@QEAA?AVFtpResponse@2@W4FtpTransferMode@2@@Z")]
            internal static extern void Open(global::System.IntPtr instance, global::System.IntPtr @return, global::Acid.Sharp.FtpTransferMode mode);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FtpDataChannel> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FtpDataChannel>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.FtpDataChannel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpDataChannel(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FtpDataChannel __CreateInstance(global::Acid.Sharp.FtpDataChannel.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpDataChannel(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FtpDataChannel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpDataChannel.__Internal));
            global::Acid.Sharp.FtpDataChannel.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FtpDataChannel(global::Acid.Sharp.FtpDataChannel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FtpDataChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public FtpDataChannel(global::Acid.Sharp.Ftp owner)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpDataChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(owner, null))
                throw new global::System.ArgumentNullException("owner", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = owner.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public FtpDataChannel(global::Acid.Sharp.FtpDataChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpDataChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FtpDataChannel __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.FtpResponse Open(global::Acid.Sharp.FtpTransferMode mode)
        {
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.Open((__Instance + __PointerAdjustment), new IntPtr(&__ret), mode);
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        public static implicit operator global::Acid.Sharp.FtpDataChannel(global::Acid.Sharp.Ftp owner)
        {
            return new global::Acid.Sharp.FtpDataChannel(owner);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Status codes possibly returned by a FTP response.</summary>
    public enum FtpResponseStatus
    {

        FtpResponseRestartMarkerReply = 110,

        FtpResponseServiceReadySoon = 120,

        FtpResponseDataConnectionAlreadyOpened = 125,

        FtpResponseOpeningDataConnection = 150,

        FtpResponseOk = 200,

        FtpResponsePointlessCommand = 202,

        FtpResponseSystemStatus = 211,

        FtpResponseDirectoryStatus = 212,

        FtpResponseFileStatus = 213,

        FtpResponseHelpMessage = 214,

        FtpResponseSystemType = 215,

        FtpResponseServiceReady = 220,

        FtpResponseClosingConnection = 221,

        FtpResponseDataConnectionOpened = 225,

        FtpResponseClosingDataConnection = 226,

        FtpResponseEnteringPassiveMode = 227,

        FtpResponseLoggedin = 230,

        FtpResponseFileactionOk = 250,

        FtpResponseDirectoryOk = 257,

        FtpResponseNeedPassword = 331,

        FtpResponseNeedAccountToLogin = 332,

        FtpResponseNeedInformation = 350,

        FtpResponseServiceUnavailable = 421,

        FtpResponseDataConnectionUnavailable = 425,

        FtpResponseTransferAborted = 426,

        FtpResponseFileActionAborted = 450,

        FtpResponseLocalError = 451,

        FtpResponseInsufficientStorageSpace = 452,

        FtpResponseCommandUnknown = 500,

        FtpResponseParametersUnknown = 501,

        FtpResponseCommandNotImplemented = 502,

        FtpResponseBadCommandSequence = 503,

        FtpResponseParameterNotImplemented = 504,

        FtpResponseNotLoggedin = 530,

        FtpResponseNeedAccountToStore = 532,

        FtpResponseFileUnavailable = 550,

        FtpResponsePageTypeUnknown = 551,

        FtpResponseNotEnoughMemory = 552,

        FtpResponseFilenameNotAllowed = 553,

        FtpResponseInvalidResponse = 1000,

        FtpResponseConnectionFailed = 1001,

        FtpResponseConnectionClosed = 1002,

        FtpResponseInvalidFile = 1003
    }

    /// <summary>Define a FTP response.</summary>
    public unsafe partial class FtpResponse : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.FtpResponseStatus m_status;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_message;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpResponse@acid@@QEAA@W4FtpResponseStatus@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::Acid.Sharp.FtpResponseStatus code, global::System.IntPtr message);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpResponse@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FtpResponse@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsOk@FtpResponse@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetOk(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStatus@FtpResponse@acid@@QEBA?AW4FtpResponseStatus@2@XZ")]
            internal static extern global::Acid.Sharp.FtpResponseStatus GetStatus(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFullMessage@FtpResponse@acid@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern global::System.IntPtr GetFullMessage(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FtpResponse> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.FtpResponse>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.FtpResponse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpResponse(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FtpResponse __CreateInstance(global::Acid.Sharp.FtpResponse.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpResponse(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FtpResponse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponse.__Internal));
            global::Acid.Sharp.FtpResponse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FtpResponse(global::Acid.Sharp.FtpResponse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FtpResponse(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Default constructor, this constructor is used by the FTP client to build the response.</summary>
        /// <param name="code">Response status code.</param>
        /// <param name="message">Response message.</param>
        public FtpResponse(global::Acid.Sharp.FtpResponseStatus code, string message)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(message, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), code, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public FtpResponse(global::Acid.Sharp.FtpResponse _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FtpResponse __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Check if the status code means a success.</para>
        /// <para>This function is defined for convenience, it is equivalent to testing if the status code is&lt;&gt;400.</para>
        /// <para></para>
        /// <para>True if the status is a success, false if it is a failure.</para>
        /// </summary>
        public bool Ok
        {
            get
            {
                var __ret = __Internal.GetOk((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the status code of the response.</summary>
        public global::Acid.Sharp.FtpResponseStatus Status
        {
            get
            {
                var __ret = __Internal.GetStatus((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the full message contained in the response.</summary>
        public string FullMessage
        {
            get
            {
                var __ret = __Internal.GetFullMessage((__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A FTP client.</summary>
    public unsafe partial class Ftp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.TcpSocket.__Internal m_commandSocket;

            [FieldOffset(72)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_receiveBuffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ftp@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Ftp@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Ftp@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Connect@Ftp@acid@@QEAA?AVFtpResponse@2@AEBVIpAddress@2@GVTime@2@@Z")]
            internal static extern void Connect(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr server, ushort port, global::Acid.Sharp.Time.__Internal timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Disconnect@Ftp@acid@@QEAA?AVFtpResponse@2@XZ")]
            internal static extern void Disconnect(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Login@Ftp@acid@@QEAA?AVFtpResponse@2@XZ")]
            internal static extern void Login(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Login@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void Login(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name, global::System.IntPtr password);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDirectoryListing@Ftp@acid@@QEAA?AVFtpResponseListing@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void GetDirectoryListing(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr directory);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ChangeDirectory@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void ChangeDirectory(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr directory);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateRemoteDirectory@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void CreateRemoteDirectory(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeleteRemoteDirectory@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeleteRemoteDirectory(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RenameRemoteFile@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void RenameRemoteFile(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr file, global::System.IntPtr newName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeleteRemoteFile@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void DeleteRemoteFile(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Download@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0W4FtpTransferMode@2@@Z")]
            internal static extern void Download(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr remoteFile, global::System.IntPtr localPath, global::Acid.Sharp.FtpTransferMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Upload@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0W4FtpTransferMode@2@_N@Z")]
            internal static extern void Upload(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr localFile, global::System.IntPtr remotePath, global::Acid.Sharp.FtpTransferMode mode, bool append);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SendCommand@Ftp@acid@@QEAA?AVFtpResponse@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void SendCommand(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr command, global::System.IntPtr parameter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?KeepAlive@Ftp@acid@@QEAA?AVFtpResponse@2@XZ")]
            internal static extern void KeepAlive(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWorkingDirectory@Ftp@acid@@QEAA?AVFtpResponseDirectory@2@XZ")]
            internal static extern void GetWorkingDirectory(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?ParentDirectory@Ftp@acid@@QEAA?AVFtpResponse@2@XZ")]
            internal static extern void ParentDirectory(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Ftp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Ftp>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Ftp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Ftp(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Ftp __CreateInstance(global::Acid.Sharp.Ftp.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Ftp(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Ftp.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Ftp.__Internal));
            global::Acid.Sharp.Ftp.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Ftp(global::Acid.Sharp.Ftp.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Ftp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Ftp(global::Acid.Sharp.Ftp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Ftp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public Ftp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Ftp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Ftp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connects to the specified FTP server. The port has a default value of 21, which is the standard port used by the FTP protocol. You shouldn't use a different value, unless you really know what you do. This function tries to connect to the server so it may take a while to complete, especially if the server is not reachable. To avoid blocking your application for too long, you can use a timeout. The default value, Time::Zero, means that the system timeout will be used (which is usually pretty long).</summary>
        /// <param name="server">Name or address of the FTP server to connect to.</param>
        /// <param name="port">Port used for the connection.</param>
        /// <param name="timeout">Maximum time to wait.</param>
        public global::Acid.Sharp.FtpResponse Connect(global::Acid.Sharp.IpAddress server, ushort port, global::Acid.Sharp.Time timeout)
        {
            if (ReferenceEquals(server, null))
                throw new global::System.ArgumentNullException("server", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = server.__Instance;
            var __arg2 = ReferenceEquals(timeout, null) ? new global::Acid.Sharp.Time.__Internal() : *(global::Acid.Sharp.Time.__Internal*) timeout.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.Connect((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, port, __arg2);
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Close the connection with the server.</summary>
        public global::Acid.Sharp.FtpResponse Disconnect()
        {
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.Disconnect((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Log in using an anonymous account. Logging in is mandatory after connecting to the server. Users that are not logged in cannot perform any operation.</summary>
        public global::Acid.Sharp.FtpResponse Login()
        {
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.Login((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Log in using a username and a password. Logging in is mandatory after connecting to the server. Users that are not logged in cannot perform any operation.</summary>
        /// <param name="name">User name.</param>
        /// <param name="password">Password.</param>
        public global::Acid.Sharp.FtpResponse Login(string name, string password)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(password, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.Login((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Get the contents of the given directory. This function retrieves the sub-directories and files contained in the given directory. It is not recursive. The \a directory parameter is relative to the current working directory.</summary>
        /// <param name="directory">Directory to list.</param>
        public global::Acid.Sharp.FtpResponseListing GetDirectoryListing(string directory)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(directory, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponseListing.__Internal();
            __Internal.GetDirectoryListing((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::Acid.Sharp.FtpResponseListing.__CreateInstance(__ret);
        }

        /// <summary>Change the current working directory. The new directory must be relative to the current one.</summary>
        /// <param name="directory">New working directory.</param>
        public global::Acid.Sharp.FtpResponse ChangeDirectory(string directory)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(directory, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.ChangeDirectory((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Create a new directory. The new directory is created as a child of the current working directory.</summary>
        /// <param name="name">Name of the directory to create.</param>
        public global::Acid.Sharp.FtpResponse CreateRemoteDirectory(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.CreateRemoteDirectory((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Remove an existing directory The directory to remove must be relative to the current working directory. Use this function with caution, the directory will be removed permanently!</summary>
        /// <param name="name">Name of the directory to remove.</param>
        public global::Acid.Sharp.FtpResponse DeleteRemoteDirectory(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.DeleteRemoteDirectory((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Rename an existing file. The filenames must be relative to the current working directory.</summary>
        /// <param name="file">File to rename.</param>
        /// <param name="newName">New name of the file.</param>
        public global::Acid.Sharp.FtpResponse RenameRemoteFile(string file, string newName)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(file, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(newName, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.RenameRemoteFile((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Remove an existing file. The file name must be relative to the current working directory. Use this function with caution, the file will be removed permanently!</summary>
        /// <param name="name">File to remove.</param>
        public global::Acid.Sharp.FtpResponse DeleteRemoteFile(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.DeleteRemoteFile((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Download a file from the server. The filename of the distant file is relative to the current working directory of the server, and the local destination path is relative to the current directory of your application. If a file with the same filename as the distant file already exists in the local destination path, it will be overwritten.</summary>
        /// <param name="remoteFile">Filename of the distant file to download.</param>
        /// <param name="localPath">The directory in which to put the file on the local computer.</param>
        /// <param name="mode">Transfer mode.</param>
        public global::Acid.Sharp.FtpResponse Download(string remoteFile, string localPath, global::Acid.Sharp.FtpTransferMode mode)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(remoteFile, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(localPath, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.Download((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1, mode);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Upload a file to the server. The name of the local file is relative to the current working directory of your application, and the remote path is relative to the current directory of the FTP server. The append parameter controls whether the remote file is appended to or overwritten if it already exists.</summary>
        /// <param name="localFile">Path of the local file to upload.</param>
        /// <param name="remotePath">The directory in which to put the file on the server.</param>
        /// <param name="mode">Transfer mode.</param>
        /// <param name="append">Pass true to append to or false to overwrite the remote file if it already exists.</param>
        public global::Acid.Sharp.FtpResponse Upload(string localFile, string remotePath, global::Acid.Sharp.FtpTransferMode mode, bool append)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(localFile, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(remotePath, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.Upload((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1, mode, append);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Send a command to the FTP server. While the most often used commands are provided as member functions in the Ftp class, this method can be used to send any FTP command to the server. If the command requires one or more parameters, they can be specified in \a parameter. If the server returns information, you can extract it from the response using FtpResponse::GetFullMessage().</summary>
        /// <param name="command">Command to send.</param>
        /// <param name="parameter">Command parameter.</param>
        public global::Acid.Sharp.FtpResponse SendCommand(string command, string parameter)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(command, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(parameter, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
            __Internal.SendCommand((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
        }

        /// <summary>Send a null command to keep the connection alive. This command is useful because the server may close the connection automatically if no command is sent.</summary>
        public global::Acid.Sharp.FtpResponse KeepAlive
        {
            get
            {
                var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
                __Internal.KeepAlive((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
            }
        }

        /// <summary>Get the current working directory. The working directory is the root path for subsequent operations involving directories and/or filenames.</summary>
        public global::Acid.Sharp.FtpResponseDirectory WorkingDirectory
        {
            get
            {
                var __ret = new global::Acid.Sharp.FtpResponseDirectory.__Internal();
                __Internal.GetWorkingDirectory((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.FtpResponseDirectory.__CreateInstance(__ret);
            }
        }

        /// <summary>Go to the parent directory of the current one.</summary>
        public global::Acid.Sharp.FtpResponse ParentDirectory
        {
            get
            {
                var __ret = new global::Acid.Sharp.FtpResponse.__Internal();
                __Internal.ParentDirectory((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.FtpResponse.__CreateInstance(__ret);
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Enumerate the available HTTP methods for a request, https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods.</summary>
    public enum HttpRequestMethod
    {

        HttpMethodGet = 0,

        HttpMethodPost = 1,

        HttpMethodHead = 2,

        HttpMethodPut = 3,

        HttpMethodDelete = 4,

        HttpMethodOptions = 5,

        HttpMethodPatch = 6,

        HttpMethodTrace = 7,

        HttpMethodConnect = 8
    }

    /// <summary>Define a HTTP request.</summary>
    public unsafe partial class HttpRequest : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S0____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S0_ m_fields;

            [FieldOffset(16)]
            internal global::Acid.Sharp.HttpRequestMethod m_method;

            [FieldOffset(24)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_uri;

            [FieldOffset(56)]
            internal uint m_majorVersion;

            [FieldOffset(60)]
            internal uint m_minorVersion;

            [FieldOffset(64)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_body;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0HttpRequest@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4HttpRequestMethod@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr uri, global::Acid.Sharp.HttpRequestMethod method, global::System.IntPtr body);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0HttpRequest@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1HttpRequest@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetField@HttpRequest@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern void SetField(global::System.IntPtr instance, global::System.IntPtr field, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMethod@HttpRequest@acid@@QEAAXW4HttpRequestMethod@2@@Z")]
            internal static extern void SetMethod(global::System.IntPtr instance, global::Acid.Sharp.HttpRequestMethod method);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetUri@HttpRequest@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetUri(global::System.IntPtr instance, global::System.IntPtr uri);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHttpVersion@HttpRequest@acid@@QEAAXII@Z")]
            internal static extern void SetHttpVersion(global::System.IntPtr instance, uint major, uint minor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBody@HttpRequest@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetBody(global::System.IntPtr instance, global::System.IntPtr body);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.HttpRequest> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.HttpRequest>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.HttpRequest __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.HttpRequest(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.HttpRequest __CreateInstance(global::Acid.Sharp.HttpRequest.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.HttpRequest(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.HttpRequest.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.HttpRequest.__Internal));
            global::Acid.Sharp.HttpRequest.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HttpRequest(global::Acid.Sharp.HttpRequest.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HttpRequest(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Default constructor, this constructor creates a GET request, with the root URI (&quot;/&quot;) and an empty body.</summary>
        /// <param name="uri">Target URI.</param>
        /// <param name="method">Method to use for the request.</param>
        /// <param name="body">Content of the request's body.</param>
        public HttpRequest(string uri, global::Acid.Sharp.HttpRequestMethod method, string body)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.HttpRequest.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(uri, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(body, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, method, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        public HttpRequest(global::Acid.Sharp.HttpRequest _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.HttpRequest.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.HttpRequest __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Set the value of a field. The field is created if it doesn't exist. The name of the field is case-insensitive. By default, a request doesn't contain any field (but the mandatory fields are added later by the HTTP client when sending the request).</summary>
        /// <param name="field">Name of the field to set.</param>
        /// <param name="value">Value of the field.</param>
        public void SetField(string field, string value)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(field, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.SetField((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Set the request method. See the Method enumeration for a complete list of all the available methods. The method is HTTP_REQUEST_METHOD_GET by default.</summary>
        /// <param name="method">Method to use for the request.</param>
        public void SetMethod(global::Acid.Sharp.HttpRequestMethod method)
        {
            __Internal.SetMethod((__Instance + __PointerAdjustment), method);
        }

        /// <summary>Set the requested URI. The URI is the resource (usually a web page or a file) that you want to get or post. The URI is &quot;/&quot; (the root page) by default.</summary>
        /// <param name="uri">URI to request, relative to the host.</param>
        public void SetUri(string uri)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(uri, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.SetUri((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Set the HTTP version for the request. The HTTP version is 1.0 by default.</summary>
        /// <param name="major">Major HTTP version number.</param>
        /// <param name="minor">Minor HTTP version number.</param>
        public void SetHttpVersion(uint major, uint minor)
        {
            __Internal.SetHttpVersion((__Instance + __PointerAdjustment), major, minor);
        }

        /// <summary>Set the body of the request. The body of a request is optional and only makes sense for POST requests. It is ignored for all other methods. The body is empty by default.</summary>
        /// <param name="body">Content of the body.</param>
        public void SetBody(string body)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(body, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.SetBody((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Enumerate all the valid status codes for a response.</summary>
    public enum HttpResponseStatus
    {

        HttpResponseOk = 200,

        HttpResponseCreated = 201,

        HttpResponseAccepted = 202,

        HttpResponseNoContent = 204,

        HttpResponseResetContent = 205,

        HttpResponsePartialContent = 206,

        HttpResponseMultipleChoices = 300,

        HttpResponseMovedPermanently = 301,

        HttpResponseMovedTemporarily = 302,

        HttpResponseNotModified = 304,

        HttpResponseBadRequest = 400,

        HttpResponseUnauthorized = 401,

        HttpResponseForbidden = 403,

        HttpResponseNotFound = 404,

        HttpResponseRangeNotSatisfiable = 407,

        HttpResponseInternalServerError = 500,

        HttpResponseNotImplemented = 501,

        HttpResponseBadGateway = 502,

        HttpResponseServiceNotAvailable = 503,

        HttpResponseGatewayTimeout = 504,

        HttpResponseVersionNotSupported = 505,

        HttpResponseInvalidResponse = 1000,

        HttpResponseConnectionFailed = 1001
    }

    /// <summary>Define a HTTP response.</summary>
    public unsafe partial class HttpResponse : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C_S0____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S0_ m_fields;

            [FieldOffset(16)]
            internal global::Acid.Sharp.HttpResponseStatus m_status;

            [FieldOffset(20)]
            internal uint m_majorVersion;

            [FieldOffset(24)]
            internal uint m_minorVersion;

            [FieldOffset(32)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_body;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0HttpResponse@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0HttpResponse@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1HttpResponse@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetField@HttpResponse@acid@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z")]
            internal static extern global::System.IntPtr GetField(global::System.IntPtr instance, global::System.IntPtr field);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStatus@HttpResponse@acid@@QEBA?AW4HttpResponseStatus@2@XZ")]
            internal static extern global::Acid.Sharp.HttpResponseStatus GetStatus(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMajorHttpVersion@HttpResponse@acid@@QEBAIXZ")]
            internal static extern uint GetMajorHttpVersion(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMinorHttpVersion@HttpResponse@acid@@QEBAIXZ")]
            internal static extern uint GetMinorHttpVersion(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBody@HttpResponse@acid@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern global::System.IntPtr GetBody(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.HttpResponse> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.HttpResponse>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.HttpResponse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.HttpResponse(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.HttpResponse __CreateInstance(global::Acid.Sharp.HttpResponse.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.HttpResponse(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.HttpResponse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.HttpResponse.__Internal));
            global::Acid.Sharp.HttpResponse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HttpResponse(global::Acid.Sharp.HttpResponse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HttpResponse(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Default constructor, constructs an empty response.</summary>
        public HttpResponse()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.HttpResponse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public HttpResponse(global::Acid.Sharp.HttpResponse _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.HttpResponse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.HttpResponse __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Get the value of a field. If the field \a field is not found in the response header, the empty string is returned. This function uses case-insensitive comparisons.</summary>
        /// <param name="field">Name of the field to get.</param>
        public string GetField(string field)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(field, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetField((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Get the response status code. The status code should be the first thing to be checked after receiving a response, it defines whether it is a success, a failure or anything else (see the Status enumeration).</summary>
        public global::Acid.Sharp.HttpResponseStatus Status
        {
            get
            {
                var __ret = __Internal.GetStatus((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the major HTTP version number of the response.</summary>
        public uint MajorHttpVersion
        {
            get
            {
                var __ret = __Internal.GetMajorHttpVersion((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the minor HTTP version number of the response.</summary>
        public uint MinorHttpVersion
        {
            get
            {
                var __ret = __Internal.GetMinorHttpVersion((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the body of the response. The body of a response may contain: The requested page (for GET requests).A response from the server (for POST requests).Nothing (for HEAD requests).An error message (in case of an error).</summary>
        public string Body
        {
            get
            {
                var __ret = __Internal.GetBody((__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A HTTP client.</summary>
    public unsafe partial class Http : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.TcpSocket.__Internal m_connection;

            [FieldOffset(72)]
            internal global::Acid.Sharp.IpAddress.__Internal m_host;

            [FieldOffset(80)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_hostName;

            [FieldOffset(112)]
            internal ushort m_port;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Http@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Http@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr host, ushort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Http@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Http@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHost@Http@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z")]
            internal static extern void SetHost(global::System.IntPtr instance, global::System.IntPtr host, ushort port);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SendRequest@Http@acid@@QEAA?AVHttpResponse@2@AEBVHttpRequest@2@VTime@2@@Z")]
            internal static extern void SendRequest(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr request, global::Acid.Sharp.Time.__Internal timeout);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Http> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Http>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Http __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Http(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Http __CreateInstance(global::Acid.Sharp.Http.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Http(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Http.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Http.__Internal));
            global::Acid.Sharp.Http.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Http(global::Acid.Sharp.Http.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Http(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Default constructor.</summary>
        public Http()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Http.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        /// <summary>Construct the HTTP client with the target host. This is equivalent to calling setHost(host, port). The port has a default value of 0, which means that the HTTP client will use the right port according to the protocol used (80 for HTTP). You should leave it like this unless you really need a port other than the standard one, or use an unknown protocol.</summary>
        /// <param name="host">Web server to connect to.</param>
        /// <param name="port">Port to use for connection.</param>
        public Http(string host, ushort port)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Http.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(host, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, port);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public Http(global::Acid.Sharp.Http _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Http.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Http __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Set the target host. This function just stores the host address and port, it doesn't actually connect to it until you send a request. The port has a default value of 0, which means that the HTTP client will use the right port according to the protocol used (80 for HTTP). You should leave it like this unless you really need a port other than the standard one, or use an unknown protocol.</summary>
        /// <param name="host">Web server to connect to.</param>
        /// <param name="port">Port to use for connection.</param>
        public void SetHost(string host, ushort port)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(host, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.SetHost((__Instance + __PointerAdjustment), __arg0, port);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Send a HTTP request and return the server's response. You must have a valid host before sending a request (see setHost). Any missing mandatory header field in the request will be added with an appropriate value. Warning: this function waits for the server's response and may not return instantly; use a thread if you don't want to block your application, or use a timeout to limit the time to wait. A value of Time::ZERO means that the client will use the system default timeout (which is usually pretty long).</summary>
        /// <param name="request">Request to send.</param>
        /// <param name="timeout">Maximum time to wait.</param>
        public global::Acid.Sharp.HttpResponse SendRequest(global::Acid.Sharp.HttpRequest request, global::Acid.Sharp.Time timeout)
        {
            if (ReferenceEquals(request, null))
                throw new global::System.ArgumentNullException("request", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = request.__Instance;
            var __arg1 = ReferenceEquals(timeout, null) ? new global::Acid.Sharp.Time.__Internal() : *(global::Acid.Sharp.Time.__Internal*) timeout.__Instance;
            var __ret = new global::Acid.Sharp.HttpResponse.__Internal();
            __Internal.SendRequest((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.HttpResponse.__CreateInstance(__ret);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Utility class to build blocks of data to transfer over the network.</summary>
    public unsafe partial class Packet : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Packet;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__C___N_std_S_allocator__C m_data;

            [FieldOffset(32)]
            internal ulong m_readPos;

            [FieldOffset(40)]
            internal ulong m_sendPos;

            [FieldOffset(48)]
            internal byte m_isValid;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Packet@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Packet@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Append@Packet@acid@@QEAAXPEBX_K@Z")]
            internal static extern void Append(global::System.IntPtr instance, global::System.IntPtr data, ulong sizeInBytes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Clear@Packet@acid@@QEAAXXZ")]
            internal static extern void Clear(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?EndOfPacket@Packet@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool EndOfPacket(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??6Packet@acid@@QEAAAEAV01@H@Z")]
            internal static extern global::System.IntPtr OperatorLessLess(global::System.IntPtr instance, int data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CheckSize@Packet@acid@@IEAA_N_K@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckSize(global::System.IntPtr instance, ulong size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetData@Packet@acid@@QEBAPEBXXZ")]
            internal static extern global::System.IntPtr GetData(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDataSize@Packet@acid@@QEBA_KXZ")]
            internal static extern ulong GetDataSize(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Packet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Packet>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Packet __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Packet(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Packet __CreateInstance(global::Acid.Sharp.Packet.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Packet(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Packet.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Packet.__Internal));
            global::Acid.Sharp.Packet.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Packet(global::Acid.Sharp.Packet.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Packet(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Default constructor, creates an empty packet.</summary>
        public Packet()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Packet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Packet");
        }

        public Packet(global::Acid.Sharp.Packet _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Packet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Packet");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Packet __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Packet.__Internal*) __Instance)->vfptr_Packet = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___dtorDelegate = (global::Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_int));
                ___dtorDelegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Append data to the end of the packet.</summary>
        /// <param name="data">Pointer to the sequence of bytes to append.</param>
        /// <param name="sizeInBytes">Number of bytes to append.</param>
        public void Append(global::System.IntPtr data, ulong sizeInBytes)
        {
            __Internal.Append((__Instance + __PointerAdjustment), data, sizeInBytes);
        }

        /// <summary>Clear the packet, after calling Clear, the packet is empty.</summary>
        public void Clear()
        {
            __Internal.Clear((__Instance + __PointerAdjustment));
        }

        /// <summary>Tell if the reading position has reached the end of the packet. This function is useful to know if there is some data left to be read, without actually reading it.</summary>
        public bool EndOfPacket()
        {
            var __ret = __Internal.EndOfPacket((__Instance + __PointerAdjustment));
            return __ret;
        }

        public static global::Acid.Sharp.Packet operator <<(global::Acid.Sharp.Packet __op, int data)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorLessLess(__arg0, data);
            global::Acid.Sharp.Packet __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Packet.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Packet) global::Acid.Sharp.Packet.NativeToManagedMap[__ret];
            else global::Acid.Sharp.Packet.NativeToManagedMap[__ret] = __result0 = (global::Acid.Sharp.Packet) global::Acid.Sharp.Packet.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Called before the packet is sent over the network. This function can be defined by derived classes to transform the data before it is sent; this can be used for compression, encryption, etc. The function must return a pointer to the modified data, as well as the number of bytes pointed. The default implementation provides the packet's data without transforming it.</summary>
        /// <param name="size">Variable to fill with the size of data to send.</param>
        protected virtual global::System.IntPtr OnSend(ref ulong size)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___OnSendDelegate = (global::Delegates.Func_IntPtr_IntPtr_ulongPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr_ulongPtr));
            fixed (ulong* __refParamPtr0 = &size)
            {
                var __arg0 = __refParamPtr0;
                var __ret = ___OnSendDelegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        /// <summary>Called after the packet is received over the network. This function can be defined by derived classes to transform the data after it is received; this can be used for decompression, decryption, etc. The function receives a pointer to the received data, and must fill the packet with the transformed bytes. The default implementation fills the packet directly without transforming the data.</summary>
        /// <param name="data">Pointer to the received bytes.</param>
        /// <param name="size">Number of bytes.</param>
        protected virtual void OnReceive(global::System.IntPtr data, ulong size)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___OnReceiveDelegate = (global::Delegates.Action_IntPtr_IntPtr_ulong) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_ulong));
            ___OnReceiveDelegate((__Instance + __PointerAdjustment), data, size);
        }

        /// <summary>Check if the packet can extract a given number of bytes. This function updates accordingly the state of the packet.</summary>
        /// <param name="size">Size to check.</param>
        protected bool CheckSize(ulong size)
        {
            var __ret = __Internal.CheckSize((__Instance + __PointerAdjustment), size);
            return __ret;
        }

        /// <summary>Get a pointer to the data contained in the packet. Warning: the returned pointer may become invalid after  you append data to the packet, therefore it should never be stored. The return pointer is NULL if the packet is empty.</summary>
        public global::System.IntPtr Data
        {
            get
            {
                var __ret = __Internal.GetData((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the size of the data contained in the packet. This function returns the number of bytes pointed to by what getData returns.</summary>
        public ulong DataSize
        {
            get
            {
                var __ret = __Internal.GetDataSize((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~Packet()
        private static global::Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Packet) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void *OnSend(std::size_t &size)
        private static global::Delegates.Func_IntPtr_IntPtr_ulongPtr _OnSendDelegateInstance;

        private static global::System.IntPtr _OnSendDelegateHook(global::System.IntPtr instance, ulong* size)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Packet) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.OnSend(ref *size);
            return __ret;
        }

        // void OnReceive(const void *data, std::size_t size)
        private static global::Delegates.Action_IntPtr_IntPtr_ulong _OnReceiveDelegateInstance;

        private static void _OnReceiveDelegateHook(global::System.IntPtr instance, global::System.IntPtr data, ulong size)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Packet) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnReceive(data, size);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _OnSendDelegateInstance += _OnSendDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_OnSendDelegateInstance).ToPointer();
                _OnReceiveDelegateInstance += _OnReceiveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_OnReceiveDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = _Thunks[1];
                    *(void**) (vfptr0 + 24) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Socket that listens to new TCP connections.</summary>
    public unsafe partial class TcpListener : global::Acid.Sharp.Socket, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Socket;

            [FieldOffset(8)]
            internal global::Acid.Sharp.SocketType m_type;

            [FieldOffset(16)]
            internal ulong m_socket;

            [FieldOffset(24)]
            internal byte m_isBlocking;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TcpListener@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0TcpListener@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Listen@TcpListener@acid@@QEAA?AW4SocketStatus@2@GAEBVIpAddress@2@@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Listen(global::System.IntPtr instance, ushort port, global::System.IntPtr address);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Close@TcpListener@acid@@QEAAXXZ")]
            internal static extern void Close(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Accept@TcpListener@acid@@QEAA?AW4SocketStatus@2@AEAVTcpSocket@2@@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Accept(global::System.IntPtr instance, global::System.IntPtr socket);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalPort@TcpListener@acid@@QEBAGXZ")]
            internal static extern ushort GetLocalPort(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.TcpListener __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.TcpListener(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.TcpListener __CreateInstance(global::Acid.Sharp.TcpListener.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.TcpListener(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.TcpListener.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.TcpListener.__Internal));
            global::Acid.Sharp.TcpListener.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private TcpListener(global::Acid.Sharp.TcpListener.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TcpListener(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Default constructor.</summary>
        public TcpListener()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.TcpListener.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.TcpListener");
        }

        public TcpListener(global::Acid.Sharp.TcpListener _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.TcpListener.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.TcpListener");
        }

        /// <summary>Start listening for incoming connection attempts. This function makes the socket start listening on the specified port, waiting for incoming connection attempts. If the socket is already listening on a port when this function is called, it will stop listening on the old port before starting to listen on the new port.</summary>
        /// <param name="port">Port to listen on for incoming connection attempts.</param>
        /// <param name="address">Address of the interface to listen on.</param>
        public global::Acid.Sharp.SocketStatus Listen(ushort port, global::Acid.Sharp.IpAddress address)
        {
            if (ReferenceEquals(address, null))
                throw new global::System.ArgumentNullException("address", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = address.__Instance;
            var __ret = __Internal.Listen((__Instance + __PointerAdjustment), port, __arg1);
            return __ret;
        }

        /// <summary>Stop listening and close the socket. This function gracefully stops the listener. If the socket is not listening, this function has no effect.</summary>
        public void Close()
        {
            __Internal.Close((__Instance + __PointerAdjustment));
        }

        /// <summary>Accept a new connection. If the socket is in blocking mode, this function will not return until a connection is actually received.</summary>
        /// <param name="socket">Socket that will hold the new connection.</param>
        public global::Acid.Sharp.SocketStatus Accept(global::Acid.Sharp.TcpSocket socket)
        {
            if (ReferenceEquals(socket, null))
                throw new global::System.ArgumentNullException("socket", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = socket.__Instance;
            var __ret = __Internal.Accept((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Get the port to which the socket is bound locally. If the socket is not listening to a port, this function returns 0.</summary>
        public ushort LocalPort
        {
            get
            {
                var __ret = __Internal.GetLocalPort((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // TcpListener
        private static global::Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.TcpListener) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Specialized socket using the UDP protocol.</summary>
    public unsafe partial class UdpSocket : global::Acid.Sharp.Socket, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_Socket;

            [FieldOffset(8)]
            internal global::Acid.Sharp.SocketType m_type;

            [FieldOffset(16)]
            internal ulong m_socket;

            [FieldOffset(24)]
            internal byte m_isBlocking;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector__C___N_std_S_allocator__C m_buffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UdpSocket@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UdpSocket@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Bind@UdpSocket@acid@@QEAA?AW4SocketStatus@2@GAEBVIpAddress@2@@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Bind(global::System.IntPtr instance, ushort port, global::System.IntPtr address);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Unbind@UdpSocket@acid@@QEAAXXZ")]
            internal static extern void Unbind(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Send@UdpSocket@acid@@QEAA?AW4SocketStatus@2@PEBX_KAEBVIpAddress@2@G@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Send(global::System.IntPtr instance, global::System.IntPtr data, ulong size, global::System.IntPtr remoteAddress, ushort remotePort);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Receive@UdpSocket@acid@@QEAA?AW4SocketStatus@2@PEAX_KAEA_KAEAVIpAddress@2@AEAG@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Receive(global::System.IntPtr instance, global::System.IntPtr data, ulong size, ulong* received, global::System.IntPtr remoteAddress, ushort* remotePort);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Send@UdpSocket@acid@@QEAA?AW4SocketStatus@2@AEAVPacket@2@AEBVIpAddress@2@G@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Send(global::System.IntPtr instance, global::System.IntPtr packet, global::System.IntPtr remoteAddress, ushort remotePort);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Receive@UdpSocket@acid@@QEAA?AW4SocketStatus@2@AEAVPacket@2@AEAVIpAddress@2@AEAG@Z")]
            internal static extern global::Acid.Sharp.SocketStatus Receive(global::System.IntPtr instance, global::System.IntPtr packet, global::System.IntPtr remoteAddress, ushort* remotePort);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalPort@UdpSocket@acid@@QEBAGXZ")]
            internal static extern ushort GetLocalPort(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.UdpSocket __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UdpSocket(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UdpSocket __CreateInstance(global::Acid.Sharp.UdpSocket.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UdpSocket(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UdpSocket.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UdpSocket.__Internal));
            global::Acid.Sharp.UdpSocket.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UdpSocket(global::Acid.Sharp.UdpSocket.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UdpSocket(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>Default constructor.</summary>
        public UdpSocket()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UdpSocket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.UdpSocket");
        }

        public UdpSocket(global::Acid.Sharp.UdpSocket _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UdpSocket.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UdpSocket");
        }

        /// <summary>Bind the socket to a specific port. Binding the socket to a port is necessary for being able to receive data on that port. You can use the special value Socket::AnyPort to tell the system to automatically pick an available port, and then call getLocalPort to retrieve the chosen port. Since the socket can only be bound to a single port at any given moment, if it is already bound when this function is called, it will be unbound from the previous port before being bound to the new one.</summary>
        /// <param name="port">Port to bind the socket to.</param>
        /// <param name="address">Address of the interface to bind to.</param>
        public global::Acid.Sharp.SocketStatus Bind(ushort port, global::Acid.Sharp.IpAddress address)
        {
            if (ReferenceEquals(address, null))
                throw new global::System.ArgumentNullException("address", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = address.__Instance;
            var __ret = __Internal.Bind((__Instance + __PointerAdjustment), port, __arg1);
            return __ret;
        }

        /// <summary>Unbind the socket from the local port to which it is bound. The port that the socket was previously bound to is immediately made available to the operating system after this function is called. This means that a subsequent call to bind() will be able to re-bind the port if no other process has done so in the mean time. If the socket is not bound to a port, this function has no effect.</summary>
        public void Unbind()
        {
            __Internal.Unbind((__Instance + __PointerAdjustment));
        }

        /// <summary>Send raw data to a remote peer. Make sure that \a size is not greater than UdpSocket::MAX_DATAGRAM_SIZE, otherwise this function will fail and no data will be sent.</summary>
        /// <param name="data">Pointer to the sequence of bytes to send.</param>
        /// <param name="size">Number of bytes to send.</param>
        /// <param name="remoteAddress">Address of the receiver.</param>
        /// <param name="remotePort">Port of the receiver to send the data to.</param>
        public global::Acid.Sharp.SocketStatus Send(global::System.IntPtr data, ulong size, global::Acid.Sharp.IpAddress remoteAddress, ushort remotePort)
        {
            if (ReferenceEquals(remoteAddress, null))
                throw new global::System.ArgumentNullException("remoteAddress", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = remoteAddress.__Instance;
            var __ret = __Internal.Send((__Instance + __PointerAdjustment), data, size, __arg2, remotePort);
            return __ret;
        }

        /// <summary>Receive raw data from a remote peer. In blocking mode, this function will wait until some bytes are actually received. Be careful to use a buffer which is large enough for the data that you intend to receive, if it is too small then an error will be returned and *all* the data will be lost.</summary>
        /// <param name="data">Pointer to the array to fill with the received bytes.</param>
        /// <param name="size">Maximum number of bytes that can be received.</param>
        /// <param name="received">This variable is filled with the actual number of bytes received.</param>
        /// <param name="remoteAddress">Address of the peer that sent the data.</param>
        /// <param name="remotePort">Port of the peer that sent the data.</param>
        public global::Acid.Sharp.SocketStatus Receive(global::System.IntPtr data, ulong size, ref ulong received, global::Acid.Sharp.IpAddress remoteAddress, ref ushort remotePort)
        {
            fixed (ulong* __refParamPtr2 = &received)
            {
                var __arg2 = __refParamPtr2;
                if (ReferenceEquals(remoteAddress, null))
                    throw new global::System.ArgumentNullException("remoteAddress", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = remoteAddress.__Instance;
                fixed (ushort* __refParamPtr4 = &remotePort)
                {
                    var __arg4 = __refParamPtr4;
                    var __ret = __Internal.Receive((__Instance + __PointerAdjustment), data, size, __arg2, __arg3, __arg4);
                    return __ret;
                }
            }
        }

        /// <summary>Send a formatted packet of data to a remote peer. Make sure that the packet size is not greater than UdpSocket::MAX_DATAGRAM_SIZE, otherwise this function will fail and no data will be sent.</summary>
        /// <param name="packet">Packet to send.</param>
        /// <param name="remoteAddress">Address of the receiver.</param>
        /// <param name="remotePort">Port of the receiver to send the data to.</param>
        public global::Acid.Sharp.SocketStatus Send(global::Acid.Sharp.Packet packet, global::Acid.Sharp.IpAddress remoteAddress, ushort remotePort)
        {
            if (ReferenceEquals(packet, null))
                throw new global::System.ArgumentNullException("packet", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = packet.__Instance;
            if (ReferenceEquals(remoteAddress, null))
                throw new global::System.ArgumentNullException("remoteAddress", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = remoteAddress.__Instance;
            var __ret = __Internal.Send((__Instance + __PointerAdjustment), __arg0, __arg1, remotePort);
            return __ret;
        }

        /// <summary>Receive a formatted packet of data from a remote peer. In blocking mode, this function will wait until the whole packet has been received.</summary>
        /// <param name="packet">Packet to fill with the received data.</param>
        /// <param name="remoteAddress">Address of the peer that sent the data.</param>
        /// <param name="remotePort">Port of the peer that sent the data.</param>
        public global::Acid.Sharp.SocketStatus Receive(global::Acid.Sharp.Packet packet, global::Acid.Sharp.IpAddress remoteAddress, ref ushort remotePort)
        {
            if (ReferenceEquals(packet, null))
                throw new global::System.ArgumentNullException("packet", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = packet.__Instance;
            if (ReferenceEquals(remoteAddress, null))
                throw new global::System.ArgumentNullException("remoteAddress", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = remoteAddress.__Instance;
            fixed (ushort* __refParamPtr2 = &remotePort)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.Receive((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                return __ret;
            }
        }

        public static uint MaxDatagramSize
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAX_DATAGRAM_SIZE@UdpSocket@acid@@2IB");
                return *__ptr;
            }
        }

        /// <summary>Get the port to which the socket is bound locally. If the socket is not bound to a port, this function returns 0.</summary>
        public ushort LocalPort
        {
            get
            {
                var __ret = __Internal.GetLocalPort((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // UdpSocket
        private static global::Delegates.Action_IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UdpSocket) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public enum NoiseType
    {
        Value = 0,
        Valuefractal = 1,
        Perlin = 2,
        Perlinfractal = 3,
        Simplex = 4,
        Simplexfractal = 5,
        Cellular = 6,
        Whitenoise = 7,
        Cubic = 8,
        Cubicfractal = 9
    }

    public enum NoiseInterp
    {
        Linear = 0,
        Hermite = 1,
        Quintic = 2
    }

    public enum NoiseFractal
    {
        Fbm = 0,
        Billow = 1,
        Rigidmulti = 2
    }

    public enum NoiseCellularFunc
    {
        NoiseCellularEuclidean = 0,
        NoiseCellularManhattan = 1,
        NoiseCellularNatural = 2
    }

    public enum NoiseCellularReturn
    {
        NoiseCellularCellvalue = 0,
        NoiseCellularNoiselookup = 1,
        NoiseCellularDistance = 2,
        NoiseCellularDistance2 = 3,
        NoiseCellularDistance2add = 4,
        NoiseCellularDistance2sub = 5,
        NoiseCellularDistance2mul = 6,
        NoiseCellularDistance2div = 7
    }

    public unsafe partial class Noise : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int m_seed;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr___nc___N_std_S_default_delete__S0_ m_perm;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr___nc___N_std_S_default_delete__S0_ m_perm12;

            [FieldOffset(24)]
            internal float m_frequency;

            [FieldOffset(28)]
            internal global::Acid.Sharp.NoiseInterp m_interp;

            [FieldOffset(32)]
            internal global::Acid.Sharp.NoiseType m_noiseType;

            [FieldOffset(36)]
            internal int m_octaves;

            [FieldOffset(40)]
            internal float m_lacunarity;

            [FieldOffset(44)]
            internal float m_gain;

            [FieldOffset(48)]
            internal global::Acid.Sharp.NoiseFractal m_fractalType;

            [FieldOffset(52)]
            internal float m_fractalBounding;

            [FieldOffset(56)]
            internal global::Acid.Sharp.NoiseCellularFunc m_cellularDistanceFunction;

            [FieldOffset(60)]
            internal global::Acid.Sharp.NoiseCellularReturn m_cellularReturnType;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Noise___N_std_S_default_delete__S0_ m_cellularNoiseLookup;

            [FieldOffset(72)]
            internal int m_cellularDistanceIndex0;

            [FieldOffset(76)]
            internal int m_cellularDistanceIndex1;

            [FieldOffset(80)]
            internal float m_cellularJitter;

            [FieldOffset(84)]
            internal float m_gradientPerturbAmp;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Noise@acid@@QEAA@AEBHAEBMAEBW4NoiseInterp@1@AEBW4NoiseType@1@011AEBW4NoiseFractal@1@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int* seed, float* frequency, global::Acid.Sharp.NoiseInterp* interp, global::Acid.Sharp.NoiseType* noiseType, int* octaves, float* lacunarity, float* gain, global::Acid.Sharp.NoiseFractal* fractalType, float* fractalBounding);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Noise@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Noise@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularDistance2Indices@Noise@acid@@QEBAXAEAH0@Z")]
            internal static extern void GetCellularDistance2Indices(global::System.IntPtr instance, int* cellularDistanceIndex0, int* cellularDistanceIndex1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularDistance2Indices@Noise@acid@@QEAAXAEBH0@Z")]
            internal static extern void SetCellularDistance2Indices(global::System.IntPtr instance, int* cellularDistanceIndex0, int* cellularDistanceIndex1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetValue(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValueFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetValueFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlin@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetPerlin(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlinFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetPerlinFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplexFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetSimplexFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellular@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetCellular(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@acid@@QEBAMHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubic@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetCubic(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubicFractal@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetCubicFractal(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoise@Noise@acid@@QEBAMMM@Z")]
            internal static extern float GetNoise(global::System.IntPtr instance, float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturb@Noise@acid@@QEBAXAEAM0@Z")]
            internal static extern void GradientPerturb(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturbFractal@Noise@acid@@QEBAXAEAM0@Z")]
            internal static extern void GradientPerturbFractal(global::System.IntPtr instance, float* x, float* y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetValue(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValueFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetValueFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlin@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetPerlin(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPerlinFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetPerlinFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplexFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetSimplexFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellular@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetCellular(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@acid@@QEBAMHHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y, int z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubic@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetCubic(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCubicFractal@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetCubicFractal(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoise@Noise@acid@@QEBAMMMM@Z")]
            internal static extern float GetNoise(global::System.IntPtr instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturb@Noise@acid@@QEBAXAEAM00@Z")]
            internal static extern void GradientPerturb(global::System.IntPtr instance, float* x, float* y, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GradientPerturbFractal@Noise@acid@@QEBAXAEAM00@Z")]
            internal static extern void GradientPerturbFractal(global::System.IntPtr instance, float* x, float* y, float* z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSimplex@Noise@acid@@QEBAMMMMM@Z")]
            internal static extern float GetSimplex(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoise@Noise@acid@@QEBAMMMMM@Z")]
            internal static extern float GetWhiteNoise(global::System.IntPtr instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWhiteNoiseInt@Noise@acid@@QEBAMHHHH@Z")]
            internal static extern float GetWhiteNoiseInt(global::System.IntPtr instance, int x, int y, int z, int w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSeed@Noise@acid@@QEBAHXZ")]
            internal static extern int GetSeed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSeed@Noise@acid@@QEAAXAEBH@Z")]
            internal static extern void SetSeed(global::System.IntPtr instance, int* seed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFrequency@Noise@acid@@QEBAMXZ")]
            internal static extern float GetFrequency(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFrequency@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFrequency(global::System.IntPtr instance, float* frequency);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInterp@Noise@acid@@QEBA?AW4NoiseInterp@2@XZ")]
            internal static extern global::Acid.Sharp.NoiseInterp GetInterp(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInterp@Noise@acid@@QEAAXAEBW4NoiseInterp@2@@Z")]
            internal static extern void SetInterp(global::System.IntPtr instance, global::Acid.Sharp.NoiseInterp* interp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNoiseType@Noise@acid@@QEBA?AW4NoiseType@2@XZ")]
            internal static extern global::Acid.Sharp.NoiseType GetNoiseType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNoiseType@Noise@acid@@QEAAXAEBW4NoiseType@2@@Z")]
            internal static extern void SetNoiseType(global::System.IntPtr instance, global::Acid.Sharp.NoiseType* noiseType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalOctaves@Noise@acid@@QEBAHXZ")]
            internal static extern int GetFractalOctaves(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalOctaves@Noise@acid@@QEAAXAEBH@Z")]
            internal static extern void SetFractalOctaves(global::System.IntPtr instance, int* octaves);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalLacunarity@Noise@acid@@QEBAMXZ")]
            internal static extern float GetFractalLacunarity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalLacunarity@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFractalLacunarity(global::System.IntPtr instance, float* lacunarity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalGain@Noise@acid@@QEBAMXZ")]
            internal static extern float GetFractalGain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalGain@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFractalGain(global::System.IntPtr instance, float* gain);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFractalType@Noise@acid@@QEBA?AW4NoiseFractal@2@XZ")]
            internal static extern global::Acid.Sharp.NoiseFractal GetFractalType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFractalType@Noise@acid@@QEAAXAEBW4NoiseFractal@2@@Z")]
            internal static extern void SetFractalType(global::System.IntPtr instance, global::Acid.Sharp.NoiseFractal* fractalType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularDistanceFunction@Noise@acid@@QEBA?AW4NoiseCellularFunc@2@XZ")]
            internal static extern global::Acid.Sharp.NoiseCellularFunc GetCellularDistanceFunction(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularDistanceFunction@Noise@acid@@QEAAXAEBW4NoiseCellularFunc@2@@Z")]
            internal static extern void SetCellularDistanceFunction(global::System.IntPtr instance, global::Acid.Sharp.NoiseCellularFunc* cellularDistanceFunction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularReturnType@Noise@acid@@QEBA?AW4NoiseCellularReturn@2@XZ")]
            internal static extern global::Acid.Sharp.NoiseCellularReturn GetCellularReturnType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularReturnType@Noise@acid@@QEAAXAEBW4NoiseCellularReturn@2@@Z")]
            internal static extern void SetCellularReturnType(global::System.IntPtr instance, global::Acid.Sharp.NoiseCellularReturn* cellularReturnType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularNoiseLookup@Noise@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetCellularNoiseLookup(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularNoiseLookup@Noise@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetCellularNoiseLookup(global::System.IntPtr instance, global::System.IntPtr noise);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCellularJitter@Noise@acid@@QEBAMXZ")]
            internal static extern float GetCellularJitter(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCellularJitter@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetCellularJitter(global::System.IntPtr instance, float* cellularJitter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGradientPerturbAmp@Noise@acid@@QEBAMXZ")]
            internal static extern float GetGradientPerturbAmp(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGradientPerturbAmp@Noise@acid@@QEAAXAEBM@Z")]
            internal static extern void SetGradientPerturbAmp(global::System.IntPtr instance, float* gradientPerturbAmp);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Noise> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Noise>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Noise __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Noise(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Noise __CreateInstance(global::Acid.Sharp.Noise.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Noise(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Noise.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Noise.__Internal));
            *(global::Acid.Sharp.Noise.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Noise(global::Acid.Sharp.Noise.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Noise(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new multi-type noise object.</summary>
        /// <param name="fractalType">The fractal noise type.</param>
        /// <param name="lacunarity">The lacunarity between octaves.</param>
        /// <param name="octaves">The amount of octaves to use.</param>
        /// <param name="fractalBounding">The fractal bounding.</param>
        /// <param name="interp">The interp type.</param>
        /// <param name="noiseType">The noise type.</param>
        /// <param name="frequency">The noise frequency.</param>
        /// <param name="seed">The seed.</param>
        public Noise(int seed, float frequency, global::Acid.Sharp.NoiseInterp* interp, global::Acid.Sharp.NoiseType* noiseType, int octaves, float lacunarity, float gain, global::Acid.Sharp.NoiseFractal* fractalType, float fractalBounding)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Noise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &seed;
            var __arg1 = &frequency;
            var __arg4 = &octaves;
            var __arg5 = &lacunarity;
            var __arg6 = &gain;
            var __arg8 = &fractalBounding;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, interp, noiseType, __arg4, __arg5, __arg6, fractalType, __arg8);
        }

        public Noise(global::Acid.Sharp.Noise _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Noise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Noise.__Internal*) __Instance) = *((global::Acid.Sharp.Noise.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Noise __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets the 2 distance indices used for distance2 return types.</summary>
        /// <param name="cellularDistanceIndex0">The cellular distance at index 0.</param>
        /// <param name="cellularDistanceIndex1">The cellular distance at index 1.</param>
        public void GetCellularDistance2Indices(ref int cellularDistanceIndex0, ref int cellularDistanceIndex1)
        {
            fixed (int* __refParamPtr0 = &cellularDistanceIndex0)
            {
                var __arg0 = __refParamPtr0;
                fixed (int* __refParamPtr1 = &cellularDistanceIndex1)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GetCellularDistance2Indices((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        /// <summary>
        /// <para>Sets the 2 distance indices used for distance2 return types.</para>
        /// <para>Both indices must be &gt;= 0, index1 must be&lt;&gt;4.</para>
        /// <para></para>
        /// <para>name=&quot;cellularDistanceIndex0&quot;&gt; The new cellular distance at index 0 (Default: 0).</para>
        /// <para>name=&quot;cellularDistanceIndex1&quot;&gt; The new cellular distance at index 1 (Default: 1).</para>
        /// </summary>
        public void SetCellularDistance2Indices(int cellularDistanceIndex0, int cellularDistanceIndex1)
        {
            var __arg0 = &cellularDistanceIndex0;
            var __arg1 = &cellularDistanceIndex1;
            __Internal.SetCellularDistance2Indices((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public float GetValue(float x, float y)
        {
            var __ret = __Internal.GetValue((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetValueFractal(float x, float y)
        {
            var __ret = __Internal.GetValueFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetPerlin(float x, float y)
        {
            var __ret = __Internal.GetPerlin((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetPerlinFractal(float x, float y)
        {
            var __ret = __Internal.GetPerlinFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetSimplex(float x, float y)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetSimplexFractal(float x, float y)
        {
            var __ret = __Internal.GetSimplexFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCellular(float x, float y)
        {
            var __ret = __Internal.GetCellular((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCubic(float x, float y)
        {
            var __ret = __Internal.GetCubic((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetCubicFractal(float x, float y)
        {
            var __ret = __Internal.GetCubicFractal((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public float GetNoise(float x, float y)
        {
            var __ret = __Internal.GetNoise((__Instance + __PointerAdjustment), x, y);
            return __ret;
        }

        public void GradientPerturb(ref float x, ref float y)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GradientPerturb((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public void GradientPerturbFractal(ref float x, ref float y)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    __Internal.GradientPerturbFractal((__Instance + __PointerAdjustment), __arg0, __arg1);
                }
            }
        }

        public float GetValue(float x, float y, float z)
        {
            var __ret = __Internal.GetValue((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetValueFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetValueFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetPerlin(float x, float y, float z)
        {
            var __ret = __Internal.GetPerlin((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetPerlinFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetPerlinFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetSimplex(float x, float y, float z)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetSimplexFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetSimplexFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCellular(float x, float y, float z)
        {
            var __ret = __Internal.GetCellular((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y, float z)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y, int z)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCubic(float x, float y, float z)
        {
            var __ret = __Internal.GetCubic((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetCubicFractal(float x, float y, float z)
        {
            var __ret = __Internal.GetCubicFractal((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public float GetNoise(float x, float y, float z)
        {
            var __ret = __Internal.GetNoise((__Instance + __PointerAdjustment), x, y, z);
            return __ret;
        }

        public void GradientPerturb(ref float x, ref float y, ref float z)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (float* __refParamPtr2 = &z)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GradientPerturb((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                    }
                }
            }
        }

        public void GradientPerturbFractal(ref float x, ref float y, ref float z)
        {
            fixed (float* __refParamPtr0 = &x)
            {
                var __arg0 = __refParamPtr0;
                fixed (float* __refParamPtr1 = &y)
                {
                    var __arg1 = __refParamPtr1;
                    fixed (float* __refParamPtr2 = &z)
                    {
                        var __arg2 = __refParamPtr2;
                        __Internal.GradientPerturbFractal((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
                    }
                }
            }
        }

        public float GetSimplex(float x, float y, float z, float w)
        {
            var __ret = __Internal.GetSimplex((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public float GetWhiteNoise(float x, float y, float z, float w)
        {
            var __ret = __Internal.GetWhiteNoise((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        public float GetWhiteNoiseInt(int x, int y, int z, int w)
        {
            var __ret = __Internal.GetWhiteNoiseInt((__Instance + __PointerAdjustment), x, y, z, w);
            return __ret;
        }

        /// <summary>Gets the seed used for all noise types.</summary>
        /// <param name="seed">The new seed (Default: 1337).</param>
        /// <remarks>Sets seed used for all noise types.</remarks>
        public int Seed
        {
            get
            {
                var __ret = __Internal.GetSeed((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetSeed((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the frequency used for all noise types.</summary>
        /// <param name="frequency">The new frequency (Default: 0.01).</param>
        /// <remarks>Sets the frequency used for all noise types.</remarks>
        public float Frequency
        {
            get
            {
                var __ret = __Internal.GetFrequency((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFrequency((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the interpolation method used for supported noise types.</summary>
        /// <param name="interp">The new interpolation method (Default: Quintic).</param>
        /// <remarks>Sets the interpolation method used to smooth between noise values.</remarks>
        public global::Acid.Sharp.NoiseInterp Interp
        {
            get
            {
                var __ret = __Internal.GetInterp((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetInterp((__Instance + __PointerAdjustment), &value);
            }
        }

        /// <summary>Gets the type of noise.</summary>
        /// <param name="noiseType">The new noise type.</param>
        /// <remarks>Sets the type of noise.</remarks>
        public global::Acid.Sharp.NoiseType NoiseType
        {
            get
            {
                var __ret = __Internal.GetNoiseType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetNoiseType((__Instance + __PointerAdjustment), &value);
            }
        }

        /// <summary>Gets the octave count for all fractal noise types.</summary>
        /// <param name="octaves">The new octaves count (Default: 2.0).</param>
        /// <remarks>Sets the octave count for all fractal noise types.</remarks>
        public int FractalOctaves
        {
            get
            {
                var __ret = __Internal.GetFractalOctaves((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFractalOctaves((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the octave lacunarity for all fractal noise types.</summary>
        /// <param name="lacunarity">The new octave lacunarity (Default: 0.5).</param>
        /// <remarks>Sets the octave octave lacunarity for all fractal noise types.</remarks>
        public float FractalLacunarity
        {
            get
            {
                var __ret = __Internal.GetFractalLacunarity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFractalLacunarity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the octave gain for all fractal noise types.</summary>
        /// <param name="gain">The new octave gain.</param>
        /// <remarks>Sets the octave gain for all fractal noise types.</remarks>
        public float FractalGain
        {
            get
            {
                var __ret = __Internal.GetFractalGain((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFractalGain((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the method for combining octaves in all fractal noise types.</summary>
        /// <param name="fractalType">The new method for combining octaves (Default: FBM).</param>
        /// <remarks>Sets the method for combining octaves in all fractal noise types.</remarks>
        public global::Acid.Sharp.NoiseFractal FractalType
        {
            get
            {
                var __ret = __Internal.GetFractalType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFractalType((__Instance + __PointerAdjustment), &value);
            }
        }

        /// <summary>Gets the distance function used in cellular noise calculations.</summary>
        /// <param name="cellularDistanceFunction">The new cellular distance function (Default: Euclidean).</param>
        /// <remarks>Sets the distance function used in cellular noise calculations.</remarks>
        public global::Acid.Sharp.NoiseCellularFunc CellularDistanceFunction
        {
            get
            {
                var __ret = __Internal.GetCellularDistanceFunction((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularDistanceFunction((__Instance + __PointerAdjustment), &value);
            }
        }

        /// <summary>Gets the return type from cellular noise calculations.</summary>
        /// <param name="cellularReturnType">The new cellular return type (Default: CellValue).</param>
        /// <remarks>Sets the return type from cellular noise calculations. Note: NoiseLookup requires another FastNoise object be set with SetCellularNoiseLookup() to function.</remarks>
        public global::Acid.Sharp.NoiseCellularReturn CellularReturnType
        {
            get
            {
                var __ret = __Internal.GetCellularReturnType((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetCellularReturnType((__Instance + __PointerAdjustment), &value);
            }
        }

        /// <summary>Gets the noise used to calculate a cell value if the cellular return type is NoiseLookup.</summary>
        /// <param name="noise">The new cellular noise lookup.</param>
        /// <remarks>Sets the noise used to calculate a cell value if cellular return type is NoiseLookup. The lookup value is acquired through GetNoise() so ensure you SetNoiseType() on the noise lookup, value, Perlin or simplex is recommended.</remarks>
        public global::Acid.Sharp.Noise CellularNoiseLookup
        {
            get
            {
                var __ret = __Internal.GetCellularNoiseLookup((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Noise __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Noise.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Noise) global::Acid.Sharp.Noise.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Noise.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetCellularNoiseLookup((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the maximum distance a cellular point can move from its grid position.</summary>
        /// <param name="cellularJitter">The new cellular maximum distance (Default: 0.45).</param>
        /// <remarks>Sets the maximum distance a cellular point can move from its grid position. Setting this high will make artifacts more common.</remarks>
        public float CellularJitter
        {
            get
            {
                var __ret = __Internal.GetCellularJitter((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetCellularJitter((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the maximum warp distance from original location when using GradientPerturb{Fractal}(...).</summary>
        /// <param name="gradientPerturbAmp">The new cellular maximum warp distance (Default: 1.0).</param>
        /// <remarks>Sets the maximum warp distance from original location when using GradientPerturb{Fractal}(...).</remarks>
        public float GradientPerturbAmp
        {
            get
            {
                var __ret = __Internal.GetGradientPerturbAmp((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetGradientPerturbAmp((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ComponentCreate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Function.__Internal m_create;

            [FieldOffset(64)]
            internal global::Std.Function.__Internal m_isSame;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentCreate@acid@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentCreate@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ComponentCreate@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ComponentCreate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ComponentCreate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ComponentCreate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ComponentCreate(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ComponentCreate __CreateInstance(global::Acid.Sharp.ComponentCreate.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ComponentCreate(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ComponentCreate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComponentCreate.__Internal));
            global::Acid.Sharp.ComponentCreate.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ComponentCreate(global::Acid.Sharp.ComponentCreate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComponentCreate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ComponentCreate(global::Acid.Sharp.ComponentCreate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComponentCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public ComponentCreate()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComponentCreate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ComponentCreate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    /// <summary>A class that holds registerd components.</summary>
    public unsafe partial class ComponentRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_ComponentCreate___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_components;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentRegister@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ComponentRegister@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ComponentRegister@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterComponent@ComponentRegister@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateComponent@ComponentRegister@acid@@QEAAPEAVIComponent@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr CreateComponent(global::System.IntPtr instance, global::System.IntPtr name);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ComponentRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ComponentRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ComponentRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ComponentRegister(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ComponentRegister __CreateInstance(global::Acid.Sharp.ComponentRegister.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ComponentRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ComponentRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComponentRegister.__Internal));
            global::Acid.Sharp.ComponentRegister.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ComponentRegister(global::Acid.Sharp.ComponentRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComponentRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new component register.</summary>
        public ComponentRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComponentRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ComponentRegister(global::Acid.Sharp.ComponentRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ComponentRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ComponentRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Deregisters a component.</summary>
        /// <param name="name">The components name.</param>
        public bool DeregisterComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.DeregisterComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates a new component from the register.</summary>
        /// <param name="name">The component name to create.</param>
        public global::Acid.Sharp.IComponent CreateComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.IComponent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IComponent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IComponent) global::Acid.Sharp.IComponent.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IComponent.__CreateInstance(__ret);
            return __result0;
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A data structure that stores objects with a notion of space.</summary>
    public unsafe abstract partial class ISpatialStructure : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpatialStructure;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpatialStructure@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpatialStructure@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ISpatialStructure> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ISpatialStructure>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ISpatialStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ISpatialStructureInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ISpatialStructure __CreateInstance(global::Acid.Sharp.ISpatialStructure.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ISpatialStructureInternal(native, skipVTables);
        }

        protected ISpatialStructure(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected ISpatialStructure()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ISpatialStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.ISpatialStructure");
        }

        protected ISpatialStructure(global::Acid.Sharp.ISpatialStructure _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ISpatialStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ISpatialStructure");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ISpatialStructure __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ISpatialStructure.__Internal*) __Instance)->vfptr_ISpatialStructure = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Adds a new object to the spatial structure.</summary>
        /// <param name="object">The object to add.</param>
        public abstract void Add(global::Acid.Sharp.GameObject @object);

        /// <summary>Removes an object from the spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        public abstract bool Remove(global::Acid.Sharp.GameObject @object);

        /// <summary>Moves an object to another spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        /// <param name="structure">The structure to move to.</param>
        public abstract bool Move(global::Acid.Sharp.GameObject @object, global::Acid.Sharp.ISpatialStructure structure);

        /// <summary>Removes all objects from the spatial structure..</summary>
        public abstract void Clear();

        /// <summary>Updates all of the game object.</summary>
        public abstract void Update();

        /// <summary>If the structure contains the object.</summary>
        /// <param name="object">The object to check for.</param>
        public abstract bool Contains(global::Acid.Sharp.GameObject @object);

        /// <summary>Gets the size of this structure.</summary>
        public abstract uint Size
        {
            get;
        }

        #region Virtual table interop

        // void Add(GameObject *object) = 0
        private static global::Delegates.Action_IntPtr_IntPtr _AddDelegateInstance;

        private static void _AddDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            __target.Add(__result0);
        }

        // bool Remove(GameObject *object) = 0
        private static global::Delegates.Func_bool_IntPtr_IntPtr _RemoveDelegateInstance;

        private static bool _RemoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            var __ret = __target.Remove(__result0);
            return __ret;
        }

        // bool Move(GameObject *object, ISpatialStructure *structure) = 0
        private static global::Delegates.Func_bool_IntPtr_IntPtr_IntPtr _MoveDelegateInstance;

        private static bool _MoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object, global::System.IntPtr structure)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            global::Acid.Sharp.ISpatialStructure __result1;
            if (structure == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.ISpatialStructure.NativeToManagedMap.ContainsKey(structure))
                __result1 = (global::Acid.Sharp.ISpatialStructure) global::Acid.Sharp.ISpatialStructure.NativeToManagedMap[structure];
            else __result1 = global::Acid.Sharp.ISpatialStructure.__CreateInstance(structure);
            var __ret = __target.Move(__result0, __result1);
            return __ret;
        }

        // void Clear() = 0
        private static global::Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // void Update() = 0
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // uint32_t GetSize() = 0
        private static global::Delegates.Func_uint_IntPtr _GetSizeDelegateInstance;

        private static uint _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        // bool Contains(GameObject *object) = 0
        private static global::Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpatialStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[7];
                _AddDelegateInstance += _AddDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                _RemoveDelegateInstance += _RemoveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RemoveDelegateInstance).ToPointer();
                _MoveDelegateInstance += _MoveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_MoveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                *(void**) (vfptr0 + 16) = _Thunks[0];
                *(void**) (vfptr0 + 24) = _Thunks[1];
                *(void**) (vfptr0 + 32) = _Thunks[2];
                *(void**) (vfptr0 + 40) = _Thunks[3];
                *(void**) (vfptr0 + 48) = _Thunks[4];
                *(void**) (vfptr0 + 56) = _Thunks[5];
                *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                *(void**) (vfptr0 + 80) = _Thunks[6];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ISpatialStructureInternal : global::Acid.Sharp.ISpatialStructure, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.ISpatialStructure.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ISpatialStructure.__Internal));
            *(global::Acid.Sharp.ISpatialStructure.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ISpatialStructureInternal(global::Acid.Sharp.ISpatialStructure.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ISpatialStructureInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Adds a new object to the spatial structure.</summary>
        /// <param name="object">The object to add.</param>
        public override void Add(global::Acid.Sharp.GameObject @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___AddDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            ___AddDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Removes an object from the spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        public override bool Remove(global::Acid.Sharp.GameObject @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___RemoveDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___RemoveDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Moves an object to another spatial structure.</summary>
        /// <param name="object">The object to remove.</param>
        /// <param name="structure">The structure to move to.</param>
        public override bool Move(global::Acid.Sharp.GameObject @object, global::Acid.Sharp.ISpatialStructure structure)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___MoveDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __arg1 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            var __ret = ___MoveDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Removes all objects from the spatial structure..</summary>
        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___ClearDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Updates all of the game object.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>If the structure contains the object.</summary>
        /// <param name="object">The object to check for.</param>
        public override bool Contains(global::Acid.Sharp.GameObject @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
            var ___ContainsDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the size of this structure.</summary>
        public override uint Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___GetSizeDelegate = (global::Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_uint_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that represents a objects that acts as a component container.</summary>
    public unsafe partial class GameObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_name;

            [FieldOffset(32)]
            internal global::Acid.Sharp.Transform.__Internal m_transform;

            [FieldOffset(72)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IComponent___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_components;

            [FieldOffset(96)]
            internal global::System.IntPtr m_structure;

            [FieldOffset(104)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(112)]
            internal byte m_removed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@acid@@QEAA@AEBVTransform@1@PEAVISpatialStructure@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr transform, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVTransform@1@PEAVISpatialStructure@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename, global::System.IntPtr transform, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0GameObject@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1GameObject@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@GameObject@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddComponent@GameObject@acid@@QEAAPEAVIComponent@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddComponent(global::System.IntPtr instance, global::System.IntPtr component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveComponent@GameObject@acid@@QEAA_NPEAVIComponent@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveComponent(global::System.IntPtr instance, global::System.IntPtr component);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveComponent@GameObject@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveComponent_1(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetName@GameObject@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetName(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetName@GameObject@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetName(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransform@GameObject@acid@@QEAAAEAVTransform@2@XZ")]
            internal static extern global::System.IntPtr GetTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTransform@GameObject@acid@@QEAAXAEBVTransform@2@@Z")]
            internal static extern void SetTransform(global::System.IntPtr instance, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@GameObject@acid@@QEBAPEAVISpatialStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStructure@GameObject@acid@@QEAAXPEAVISpatialStructure@2@@Z")]
            internal static extern void SetStructure(global::System.IntPtr instance, global::System.IntPtr structure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRemoved@GameObject@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRemoved(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRemoved@GameObject@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetRemoved(global::System.IntPtr instance, bool* removed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@GameObject@acid@@QEBAPEAV12@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetParent@GameObject@acid@@QEAAXPEAV12@@Z")]
            internal static extern void SetParent(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComponentCount@GameObject@acid@@QEBAIXZ")]
            internal static extern uint GetComponentCount(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.GameObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.GameObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.GameObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.GameObject(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.GameObject __CreateInstance(global::Acid.Sharp.GameObject.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.GameObject(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.GameObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GameObject.__Internal));
            global::Acid.Sharp.GameObject.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private GameObject(global::Acid.Sharp.GameObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GameObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new Game Object and stores it into a structure.</summary>
        /// <param name="transform">The objects initial world position, rotation, and scale.</param>
        /// <param name="structure">The structure to store the object into, if null it will be stored in the scenes structure.</param>
        public GameObject(global::Acid.Sharp.Transform transform, global::Acid.Sharp.ISpatialStructure structure)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            var __arg1 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Creates a new Game Object and stores it into a structure.</summary>
        /// <param name="filename">The file to load the component data from.</param>
        /// <param name="transform">The objects initial world position, rotation, and scale.</param>
        /// <param name="structure">The structure to store the object into, if null it will be stored in the scenes structure.</param>
        public GameObject(string filename, global::Acid.Sharp.Transform transform, global::Acid.Sharp.ISpatialStructure structure)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = transform.__Instance;
            var __arg2 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public GameObject(global::Acid.Sharp.GameObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.GameObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        /// <summary>Adds a component to this game object.</summary>
        /// <param name="component">The component to add.</param>
        public global::Acid.Sharp.IComponent AddComponent(global::Acid.Sharp.IComponent component)
        {
            var __arg0 = ReferenceEquals(component, null) ? global::System.IntPtr.Zero : component.__Instance;
            var __ret = __Internal.AddComponent((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.IComponent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IComponent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IComponent) global::Acid.Sharp.IComponent.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IComponent.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Removes a component from this game object.</summary>
        /// <param name="component">The component to remove.</param>
        public bool RemoveComponent(global::Acid.Sharp.IComponent component)
        {
            var __arg0 = ReferenceEquals(component, null) ? global::System.IntPtr.Zero : component.__Instance;
            var __ret = __Internal.RemoveComponent((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Removes a component from this game object.</summary>
        /// <param name="name">The name of the component to remove.</param>
        public bool RemoveComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.RemoveComponent_1((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        public string Name
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetName((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public global::Acid.Sharp.Transform Transform
        {
            get
            {
                var __ret = __Internal.GetTransform((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Transform __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Transform.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Transform) global::Acid.Sharp.Transform.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Transform.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.ISpatialStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ISpatialStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ISpatialStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ISpatialStructure) global::Acid.Sharp.ISpatialStructure.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ISpatialStructure.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetStructure((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Removed
        {
            get
            {
                var __ret = __Internal.GetRemoved((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRemoved((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.GameObject Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::Acid.Sharp.GameObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetParent((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the count of components attached to this Game Object.</summary>
        public uint ComponentCount
        {
            get
            {
                var __ret = __Internal.GetComponentCount((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a entity prefab.</summary>
    public unsafe partial class PrefabObject : global::Acid.Sharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IFile___N_std_S_default_delete__S0_ m_file;

            [FieldOffset(48)]
            internal global::System.IntPtr m_parent;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PrefabObject@acid@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PrefabObject@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PrefabObject@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Write@PrefabObject@acid@@QEAAXAEBVGameObject@2@@Z")]
            internal static extern void Write(global::System.IntPtr instance, global::System.IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Save@PrefabObject@acid@@QEAAXXZ")]
            internal static extern void Save(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetParent@PrefabObject@acid@@QEBAPEAVMetadata@2@XZ")]
            internal static extern global::System.IntPtr GetParent(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.PrefabObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PrefabObject(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.PrefabObject __CreateInstance(global::Acid.Sharp.PrefabObject.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PrefabObject(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.PrefabObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PrefabObject.__Internal));
            global::Acid.Sharp.PrefabObject.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PrefabObject(global::Acid.Sharp.PrefabObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PrefabObject(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new entity prefab.</summary>
        /// <param name="filename">The file name.</param>
        public PrefabObject(string filename)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PrefabObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.PrefabObject");
        }

        public PrefabObject(global::Acid.Sharp.PrefabObject _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PrefabObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.PrefabObject");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.PrefabObject.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Write(global::Acid.Sharp.GameObject gameObject)
        {
            if (ReferenceEquals(gameObject, null))
                throw new global::System.ArgumentNullException("gameObject", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = gameObject.__Instance;
            __Internal.Write((__Instance + __PointerAdjustment), __arg0);
        }

        public void Save()
        {
            __Internal.Save((__Instance + __PointerAdjustment));
        }

        public static explicit operator global::Acid.Sharp.PrefabObject(string filename)
        {
            return new global::Acid.Sharp.PrefabObject(filename);
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public global::Acid.Sharp.Metadata Parent
        {
            get
            {
                var __ret = __Internal.GetParent((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Metadata __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.PrefabObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ParticleData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Matrix4.__Internal modelMatrix;

            [FieldOffset(64)]
            internal global::Acid.Sharp.Colour.__Internal colourOffset;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Vector4.__Internal offsets;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector3.__Internal blend;

            [FieldOffset(108)]
            internal float _padding;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ParticleData@acid@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ParticleData@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ParticleData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ParticleData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ParticleData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ParticleData(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ParticleData __CreateInstance(global::Acid.Sharp.ParticleData.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ParticleData(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ParticleData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ParticleData.__Internal));
            global::Acid.Sharp.ParticleData.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ParticleData(global::Acid.Sharp.ParticleData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ParticleData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ParticleData(global::Acid.Sharp.ParticleData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ParticleData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public ParticleData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ParticleData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ParticleData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.Matrix4 ModelMatrix
        {
            get
            {
                return global::Acid.Sharp.Matrix4.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.ParticleData.__Internal*) __Instance)->modelMatrix));
            }

            set
            {
                ((global::Acid.Sharp.ParticleData.__Internal*)__Instance)->modelMatrix = ReferenceEquals(value, null) ? new global::Acid.Sharp.Matrix4.__Internal() : *(global::Acid.Sharp.Matrix4.__Internal*) value.__Instance;
            }
        }

        public global::Acid.Sharp.Colour ColourOffset
        {
            get
            {
                return global::Acid.Sharp.Colour.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.ParticleData.__Internal*) __Instance)->colourOffset));
            }

            set
            {
                ((global::Acid.Sharp.ParticleData.__Internal*)__Instance)->colourOffset = ReferenceEquals(value, null) ? new global::Acid.Sharp.Colour.__Internal() : *(global::Acid.Sharp.Colour.__Internal*) value.__Instance;
            }
        }

        public global::Acid.Sharp.Vector4 Offsets
        {
            get
            {
                return global::Acid.Sharp.Vector4.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.ParticleData.__Internal*) __Instance)->offsets));
            }

            set
            {
                ((global::Acid.Sharp.ParticleData.__Internal*)__Instance)->offsets = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector4.__Internal() : *(global::Acid.Sharp.Vector4.__Internal*) value.__Instance;
            }
        }

        public global::Acid.Sharp.Vector3 Blend
        {
            get
            {
                return global::Acid.Sharp.Vector3.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.ParticleData.__Internal*) __Instance)->blend));
            }

            set
            {
                ((global::Acid.Sharp.ParticleData.__Internal*)__Instance)->blend = ReferenceEquals(value, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) value.__Instance;
            }
        }

        public float Padding
        {
            get
            {
                return ((global::Acid.Sharp.ParticleData.__Internal*) __Instance)->_padding;
            }

            set
            {
                ((global::Acid.Sharp.ParticleData.__Internal*)__Instance)->_padding = value;
            }
        }
    }

    /// <summary>A definition for what a particle should act and look like.</summary>
    public unsafe partial class ParticleType : global::Acid.Sharp.IResource, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 200)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(40)]
            internal global::Std.SharedPtr.__Internal m_texture;

            [FieldOffset(56)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(72)]
            internal uint m_numberOfRows;

            [FieldOffset(76)]
            internal global::Acid.Sharp.Colour.__Internal m_colourOffset;

            [FieldOffset(92)]
            internal float m_lifeLength;

            [FieldOffset(96)]
            internal float m_stageCycles;

            [FieldOffset(100)]
            internal float m_scale;

            [FieldOffset(104)]
            internal uint m_instances;

            [FieldOffset(112)]
            internal global::Acid.Sharp.StorageHandler.__Internal m_storageBuffer;

            [FieldOffset(152)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ParticleType@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ParticleType@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@ParticleType@acid@@QEAA_NAEBVCommandBuffer@2@AEBVPipeline@2@AEAVUniformHandler@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline, global::System.IntPtr uniformScene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@ParticleType@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void Decode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@ParticleType@acid@@QEBAXAEAVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr instance, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNumberOfRows@ParticleType@acid@@QEBAIXZ")]
            internal static extern uint GetNumberOfRows(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNumberOfRows@ParticleType@acid@@QEAAXAEBI@Z")]
            internal static extern void SetNumberOfRows(global::System.IntPtr instance, uint* numberOfRows);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetColourOffset@ParticleType@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetColourOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetColourOffset@ParticleType@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetColourOffset(global::System.IntPtr instance, global::System.IntPtr colourOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLifeLength@ParticleType@acid@@QEBAMXZ")]
            internal static extern float GetLifeLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLifeLength@ParticleType@acid@@QEAAXAEBM@Z")]
            internal static extern void SetLifeLength(global::System.IntPtr instance, float* lifeLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStageCycles@ParticleType@acid@@QEBAMXZ")]
            internal static extern float GetStageCycles(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStageCycles@ParticleType@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStageCycles(global::System.IntPtr instance, float* stageCycles);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@ParticleType@acid@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScale@ParticleType@acid@@QEAAXAEBM@Z")]
            internal static extern void SetScale(global::System.IntPtr instance, float* scale);
        }

        internal static new global::Acid.Sharp.ParticleType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ParticleType(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ParticleType __CreateInstance(global::Acid.Sharp.ParticleType.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ParticleType(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ParticleType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ParticleType.__Internal));
            global::Acid.Sharp.ParticleType.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ParticleType(global::Acid.Sharp.ParticleType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ParticleType(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ParticleType(global::Acid.Sharp.ParticleType _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ParticleType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ParticleType");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ParticleType.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool CmdRender(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Pipeline pipeline, global::Acid.Sharp.UniformHandler uniformScene)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            if (ReferenceEquals(uniformScene, null))
                throw new global::System.ArgumentNullException("uniformScene", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = uniformScene.__Instance;
            var __ret = __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        public void Decode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Decode((__Instance + __PointerAdjustment), __arg0);
        }

        public void Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            __Internal.Encode((__Instance + __PointerAdjustment), __arg0);
        }

        public static uint MaxTypeInstances
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAX_TYPE_INSTANCES@ParticleType@acid@@2IB");
                return *__ptr;
            }
        }

        public static float FrustumBuffer
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?FRUSTUM_BUFFER@ParticleType@acid@@2MB");
                return *__ptr;
            }
        }

        public uint NumberOfRows
        {
            get
            {
                var __ret = __Internal.GetNumberOfRows((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetNumberOfRows((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Colour ColourOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetColourOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetColourOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float LifeLength
        {
            get
            {
                var __ret = __Internal.GetLifeLength((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetLifeLength((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float StageCycles
        {
            get
            {
                var __ret = __Internal.GetStageCycles((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStageCycles((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetScale((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ParticleType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A instance of a particle type.</summary>
    public unsafe partial class Particle : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.SharedPtr.__Internal m_particleType;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [FieldOffset(28)]
            internal global::Acid.Sharp.Vector3.__Internal m_velocity;

            [FieldOffset(40)]
            internal global::Acid.Sharp.Vector3.__Internal m_change;

            [FieldOffset(52)]
            internal global::Acid.Sharp.Vector2.__Internal m_textureOffset1;

            [FieldOffset(60)]
            internal global::Acid.Sharp.Vector2.__Internal m_textureOffset2;

            [FieldOffset(68)]
            internal float m_lifeLength;

            [FieldOffset(72)]
            internal float m_stageCycles;

            [FieldOffset(76)]
            internal float m_rotation;

            [FieldOffset(80)]
            internal float m_scale;

            [FieldOffset(84)]
            internal float m_gravityEffect;

            [FieldOffset(88)]
            internal float m_elapsedTime;

            [FieldOffset(92)]
            internal float m_transparency;

            [FieldOffset(96)]
            internal float m_textureBlendFactor;

            [FieldOffset(100)]
            internal float m_distanceToCamera;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Particle@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Particle@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Particle@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??MParticle@acid@@QEBA_NAEBV01@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAlive@Particle@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetAlive(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Particle@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetVelocity@Particle@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetVelocity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetChange@Particle@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetChange(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureOffset1@Particle@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetTextureOffset1(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureOffset2@Particle@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetTextureOffset2(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLifeLength@Particle@acid@@QEBAMXZ")]
            internal static extern float GetLifeLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRotation@Particle@acid@@QEBAMXZ")]
            internal static extern float GetRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScale@Particle@acid@@QEBAMXZ")]
            internal static extern float GetScale(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGravityEffect@Particle@acid@@QEBAMXZ")]
            internal static extern float GetGravityEffect(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetElapsedTime@Particle@acid@@QEBAMXZ")]
            internal static extern float GetElapsedTime(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTransparency@Particle@acid@@QEBAMXZ")]
            internal static extern float GetTransparency(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTextureBlendFactor@Particle@acid@@QEBAMXZ")]
            internal static extern float GetTextureBlendFactor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DistanceToCamera@Particle@acid@@QEBAMXZ")]
            internal static extern float DistanceToCamera(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Particle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Particle>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Particle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Particle(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Particle __CreateInstance(global::Acid.Sharp.Particle.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Particle(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Particle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Particle.__Internal));
            global::Acid.Sharp.Particle.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Particle(global::Acid.Sharp.Particle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Particle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Particle(global::Acid.Sharp.Particle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Particle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Particle __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the particle.</summary>
        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public static bool operator >(global::Acid.Sharp.Particle __op, global::Acid.Sharp.Particle other)
        {
            return !(__op < other);
        }

        public static bool operator <(global::Acid.Sharp.Particle __op, global::Acid.Sharp.Particle other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static float FadeTime
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?FADE_TIME@Particle@acid@@2MB");
                return *__ptr;
            }
        }

        public bool Alive
        {
            get
            {
                var __ret = __Internal.GetAlive((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector3 Velocity
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetVelocity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector3 Change
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetChange((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector2 TextureOffset1
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetTextureOffset1((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector2 TextureOffset2
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetTextureOffset2((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }
        }

        public float LifeLength
        {
            get
            {
                var __ret = __Internal.GetLifeLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Rotation
        {
            get
            {
                var __ret = __Internal.GetRotation((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Scale
        {
            get
            {
                var __ret = __Internal.GetScale((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float GravityEffect
        {
            get
            {
                var __ret = __Internal.GetGravityEffect((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float ElapsedTime
        {
            get
            {
                var __ret = __Internal.GetElapsedTime((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Transparency
        {
            get
            {
                var __ret = __Internal.GetTransparency((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float TextureBlendFactor
        {
            get
            {
                var __ret = __Internal.GetTextureBlendFactor((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float DistanceToCamera
        {
            get
            {
                var __ret = __Internal.DistanceToCamera((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A manager that manages particles.</summary>
    public unsafe partial class Particles : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_shared_ptr____N_acid_S_ParticleType___N_std_S_vector____N_acid_S_Particle___N_std_S_allocator__S3____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S2_ m_particles;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Particles@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Particles@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Particles@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Particles@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddParticle@Particles@acid@@QEAAXAEBVParticle@2@@Z")]
            internal static extern void AddParticle(global::System.IntPtr instance, global::System.IntPtr particle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Clear@Particles@acid@@QEAAXXZ")]
            internal static extern void Clear(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Particles __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Particles(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Particles __CreateInstance(global::Acid.Sharp.Particles.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Particles(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Particles.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Particles.__Internal));
            global::Acid.Sharp.Particles.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Particles(global::Acid.Sharp.Particles.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Particles(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Particles()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Particles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Particles");
        }

        public Particles(global::Acid.Sharp.Particles _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Particles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Particles");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Particles.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public void AddParticle(global::Acid.Sharp.Particle particle)
        {
            if (ReferenceEquals(particle, null))
                throw new global::System.ArgumentNullException("particle", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = particle.__Instance;
            __Internal.AddParticle((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Clears all particles from the scene.</summary>
        public void Clear()
        {
            __Internal.Clear((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Particles Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Particles __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Particles.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Particles) global::Acid.Sharp.Particles.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Particles.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Particles) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A interface that defines a particle spawn type.</summary>
    public unsafe abstract partial class ISpawnParticle : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpawnParticle@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ISpawnParticle@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ISpawnParticle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ISpawnParticle>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ISpawnParticle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ISpawnParticleInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ISpawnParticle __CreateInstance(global::Acid.Sharp.ISpawnParticle.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ISpawnParticleInternal(native, skipVTables);
        }

        protected ISpawnParticle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected ISpawnParticle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ISpawnParticle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.ISpawnParticle");
        }

        protected ISpawnParticle(global::Acid.Sharp.ISpawnParticle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ISpawnParticle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ISpawnParticle");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ISpawnParticle __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ISpawnParticle.__Internal*) __Instance)->vfptr_ISpawnParticle = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Decode(global::Acid.Sharp.Metadata metadata);

        public abstract void Encode(global::Acid.Sharp.Metadata metadata);

        /// <summary>Creates a new particle position.</summary>
        public abstract global::Acid.Sharp.Vector3 GeneratePosition();

        #region Virtual table interop

        // void Decode(const Metadata &metadata) = 0
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpawnParticle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const = 0
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpawnParticle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // Vector3 GeneratePosition() = 0
        private static global::Delegates.Action_IntPtr_IntPtr _GeneratePositionDelegateInstance;

        private static void _GeneratePositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ISpawnParticle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GeneratePosition();
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GeneratePositionDelegateInstance += _GeneratePositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GeneratePositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ISpawnParticleInternal : global::Acid.Sharp.ISpawnParticle, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.ISpawnParticle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ISpawnParticle.__Internal));
            *(global::Acid.Sharp.ISpawnParticle.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ISpawnParticleInternal(global::Acid.Sharp.ISpawnParticle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ISpawnParticleInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>Creates a new particle position.</summary>
        public override global::Acid.Sharp.Vector3 GeneratePosition()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GeneratePositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            ___GeneratePositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A system of particles that are to be spawned.</summary>
    public unsafe partial class ParticleSystem : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_ParticleType___N_std_S_allocator__S0_ m_types;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_ISpawnParticle___N_std_S_default_delete__S0_ m_spawn;

            [FieldOffset(56)]
            internal float m_pps;

            [FieldOffset(60)]
            internal float m_averageSpeed;

            [FieldOffset(64)]
            internal float m_gravityEffect;

            [FieldOffset(68)]
            internal byte m_randomRotation;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector3.__Internal m_lastPosition;

            [FieldOffset(84)]
            internal global::Acid.Sharp.Vector3.__Internal m_localOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector3.__Internal m_direction;

            [FieldOffset(108)]
            internal float m_directionDeviation;

            [FieldOffset(112)]
            internal float m_speedDeviation;

            [FieldOffset(116)]
            internal float m_lifeDeviation;

            [FieldOffset(120)]
            internal float m_stageDeviation;

            [FieldOffset(124)]
            internal float m_scaleDeviation;

            [FieldOffset(128)]
            internal float m_timePassed;

            [FieldOffset(132)]
            internal byte m_paused;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ParticleSystem@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ParticleSystem@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TrySetSpawn@ParticleSystem@acid@@QEAAXAEBVMetadata@2@@Z")]
            internal static extern void TrySetSpawn(global::System.IntPtr instance, global::System.IntPtr spawnNode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDirection@ParticleSystem@acid@@QEAAXAEBVVector3@2@AEBM@Z")]
            internal static extern void SetDirection(global::System.IntPtr instance, global::System.IntPtr direction, float* deviation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpawn@ParticleSystem@acid@@QEBAPEAVISpawnParticle@2@XZ")]
            internal static extern global::System.IntPtr GetSpawn(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSpawn@ParticleSystem@acid@@QEAAXPEAVISpawnParticle@2@@Z")]
            internal static extern void SetSpawn(global::System.IntPtr instance, global::System.IntPtr spawn);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPps@ParticleSystem@acid@@QEBAMXZ")]
            internal static extern float GetPps(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPps@ParticleSystem@acid@@QEAAXAEBM@Z")]
            internal static extern void SetPps(global::System.IntPtr instance, float* pps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAverageSpeed@ParticleSystem@acid@@QEBAMXZ")]
            internal static extern float GetAverageSpeed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAverageSpeed@ParticleSystem@acid@@QEAAXAEBM@Z")]
            internal static extern void SetAverageSpeed(global::System.IntPtr instance, float* averageSpeed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGravityEffect@ParticleSystem@acid@@QEBAMXZ")]
            internal static extern float GetGravityEffect(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGravityEffect@ParticleSystem@acid@@QEAAXAEBM@Z")]
            internal static extern void SetGravityEffect(global::System.IntPtr instance, float* gravityEffect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsRandomRotation@ParticleSystem@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetRandomRotation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRandomRotation@ParticleSystem@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetRandomRotation(global::System.IntPtr instance, bool* randomRotation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalOffset@ParticleSystem@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetLocalOffset(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLocalOffset@ParticleSystem@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLocalOffset(global::System.IntPtr instance, global::System.IntPtr localOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpeedDeviation@ParticleSystem@acid@@QEBAMXZ")]
            internal static extern float GetSpeedDeviation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSpeedDeviation@ParticleSystem@acid@@QEAAXAEBM@Z")]
            internal static extern void SetSpeedDeviation(global::System.IntPtr instance, float* speedDeviation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLifeDeviation@ParticleSystem@acid@@QEBAMXZ")]
            internal static extern float GetLifeDeviation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLifeDeviation@ParticleSystem@acid@@QEAAXAEBM@Z")]
            internal static extern void SetLifeDeviation(global::System.IntPtr instance, float* lifeDeviation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStageDeviation@ParticleSystem@acid@@QEBAMXZ")]
            internal static extern float GetStageDeviation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStageDeviation@ParticleSystem@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStageDeviation(global::System.IntPtr instance, float* stageDeviation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScaleDeviation@ParticleSystem@acid@@QEBAMXZ")]
            internal static extern float GetScaleDeviation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScaleDeviation@ParticleSystem@acid@@QEAAXAEBM@Z")]
            internal static extern void SetScaleDeviation(global::System.IntPtr instance, float* scaleDeviation);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPaused@ParticleSystem@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetPaused(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPaused@ParticleSystem@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetPaused(global::System.IntPtr instance, bool* paused);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDirection@ParticleSystem@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetDirection(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        internal static new global::Acid.Sharp.ParticleSystem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ParticleSystem(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ParticleSystem __CreateInstance(global::Acid.Sharp.ParticleSystem.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ParticleSystem(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ParticleSystem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ParticleSystem.__Internal));
            global::Acid.Sharp.ParticleSystem.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ParticleSystem(global::Acid.Sharp.ParticleSystem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ParticleSystem(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ParticleSystem(global::Acid.Sharp.ParticleSystem _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ParticleSystem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ParticleSystem");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ParticleSystem.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public void TrySetSpawn(global::Acid.Sharp.Metadata spawnNode)
        {
            if (ReferenceEquals(spawnNode, null))
                throw new global::System.ArgumentNullException("spawnNode", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = spawnNode.__Instance;
            __Internal.TrySetSpawn((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetDirection(global::Acid.Sharp.Vector3 direction, float deviation)
        {
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = direction.__Instance;
            var __arg1 = &deviation;
            __Internal.SetDirection((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public global::Acid.Sharp.ISpawnParticle Spawn
        {
            get
            {
                var __ret = __Internal.GetSpawn((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ISpawnParticle __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ISpawnParticle.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ISpawnParticle) global::Acid.Sharp.ISpawnParticle.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ISpawnParticle.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetSpawn((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Pps
        {
            get
            {
                var __ret = __Internal.GetPps((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetPps((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float AverageSpeed
        {
            get
            {
                var __ret = __Internal.GetAverageSpeed((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetAverageSpeed((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float GravityEffect
        {
            get
            {
                var __ret = __Internal.GetGravityEffect((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetGravityEffect((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool RandomRotation
        {
            get
            {
                var __ret = __Internal.GetRandomRotation((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRandomRotation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 LocalOffset
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetLocalOffset((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLocalOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float SpeedDeviation
        {
            get
            {
                var __ret = __Internal.GetSpeedDeviation((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetSpeedDeviation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float LifeDeviation
        {
            get
            {
                var __ret = __Internal.GetLifeDeviation((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetLifeDeviation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float StageDeviation
        {
            get
            {
                var __ret = __Internal.GetStageDeviation((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStageDeviation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ScaleDeviation
        {
            get
            {
                var __ret = __Internal.GetScaleDeviation((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetScaleDeviation((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Paused
        {
            get
            {
                var __ret = __Internal.GetPaused((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetPaused((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Direction
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetDirection((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ParticleSystem) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class RendererParticles : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 728)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformScene;

            [FieldOffset(64)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererParticles@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererParticles@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RendererParticles@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.RendererParticles __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererParticles(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RendererParticles __CreateInstance(global::Acid.Sharp.RendererParticles.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererParticles(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RendererParticles.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererParticles.__Internal));
            global::Acid.Sharp.RendererParticles.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererParticles(global::Acid.Sharp.RendererParticles.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererParticles(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public RendererParticles(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererParticles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererParticles");
        }

        public RendererParticles(global::Acid.Sharp.RendererParticles _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererParticles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererParticles");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.RendererParticles.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.RendererParticles(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.RendererParticles(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.RendererParticles) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class SpawnCircle : global::Acid.Sharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal float m_radius;

            [FieldOffset(12)]
            internal global::Acid.Sharp.Vector3.__Internal m_heading;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Vector3.__Internal m_spawnPosition;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnCircle@acid@@QEAA@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* radius, global::System.IntPtr heading);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnCircle@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@SpawnCircle@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@SpawnCircle@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeading@SpawnCircle@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetHeading(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeading@SpawnCircle@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetHeading(global::System.IntPtr instance, global::System.IntPtr heading);
        }

        internal static new global::Acid.Sharp.SpawnCircle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnCircle(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SpawnCircle __CreateInstance(global::Acid.Sharp.SpawnCircle.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnCircle(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SpawnCircle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnCircle.__Internal));
            global::Acid.Sharp.SpawnCircle.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnCircle(global::Acid.Sharp.SpawnCircle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnCircle(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public SpawnCircle(float radius, global::Acid.Sharp.Vector3 heading)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnCircle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &radius;
            if (ReferenceEquals(heading, null))
                throw new global::System.ArgumentNullException("heading", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = heading.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnCircle");
        }

        public SpawnCircle(global::Acid.Sharp.SpawnCircle _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnCircle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnCircle");
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override global::Acid.Sharp.Vector3 GeneratePosition()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GeneratePositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            ___GeneratePositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Heading
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetHeading((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetHeading((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnCircle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnCircle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // Vector3 GeneratePosition() override
        private static global::Delegates.Action_IntPtr_IntPtr _GeneratePositionDelegateInstance;

        private static void _GeneratePositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnCircle) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GeneratePosition();
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GeneratePositionDelegateInstance += _GeneratePositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GeneratePositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class SpawnLine : global::Acid.Sharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal float m_length;

            [FieldOffset(12)]
            internal global::Acid.Sharp.Vector3.__Internal m_axis;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Vector3.__Internal m_spawnPosition;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnLine@acid@@QEAA@AEBMAEBVVector3@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* length, global::System.IntPtr axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnLine@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLength@SpawnLine@acid@@QEBAMXZ")]
            internal static extern float GetLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLength@SpawnLine@acid@@QEAAXAEBM@Z")]
            internal static extern void SetLength(global::System.IntPtr instance, float* length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxis@SpawnLine@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetAxis(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAxis@SpawnLine@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetAxis(global::System.IntPtr instance, global::System.IntPtr axis);
        }

        internal static new global::Acid.Sharp.SpawnLine __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnLine(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SpawnLine __CreateInstance(global::Acid.Sharp.SpawnLine.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnLine(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SpawnLine.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnLine.__Internal));
            global::Acid.Sharp.SpawnLine.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnLine(global::Acid.Sharp.SpawnLine.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnLine(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public SpawnLine(float length, global::Acid.Sharp.Vector3 axis)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &length;
            if (ReferenceEquals(axis, null))
                throw new global::System.ArgumentNullException("axis", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = axis.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnLine");
        }

        public SpawnLine(global::Acid.Sharp.SpawnLine _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnLine.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnLine");
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override global::Acid.Sharp.Vector3 GeneratePosition()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GeneratePositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            ___GeneratePositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public float Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetLength((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Axis
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetAxis((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAxis((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnLine) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnLine) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // Vector3 GeneratePosition() override
        private static global::Delegates.Action_IntPtr_IntPtr _GeneratePositionDelegateInstance;

        private static void _GeneratePositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnLine) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GeneratePosition();
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GeneratePositionDelegateInstance += _GeneratePositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GeneratePositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class SpawnPoint : global::Acid.Sharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Vector3.__Internal m_point;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnPoint@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnPoint@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPoint@SpawnPoint@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPoint(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPoint@SpawnPoint@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPoint(global::System.IntPtr instance, global::System.IntPtr point);
        }

        internal static new global::Acid.Sharp.SpawnPoint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnPoint(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SpawnPoint __CreateInstance(global::Acid.Sharp.SpawnPoint.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnPoint(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SpawnPoint.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnPoint.__Internal));
            global::Acid.Sharp.SpawnPoint.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnPoint(global::Acid.Sharp.SpawnPoint.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnPoint(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public SpawnPoint()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnPoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnPoint");
        }

        public SpawnPoint(global::Acid.Sharp.SpawnPoint _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnPoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnPoint");
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override global::Acid.Sharp.Vector3 GeneratePosition()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GeneratePositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            ___GeneratePositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public global::Acid.Sharp.Vector3 Point
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPoint((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPoint((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnPoint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnPoint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // Vector3 GeneratePosition() override
        private static global::Delegates.Action_IntPtr_IntPtr _GeneratePositionDelegateInstance;

        private static void _GeneratePositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnPoint) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GeneratePosition();
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GeneratePositionDelegateInstance += _GeneratePositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GeneratePositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class SpawnSphere : global::Acid.Sharp.ISpawnParticle, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpawnParticle;

            [FieldOffset(8)]
            internal float m_radius;

            [FieldOffset(12)]
            internal global::Acid.Sharp.Vector3.__Internal m_spawnPosition;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnSphere@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SpawnSphere@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@SpawnSphere@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@SpawnSphere@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float* radius);
        }

        internal static new global::Acid.Sharp.SpawnSphere __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnSphere(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SpawnSphere __CreateInstance(global::Acid.Sharp.SpawnSphere.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SpawnSphere(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SpawnSphere.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnSphere.__Internal));
            global::Acid.Sharp.SpawnSphere.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SpawnSphere(global::Acid.Sharp.SpawnSphere.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SpawnSphere(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public SpawnSphere(float radius)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &radius;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnSphere");
        }

        public SpawnSphere(global::Acid.Sharp.SpawnSphere _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SpawnSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.SpawnSphere");
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override global::Acid.Sharp.Vector3 GeneratePosition()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___GeneratePositionDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __ret = new global::Acid.Sharp.Vector3.__Internal();
            ___GeneratePositionDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static explicit operator global::Acid.Sharp.SpawnSphere(float radius)
        {
            return new global::Acid.Sharp.SpawnSphere(ref *radius);
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // Vector3 GeneratePosition() override
        private static global::Delegates.Action_IntPtr_IntPtr _GeneratePositionDelegateInstance;

        private static void _GeneratePositionDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SpawnSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GeneratePosition();
            *(global::Acid.Sharp.Vector3.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::Acid.Sharp.Vector3.__Internal() : *(global::Acid.Sharp.Vector3.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GeneratePositionDelegateInstance += _GeneratePositionDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GeneratePositionDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class BtCollisionShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCollisionShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCollisionShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtCollisionShape __CreateInstance(global::BtCollisionShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtCollisionShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCollisionShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCollisionShape.__Internal));
        *(global::BtCollisionShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCollisionShape(global::BtCollisionShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCollisionShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtVector3
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtVector3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtVector3>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtVector3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtVector3(native.ToPointer(), skipVTables);
    }

    internal static global::BtVector3 __CreateInstance(global::BtVector3.__Internal native, bool skipVTables = false)
    {
        return new global::BtVector3(native, skipVTables);
    }

    private static void* __CopyValue(global::BtVector3.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtVector3.__Internal));
        *(global::BtVector3.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtVector3(global::BtVector3.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtVector3(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtQuaternion
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtQuaternion> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtQuaternion>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtQuaternion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtQuaternion(native.ToPointer(), skipVTables);
    }

    internal static global::BtQuaternion __CreateInstance(global::BtQuaternion.__Internal native, bool skipVTables = false)
    {
        return new global::BtQuaternion(native, skipVTables);
    }

    private static void* __CopyValue(global::BtQuaternion.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtQuaternion.__Internal));
        *(global::BtQuaternion.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtQuaternion(global::BtQuaternion.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtQuaternion(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtTransform
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtTransform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtTransform>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtTransform __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtTransform(native.ToPointer(), skipVTables);
    }

    internal static global::BtTransform __CreateInstance(global::BtTransform.__Internal native, bool skipVTables = false)
    {
        return new global::BtTransform(native, skipVTables);
    }

    private static void* __CopyValue(global::BtTransform.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtTransform.__Internal));
        *(global::BtTransform.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtTransform(global::BtTransform.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtTransform(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    /// <summary>A simple class that represents a physics shape.</summary>
    public unsafe abstract partial class Collider : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Collider@acid@@QEAA@AEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Collider@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@Collider@acid@@SA?AVbtVector3@@AEBVVector3@2@@Z")]
            internal static extern global::BtVector3.__Internal Convert(global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@Collider@acid@@SA?AVVector3@2@AEBVbtVector3@@@Z")]
            internal static extern global::Acid.Sharp.Vector3.__Internal Convert_1(global::System.IntPtr vector);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@Collider@acid@@SA?AVbtQuaternion@@AEBVQuaternion@2@@Z")]
            internal static extern global::BtQuaternion.__Internal Convert_2(global::System.IntPtr quaternion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@Collider@acid@@SA?AVQuaternion@2@AEBVbtQuaternion@@@Z")]
            internal static extern global::Acid.Sharp.Quaternion.__Internal Convert_3(global::System.IntPtr quaternion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@Collider@acid@@SA?AVbtTransform@@AEBVTransform@2@@Z")]
            internal static extern global::BtTransform.__Internal Convert_4(global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Convert@Collider@acid@@SA?AVTransform@2@AEBVbtTransform@@AEBVVector3@2@@Z")]
            internal static extern global::Acid.Sharp.Transform.__Internal Convert(global::System.IntPtr transform, global::System.IntPtr scaling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLocalTransform@Collider@acid@@QEAAAEAVTransform@2@XZ")]
            internal static extern global::System.IntPtr GetLocalTransform(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLocalTransform@Collider@acid@@QEAAXAEBVTransform@2@@Z")]
            internal static extern void SetLocalTransform(global::System.IntPtr instance, global::System.IntPtr localTransform);
        }

        internal static new global::Acid.Sharp.Collider __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Collider __CreateInstance(global::Acid.Sharp.Collider.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderInternal(native, skipVTables);
        }

        protected Collider(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new collider shape.</summary>
        /// <param name="localTransform">The parent offset of the body.</param>
        protected Collider(global::Acid.Sharp.Transform localTransform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Collider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Collider");
        }

        protected Collider(global::Acid.Sharp.Collider _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Collider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Collider");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Collider.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static global::BtVector3 Convert(global::Acid.Sharp.Vector3 vector)
        {
            if (ReferenceEquals(vector, null))
                throw new global::System.ArgumentNullException("vector", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = vector.__Instance;
            var __ret = __Internal.Convert(__arg0);
            return global::BtVector3.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Vector3 Convert(global::BtVector3 vector)
        {
            if (ReferenceEquals(vector, null))
                throw new global::System.ArgumentNullException("vector", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = vector.__Instance;
            var __ret = __Internal.Convert_1(__arg0);
            return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
        }

        public static global::BtQuaternion Convert(global::Acid.Sharp.Quaternion quaternion)
        {
            if (ReferenceEquals(quaternion, null))
                throw new global::System.ArgumentNullException("quaternion", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = quaternion.__Instance;
            var __ret = __Internal.Convert_2(__arg0);
            return global::BtQuaternion.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Quaternion Convert(global::BtQuaternion quaternion)
        {
            if (ReferenceEquals(quaternion, null))
                throw new global::System.ArgumentNullException("quaternion", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = quaternion.__Instance;
            var __ret = __Internal.Convert_3(__arg0);
            return global::Acid.Sharp.Quaternion.__CreateInstance(__ret);
        }

        public static global::BtTransform Convert(global::Acid.Sharp.Transform transform)
        {
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            var __ret = __Internal.Convert_4(__arg0);
            return global::BtTransform.__CreateInstance(__ret);
        }

        public static global::Acid.Sharp.Transform Convert(global::BtTransform transform, global::Acid.Sharp.Vector3 scaling)
        {
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = transform.__Instance;
            if (ReferenceEquals(scaling, null))
                throw new global::System.ArgumentNullException("scaling", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = scaling.__Instance;
            var __ret = __Internal.Convert(__arg0, __arg1);
            return global::Acid.Sharp.Transform.__CreateInstance(__ret);
        }

        protected global::Acid.Sharp.Transform MLocalTransform
        {
            get
            {
                return global::Acid.Sharp.Transform.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.Collider.__Internal*) __Instance)->m_localTransform));
            }

            set
            {
                ((global::Acid.Sharp.Collider.__Internal*)__Instance)->m_localTransform = ReferenceEquals(value, null) ? new global::Acid.Sharp.Transform.__Internal() : *(global::Acid.Sharp.Transform.__Internal*) value.__Instance;
            }
        }

        public global::Acid.Sharp.Transform LocalTransform
        {
            get
            {
                var __ret = __Internal.GetLocalTransform((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Transform __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Transform.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Transform) global::Acid.Sharp.Transform.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Transform.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLocalTransform((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the collision shape defined in this collider.</summary>
        public abstract global::BtCollisionShape CollisionShape
        {
            get;
        }

        #region Virtual table interop

        // void Start() { }
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() { }
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) { }
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const { }
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape* GetCollisionShape() const = 0
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Collider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ColliderInternal : global::Acid.Sharp.Collider, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.Collider.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Collider.__Internal));
            *(global::Acid.Sharp.Collider.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ColliderInternal(global::Acid.Sharp.Collider.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ColliderInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets the collision shape defined in this collider.</summary>
        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

public unsafe partial class BtBoxShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtBoxShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtBoxShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtBoxShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtBoxShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtBoxShape __CreateInstance(global::BtBoxShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtBoxShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtBoxShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtBoxShape.__Internal));
        *(global::BtBoxShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtBoxShape(global::BtBoxShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtBoxShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ColliderCube : global::Acid.Sharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btBoxShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector3.__Internal m_extents;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCube@acid@@QEAA@AEBVVector3@1@AEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr extents, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCube@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ColliderCube@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetExtents@ColliderCube@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetExtents(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetExtents@ColliderCube@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetExtents(global::System.IntPtr instance, global::System.IntPtr extents);
        }

        internal static new global::Acid.Sharp.ColliderCube __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCube(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ColliderCube __CreateInstance(global::Acid.Sharp.ColliderCube.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCube(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ColliderCube.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCube.__Internal));
            global::Acid.Sharp.ColliderCube.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderCube(global::Acid.Sharp.ColliderCube.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderCube(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ColliderCube(global::Acid.Sharp.Vector3 extents, global::Acid.Sharp.Transform localTransform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCube.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(extents, null))
                throw new global::System.ArgumentNullException("extents", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = extents.__Instance;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCube");
        }

        public ColliderCube(global::Acid.Sharp.ColliderCube _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCube.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCube");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ColliderCube.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public global::Acid.Sharp.Vector3 Extents
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetExtents((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetExtents((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape *GetCollisionShape() const override
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCube) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class BtCapsuleShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCapsuleShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCapsuleShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCapsuleShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCapsuleShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtCapsuleShape __CreateInstance(global::BtCapsuleShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtCapsuleShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCapsuleShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCapsuleShape.__Internal));
        *(global::BtCapsuleShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCapsuleShape(global::BtCapsuleShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCapsuleShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ColliderCapsule : global::Acid.Sharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCapsuleShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(72)]
            internal float m_radius;

            [FieldOffset(76)]
            internal float m_height;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCapsule@acid@@QEAA@AEBM0AEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* radius, float* height, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCapsule@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ColliderCapsule@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@ColliderCapsule@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@ColliderCapsule@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@ColliderCapsule@acid@@QEBAMXZ")]
            internal static extern float GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@ColliderCapsule@acid@@QEAAXAEBM@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, float* height);
        }

        internal static new global::Acid.Sharp.ColliderCapsule __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCapsule(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ColliderCapsule __CreateInstance(global::Acid.Sharp.ColliderCapsule.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCapsule(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ColliderCapsule.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCapsule.__Internal));
            global::Acid.Sharp.ColliderCapsule.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderCapsule(global::Acid.Sharp.ColliderCapsule.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderCapsule(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ColliderCapsule(float radius, float height, global::Acid.Sharp.Transform localTransform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCapsule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &radius;
            var __arg1 = &height;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCapsule");
        }

        public ColliderCapsule(global::Acid.Sharp.ColliderCapsule _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCapsule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCapsule");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ColliderCapsule.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetHeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCapsule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCapsule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCapsule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCapsule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape *GetCollisionShape() const override
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCapsule) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class BtConeShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtConeShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtConeShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtConeShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtConeShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtConeShape __CreateInstance(global::BtConeShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtConeShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtConeShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtConeShape.__Internal));
        *(global::BtConeShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtConeShape(global::BtConeShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtConeShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ColliderCone : global::Acid.Sharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btConeShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(72)]
            internal float m_radius;

            [FieldOffset(76)]
            internal float m_height;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCone@acid@@QEAA@AEBM0AEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* radius, float* height, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCone@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ColliderCone@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@ColliderCone@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@ColliderCone@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@ColliderCone@acid@@QEBAMXZ")]
            internal static extern float GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@ColliderCone@acid@@QEAAXAEBM@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, float* height);
        }

        internal static new global::Acid.Sharp.ColliderCone __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCone(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ColliderCone __CreateInstance(global::Acid.Sharp.ColliderCone.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCone(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ColliderCone.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCone.__Internal));
            global::Acid.Sharp.ColliderCone.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderCone(global::Acid.Sharp.ColliderCone.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderCone(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ColliderCone(float radius, float height, global::Acid.Sharp.Transform localTransform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCone.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &radius;
            var __arg1 = &height;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCone");
        }

        public ColliderCone(global::Acid.Sharp.ColliderCone _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCone.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCone");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ColliderCone.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetHeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape *GetCollisionShape() const override
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class BtConvexHullShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtConvexHullShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtConvexHullShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtConvexHullShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtConvexHullShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtConvexHullShape __CreateInstance(global::BtConvexHullShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtConvexHullShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtConvexHullShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtConvexHullShape.__Internal));
        *(global::BtConvexHullShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtConvexHullShape(global::BtConvexHullShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtConvexHullShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ColliderConvexHull : global::Acid.Sharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btConvexHullShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(72)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(88)]
            internal uint m_points;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderConvexHull@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ColliderConvexHull@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPoints@ColliderConvexHull@acid@@QEBAIXZ")]
            internal static extern uint GetPoints(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.ColliderConvexHull __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderConvexHull(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ColliderConvexHull __CreateInstance(global::Acid.Sharp.ColliderConvexHull.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderConvexHull(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ColliderConvexHull.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderConvexHull.__Internal));
            global::Acid.Sharp.ColliderConvexHull.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderConvexHull(global::Acid.Sharp.ColliderConvexHull.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderConvexHull(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ColliderConvexHull(global::Acid.Sharp.ColliderConvexHull _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderConvexHull.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderConvexHull");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ColliderConvexHull.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint Points
        {
            get
            {
                var __ret = __Internal.GetPoints((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderConvexHull) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderConvexHull) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderConvexHull) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderConvexHull) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape *GetCollisionShape() const override
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderConvexHull) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class BtCylinderShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCylinderShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCylinderShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCylinderShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCylinderShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtCylinderShape __CreateInstance(global::BtCylinderShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtCylinderShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCylinderShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCylinderShape.__Internal));
        *(global::BtCylinderShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCylinderShape(global::BtCylinderShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCylinderShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ColliderCylinder : global::Acid.Sharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCylinderShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(72)]
            internal float m_radius;

            [FieldOffset(76)]
            internal float m_height;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCylinder@acid@@QEAA@AEBM0AEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* radius, float* height, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderCylinder@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ColliderCylinder@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@ColliderCylinder@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@ColliderCylinder@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@ColliderCylinder@acid@@QEBAMXZ")]
            internal static extern float GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetHeight@ColliderCylinder@acid@@QEAAXAEBM@Z")]
            internal static extern void SetHeight(global::System.IntPtr instance, float* height);
        }

        internal static new global::Acid.Sharp.ColliderCylinder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCylinder(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ColliderCylinder __CreateInstance(global::Acid.Sharp.ColliderCylinder.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderCylinder(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ColliderCylinder.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCylinder.__Internal));
            global::Acid.Sharp.ColliderCylinder.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderCylinder(global::Acid.Sharp.ColliderCylinder.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderCylinder(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ColliderCylinder(float radius, float height, global::Acid.Sharp.Transform localTransform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCylinder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &radius;
            var __arg1 = &height;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCylinder");
        }

        public ColliderCylinder(global::Acid.Sharp.ColliderCylinder _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderCylinder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderCylinder");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ColliderCylinder.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetHeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape *GetCollisionShape() const override
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderCylinder) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class BtHeightfieldTerrainShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtHeightfieldTerrainShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtHeightfieldTerrainShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtHeightfieldTerrainShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtHeightfieldTerrainShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtHeightfieldTerrainShape __CreateInstance(global::BtHeightfieldTerrainShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtHeightfieldTerrainShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtHeightfieldTerrainShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtHeightfieldTerrainShape.__Internal));
        *(global::BtHeightfieldTerrainShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtHeightfieldTerrainShape(global::BtHeightfieldTerrainShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtHeightfieldTerrainShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ColliderHeightfield : global::Acid.Sharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btHeightfieldTerrainShape___N_std_S_default_delete__S0_ m_shape;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderHeightfield@acid@@QEAA@AEBH0PEBXAEBM2AEB_NAEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, int* heightStickWidth, int* heightStickLength, global::System.IntPtr heightfieldData, float* minHeight, float* maxHeight, bool* flipQuadEdges, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderHeightfield@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ColliderHeightfield@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Initialize@ColliderHeightfield@acid@@QEAAXAEBH0PEBXAEBM2AEB_N@Z")]
            internal static extern void Initialize(global::System.IntPtr instance, int* heightStickWidth, int* heightStickLength, global::System.IntPtr heightfieldData, float* minHeight, float* maxHeight, bool* flipQuadEdges);
        }

        internal static new global::Acid.Sharp.ColliderHeightfield __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderHeightfield(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ColliderHeightfield __CreateInstance(global::Acid.Sharp.ColliderHeightfield.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderHeightfield(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ColliderHeightfield.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderHeightfield.__Internal));
            global::Acid.Sharp.ColliderHeightfield.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderHeightfield(global::Acid.Sharp.ColliderHeightfield.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderHeightfield(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ColliderHeightfield(int heightStickWidth, int heightStickLength, global::System.IntPtr heightfieldData, float minHeight, float maxHeight, bool flipQuadEdges, global::Acid.Sharp.Transform localTransform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderHeightfield.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &heightStickWidth;
            var __arg1 = &heightStickLength;
            var __arg3 = &minHeight;
            var __arg4 = &maxHeight;
            var __arg5 = &flipQuadEdges;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg6 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, heightfieldData, __arg3, __arg4, __arg5, __arg6);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderHeightfield");
        }

        public ColliderHeightfield(global::Acid.Sharp.ColliderHeightfield _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderHeightfield.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderHeightfield");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ColliderHeightfield.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public void Initialize(int heightStickWidth, int heightStickLength, global::System.IntPtr heightfieldData, float minHeight, float maxHeight, bool flipQuadEdges)
        {
            var __arg0 = &heightStickWidth;
            var __arg1 = &heightStickLength;
            var __arg3 = &minHeight;
            var __arg4 = &maxHeight;
            var __arg5 = &flipQuadEdges;
            __Internal.Initialize((__Instance + __PointerAdjustment), __arg0, __arg1, heightfieldData, __arg3, __arg4, __arg5);
        }

        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderHeightfield) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderHeightfield) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderHeightfield) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderHeightfield) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape *GetCollisionShape() const override
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderHeightfield) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

public unsafe partial class BtSphereShape
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtSphereShape> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtSphereShape>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtSphereShape __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtSphereShape(native.ToPointer(), skipVTables);
    }

    internal static global::BtSphereShape __CreateInstance(global::BtSphereShape.__Internal native, bool skipVTables = false)
    {
        return new global::BtSphereShape(native, skipVTables);
    }

    private static void* __CopyValue(global::BtSphereShape.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtSphereShape.__Internal));
        *(global::BtSphereShape.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtSphereShape(global::BtSphereShape.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtSphereShape(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class ColliderSphere : global::Acid.Sharp.Collider, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Transform.__Internal m_localTransform;

            [FieldOffset(64)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btSphereShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(72)]
            internal float m_radius;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderSphere@acid@@QEAA@AEBMAEBVTransform@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* radius, global::System.IntPtr localTransform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ColliderSphere@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ColliderSphere@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRadius@ColliderSphere@acid@@QEBAMXZ")]
            internal static extern float GetRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetRadius@ColliderSphere@acid@@QEAAXAEBM@Z")]
            internal static extern void SetRadius(global::System.IntPtr instance, float* radius);
        }

        internal static new global::Acid.Sharp.ColliderSphere __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderSphere(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ColliderSphere __CreateInstance(global::Acid.Sharp.ColliderSphere.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ColliderSphere(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ColliderSphere.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderSphere.__Internal));
            global::Acid.Sharp.ColliderSphere.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ColliderSphere(global::Acid.Sharp.ColliderSphere.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ColliderSphere(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ColliderSphere(float radius, global::Acid.Sharp.Transform localTransform)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &radius;
            if (ReferenceEquals(localTransform, null))
                throw new global::System.ArgumentNullException("localTransform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = localTransform.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderSphere");
        }

        public ColliderSphere(global::Acid.Sharp.ColliderSphere _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ColliderSphere.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ColliderSphere");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ColliderSphere.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public float Radius
        {
            get
            {
                var __ret = __Internal.GetRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public override global::BtCollisionShape CollisionShape
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
                var ___GetCollisionShapeDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetCollisionShapeDelegate((__Instance + __PointerAdjustment));
                global::BtCollisionShape __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtCollisionShape.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtCollisionShape) global::BtCollisionShape.NativeToManagedMap[__ret];
                else __result0 = global::BtCollisionShape.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // btCollisionShape *GetCollisionShape() const override
        private static global::Delegates.Func_IntPtr_IntPtr _GetCollisionShapeDelegateInstance;

        private static global::System.IntPtr _GetCollisionShapeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ColliderSphere) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.CollisionShape;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _GetCollisionShapeDelegateInstance += _GetCollisionShapeDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetCollisionShapeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(6 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Force : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector3.__Internal m_direction;

            [FieldOffset(12)]
            internal byte m_neverExpires;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Time.__Internal m_timeLeft;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Vector3.__Internal m_position;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Force@acid@@QEAA@AEBVVector3@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr direction, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Force@acid@@QEAA@AEBVVector3@1@AEBVTime@1@0@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr direction, global::System.IntPtr time, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Force@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@Force@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDirection@Force@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetDirection(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDirection@Force@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetDirection(global::System.IntPtr instance, global::System.IntPtr direction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetTimeLeft@Force@acid@@QEBA?AVTime@2@XZ")]
            internal static extern void GetTimeLeft(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetTimeLeft@Force@acid@@QEAAXAEBVTime@2@@Z")]
            internal static extern void SetTimeLeft(global::System.IntPtr instance, global::System.IntPtr timeLeft);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPosition@Force@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPosition@Force@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetPosition(global::System.IntPtr instance, global::System.IntPtr position);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsExpired@Force@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetExpired(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Force> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Force>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Force __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Force(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Force __CreateInstance(global::Acid.Sharp.Force.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Force(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Force.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Force.__Internal));
            global::Acid.Sharp.Force.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Force(global::Acid.Sharp.Force.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Force(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Force(global::Acid.Sharp.Vector3 direction, global::Acid.Sharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Force.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = direction.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public Force(global::Acid.Sharp.Vector3 direction, global::Acid.Sharp.Time time, global::Acid.Sharp.Vector3 position)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Force.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = direction.__Instance;
            if (ReferenceEquals(time, null))
                throw new global::System.ArgumentNullException("time", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = time.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = position.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public Force(global::Acid.Sharp.Force _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Force.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Force __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.Vector3 Direction
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetDirection((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDirection((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Time TimeLeft
        {
            get
            {
                var __ret = new global::Acid.Sharp.Time.__Internal();
                __Internal.GetTimeLeft((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Time.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetTimeLeft((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Position
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Expired
        {
            get
            {
                var __ret = __Internal.GetExpired((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

public unsafe partial class BtCollisionObject
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionObject>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCollisionObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCollisionObject(native.ToPointer(), skipVTables);
    }

    internal static global::BtCollisionObject __CreateInstance(global::BtCollisionObject.__Internal native, bool skipVTables = false)
    {
        return new global::BtCollisionObject(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCollisionObject.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCollisionObject.__Internal));
        *(global::BtCollisionObject.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCollisionObject(global::BtCollisionObject.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCollisionObject(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a object in a scene effected by physics.</summary>
    public unsafe abstract partial class CollisionObject : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal float m_friction;

            [FieldOffset(28)]
            internal float m_frictionRolling;

            [FieldOffset(32)]
            internal float m_frictionSpinning;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionObject___N_std_S_default_delete__S0_ m_body;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Force___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_forces;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Observer.__Internalc__N_acid_S_Observer__p1___N_acid_S_CollisionObject m_collisionEvents;

            [FieldOffset(104)]
            internal global::Acid.Sharp.Observer.__Internalc__N_acid_S_Observer__p1___N_acid_S_CollisionObject m_separationEvents;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CollisionObject@acid@@QEAA@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* friction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0CollisionObject@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1CollisionObject@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddForce@CollisionObject@acid@@QEAAPEAVForce@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddForce(global::System.IntPtr instance, global::System.IntPtr force);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetChildTransform@CollisionObject@acid@@QEAAXPEAVCollider@2@AEBVTransform@2@@Z")]
            internal static extern void SetChildTransform(global::System.IntPtr instance, global::System.IntPtr child, global::System.IntPtr transform);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddChild@CollisionObject@acid@@QEAAXPEAVCollider@2@@Z")]
            internal static extern void AddChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveChild@CollisionObject@acid@@QEAAXPEAVCollider@2@@Z")]
            internal static extern void RemoveChild(global::System.IntPtr instance, global::System.IntPtr child);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetIgnoreCollisionCheck@CollisionObject@acid@@QEAAXPEAV12@AEB_N@Z")]
            internal static extern void SetIgnoreCollisionCheck(global::System.IntPtr instance, global::System.IntPtr other, bool* ignore);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateShape@CollisionObject@acid@@IEAAXXZ")]
            internal static extern void CreateShape(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFriction@CollisionObject@acid@@QEBAMXZ")]
            internal static extern float GetFriction(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFriction@CollisionObject@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFriction(global::System.IntPtr instance, float* friction);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFrictionRolling@CollisionObject@acid@@QEBAMXZ")]
            internal static extern float GetFrictionRolling(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFrictionRolling@CollisionObject@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFrictionRolling(global::System.IntPtr instance, float* frictionRolling);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFrictionSpinning@CollisionObject@acid@@QEBAMXZ")]
            internal static extern float GetFrictionSpinning(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFrictionSpinning@CollisionObject@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFrictionSpinning(global::System.IntPtr instance, float* frictionSpinning);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsShapeCreated@CollisionObject@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetShapeCreated(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.CollisionObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.CollisionObjectInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.CollisionObject __CreateInstance(global::Acid.Sharp.CollisionObject.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.CollisionObjectInternal(native, skipVTables);
        }

        protected CollisionObject(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new collision object.</summary>
        /// <param name="friction">The amount of surface friction.</param>
        /// <param name="localTransform">The parent offset of the body.</param>
        protected CollisionObject(float friction)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.CollisionObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &friction;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.CollisionObject");
        }

        protected CollisionObject(global::Acid.Sharp.CollisionObject _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.CollisionObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.CollisionObject");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.CollisionObject.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets if the shape is partially in the view frustum.</summary>
        /// <param name="frustum">The view frustum.</param>
        public abstract bool InFrustum(global::Acid.Sharp.Frustum frustum);

        public global::Acid.Sharp.Force AddForce(global::Acid.Sharp.Force force)
        {
            var __arg0 = ReferenceEquals(force, null) ? global::System.IntPtr.Zero : force.__Instance;
            var __ret = __Internal.AddForce((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.Force __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Force.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Force) global::Acid.Sharp.Force.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Force.__CreateInstance(__ret);
            return __result0;
        }

        public abstract void ClearForces();

        public void SetChildTransform(global::Acid.Sharp.Collider child, global::Acid.Sharp.Transform transform)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            if (ReferenceEquals(transform, null))
                throw new global::System.ArgumentNullException("transform", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = transform.__Instance;
            __Internal.SetChildTransform((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public void AddChild(global::Acid.Sharp.Collider child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.AddChild((__Instance + __PointerAdjustment), __arg0);
        }

        public void RemoveChild(global::Acid.Sharp.Collider child)
        {
            var __arg0 = ReferenceEquals(child, null) ? global::System.IntPtr.Zero : child.__Instance;
            __Internal.RemoveChild((__Instance + __PointerAdjustment), __arg0);
        }

        public void SetIgnoreCollisionCheck(global::Acid.Sharp.CollisionObject other, bool ignore)
        {
            var __arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
            var __arg1 = &ignore;
            __Internal.SetIgnoreCollisionCheck((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        protected void CreateShape()
        {
            __Internal.CreateShape((__Instance + __PointerAdjustment));
        }

        protected abstract void RecalculateMass();

        protected float MFriction
        {
            get
            {
                return ((global::Acid.Sharp.CollisionObject.__Internal*) __Instance)->m_friction;
            }

            set
            {
                ((global::Acid.Sharp.CollisionObject.__Internal*)__Instance)->m_friction = value;
            }
        }

        protected float MFrictionRolling
        {
            get
            {
                return ((global::Acid.Sharp.CollisionObject.__Internal*) __Instance)->m_frictionRolling;
            }

            set
            {
                ((global::Acid.Sharp.CollisionObject.__Internal*)__Instance)->m_frictionRolling = value;
            }
        }

        protected float MFrictionSpinning
        {
            get
            {
                return ((global::Acid.Sharp.CollisionObject.__Internal*) __Instance)->m_frictionSpinning;
            }

            set
            {
                ((global::Acid.Sharp.CollisionObject.__Internal*)__Instance)->m_frictionSpinning = value;
            }
        }

        public float Friction
        {
            get
            {
                var __ret = __Internal.GetFriction((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFriction((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float FrictionRolling
        {
            get
            {
                var __ret = __Internal.GetFrictionRolling((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFrictionRolling((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float FrictionSpinning
        {
            get
            {
                var __ret = __Internal.GetFrictionSpinning((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFrictionSpinning((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool ShapeCreated
        {
            get
            {
                var __ret = __Internal.GetShapeCreated((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Start() { }
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.CollisionObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() { }
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.CollisionObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) { }
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.CollisionObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const { }
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.CollisionObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // bool InFrustum(const Frustum &frustum) = 0
        private static global::Delegates.Func_bool_IntPtr_IntPtr _InFrustumDelegateInstance;

        private static bool _InFrustumDelegateHook(global::System.IntPtr instance, global::System.IntPtr frustum)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.CollisionObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Frustum __result0;
            if (frustum == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Frustum.NativeToManagedMap.ContainsKey(frustum))
                __result0 = (global::Acid.Sharp.Frustum) global::Acid.Sharp.Frustum.NativeToManagedMap[frustum];
            else __result0 = global::Acid.Sharp.Frustum.__CreateInstance(frustum);
            var __ret = __target.InFrustum(__result0);
            return __ret;
        }

        // void ClearForces() = 0
        private static global::Delegates.Action_IntPtr _ClearForcesDelegateInstance;

        private static void _ClearForcesDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.CollisionObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ClearForces();
        }

        // void RecalculateMass() = 0
        private static global::Delegates.Action_IntPtr _RecalculateMassDelegateInstance;

        private static void _RecalculateMassDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.CollisionObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.RecalculateMass();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[7];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _InFrustumDelegateInstance += _InFrustumDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_InFrustumDelegateInstance).ToPointer();
                _ClearForcesDelegateInstance += _ClearForcesDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ClearForcesDelegateInstance).ToPointer();
                _RecalculateMassDelegateInstance += _RecalculateMassDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_RecalculateMassDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
                *(void**) (vfptr0 + 56) = _Thunks[6];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class CollisionObjectInternal : global::Acid.Sharp.CollisionObject, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.CollisionObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.CollisionObject.__Internal));
            *(global::Acid.Sharp.CollisionObject.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal CollisionObjectInternal(global::Acid.Sharp.CollisionObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal CollisionObjectInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Gets if the shape is partially in the view frustum.</summary>
        /// <param name="frustum">The view frustum.</param>
        public override bool InFrustum(global::Acid.Sharp.Frustum frustum)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___InFrustumDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(frustum, null))
                throw new global::System.ArgumentNullException("frustum", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frustum.__Instance;
            var __ret = ___InFrustumDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override void ClearForces()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___ClearForcesDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearForcesDelegate((__Instance + __PointerAdjustment));
        }

        protected override void RecalculateMass()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___RecalculateMassDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___RecalculateMassDelegate((__Instance + __PointerAdjustment));
        }
    }
}

public unsafe partial class BtRigidBody
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtRigidBody> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtRigidBody>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtRigidBody __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtRigidBody(native.ToPointer(), skipVTables);
    }

    internal static global::BtRigidBody __CreateInstance(global::BtRigidBody.__Internal native, bool skipVTables = false)
    {
        return new global::BtRigidBody(native, skipVTables);
    }

    private static void* __CopyValue(global::BtRigidBody.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtRigidBody.__Internal));
        *(global::BtRigidBody.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtRigidBody(global::BtRigidBody.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtRigidBody(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a object in a scene effected by physics.</summary>
    public unsafe partial class Rigidbody : global::Acid.Sharp.CollisionObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 200)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal float m_friction;

            [FieldOffset(28)]
            internal float m_frictionRolling;

            [FieldOffset(32)]
            internal float m_frictionSpinning;

            [FieldOffset(40)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionShape___N_std_S_default_delete__S0_ m_shape;

            [FieldOffset(48)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionObject___N_std_S_default_delete__S0_ m_body;

            [FieldOffset(56)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Force___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_forces;

            [FieldOffset(80)]
            internal global::Acid.Sharp.Observer.__Internalc__N_acid_S_Observer__p1___N_acid_S_CollisionObject m_collisionEvents;

            [FieldOffset(104)]
            internal global::Acid.Sharp.Observer.__Internalc__N_acid_S_Observer__p1___N_acid_S_CollisionObject m_separationEvents;

            [FieldOffset(128)]
            internal float m_mass;

            [FieldOffset(132)]
            internal global::Acid.Sharp.Vector3.__Internal m_gravity;

            [FieldOffset(144)]
            internal global::Acid.Sharp.Vector3.__Internal m_linearFactor;

            [FieldOffset(156)]
            internal global::Acid.Sharp.Vector3.__Internal m_angularFactor;

            [FieldOffset(168)]
            internal global::Acid.Sharp.Vector3.__Internal m_linearVelocity;

            [FieldOffset(180)]
            internal global::Acid.Sharp.Vector3.__Internal m_angularVelocity;

            [FieldOffset(192)]
            internal global::System.IntPtr m_rigidBody;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Rigidbody@acid@@QEAA@AEBM0AEBVVector3@1@1@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, float* mass, float* friction, global::System.IntPtr linearFactor, global::System.IntPtr angularFactor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Rigidbody@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Rigidbody@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMass@Rigidbody@acid@@QEBAMXZ")]
            internal static extern float GetMass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetMass@Rigidbody@acid@@QEAAXAEBM@Z")]
            internal static extern void SetMass(global::System.IntPtr instance, float* mass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGravity@Rigidbody@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetGravity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGravity@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetGravity(global::System.IntPtr instance, global::System.IntPtr gravity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLinearFactor@Rigidbody@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetLinearFactor(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLinearFactor@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLinearFactor(global::System.IntPtr instance, global::System.IntPtr linearFactor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAngularFactor@Rigidbody@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetAngularFactor(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAngularFactor@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetAngularFactor(global::System.IntPtr instance, global::System.IntPtr angularFactor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLinearVelocity@Rigidbody@acid@@QEBA?BVVector3@2@XZ")]
            internal static extern void GetLinearVelocity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLinearVelocity@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLinearVelocity(global::System.IntPtr instance, global::System.IntPtr linearVelocity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAngularVelocity@Rigidbody@acid@@QEBA?BVVector3@2@XZ")]
            internal static extern void GetAngularVelocity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAngularVelocity@Rigidbody@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetAngularVelocity(global::System.IntPtr instance, global::System.IntPtr angularVelocity);
        }

        internal static new global::Acid.Sharp.Rigidbody __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Rigidbody(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Rigidbody __CreateInstance(global::Acid.Sharp.Rigidbody.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Rigidbody(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Rigidbody.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Rigidbody.__Internal));
            global::Acid.Sharp.Rigidbody.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Rigidbody(global::Acid.Sharp.Rigidbody.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Rigidbody(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new rigidbody.</summary>
        /// <param name="mass">The mass of the object.</param>
        /// <param name="friction">The amount of surface friction.</param>
        /// <param name="linearFactor">How effected each axis (XYZ) will be to linear movement.</param>
        /// <param name="angularFactor">How effected each axis (XYZ) will be to angular movement.</param>
        public Rigidbody(float mass, float friction, global::Acid.Sharp.Vector3 linearFactor, global::Acid.Sharp.Vector3 angularFactor)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Rigidbody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &mass;
            var __arg1 = &friction;
            if (ReferenceEquals(linearFactor, null))
                throw new global::System.ArgumentNullException("linearFactor", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = linearFactor.__Instance;
            if (ReferenceEquals(angularFactor, null))
                throw new global::System.ArgumentNullException("angularFactor", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = angularFactor.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "Acid.Sharp.Rigidbody");
        }

        public Rigidbody(global::Acid.Sharp.Rigidbody _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Rigidbody.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Rigidbody");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Rigidbody.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public override bool InFrustum(global::Acid.Sharp.Frustum frustum)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___InFrustumDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr));
            if (ReferenceEquals(frustum, null))
                throw new global::System.ArgumentNullException("frustum", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = frustum.__Instance;
            var __ret = ___InFrustumDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override void ClearForces()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___ClearForcesDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearForcesDelegate((__Instance + __PointerAdjustment));
        }

        protected override void RecalculateMass()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
            var ___RecalculateMassDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___RecalculateMassDelegate((__Instance + __PointerAdjustment));
        }

        public float Mass
        {
            get
            {
                var __ret = __Internal.GetMass((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetMass((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 Gravity
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetGravity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetGravity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 LinearFactor
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetLinearFactor((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLinearFactor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 AngularFactor
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetAngularFactor((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAngularFactor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 LinearVelocity
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetLinearVelocity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLinearVelocity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector3 AngularVelocity
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetAngularVelocity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAngularVelocity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // bool InFrustum(const Frustum &frustum) override
        private static global::Delegates.Func_bool_IntPtr_IntPtr _InFrustumDelegateInstance;

        private static bool _InFrustumDelegateHook(global::System.IntPtr instance, global::System.IntPtr frustum)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Frustum __result0;
            if (frustum == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Frustum.NativeToManagedMap.ContainsKey(frustum))
                __result0 = (global::Acid.Sharp.Frustum) global::Acid.Sharp.Frustum.NativeToManagedMap[frustum];
            else __result0 = global::Acid.Sharp.Frustum.__CreateInstance(frustum);
            var __ret = __target.InFrustum(__result0);
            return __ret;
        }

        // void ClearForces() override
        private static global::Delegates.Action_IntPtr _ClearForcesDelegateInstance;

        private static void _ClearForcesDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ClearForces();
        }

        // void RecalculateMass() override
        private static global::Delegates.Action_IntPtr _RecalculateMassDelegateInstance;

        private static void _RecalculateMassDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Rigidbody) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.RecalculateMass();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[7];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _InFrustumDelegateInstance += _InFrustumDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_InFrustumDelegateInstance).ToPointer();
                _ClearForcesDelegateInstance += _ClearForcesDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_ClearForcesDelegateInstance).ToPointer();
                _RecalculateMassDelegateInstance += _RecalculateMassDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_RecalculateMassDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
                *(void**) (vfptr0 + 56) = _Thunks[6];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a loaded cubemap texture.</summary>
    public unsafe partial class Cubemap : global::Acid.Sharp.IResource, global::Acid.Sharp.IIDescriptor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 184)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IResource;

            [FieldOffset(8)]
            internal global::System.IntPtr vfptr_IDescriptor;

            [FieldOffset(16)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filename;

            [FieldOffset(48)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_fileSuffix;

            [FieldOffset(80)]
            internal global::VkFilter m_filter;

            [FieldOffset(84)]
            internal global::VkSamplerAddressMode m_addressMode;

            [FieldOffset(88)]
            internal byte m_anisotropic;

            [FieldOffset(92)]
            internal uint m_mipLevels;

            [FieldOffset(96)]
            internal global::VkSampleCountFlagBits m_samples;

            [FieldOffset(100)]
            internal global::VkImageLayout m_imageLayout;

            [FieldOffset(104)]
            internal uint m_components;

            [FieldOffset(108)]
            internal uint m_width;

            [FieldOffset(112)]
            internal uint m_height;

            [FieldOffset(120)]
            internal global::System.IntPtr m_image;

            [FieldOffset(128)]
            internal global::System.IntPtr m_deviceMemory;

            [FieldOffset(136)]
            internal global::System.IntPtr m_imageView;

            [FieldOffset(144)]
            internal global::System.IntPtr m_sampler;

            [FieldOffset(152)]
            internal global::VkFormat m_format;

            [FieldOffset(160)]
            internal global::VkDescriptorImageInfo.__Internal m_imageInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Cubemap@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Cubemap@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPixels@Cubemap@acid@@QEAAPEAEAEBI@Z")]
            internal static extern byte* GetPixels(global::System.IntPtr instance, uint* arrayLayer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPixels@Cubemap@acid@@QEAAPEAEXZ")]
            internal static extern byte* GetPixels(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPixels@Cubemap@acid@@QEAAXPEAE@Z")]
            internal static extern void SetPixels(global::System.IntPtr instance, byte* pixels);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFileSuffix@Cubemap@acid@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetFileSuffix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsAnisotropic@Cubemap@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetAnisotropic(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMipLevels@Cubemap@acid@@QEBAIXZ")]
            internal static extern uint GetMipLevels(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComponents@Cubemap@acid@@QEBAIXZ")]
            internal static extern uint GetComponents(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@Cubemap@acid@@QEBAIXZ")]
            internal static extern uint GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@Cubemap@acid@@QEBAIXZ")]
            internal static extern uint GetHeight(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Cubemap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Cubemap(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Cubemap __CreateInstance(global::Acid.Sharp.Cubemap.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Cubemap(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Cubemap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Cubemap.__Internal));
            global::Acid.Sharp.Cubemap.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Cubemap(global::Acid.Sharp.Cubemap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Cubemap(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8) };
        }

        public Cubemap(global::Acid.Sharp.Cubemap _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Cubemap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Cubemap");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IResource __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Cubemap.__Internal*) __Instance)->vfptr_IResource = new global::System.IntPtr(__OriginalVTables[0]);
            ((global::Acid.Sharp.Cubemap.__Internal*) __Instance)->vfptr_IDescriptor = new global::System.IntPtr(__OriginalVTables[1]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gets a copy of the face of a cubemaps pixels from memory, after usage is finished remember to delete the result.</summary>
        /// <param name="arrayLayer">The layer to copy from.</param>
        public byte* GetPixels(uint arrayLayer)
        {
            var __arg0 = &arrayLayer;
            var __ret = __Internal.GetPixels((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public global::System.IntPtr __PointerToIDescriptor
        {
            get
            {
                return __Instance + 8;
            }
        }

        /// <summary>Gets a copy of the cubemaps pixels from memory, after usage is finished remember to delete the result.</summary>
        /// <param name="pixels">The pixels to copy to the image.</param>
        /// <remarks>Copies the pixels into this cubemaps memory.</remarks>
        public byte* Pixels
        {
            get
            {
                var __ret = __Internal.GetPixels((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetPixels((__Instance + __PointerAdjustment), value);
            }
        }

        public override string Filename
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetFilenameDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                ___GetFilenameDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public string FileSuffix
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetFileSuffix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public bool Anisotropic
        {
            get
            {
                var __ret = __Internal.GetAnisotropic((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint MipLevels
        {
            get
            {
                var __ret = __Internal.GetMipLevels((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Components
        {
            get
            {
                var __ret = __Internal.GetComponents((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // std::string GetFilename() override { return m_filename; }
        private static global::Delegates.Action_IntPtr_IntPtr _GetFilenameDelegateInstance;

        private static void _GetFilenameDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Cubemap) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Filename;
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetFilenameDelegateInstance += _GetFilenameDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetFilenameDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[2];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                var vfptr1 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[1] = vfptr1.ToPointer();
                *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 0);
                *(void**) (vfptr1 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 8);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
            *(void**) (__Instance + 8) = __ManagedVTables[1];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public enum DeferredModel
    {
        DeferredIbl = 0,
        DeferredSimple = 1
    }

    public unsafe partial class RendererDeferred : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 880)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformScene;

            [FieldOffset(112)]
            internal global::Acid.Sharp.DeferredModel m_lightModel;

            [FieldOffset(120)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(784)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(800)]
            internal global::Std.SharedPtr.__Internal m_brdf;

            [FieldOffset(816)]
            internal global::Std.SharedPtr.__Internal m_skybox;

            [FieldOffset(832)]
            internal global::Std.SharedPtr.__Internal m_ibl;

            [FieldOffset(848)]
            internal global::Acid.Sharp.Fog.__Internal m_fog;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererDeferred@acid@@QEAA@AEBVGraphicsStage@1@AEBW4DeferredModel@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, global::Acid.Sharp.DeferredModel* lightModel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererDeferred@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RendererDeferred@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFog@RendererDeferred@acid@@QEBA?AVFog@2@XZ")]
            internal static extern void GetFog(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFog@RendererDeferred@acid@@QEAAXAEBVFog@2@@Z")]
            internal static extern void SetFog(global::System.IntPtr instance, global::System.IntPtr fog);
        }

        internal static new global::Acid.Sharp.RendererDeferred __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererDeferred(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RendererDeferred __CreateInstance(global::Acid.Sharp.RendererDeferred.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererDeferred(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RendererDeferred.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererDeferred.__Internal));
            global::Acid.Sharp.RendererDeferred.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererDeferred(global::Acid.Sharp.RendererDeferred.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererDeferred(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public RendererDeferred(global::Acid.Sharp.GraphicsStage graphicsStage, global::Acid.Sharp.DeferredModel* lightModel)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererDeferred.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, lightModel);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererDeferred");
        }

        public RendererDeferred(global::Acid.Sharp.RendererDeferred _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererDeferred.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererDeferred");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.RendererDeferred.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static uint MaxLights
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?MAX_LIGHTS@RendererDeferred@acid@@2IB");
                return *__ptr;
            }
        }

        public global::Acid.Sharp.Fog Fog
        {
            get
            {
                var __ret = new global::Acid.Sharp.Fog.__Internal();
                __Internal.GetFog((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Fog.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetFog((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.RendererDeferred) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A object used to manage s.</summary>
    public unsafe abstract partial class IManagerRender : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IManagerRender;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_RenderpassCreate___N_std_S_allocator__S0_ m_renderpassCreates;

            [FieldOffset(32)]
            internal byte m_started;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IManagerRender@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IManagerRender@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsStarted@IManagerRender@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetStarted(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStarted@IManagerRender@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetStarted(global::System.IntPtr instance, bool* started);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IManagerRender> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IManagerRender>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IManagerRender __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IManagerRenderInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IManagerRender __CreateInstance(global::Acid.Sharp.IManagerRender.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IManagerRenderInternal(native, skipVTables);
        }

        protected IManagerRender(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IManagerRender(global::Acid.Sharp.IManagerRender _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IManagerRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IManagerRender");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IManagerRender __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IManagerRender.__Internal*) __Instance)->vfptr_IManagerRender = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Run when starting the renderer manager.</summary>
        public abstract void Start();

        /// <summary>Run when updating the renderer manager.</summary>
        public abstract void Update();

        public bool Started
        {
            get
            {
                var __ret = __Internal.GetStarted((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStarted((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Start() = 0
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IManagerRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() = 0
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IManagerRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IManagerRenderInternal : global::Acid.Sharp.IManagerRender, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IManagerRender.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IManagerRender.__Internal));
            *(global::Acid.Sharp.IManagerRender.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IManagerRenderInternal(global::Acid.Sharp.IManagerRender.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IManagerRenderInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Run when starting the renderer manager.</summary>
        public override void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Run when updating the renderer manager.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A class that contains and manages renderers registered to a render manager.</summary>
    public unsafe partial class RendererRegister : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_acid_S_GraphicsStage___N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IRenderer___N_std_S_default_delete__S3____N_std_S_allocator__S2____N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S1_ m_stages;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererRegister@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererRegister@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RendererRegister@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Clear@RendererRegister@acid@@QEAAXXZ")]
            internal static extern void Clear(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddRenderer@RendererRegister@acid@@QEAAPEAVIRenderer@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddRenderer(global::System.IntPtr instance, global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveRenderer@RendererRegister@acid@@QEAA_NPEAVIRenderer@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveRenderer(global::System.IntPtr instance, global::System.IntPtr renderer);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RendererRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.RendererRegister>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.RendererRegister __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererRegister(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RendererRegister __CreateInstance(global::Acid.Sharp.RendererRegister.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererRegister(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RendererRegister.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererRegister.__Internal));
            global::Acid.Sharp.RendererRegister.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererRegister(global::Acid.Sharp.RendererRegister.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RendererRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public RendererRegister(global::Acid.Sharp.RendererRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.RendererRegister __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Clear()
        {
            __Internal.Clear((__Instance + __PointerAdjustment));
        }

        /// <summary>Adds a renderer to this register.</summary>
        /// <param name="renderer">The renderer to add.</param>
        public global::Acid.Sharp.IRenderer AddRenderer(global::Acid.Sharp.IRenderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.AddRenderer((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.IRenderer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IRenderer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IRenderer) global::Acid.Sharp.IRenderer.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IRenderer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Removes a renderer from this register.</summary>
        /// <param name="renderer">The renderer to remove.</param>
        public bool RemoveRenderer(global::Acid.Sharp.IRenderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RemoveRenderer((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Renderer : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IManagerRender___N_std_S_default_delete__S0_ m_managerRender;

            [FieldOffset(16)]
            internal global::Acid.Sharp.RendererRegister.__Internal m_rendererRegister;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_RenderStage___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_renderStages;

            [FieldOffset(56)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Swapchain___N_std_S_default_delete__S0_ m_swapchain;

            [FieldOffset(64)]
            internal global::System.IntPtr m_fenceSwapchainImage;

            [FieldOffset(72)]
            internal uint m_activeSwapchainImage;

            [FieldOffset(80)]
            internal global::System.IntPtr m_pipelineCache;

            [FieldOffset(88)]
            internal global::System.IntPtr m_semaphore;

            [FieldOffset(96)]
            internal global::System.IntPtr m_commandPool;

            [FieldOffset(104)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_CommandBuffer___N_std_S_default_delete__S0_ m_commandBuffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Renderer@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Renderer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Renderer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Renderer@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CaptureScreenshot@Renderer@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void CaptureScreenshot(global::System.IntPtr instance, global::System.IntPtr filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?AddRenderer@Renderer@acid@@QEAAPEAVIRenderer@2@PEAV32@@Z")]
            internal static extern global::System.IntPtr AddRenderer(global::System.IntPtr instance, global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveRenderer@Renderer@acid@@QEAA_NPEAVIRenderer@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveRenderer(global::System.IntPtr instance, global::System.IntPtr renderer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetRenderStage@Renderer@acid@@QEBAPEAVRenderStage@2@AEBI@Z")]
            internal static extern global::System.IntPtr GetRenderStage(global::System.IntPtr instance, uint* index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttachment@Renderer@acid@@QEBAPEAVIDescriptor@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr GetAttachment(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetManager@Renderer@acid@@QEBAPEAVIManagerRender@2@XZ")]
            internal static extern global::System.IntPtr GetManager(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetManager@Renderer@acid@@QEAAXPEAVIManagerRender@2@@Z")]
            internal static extern void SetManager(global::System.IntPtr instance, global::System.IntPtr managerRender);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSwapchain@Renderer@acid@@QEBAPEAVSwapchain@2@XZ")]
            internal static extern global::System.IntPtr GetSwapchain(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCommandBuffer@Renderer@acid@@QEBAPEAVCommandBuffer@2@XZ")]
            internal static extern global::System.IntPtr GetCommandBuffer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetActiveSwapchainImage@Renderer@acid@@QEBAIXZ")]
            internal static extern uint GetActiveSwapchainImage(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Renderer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Renderer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Renderer __CreateInstance(global::Acid.Sharp.Renderer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Renderer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Renderer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Renderer.__Internal));
            global::Acid.Sharp.Renderer.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Renderer(global::Acid.Sharp.Renderer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Renderer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Renderer()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Renderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Renderer");
        }

        public Renderer(global::Acid.Sharp.Renderer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Renderer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Renderer");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Renderer.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Takes a screenshot of the current image of the display and saves it into a image file.</summary>
        /// <param name="filename">The file to save the screenshot to.</param>
        public void CaptureScreenshot(string filename)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.CaptureScreenshot((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>Adds a renderer to this register.</summary>
        /// <param name="renderer">The renderer to add.</param>
        public global::Acid.Sharp.IRenderer AddRenderer(global::Acid.Sharp.IRenderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.AddRenderer((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.IRenderer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IRenderer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IRenderer) global::Acid.Sharp.IRenderer.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IRenderer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Removes a renderer from this register.</summary>
        /// <param name="renderer">The renderer to remove.</param>
        public bool RemoveRenderer(global::Acid.Sharp.IRenderer renderer)
        {
            var __arg0 = ReferenceEquals(renderer, null) ? global::System.IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.RemoveRenderer((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public global::Acid.Sharp.RenderStage GetRenderStage(uint index)
        {
            var __arg0 = &index;
            var __ret = __Internal.GetRenderStage((__Instance + __PointerAdjustment), __arg0);
            global::Acid.Sharp.RenderStage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.RenderStage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.RenderStage) global::Acid.Sharp.RenderStage.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.RenderStage.__CreateInstance(__ret);
            return __result0;
        }

        public global::Acid.Sharp.IIDescriptor GetAttachment(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetAttachment((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.IIDescriptor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IDescriptor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IIDescriptor) global::Acid.Sharp.IDescriptor.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IDescriptor.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Renderer Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Renderer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Renderer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Renderer) global::Acid.Sharp.Renderer.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Renderer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the renderer manager.</summary>
        /// <param name="rendererMaster">The new renderer manager.</param>
        /// <remarks>Sets the current renderer manager to a new renderer manager.</remarks>
        public global::Acid.Sharp.IManagerRender Manager
        {
            get
            {
                var __ret = __Internal.GetManager((__Instance + __PointerAdjustment));
                global::Acid.Sharp.IManagerRender __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.IManagerRender.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.IManagerRender) global::Acid.Sharp.IManagerRender.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.IManagerRender.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetManager((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Swapchain Swapchain
        {
            get
            {
                var __ret = __Internal.GetSwapchain((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Swapchain __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Swapchain.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Swapchain) global::Acid.Sharp.Swapchain.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Swapchain.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.CommandBuffer CommandBuffer
        {
            get
            {
                var __ret = __Internal.GetCommandBuffer((__Instance + __PointerAdjustment));
                global::Acid.Sharp.CommandBuffer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint ActiveSwapchainImage
        {
            get
            {
                var __ret = __Internal.GetActiveSwapchainImage((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Renderer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a post effect shader and on application saves the result into a FBO.</summary>
    public unsafe abstract partial class IPostFilter : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 768)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPostFilter@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IPostFilter@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttachment@IPostFilter@acid@@QEBAPEAVIDescriptor@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAV32@@Z")]
            internal static extern global::System.IntPtr GetAttachment(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAttachment@IPostFilter@acid@@QEBAPEAVIDescriptor@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z")]
            internal static extern global::System.IntPtr GetAttachment_1(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr rendererAttachment);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAttachment@IPostFilter@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVIDescriptor@2@@Z")]
            internal static extern void SetAttachment(global::System.IntPtr instance, global::System.IntPtr descriptorName, global::System.IntPtr descriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?RemoveAttachment@IPostFilter@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveAttachment(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PushConditional@IPostFilter@acid@@IEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@000@Z")]
            internal static extern void PushConditional(global::System.IntPtr instance, global::System.IntPtr descriptorName1, global::System.IntPtr descriptorName2, global::System.IntPtr rendererAttachment1, global::System.IntPtr rendererAttachment2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDescriptorSet@IPostFilter@acid@@QEBAAEBVDescriptorsHandler@2@XZ")]
            internal static extern global::System.IntPtr GetDescriptorSet(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipeline@IPostFilter@acid@@QEBAAEBVPipeline@2@XZ")]
            internal static extern global::System.IntPtr GetPipeline(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.IPostFilter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IPostFilterInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IPostFilter __CreateInstance(global::Acid.Sharp.IPostFilter.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IPostFilterInternal(native, skipVTables);
        }

        protected IPostFilter(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IPostFilter(global::Acid.Sharp.IPostFilter _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPostFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IPostFilter");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IPostFilter.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override abstract void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera);

        public global::Acid.Sharp.IIDescriptor GetAttachment(string descriptorName, global::Acid.Sharp.IIDescriptor descriptor)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(descriptor, null) ? global::System.IntPtr.Zero : descriptor.__PointerToIDescriptor;
            var __ret = __Internal.GetAttachment((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.IIDescriptor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IDescriptor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IIDescriptor) global::Acid.Sharp.IDescriptor.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IDescriptor.__CreateInstance(__ret);
            return __result0;
        }

        public global::Acid.Sharp.IIDescriptor GetAttachment(string descriptorName, string rendererAttachment)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(rendererAttachment, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.GetAttachment_1((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            global::Acid.Sharp.IIDescriptor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IDescriptor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IIDescriptor) global::Acid.Sharp.IDescriptor.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IDescriptor.__CreateInstance(__ret);
            return __result0;
        }

        public void SetAttachment(string descriptorName, global::Acid.Sharp.IIDescriptor descriptor)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = ReferenceEquals(descriptor, null) ? global::System.IntPtr.Zero : descriptor.__PointerToIDescriptor;
            __Internal.SetAttachment((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public bool RemoveAttachment(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.RemoveAttachment((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Used instead of `m_descriptorSet.Push()` in instances where a writeColour is the same as samplerColour in a shader. By switching between what will be the input and output of each filter previous changes are available to the shader.</summary>
        /// <param name="descriptorName1">The first descriptor in the shader.</param>
        /// <param name="descriptorName2">The second descriptor in the shader.</param>
        /// <param name="rendererAttachment1">The name of the renderers attachment that will be first option.</param>
        /// <param name="rendererAttachment2">The name of the renderers attachment that will be second option.</param>
        protected void PushConditional(string descriptorName1, string descriptorName2, string rendererAttachment1, string rendererAttachment2)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(descriptorName1, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(descriptorName2, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(rendererAttachment1, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __allocator3 = new global::Std.Allocator<char>();
            var __basicString3 = global::Std.BasicStringExtensions.BasicString(rendererAttachment2, __allocator3);
            var __arg3 = __basicString3.__Instance;
            __Internal.PushConditional((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            __basicString3.Dispose(false);
            __allocator3.Dispose();
        }

        protected global::Acid.Sharp.DescriptorsHandler MDescriptorSet
        {
            get
            {
                return global::Acid.Sharp.DescriptorsHandler.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.IPostFilter.__Internal*) __Instance)->m_descriptorSet));
            }

            set
            {
                ((global::Acid.Sharp.IPostFilter.__Internal*)__Instance)->m_descriptorSet = ReferenceEquals(value, null) ? new global::Acid.Sharp.DescriptorsHandler.__Internal() : *(global::Acid.Sharp.DescriptorsHandler.__Internal*) value.__Instance;
            }
        }

        protected global::Acid.Sharp.Pipeline MPipeline
        {
            get
            {
                return global::Acid.Sharp.Pipeline.__CreateInstance(new global::System.IntPtr(&((global::Acid.Sharp.IPostFilter.__Internal*) __Instance)->m_pipeline));
            }

            set
            {
                ((global::Acid.Sharp.IPostFilter.__Internal*)__Instance)->m_pipeline = ReferenceEquals(value, null) ? new global::Acid.Sharp.Pipeline.__Internal() : *(global::Acid.Sharp.Pipeline.__Internal*) value.__Instance;
            }
        }

        public global::Acid.Sharp.DescriptorsHandler DescriptorSet
        {
            get
            {
                var __ret = __Internal.GetDescriptorSet((__Instance + __PointerAdjustment));
                global::Acid.Sharp.DescriptorsHandler __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.DescriptorsHandler) global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.DescriptorsHandler.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.Pipeline Pipeline
        {
            get
            {
                var __ret = __Internal.GetPipeline((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Pipeline __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Pipeline.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Pipeline) global::Acid.Sharp.Pipeline.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Pipeline.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override = 0
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IPostFilter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IPostFilterInternal : global::Acid.Sharp.IPostFilter, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IPostFilter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPostFilter.__Internal));
            *(global::Acid.Sharp.IPostFilter.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IPostFilterInternal(global::Acid.Sharp.IPostFilter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IPostFilterInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }
    }
}

namespace Acid.Sharp
{
    public enum BlurType
    {
        _5 = 5,
        _9 = 9,
        _13 = 13
    }

    public unsafe partial class FilterBlur : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 808)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal global::Acid.Sharp.BlurType m_blurType;

            [FieldOffset(796)]
            internal global::Acid.Sharp.Vector2.__Internal m_direction;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterBlur@acid@@QEAA@AEBVGraphicsStage@1@AEBVVector2@1@AEBW4BlurType@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, global::System.IntPtr direction, global::Acid.Sharp.BlurType* blurType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterBlur@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterBlur@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDirection@FilterBlur@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetDirection(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetDirection@FilterBlur@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetDirection(global::System.IntPtr instance, global::System.IntPtr direction);
        }

        internal static new global::Acid.Sharp.FilterBlur __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterBlur(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterBlur __CreateInstance(global::Acid.Sharp.FilterBlur.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterBlur(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterBlur.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterBlur.__Internal));
            global::Acid.Sharp.FilterBlur.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterBlur(global::Acid.Sharp.FilterBlur.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterBlur(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterBlur(global::Acid.Sharp.GraphicsStage graphicsStage, global::Acid.Sharp.Vector2 direction, global::Acid.Sharp.BlurType* blurType)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterBlur.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            if (ReferenceEquals(direction, null))
                throw new global::System.ArgumentNullException("direction", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = direction.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, blurType);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterBlur");
        }

        public FilterBlur(global::Acid.Sharp.FilterBlur _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterBlur.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterBlur");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterBlur.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public global::Acid.Sharp.Vector2 Direction
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetDirection((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetDirection((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterBlur) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterCrt : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 824)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal global::Acid.Sharp.Colour.__Internal m_screenColour;

            [FieldOffset(808)]
            internal float m_curveAmountX;

            [FieldOffset(812)]
            internal float m_curveAmountY;

            [FieldOffset(816)]
            internal float m_scanLineSize;

            [FieldOffset(820)]
            internal float m_scanIntensity;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterCrt@acid@@QEAA@AEBVGraphicsStage@1@AEBVColour@1@AEBM222@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, global::System.IntPtr screenColour, float* curveAmountX, float* curveAmountY, float* scanLineSize, float* scanIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterCrt@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterCrt@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScreenColour@FilterCrt@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetScreenColour(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScreenColour@FilterCrt@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetScreenColour(global::System.IntPtr instance, global::System.IntPtr screenColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurveAmountX@FilterCrt@acid@@QEBAMXZ")]
            internal static extern float GetCurveAmountX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCurveAmountX@FilterCrt@acid@@QEAAXAEBM@Z")]
            internal static extern void SetCurveAmountX(global::System.IntPtr instance, float* curveAmountX);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCurveAmountY@FilterCrt@acid@@QEBAMXZ")]
            internal static extern float GetCurveAmountY(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCurveAmountY@FilterCrt@acid@@QEAAXAEBM@Z")]
            internal static extern void SetCurveAmountY(global::System.IntPtr instance, float* curveAmountY);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScanLineSize@FilterCrt@acid@@QEBAMXZ")]
            internal static extern float GetScanLineSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScanLineSize@FilterCrt@acid@@QEAAXAEBM@Z")]
            internal static extern void SetScanLineSize(global::System.IntPtr instance, float* scanLineSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScanIntensity@FilterCrt@acid@@QEBAMXZ")]
            internal static extern float GetScanIntensity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScanIntensity@FilterCrt@acid@@QEAAXAEBM@Z")]
            internal static extern void SetScanIntensity(global::System.IntPtr instance, float* scanIntensity);
        }

        internal static new global::Acid.Sharp.FilterCrt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterCrt(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterCrt __CreateInstance(global::Acid.Sharp.FilterCrt.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterCrt(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterCrt.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterCrt.__Internal));
            global::Acid.Sharp.FilterCrt.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterCrt(global::Acid.Sharp.FilterCrt.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterCrt(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterCrt(global::Acid.Sharp.GraphicsStage graphicsStage, global::Acid.Sharp.Colour screenColour, float curveAmountX, float curveAmountY, float scanLineSize, float scanIntensity)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterCrt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            if (ReferenceEquals(screenColour, null))
                throw new global::System.ArgumentNullException("screenColour", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = screenColour.__Instance;
            var __arg2 = &curveAmountX;
            var __arg3 = &curveAmountY;
            var __arg4 = &scanLineSize;
            var __arg5 = &scanIntensity;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterCrt");
        }

        public FilterCrt(global::Acid.Sharp.FilterCrt _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterCrt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterCrt");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterCrt.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public global::Acid.Sharp.Colour ScreenColour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetScreenColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetScreenColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float CurveAmountX
        {
            get
            {
                var __ret = __Internal.GetCurveAmountX((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetCurveAmountX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float CurveAmountY
        {
            get
            {
                var __ret = __Internal.GetCurveAmountY((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetCurveAmountY((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ScanLineSize
        {
            get
            {
                var __ret = __Internal.GetScanLineSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetScanLineSize((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ScanIntensity
        {
            get
            {
                var __ret = __Internal.GetScanIntensity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetScanIntensity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterCrt) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterDarken : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 800)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal float m_factor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDarken@acid@@QEAA@AEBVGraphicsStage@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDarken@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterDarken@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFactor@FilterDarken@acid@@QEBAMXZ")]
            internal static extern float GetFactor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFactor@FilterDarken@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFactor(global::System.IntPtr instance, float* factor);
        }

        internal static new global::Acid.Sharp.FilterDarken __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterDarken(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterDarken __CreateInstance(global::Acid.Sharp.FilterDarken.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterDarken(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterDarken.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDarken.__Internal));
            global::Acid.Sharp.FilterDarken.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterDarken(global::Acid.Sharp.FilterDarken.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterDarken(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterDarken(global::Acid.Sharp.GraphicsStage graphicsStage, float factor)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDarken.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &factor;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterDarken");
        }

        public FilterDarken(global::Acid.Sharp.FilterDarken _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDarken.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterDarken");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterDarken.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float Factor
        {
            get
            {
                var __ret = __Internal.GetFactor((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFactor((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterDarken) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterDefault : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 776)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal byte m_lastFilter;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDefault@acid@@QEAA@AEBVGraphicsStage@1@AEB_N@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, bool* lastFilter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDefault@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterDefault@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FilterDefault __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterDefault(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterDefault __CreateInstance(global::Acid.Sharp.FilterDefault.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterDefault(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterDefault.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDefault.__Internal));
            global::Acid.Sharp.FilterDefault.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterDefault(global::Acid.Sharp.FilterDefault.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterDefault(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterDefault(global::Acid.Sharp.GraphicsStage graphicsStage, bool lastFilter)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDefault.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &lastFilter;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterDefault");
        }

        public FilterDefault(global::Acid.Sharp.FilterDefault _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDefault.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterDefault");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterDefault.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterDefault) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents a system of post effects.</summary>
    public unsafe abstract partial class IPostPipeline : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPostPipeline@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IPostPipeline@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::Acid.Sharp.IPostPipeline __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IPostPipelineInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IPostPipeline __CreateInstance(global::Acid.Sharp.IPostPipeline.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IPostPipelineInternal(native, skipVTables);
        }

        protected IPostPipeline(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new post pipeline.</summary>
        /// <param name="graphicsStage">The pipelines graphics stage.</param>
        protected IPostPipeline(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPostPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IPostPipeline");
        }

        protected IPostPipeline(global::Acid.Sharp.IPostPipeline _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPostPipeline.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IPostPipeline");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IPostPipeline.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Renders the post pipeline.</summary>
        public override abstract void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera);

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override = 0
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IPostPipeline) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IPostPipelineInternal : global::Acid.Sharp.IPostPipeline, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IPostPipeline.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IPostPipeline.__Internal));
            *(global::Acid.Sharp.IPostPipeline.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IPostPipelineInternal(global::Acid.Sharp.IPostPipeline.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IPostPipelineInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Renders the post pipeline.</summary>
        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class PipelineBlur : global::Acid.Sharp.IPostPipeline, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1672)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.FilterBlur.__Internal m_filterBlurVertical;

            [FieldOffset(832)]
            internal global::Acid.Sharp.FilterBlur.__Internal m_filterBlurHorizontal;

            [FieldOffset(1640)]
            internal byte m_toScreen;

            [FieldOffset(1644)]
            internal float m_inputScale;

            [FieldOffset(1648)]
            internal float m_outputScale;

            [FieldOffset(1652)]
            internal float m_blur;

            [FieldOffset(1656)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Texture___N_std_S_default_delete__S0_ m_output;

            [FieldOffset(1664)]
            internal uint m_lastWidth;

            [FieldOffset(1668)]
            internal uint m_lastHeight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineBlur@acid@@QEAA@AEBVGraphicsStage@1@AEBMAEBW4BlurType@1@AEB_N11@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* blur, global::Acid.Sharp.BlurType* blurType, bool* toScreen, float* inputScale, float* outputScale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0PipelineBlur@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1PipelineBlur@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInputScale@PipelineBlur@acid@@QEBAMXZ")]
            internal static extern float GetInputScale(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInputScale@PipelineBlur@acid@@QEAAXAEBM@Z")]
            internal static extern void SetInputScale(global::System.IntPtr instance, float* inputScale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOutputScale@PipelineBlur@acid@@QEBAMXZ")]
            internal static extern float GetOutputScale(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetOutputScale@PipelineBlur@acid@@QEAAXAEBM@Z")]
            internal static extern void SetOutputScale(global::System.IntPtr instance, float* outputScale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBlur@PipelineBlur@acid@@QEBAMXZ")]
            internal static extern float GetBlur(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBlur@PipelineBlur@acid@@QEAAXAEBM@Z")]
            internal static extern void SetBlur(global::System.IntPtr instance, float* blur);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOutput@PipelineBlur@acid@@QEBAPEAVTexture@2@XZ")]
            internal static extern global::System.IntPtr GetOutput(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.PipelineBlur __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineBlur(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.PipelineBlur __CreateInstance(global::Acid.Sharp.PipelineBlur.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.PipelineBlur(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.PipelineBlur.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineBlur.__Internal));
            global::Acid.Sharp.PipelineBlur.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private PipelineBlur(global::Acid.Sharp.PipelineBlur.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PipelineBlur(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public PipelineBlur(global::Acid.Sharp.GraphicsStage graphicsStage, float blur, global::Acid.Sharp.BlurType* blurType, bool toScreen, float inputScale, float outputScale)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineBlur.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &blur;
            var __arg3 = &toScreen;
            var __arg4 = &inputScale;
            var __arg5 = &outputScale;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, blurType, __arg3, __arg4, __arg5);
            SetupVTables(GetType().FullName == "Acid.Sharp.PipelineBlur");
        }

        public PipelineBlur(global::Acid.Sharp.PipelineBlur _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.PipelineBlur.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.PipelineBlur");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.PipelineBlur.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float InputScale
        {
            get
            {
                var __ret = __Internal.GetInputScale((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetInputScale((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float OutputScale
        {
            get
            {
                var __ret = __Internal.GetOutputScale((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetOutputScale((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Blur
        {
            get
            {
                var __ret = __Internal.GetBlur((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetBlur((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Texture Output
        {
            get
            {
                var __ret = __Internal.GetOutput((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Texture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Texture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Texture) global::Acid.Sharp.Texture.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Texture.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.PipelineBlur) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterDof : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 824)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal global::System.IntPtr m_pipelineBlur;

            [FieldOffset(800)]
            internal float m_focusPoint;

            [FieldOffset(804)]
            internal float m_nearField;

            [FieldOffset(808)]
            internal float m_nearTransition;

            [FieldOffset(812)]
            internal float m_farField;

            [FieldOffset(816)]
            internal float m_farTransition;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDof@acid@@QEAA@AEBVGraphicsStage@1@PEAVPipelineBlur@1@AEBM2222@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, global::System.IntPtr pipelineBlur, float* focusPoint, float* nearField, float* nearTransition, float* farField, float* farTransition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterDof@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterDof@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPipelineBlur@FilterDof@acid@@QEBAPEAVPipelineBlur@2@XZ")]
            internal static extern global::System.IntPtr GetPipelineBlur(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPipelineBlur@FilterDof@acid@@QEAAXPEAVPipelineBlur@2@@Z")]
            internal static extern void SetPipelineBlur(global::System.IntPtr instance, global::System.IntPtr pipelineBlur);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFocusPoint@FilterDof@acid@@QEBAMXZ")]
            internal static extern float GetFocusPoint(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFocusPoint@FilterDof@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFocusPoint(global::System.IntPtr instance, float* focusPoint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNearField@FilterDof@acid@@QEBAMXZ")]
            internal static extern float GetNearField(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNearField@FilterDof@acid@@QEAAXAEBM@Z")]
            internal static extern void SetNearField(global::System.IntPtr instance, float* nearField);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetNearTransition@FilterDof@acid@@QEBAMXZ")]
            internal static extern float GetNearTransition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetNearTransition@FilterDof@acid@@QEAAXAEBM@Z")]
            internal static extern void SetNearTransition(global::System.IntPtr instance, float* nearTransition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFarField@FilterDof@acid@@QEBAMXZ")]
            internal static extern float GetFarField(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFarField@FilterDof@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFarField(global::System.IntPtr instance, float* farField);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFarTransition@FilterDof@acid@@QEBAMXZ")]
            internal static extern float GetFarTransition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFarTransition@FilterDof@acid@@QEAAXAEBM@Z")]
            internal static extern void SetFarTransition(global::System.IntPtr instance, float* farTransition);
        }

        internal static new global::Acid.Sharp.FilterDof __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterDof(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterDof __CreateInstance(global::Acid.Sharp.FilterDof.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterDof(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterDof.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDof.__Internal));
            global::Acid.Sharp.FilterDof.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterDof(global::Acid.Sharp.FilterDof.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterDof(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterDof(global::Acid.Sharp.GraphicsStage graphicsStage, global::Acid.Sharp.PipelineBlur pipelineBlur, float focusPoint, float nearField, float nearTransition, float farField, float farTransition)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDof.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = ReferenceEquals(pipelineBlur, null) ? global::System.IntPtr.Zero : pipelineBlur.__Instance;
            var __arg2 = &focusPoint;
            var __arg3 = &nearField;
            var __arg4 = &nearTransition;
            var __arg5 = &farField;
            var __arg6 = &farTransition;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterDof");
        }

        public FilterDof(global::Acid.Sharp.FilterDof _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterDof.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterDof");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterDof.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public global::Acid.Sharp.PipelineBlur PipelineBlur
        {
            get
            {
                var __ret = __Internal.GetPipelineBlur((__Instance + __PointerAdjustment));
                global::Acid.Sharp.PipelineBlur __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.PipelineBlur.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.PipelineBlur) global::Acid.Sharp.PipelineBlur.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.PipelineBlur.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetPipelineBlur((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float FocusPoint
        {
            get
            {
                var __ret = __Internal.GetFocusPoint((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFocusPoint((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float NearField
        {
            get
            {
                var __ret = __Internal.GetNearField((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetNearField((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float NearTransition
        {
            get
            {
                var __ret = __Internal.GetNearTransition((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetNearTransition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float FarField
        {
            get
            {
                var __ret = __Internal.GetFarField((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFarField((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float FarTransition
        {
            get
            {
                var __ret = __Internal.GetFarTransition((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetFarTransition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterDof) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterEmboss : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 768)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterEmboss@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterEmboss@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterEmboss@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FilterEmboss __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterEmboss(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterEmboss __CreateInstance(global::Acid.Sharp.FilterEmboss.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterEmboss(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterEmboss.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterEmboss.__Internal));
            global::Acid.Sharp.FilterEmboss.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterEmboss(global::Acid.Sharp.FilterEmboss.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterEmboss(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterEmboss(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterEmboss.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterEmboss");
        }

        public FilterEmboss(global::Acid.Sharp.FilterEmboss _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterEmboss.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterEmboss");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterEmboss.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.FilterEmboss(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.FilterEmboss(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterEmboss) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterFxaa : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 800)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal float m_spanMax;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterFxaa@acid@@QEAA@AEBVGraphicsStage@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* spanMax);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterFxaa@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterFxaa@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSpanMax@FilterFxaa@acid@@QEBAMXZ")]
            internal static extern float GetSpanMax(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSpanMax@FilterFxaa@acid@@QEAAXAEBM@Z")]
            internal static extern void SetSpanMax(global::System.IntPtr instance, float* spanMax);
        }

        internal static new global::Acid.Sharp.FilterFxaa __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterFxaa(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterFxaa __CreateInstance(global::Acid.Sharp.FilterFxaa.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterFxaa(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterFxaa.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterFxaa.__Internal));
            global::Acid.Sharp.FilterFxaa.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterFxaa(global::Acid.Sharp.FilterFxaa.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterFxaa(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterFxaa(global::Acid.Sharp.GraphicsStage graphicsStage, float spanMax)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterFxaa.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &spanMax;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterFxaa");
        }

        public FilterFxaa(global::Acid.Sharp.FilterFxaa _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterFxaa.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterFxaa");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterFxaa.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float SpanMax
        {
            get
            {
                var __ret = __Internal.GetSpanMax((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetSpanMax((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterFxaa) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterGrain : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 800)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal float m_strength;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrain@acid@@QEAA@AEBVGraphicsStage@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* strength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrain@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterGrain@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStrength@FilterGrain@acid@@QEBAMXZ")]
            internal static extern float GetStrength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStrength@FilterGrain@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStrength(global::System.IntPtr instance, float* strength);
        }

        internal static new global::Acid.Sharp.FilterGrain __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterGrain(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterGrain __CreateInstance(global::Acid.Sharp.FilterGrain.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterGrain(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterGrain.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterGrain.__Internal));
            global::Acid.Sharp.FilterGrain.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterGrain(global::Acid.Sharp.FilterGrain.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterGrain(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterGrain(global::Acid.Sharp.GraphicsStage graphicsStage, float strength)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterGrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &strength;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterGrain");
        }

        public FilterGrain(global::Acid.Sharp.FilterGrain _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterGrain.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterGrain");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterGrain.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float Strength
        {
            get
            {
                var __ret = __Internal.GetStrength((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStrength((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterGrain) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterGrey : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 768)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrey@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterGrey@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterGrey@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FilterGrey __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterGrey(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterGrey __CreateInstance(global::Acid.Sharp.FilterGrey.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterGrey(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterGrey.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterGrey.__Internal));
            global::Acid.Sharp.FilterGrey.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterGrey(global::Acid.Sharp.FilterGrey.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterGrey(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterGrey(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterGrey.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterGrey");
        }

        public FilterGrey(global::Acid.Sharp.FilterGrey _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterGrey.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterGrey");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterGrey.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.FilterGrey(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.FilterGrey(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterGrey) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterLensflare : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 808)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal global::Acid.Sharp.Vector3.__Internal m_sunPosition;

            [FieldOffset(804)]
            internal float m_sunHeight;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterLensflare@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterLensflare@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterLensflare@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunPosition@FilterLensflare@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetSunPosition(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSunPosition@FilterLensflare@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetSunPosition(global::System.IntPtr instance, global::System.IntPtr sunPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSunHeight@FilterLensflare@acid@@QEBAMXZ")]
            internal static extern float GetSunHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSunHeight@FilterLensflare@acid@@QEAAXAEBM@Z")]
            internal static extern void SetSunHeight(global::System.IntPtr instance, float* sunHeight);
        }

        internal static new global::Acid.Sharp.FilterLensflare __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterLensflare(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterLensflare __CreateInstance(global::Acid.Sharp.FilterLensflare.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterLensflare(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterLensflare.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterLensflare.__Internal));
            global::Acid.Sharp.FilterLensflare.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterLensflare(global::Acid.Sharp.FilterLensflare.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterLensflare(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterLensflare(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterLensflare.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterLensflare");
        }

        public FilterLensflare(global::Acid.Sharp.FilterLensflare _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterLensflare.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterLensflare");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterLensflare.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.FilterLensflare(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.FilterLensflare(graphicsStage);
        }

        public global::Acid.Sharp.Vector3 SunPosition
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetSunPosition((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetSunPosition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float SunHeight
        {
            get
            {
                var __ret = __Internal.GetSunHeight((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetSunHeight((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterLensflare) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterNegative : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 768)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterNegative@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterNegative@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterNegative@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FilterNegative __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterNegative(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterNegative __CreateInstance(global::Acid.Sharp.FilterNegative.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterNegative(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterNegative.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterNegative.__Internal));
            global::Acid.Sharp.FilterNegative.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterNegative(global::Acid.Sharp.FilterNegative.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterNegative(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterNegative(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterNegative.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterNegative");
        }

        public FilterNegative(global::Acid.Sharp.FilterNegative _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterNegative.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterNegative");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterNegative.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.FilterNegative(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.FilterNegative(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterNegative) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterPixel : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 800)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal float m_pixelSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterPixel@acid@@QEAA@AEBVGraphicsStage@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* pixelSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterPixel@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterPixel@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPixelSize@FilterPixel@acid@@QEBAMXZ")]
            internal static extern float GetPixelSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPixelSize@FilterPixel@acid@@QEAAXAEBM@Z")]
            internal static extern void SetPixelSize(global::System.IntPtr instance, float* pixelSize);
        }

        internal static new global::Acid.Sharp.FilterPixel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterPixel(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterPixel __CreateInstance(global::Acid.Sharp.FilterPixel.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterPixel(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterPixel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterPixel.__Internal));
            global::Acid.Sharp.FilterPixel.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterPixel(global::Acid.Sharp.FilterPixel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterPixel(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterPixel(global::Acid.Sharp.GraphicsStage graphicsStage, float pixelSize)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterPixel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &pixelSize;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterPixel");
        }

        public FilterPixel(global::Acid.Sharp.FilterPixel _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterPixel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterPixel");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterPixel.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float PixelSize
        {
            get
            {
                var __ret = __Internal.GetPixelSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetPixelSize((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterPixel) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterSepia : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 768)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterSepia@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterSepia@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterSepia@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FilterSepia __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterSepia(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterSepia __CreateInstance(global::Acid.Sharp.FilterSepia.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterSepia(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterSepia.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterSepia.__Internal));
            global::Acid.Sharp.FilterSepia.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterSepia(global::Acid.Sharp.FilterSepia.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterSepia(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterSepia(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterSepia.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterSepia");
        }

        public FilterSepia(global::Acid.Sharp.FilterSepia _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterSepia.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterSepia");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterSepia.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.FilterSepia(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.FilterSepia(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterSepia) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterSsao : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 832)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal global::Std.SharedPtr.__Internal m_noise;

            [FieldOffset(808)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_acid_S_Vector3___N_std_S_allocator__S0_ m_kernel;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterSsao@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterSsao@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterSsao@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FilterSsao __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterSsao(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterSsao __CreateInstance(global::Acid.Sharp.FilterSsao.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterSsao(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterSsao.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterSsao.__Internal));
            global::Acid.Sharp.FilterSsao.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterSsao(global::Acid.Sharp.FilterSsao.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterSsao(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterSsao(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterSsao.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterSsao");
        }

        public FilterSsao(global::Acid.Sharp.FilterSsao _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterSsao.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterSsao");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterSsao.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.FilterSsao(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.FilterSsao(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterSsao) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterTiltshift : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 808)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal float m_blurAmount;

            [FieldOffset(796)]
            internal float m_centre;

            [FieldOffset(800)]
            internal float m_stepSize;

            [FieldOffset(804)]
            internal float m_steps;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTiltshift@acid@@QEAA@AEBVGraphicsStage@1@AEBM111@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* blurAmount, float* centre, float* stepSize, float* steps);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTiltshift@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterTiltshift@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBlurAmount@FilterTiltshift@acid@@QEBAMXZ")]
            internal static extern float GetBlurAmount(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBlurAmount@FilterTiltshift@acid@@QEAAXAEBM@Z")]
            internal static extern void SetBlurAmount(global::System.IntPtr instance, float* blurAmount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCentre@FilterTiltshift@acid@@QEBAMXZ")]
            internal static extern float GetCentre(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCentre@FilterTiltshift@acid@@QEAAXAEBM@Z")]
            internal static extern void SetCentre(global::System.IntPtr instance, float* centre);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStepSize@FilterTiltshift@acid@@QEBAMXZ")]
            internal static extern float GetStepSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStepSize@FilterTiltshift@acid@@QEAAXAEBM@Z")]
            internal static extern void SetStepSize(global::System.IntPtr instance, float* stepSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSteps@FilterTiltshift@acid@@QEBAMXZ")]
            internal static extern float GetSteps(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSteps@FilterTiltshift@acid@@QEAAXAEBM@Z")]
            internal static extern void SetSteps(global::System.IntPtr instance, float* steps);
        }

        internal static new global::Acid.Sharp.FilterTiltshift __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterTiltshift(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterTiltshift __CreateInstance(global::Acid.Sharp.FilterTiltshift.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterTiltshift(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterTiltshift.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterTiltshift.__Internal));
            global::Acid.Sharp.FilterTiltshift.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterTiltshift(global::Acid.Sharp.FilterTiltshift.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterTiltshift(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterTiltshift(global::Acid.Sharp.GraphicsStage graphicsStage, float blurAmount, float centre, float stepSize, float steps)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterTiltshift.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &blurAmount;
            var __arg2 = &centre;
            var __arg3 = &stepSize;
            var __arg4 = &steps;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterTiltshift");
        }

        public FilterTiltshift(global::Acid.Sharp.FilterTiltshift _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterTiltshift.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterTiltshift");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterTiltshift.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float BlurAmount
        {
            get
            {
                var __ret = __Internal.GetBlurAmount((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetBlurAmount((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Centre
        {
            get
            {
                var __ret = __Internal.GetCentre((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetCentre((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float StepSize
        {
            get
            {
                var __ret = __Internal.GetStepSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStepSize((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Steps
        {
            get
            {
                var __ret = __Internal.GetSteps((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetSteps((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterTiltshift) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterTone : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 768)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTone@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterTone@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterTone@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FilterTone __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterTone(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterTone __CreateInstance(global::Acid.Sharp.FilterTone.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterTone(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterTone.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterTone.__Internal));
            global::Acid.Sharp.FilterTone.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterTone(global::Acid.Sharp.FilterTone.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterTone(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterTone(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterTone.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterTone");
        }

        public FilterTone(global::Acid.Sharp.FilterTone _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterTone.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterTone");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterTone.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.FilterTone(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.FilterTone(graphicsStage);
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterTone) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterVignette : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 808)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal float m_innerRadius;

            [FieldOffset(796)]
            internal float m_outerRadius;

            [FieldOffset(800)]
            internal float m_opacity;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterVignette@acid@@QEAA@AEBVGraphicsStage@1@AEBM11@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* innerRadius, float* outerRadius, float* opacity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterVignette@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterVignette@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetInnerRadius@FilterVignette@acid@@QEBAMXZ")]
            internal static extern float GetInnerRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInnerRadius@FilterVignette@acid@@QEAAXAEBM@Z")]
            internal static extern void SetInnerRadius(global::System.IntPtr instance, float* innerRadius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOuterRadius@FilterVignette@acid@@QEBAMXZ")]
            internal static extern float GetOuterRadius(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetOuterRadius@FilterVignette@acid@@QEAAXAEBM@Z")]
            internal static extern void SetOuterRadius(global::System.IntPtr instance, float* outerRadius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOpacity@FilterVignette@acid@@QEBAMXZ")]
            internal static extern float GetOpacity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetOpacity@FilterVignette@acid@@QEAAXAEBM@Z")]
            internal static extern void SetOpacity(global::System.IntPtr instance, float* opacity);
        }

        internal static new global::Acid.Sharp.FilterVignette __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterVignette(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterVignette __CreateInstance(global::Acid.Sharp.FilterVignette.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterVignette(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterVignette.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterVignette.__Internal));
            global::Acid.Sharp.FilterVignette.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterVignette(global::Acid.Sharp.FilterVignette.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterVignette(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterVignette(global::Acid.Sharp.GraphicsStage graphicsStage, float innerRadius, float outerRadius, float opacity)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterVignette.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &innerRadius;
            var __arg2 = &outerRadius;
            var __arg3 = &opacity;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterVignette");
        }

        public FilterVignette(global::Acid.Sharp.FilterVignette _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterVignette.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterVignette");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterVignette.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float InnerRadius
        {
            get
            {
                var __ret = __Internal.GetInnerRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetInnerRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float OuterRadius
        {
            get
            {
                var __ret = __Internal.GetOuterRadius((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetOuterRadius((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Opacity
        {
            get
            {
                var __ret = __Internal.GetOpacity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetOpacity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterVignette) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class FilterWobble : global::Acid.Sharp.IPostFilter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 800)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(736)]
            internal global::Std.SharedPtr.__Internal m_model;

            [FieldOffset(752)]
            internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_attachments;

            [FieldOffset(768)]
            internal global::Acid.Sharp.PushHandler.__Internal m_pushScene;

            [FieldOffset(792)]
            internal float m_wobbleSpeed;

            [FieldOffset(796)]
            internal float m_wobbleAmount;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterWobble@acid@@QEAA@AEBVGraphicsStage@1@AEBM@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage, float* wobbleSpeed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FilterWobble@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FilterWobble@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWobbleSpeed@FilterWobble@acid@@QEBAMXZ")]
            internal static extern float GetWobbleSpeed(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetWobbleSpeed@FilterWobble@acid@@QEAAXAEBM@Z")]
            internal static extern void SetWobbleSpeed(global::System.IntPtr instance, float* wobbleSpeed);
        }

        internal static new global::Acid.Sharp.FilterWobble __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterWobble(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FilterWobble __CreateInstance(global::Acid.Sharp.FilterWobble.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FilterWobble(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FilterWobble.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterWobble.__Internal));
            global::Acid.Sharp.FilterWobble.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FilterWobble(global::Acid.Sharp.FilterWobble.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FilterWobble(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public FilterWobble(global::Acid.Sharp.GraphicsStage graphicsStage, float wobbleSpeed)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterWobble.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            var __arg1 = &wobbleSpeed;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterWobble");
        }

        public FilterWobble(global::Acid.Sharp.FilterWobble _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FilterWobble.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.FilterWobble");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.FilterWobble.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public float WobbleSpeed
        {
            get
            {
                var __ret = __Internal.GetWobbleSpeed((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetWobbleSpeed((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.FilterWobble) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class InstanceBuffer : global::Acid.Sharp.Buffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong m_size;

            [FieldOffset(8)]
            internal global::System.IntPtr m_buffer;

            [FieldOffset(16)]
            internal global::System.IntPtr m_bufferMemory;

            [FieldOffset(24)]
            internal global::VkDescriptorBufferInfo.__Internal m_bufferInfo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0InstanceBuffer@acid@@QEAA@AEB_K@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, ulong* size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0InstanceBuffer@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1InstanceBuffer@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@InstanceBuffer@acid@@QEAAXPEBX@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr newData);
        }

        internal static new global::Acid.Sharp.InstanceBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.InstanceBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.InstanceBuffer __CreateInstance(global::Acid.Sharp.InstanceBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.InstanceBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.InstanceBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.InstanceBuffer.__Internal));
            *(global::Acid.Sharp.InstanceBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private InstanceBuffer(global::Acid.Sharp.InstanceBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected InstanceBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public InstanceBuffer(ulong size)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.InstanceBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &size;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public InstanceBuffer(global::Acid.Sharp.InstanceBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.InstanceBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.InstanceBuffer.__Internal*) __Instance) = *((global::Acid.Sharp.InstanceBuffer.__Internal*) _0.__Instance);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update(global::System.IntPtr newData)
        {
            __Internal.Update((__Instance + __PointerAdjustment), newData);
        }

        public static explicit operator global::Acid.Sharp.InstanceBuffer(ulong size)
        {
            return new global::Acid.Sharp.InstanceBuffer(ref *size);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a compute Vulkan pipeline.</summary>
    public unsafe partial class Compute : global::Acid.Sharp.IPipeline, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 176)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IPipeline;

            [FieldOffset(8)]
            internal global::Acid.Sharp.ComputeCreate.__Internal m_computeCreate;

            [FieldOffset(80)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_ShaderProgram___N_std_S_default_delete__S0_ m_shaderProgram;

            [FieldOffset(88)]
            internal global::System.IntPtr m_shaderModule;

            [FieldOffset(96)]
            internal global::VkPipelineShaderStageCreateInfo.__Internal m_shaderStageCreateInfo;

            [FieldOffset(144)]
            internal global::System.IntPtr m_descriptorSetLayout;

            [FieldOffset(152)]
            internal global::System.IntPtr m_descriptorPool;

            [FieldOffset(160)]
            internal global::System.IntPtr m_pipeline;

            [FieldOffset(168)]
            internal global::System.IntPtr m_pipelineLayout;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Compute@acid@@QEAA@AEBVComputeCreate@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr computeCreate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Compute@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Compute@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@Compute@acid@@QEBA_NAEBVCommandBuffer@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetComputeCreate@Compute@acid@@QEBA?AVComputeCreate@2@XZ")]
            internal static extern void GetComputeCreate(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        internal static new global::Acid.Sharp.Compute __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Compute(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Compute __CreateInstance(global::Acid.Sharp.Compute.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Compute(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Compute.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Compute.__Internal));
            global::Acid.Sharp.Compute.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Compute(global::Acid.Sharp.Compute.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Compute(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new compute pipeline.</summary>
        /// <param name="pipelineCreate">The compute pipelines creation info.</param>
        public Compute(global::Acid.Sharp.ComputeCreate computeCreate)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Compute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(computeCreate, null))
                throw new global::System.ArgumentNullException("computeCreate", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = computeCreate.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Compute");
        }

        public Compute(global::Acid.Sharp.Compute _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Compute.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Compute");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IPipeline __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Compute.__Internal*) __Instance)->vfptr_IPipeline = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool CmdRender(global::Acid.Sharp.CommandBuffer commandBuffer)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            var __ret = __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public static explicit operator global::Acid.Sharp.Compute(global::Acid.Sharp.ComputeCreate computeCreate)
        {
            return new global::Acid.Sharp.Compute(computeCreate);
        }

        public override global::Acid.Sharp.ShaderProgram ShaderProgram
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
                var ___GetShaderProgramDelegate = (global::Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_IntPtr_IntPtr));
                var __ret = ___GetShaderProgramDelegate((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ShaderProgram __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ShaderProgram.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ShaderProgram) global::Acid.Sharp.ShaderProgram.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ShaderProgram.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.ComputeCreate ComputeCreate
        {
            get
            {
                var __ret = new global::Acid.Sharp.ComputeCreate.__Internal();
                __Internal.GetComputeCreate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.ComputeCreate.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // ShaderProgram *GetShaderProgram() const override { return m_shaderProgram.get(); }
        private static global::Delegates.Func_IntPtr_IntPtr _GetShaderProgramDelegateInstance;

        private static global::System.IntPtr _GetShaderProgramDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Compute) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ShaderProgram;
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetShaderProgramDelegateInstance += _GetShaderProgramDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetShaderProgramDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for managing resources.</summary>
    public unsafe partial class Resources : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____N_acid_S_IResource___N_std_S_allocator__S0_ m_resources;

            [FieldOffset(32)]
            internal global::Acid.Sharp.Timer.__Internal m_timerPurge;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Resources@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Resources@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Resources@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Resources@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Remove@Resources@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Remove(global::System.IntPtr instance, global::System.IntPtr filename);
        }

        internal static new global::Acid.Sharp.Resources __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Resources(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Resources __CreateInstance(global::Acid.Sharp.Resources.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Resources(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Resources.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Resources.__Internal));
            global::Acid.Sharp.Resources.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Resources(global::Acid.Sharp.Resources.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Resources(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Resources()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Resources.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Resources");
        }

        public Resources(global::Acid.Sharp.Resources _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Resources.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Resources");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Resources.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public bool Remove(string filename)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Remove((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Resources Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Resources __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Resources.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Resources) global::Acid.Sharp.Resources.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Resources.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Resources) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class SelectorJoystick : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 496)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.JoystickPort m_joystick;

            [FieldOffset(8)]
            internal global::Acid.Sharp.AxisJoystick.__Internal m_axisX;

            [FieldOffset(56)]
            internal global::Acid.Sharp.AxisJoystick.__Internal m_axisY;

            [FieldOffset(104)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_std_S_optional____N_acid_S_ButtonJoystick_Vk7 m_inputButtons;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SelectorJoystick@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SelectorJoystick@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetInputButton@SelectorJoystick@acid@@QEAAXAEBW4MouseButton@2@AEBVButtonJoystick@2@@Z")]
            internal static extern void SetInputButton(global::System.IntPtr instance, global::Acid.Sharp.MouseButton* button, global::System.IntPtr inputButton);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetJoystick@SelectorJoystick@acid@@QEBA?AW4JoystickPort@2@XZ")]
            internal static extern global::Acid.Sharp.JoystickPort GetJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetJoystick@SelectorJoystick@acid@@QEAAXAEBW4JoystickPort@2@@Z")]
            internal static extern void SetJoystick(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* joystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxisX@SelectorJoystick@acid@@QEBA?AVAxisJoystick@2@XZ")]
            internal static extern void GetAxisX(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAxisX@SelectorJoystick@acid@@QEAAXAEBVAxisJoystick@2@@Z")]
            internal static extern void SetAxisX(global::System.IntPtr instance, global::System.IntPtr axisX);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAxisY@SelectorJoystick@acid@@QEBA?AVAxisJoystick@2@XZ")]
            internal static extern void GetAxisY(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAxisY@SelectorJoystick@acid@@QEAAXAEBVAxisJoystick@2@@Z")]
            internal static extern void SetAxisY(global::System.IntPtr instance, global::System.IntPtr axisY);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SelectorJoystick> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.SelectorJoystick>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.SelectorJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SelectorJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SelectorJoystick __CreateInstance(global::Acid.Sharp.SelectorJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SelectorJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SelectorJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SelectorJoystick.__Internal));
            global::Acid.Sharp.SelectorJoystick.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SelectorJoystick(global::Acid.Sharp.SelectorJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SelectorJoystick(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SelectorJoystick(global::Acid.Sharp.SelectorJoystick _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SelectorJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.SelectorJoystick __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetInputButton(global::Acid.Sharp.MouseButton* button, global::Acid.Sharp.ButtonJoystick inputButton)
        {
            if (ReferenceEquals(inputButton, null))
                throw new global::System.ArgumentNullException("inputButton", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = inputButton.__Instance;
            __Internal.SetInputButton((__Instance + __PointerAdjustment), button, __arg1);
        }

        public global::Acid.Sharp.JoystickPort Joystick
        {
            get
            {
                var __ret = __Internal.GetJoystick((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetJoystick((__Instance + __PointerAdjustment), &value);
            }
        }

        public global::Acid.Sharp.AxisJoystick AxisX
        {
            get
            {
                var __ret = new global::Acid.Sharp.AxisJoystick.__Internal();
                __Internal.GetAxisX((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.AxisJoystick.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAxisX((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.AxisJoystick AxisY
        {
            get
            {
                var __ret = new global::Acid.Sharp.AxisJoystick.__Internal();
                __Internal.GetAxisY((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.AxisJoystick.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetAxisY((__Instance + __PointerAdjustment), __arg0);
            }
        }
    }

    public unsafe partial class UiSelectorMouse : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.MouseButton m_mouseButton;

            [FieldOffset(4)]
            internal byte m_isDown;

            [FieldOffset(5)]
            internal byte m_wasDown;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelectorMouse@acid@@QEAA@AEBU01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiSelectorMouse> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiSelectorMouse>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.UiSelectorMouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiSelectorMouse(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiSelectorMouse __CreateInstance(global::Acid.Sharp.UiSelectorMouse.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiSelectorMouse(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiSelectorMouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiSelectorMouse.__Internal));
            *(global::Acid.Sharp.UiSelectorMouse.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UiSelectorMouse(global::Acid.Sharp.UiSelectorMouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiSelectorMouse(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UiSelectorMouse(global::Acid.Sharp.UiSelectorMouse _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiSelectorMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.UiSelectorMouse.__Internal*) __Instance) = *((global::Acid.Sharp.UiSelectorMouse.__Internal*) _0.__Instance);
        }

        public UiSelectorMouse()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiSelectorMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiSelectorMouse __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Acid.Sharp.MouseButton MMouseButton
        {
            get
            {
                return ((global::Acid.Sharp.UiSelectorMouse.__Internal*) __Instance)->m_mouseButton;
            }

            set
            {
                ((global::Acid.Sharp.UiSelectorMouse.__Internal*)__Instance)->m_mouseButton = value;
            }
        }

        public bool MIsDown
        {
            get
            {
                return ((global::Acid.Sharp.UiSelectorMouse.__Internal*) __Instance)->m_isDown != 0;
            }

            set
            {
                ((global::Acid.Sharp.UiSelectorMouse.__Internal*)__Instance)->m_isDown = (byte) (value ? 1 : 0);
            }
        }

        public bool MWasDown
        {
            get
            {
                return ((global::Acid.Sharp.UiSelectorMouse.__Internal*) __Instance)->m_wasDown != 0;
            }

            set
            {
                ((global::Acid.Sharp.UiSelectorMouse.__Internal*)__Instance)->m_wasDown = (byte) (value ? 1 : 0);
            }
        }
    }

    /// <summary>Represents a virtual cursor that will be used to determine if a ui action was preformed by a device.</summary>
    public unsafe partial class UiSelector : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float m_cursorX;

            [FieldOffset(4)]
            internal float m_cursorY;

            [FieldOffset(8)]
            internal global::Std.Array.__Internalc__N_std_S_array____N_acid_S_UiSelectorMouse_Vk7 m_selectorMice;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelector@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiSelector@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UiSelector@acid@@QEAAXAEB_NAEBVSelectorJoystick@2@@Z")]
            internal static extern void Update(global::System.IntPtr instance, bool* paused, global::System.IntPtr selectorJoystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsSelected@UiSelector@acid@@QEBA_NAEBVUiObject@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetSelected(global::System.IntPtr instance, global::System.IntPtr @object);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CancelWasEvent@UiSelector@acid@@QEAAXXZ")]
            internal static extern void CancelWasEvent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsDown@UiSelector@acid@@QEBA_NAEBW4MouseButton@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetDown(global::System.IntPtr instance, global::Acid.Sharp.MouseButton* button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?WasDown@UiSelector@acid@@QEBA_NAEBW4MouseButton@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool WasDown(global::System.IntPtr instance, global::Acid.Sharp.MouseButton* button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCursorX@UiSelector@acid@@QEBAMXZ")]
            internal static extern float GetCursorX(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCursorY@UiSelector@acid@@QEBAMXZ")]
            internal static extern float GetCursorY(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiSelector> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiSelector>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.UiSelector __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiSelector(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiSelector __CreateInstance(global::Acid.Sharp.UiSelector.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiSelector(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiSelector.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiSelector.__Internal));
            *(global::Acid.Sharp.UiSelector.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UiSelector(global::Acid.Sharp.UiSelector.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiSelector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UiSelector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiSelector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public UiSelector(global::Acid.Sharp.UiSelector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiSelector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.UiSelector.__Internal*) __Instance) = *((global::Acid.Sharp.UiSelector.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiSelector __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update(bool paused, global::Acid.Sharp.SelectorJoystick selectorJoystick)
        {
            var __arg0 = &paused;
            if (ReferenceEquals(selectorJoystick, null))
                throw new global::System.ArgumentNullException("selectorJoystick", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = selectorJoystick.__Instance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        /// <summary>Gets if the object provided has the cursor hovered above it.</summary>
        /// <param name="object">The object to check with.</param>
        public bool GetSelected(global::Acid.Sharp.UiObject @object)
        {
            if (ReferenceEquals(@object, null))
                throw new global::System.ArgumentNullException("@object", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = @object.__Instance;
            var __ret = __Internal.GetSelected((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void CancelWasEvent()
        {
            __Internal.CancelWasEvent((__Instance + __PointerAdjustment));
        }

        public bool GetDown(global::Acid.Sharp.MouseButton* button)
        {
            var __ret = __Internal.GetDown((__Instance + __PointerAdjustment), button);
            return __ret;
        }

        public bool WasDown(global::Acid.Sharp.MouseButton* button)
        {
            var __ret = __Internal.WasDown((__Instance + __PointerAdjustment), button);
            return __ret;
        }

        public float CursorX
        {
            get
            {
                var __ret = __Internal.GetCursorX((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float CursorY
        {
            get
            {
                var __ret = __Internal.GetCursorY((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

public unsafe partial class BtCollisionConfiguration
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionConfiguration> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionConfiguration>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCollisionConfiguration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCollisionConfiguration(native.ToPointer(), skipVTables);
    }

    internal static global::BtCollisionConfiguration __CreateInstance(global::BtCollisionConfiguration.__Internal native, bool skipVTables = false)
    {
        return new global::BtCollisionConfiguration(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCollisionConfiguration.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCollisionConfiguration.__Internal));
        *(global::BtCollisionConfiguration.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCollisionConfiguration(global::BtCollisionConfiguration.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCollisionConfiguration(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtBroadphaseInterface
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtBroadphaseInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtBroadphaseInterface>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtBroadphaseInterface __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtBroadphaseInterface(native.ToPointer(), skipVTables);
    }

    internal static global::BtBroadphaseInterface __CreateInstance(global::BtBroadphaseInterface.__Internal native, bool skipVTables = false)
    {
        return new global::BtBroadphaseInterface(native, skipVTables);
    }

    private static void* __CopyValue(global::BtBroadphaseInterface.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtBroadphaseInterface.__Internal));
        *(global::BtBroadphaseInterface.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtBroadphaseInterface(global::BtBroadphaseInterface.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtBroadphaseInterface(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtCollisionDispatcher
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionDispatcher> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtCollisionDispatcher>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtCollisionDispatcher __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtCollisionDispatcher(native.ToPointer(), skipVTables);
    }

    internal static global::BtCollisionDispatcher __CreateInstance(global::BtCollisionDispatcher.__Internal native, bool skipVTables = false)
    {
        return new global::BtCollisionDispatcher(native, skipVTables);
    }

    private static void* __CopyValue(global::BtCollisionDispatcher.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtCollisionDispatcher.__Internal));
        *(global::BtCollisionDispatcher.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtCollisionDispatcher(global::BtCollisionDispatcher.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtCollisionDispatcher(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtSequentialImpulseConstraintSolver
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtSequentialImpulseConstraintSolver> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtSequentialImpulseConstraintSolver>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtSequentialImpulseConstraintSolver __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtSequentialImpulseConstraintSolver(native.ToPointer(), skipVTables);
    }

    internal static global::BtSequentialImpulseConstraintSolver __CreateInstance(global::BtSequentialImpulseConstraintSolver.__Internal native, bool skipVTables = false)
    {
        return new global::BtSequentialImpulseConstraintSolver(native, skipVTables);
    }

    private static void* __CopyValue(global::BtSequentialImpulseConstraintSolver.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtSequentialImpulseConstraintSolver.__Internal));
        *(global::BtSequentialImpulseConstraintSolver.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtSequentialImpulseConstraintSolver(global::BtSequentialImpulseConstraintSolver.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtSequentialImpulseConstraintSolver(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

public unsafe partial class BtDiscreteDynamicsWorld
{
    [StructLayout(LayoutKind.Explicit, Size = 0)]
    public partial struct __Internal
    {
    }

    public global::System.IntPtr __Instance { get; protected set; }

    protected int __PointerAdjustment;
    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtDiscreteDynamicsWorld> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::BtDiscreteDynamicsWorld>();
    protected void*[] __OriginalVTables;

    protected bool __ownsNativeInstance;

    internal static global::BtDiscreteDynamicsWorld __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
    {
        return new global::BtDiscreteDynamicsWorld(native.ToPointer(), skipVTables);
    }

    internal static global::BtDiscreteDynamicsWorld __CreateInstance(global::BtDiscreteDynamicsWorld.__Internal native, bool skipVTables = false)
    {
        return new global::BtDiscreteDynamicsWorld(native, skipVTables);
    }

    private static void* __CopyValue(global::BtDiscreteDynamicsWorld.__Internal native)
    {
        var ret = Marshal.AllocHGlobal(sizeof(global::BtDiscreteDynamicsWorld.__Internal));
        *(global::BtDiscreteDynamicsWorld.__Internal*) ret = native;
        return ret.ToPointer();
    }

    private BtDiscreteDynamicsWorld(global::BtDiscreteDynamicsWorld.__Internal native, bool skipVTables = false)
        : this(__CopyValue(native), skipVTables)
    {
        __ownsNativeInstance = true;
        NativeToManagedMap[__Instance] = this;
    }

    protected BtDiscreteDynamicsWorld(void* native, bool skipVTables = false)
    {
        if (native == null)
            return;
        __Instance = new global::System.IntPtr(native);
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Raycast : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_hasHit;

            [FieldOffset(4)]
            internal global::Acid.Sharp.Vector3.__Internal m_pointWorld;

            [FieldOffset(16)]
            internal global::System.IntPtr m_collisionObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Raycast@acid@@QEAA@_NAEBVVector3@1@PEAVCollisionObject@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, bool m_hasHit, global::System.IntPtr m_pointWorld, global::System.IntPtr collisionObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Raycast@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?HasHit@Raycast@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasHit(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPointWorld@Raycast@acid@@QEBAAEBVVector3@2@XZ")]
            internal static extern global::System.IntPtr GetPointWorld(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCollisionObject@Raycast@acid@@QEBAPEAVCollisionObject@2@XZ")]
            internal static extern global::System.IntPtr GetCollisionObject(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Raycast> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Raycast>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Raycast __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Raycast(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Raycast __CreateInstance(global::Acid.Sharp.Raycast.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Raycast(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Raycast.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Raycast.__Internal));
            global::Acid.Sharp.Raycast.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Raycast(global::Acid.Sharp.Raycast.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Raycast(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Raycast(bool m_hasHit, global::Acid.Sharp.Vector3 m_pointWorld, global::Acid.Sharp.CollisionObject collisionObject)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Raycast.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(m_pointWorld, null))
                throw new global::System.ArgumentNullException("m_pointWorld", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = m_pointWorld.__Instance;
            var __arg2 = ReferenceEquals(collisionObject, null) ? global::System.IntPtr.Zero : collisionObject.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), m_hasHit, __arg1, __arg2);
        }

        public Raycast(global::Acid.Sharp.Raycast _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Raycast.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Raycast __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool HasHit
        {
            get
            {
                var __ret = __Internal.HasHit((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public global::Acid.Sharp.Vector3 PointWorld
        {
            get
            {
                var __ret = __Internal.GetPointWorld((__Instance + __PointerAdjustment));
                global::Acid.Sharp.Vector3 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.Vector3.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.Vector3) global::Acid.Sharp.Vector3.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.Vector3.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::Acid.Sharp.CollisionObject CollisionObject
        {
            get
            {
                var __ret = __Internal.GetCollisionObject((__Instance + __PointerAdjustment));
                global::Acid.Sharp.CollisionObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.CollisionObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.CollisionObject) global::Acid.Sharp.CollisionObject.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.CollisionObject.__CreateInstance(__ret);
                return __result0;
            }
        }
    }

    public unsafe partial class ScenePhysics : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionConfiguration___N_std_S_default_delete__S0_ m_collisionConfiguration;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btBroadphaseInterface___N_std_S_default_delete__S0_ m_broadphase;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btCollisionDispatcher___N_std_S_default_delete__S0_ m_dispatcher;

            [FieldOffset(24)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btSequentialImpulseConstraintSolver___N_std_S_default_delete__S0_ m_solver;

            [FieldOffset(32)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____S_btDiscreteDynamicsWorld___N_std_S_default_delete__S0_ m_dynamicsWorld;

            [FieldOffset(40)]
            internal global::Std.Set.__Internalc__N_std_S_set____N_std_S_pair___1__S_btCollisionObject_S1____N_std_S_less__S0____N_std_S_allocator__S0_ m_pairsLastUpdate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ScenePhysics@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ScenePhysics@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ScenePhysics@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ScenePhysics@acid@@QEAAXXZ")]
            internal static extern void Update(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Raytest@ScenePhysics@acid@@QEAA?AVRaycast@2@AEBVVector3@2@0@Z")]
            internal static extern void Raytest(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr start, global::System.IntPtr end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetGravity@ScenePhysics@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetGravity(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetGravity@ScenePhysics@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetGravity(global::System.IntPtr instance, global::System.IntPtr gravity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetAirDensity@ScenePhysics@acid@@QEBAMXZ")]
            internal static extern float GetAirDensity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetAirDensity@ScenePhysics@acid@@QEAAXAEBM@Z")]
            internal static extern void SetAirDensity(global::System.IntPtr instance, float* airDensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBroadphase@ScenePhysics@acid@@QEAAPEAVbtBroadphaseInterface@@XZ")]
            internal static extern global::System.IntPtr GetBroadphase(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDynamicsWorld@ScenePhysics@acid@@QEAAPEAVbtDiscreteDynamicsWorld@@XZ")]
            internal static extern global::System.IntPtr GetDynamicsWorld(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ScenePhysics> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ScenePhysics>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ScenePhysics __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ScenePhysics(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ScenePhysics __CreateInstance(global::Acid.Sharp.ScenePhysics.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ScenePhysics(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ScenePhysics.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ScenePhysics.__Internal));
            global::Acid.Sharp.ScenePhysics.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ScenePhysics(global::Acid.Sharp.ScenePhysics.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ScenePhysics(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ScenePhysics()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ScenePhysics.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ScenePhysics(global::Acid.Sharp.ScenePhysics _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ScenePhysics.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ScenePhysics __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update()
        {
            __Internal.Update((__Instance + __PointerAdjustment));
        }

        public global::Acid.Sharp.Raycast Raytest(global::Acid.Sharp.Vector3 start, global::Acid.Sharp.Vector3 end)
        {
            if (ReferenceEquals(start, null))
                throw new global::System.ArgumentNullException("start", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = start.__Instance;
            if (ReferenceEquals(end, null))
                throw new global::System.ArgumentNullException("end", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = end.__Instance;
            var __ret = new global::Acid.Sharp.Raycast.__Internal();
            __Internal.Raytest((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0, __arg1);
            return global::Acid.Sharp.Raycast.__CreateInstance(__ret);
        }

        public global::Acid.Sharp.Vector3 Gravity
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetGravity((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetGravity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float AirDensity
        {
            get
            {
                var __ret = __Internal.GetAirDensity((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetAirDensity((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::BtBroadphaseInterface Broadphase
        {
            get
            {
                var __ret = __Internal.GetBroadphase((__Instance + __PointerAdjustment));
                global::BtBroadphaseInterface __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtBroadphaseInterface.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtBroadphaseInterface) global::BtBroadphaseInterface.NativeToManagedMap[__ret];
                else __result0 = global::BtBroadphaseInterface.__CreateInstance(__ret);
                return __result0;
            }
        }

        public global::BtDiscreteDynamicsWorld DynamicsWorld
        {
            get
            {
                var __ret = __Internal.GetDynamicsWorld((__Instance + __PointerAdjustment));
                global::BtDiscreteDynamicsWorld __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::BtDiscreteDynamicsWorld.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::BtDiscreteDynamicsWorld) global::BtDiscreteDynamicsWorld.NativeToManagedMap[__ret];
                else __result0 = global::BtDiscreteDynamicsWorld.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A structure of spatial objects for a 3D space.</summary>
    public unsafe partial class SceneStructure : global::Acid.Sharp.ISpatialStructure, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_ISpatialStructure;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_GameObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_objects;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SceneStructure@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0SceneStructure@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1SceneStructure@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.SceneStructure __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SceneStructure(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.SceneStructure __CreateInstance(global::Acid.Sharp.SceneStructure.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.SceneStructure(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.SceneStructure.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SceneStructure.__Internal));
            global::Acid.Sharp.SceneStructure.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SceneStructure(global::Acid.Sharp.SceneStructure.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SceneStructure(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new scene structure.</summary>
        public SceneStructure()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SceneStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.SceneStructure");
        }

        public SceneStructure(global::Acid.Sharp.SceneStructure _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.SceneStructure.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.SceneStructure");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ISpatialStructure __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.SceneStructure.__Internal*) __Instance)->vfptr_ISpatialStructure = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Add(global::Acid.Sharp.GameObject @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___AddDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            ___AddDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override bool Remove(global::Acid.Sharp.GameObject @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___RemoveDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___RemoveDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override bool Move(global::Acid.Sharp.GameObject @object, global::Acid.Sharp.ISpatialStructure structure)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___MoveDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __arg1 = ReferenceEquals(structure, null) ? global::System.IntPtr.Zero : structure.__Instance;
            var __ret = ___MoveDelegate((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        public override void Clear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___ClearDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___ClearDelegate((__Instance + __PointerAdjustment));
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override bool Contains(global::Acid.Sharp.GameObject @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 10 * 8);
            var ___ContainsDelegate = (global::Delegates.Func_bool_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___ContainsDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override uint Size
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 7 * 8);
                var ___GetSizeDelegate = (global::Delegates.Func_uint_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_uint_IntPtr));
                var __ret = ___GetSizeDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Add(GameObject *object) override
        private static global::Delegates.Action_IntPtr_IntPtr _AddDelegateInstance;

        private static void _AddDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            __target.Add(__result0);
        }

        // bool Remove(GameObject *object) override
        private static global::Delegates.Func_bool_IntPtr_IntPtr _RemoveDelegateInstance;

        private static bool _RemoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            var __ret = __target.Remove(__result0);
            return __ret;
        }

        // bool Move(GameObject *object, ISpatialStructure *structure) override
        private static global::Delegates.Func_bool_IntPtr_IntPtr_IntPtr _MoveDelegateInstance;

        private static bool _MoveDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object, global::System.IntPtr structure)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            global::Acid.Sharp.ISpatialStructure __result1;
            if (structure == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.ISpatialStructure.NativeToManagedMap.ContainsKey(structure))
                __result1 = (global::Acid.Sharp.ISpatialStructure) global::Acid.Sharp.ISpatialStructure.NativeToManagedMap[structure];
            else __result1 = global::Acid.Sharp.ISpatialStructure.__CreateInstance(structure);
            var __ret = __target.Move(__result0, __result1);
            return __ret;
        }

        // void Clear() override
        private static global::Delegates.Action_IntPtr _ClearDelegateInstance;

        private static void _ClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Clear();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // uint32_t GetSize() override { return static_cast<uint32_t>(m_objects.size()); }
        private static global::Delegates.Func_uint_IntPtr _GetSizeDelegateInstance;

        private static uint _GetSizeDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Size;
            return __ret;
        }

        // bool Contains(GameObject *object) override
        private static global::Delegates.Func_bool_IntPtr_IntPtr _ContainsDelegateInstance;

        private static bool _ContainsDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.SceneStructure) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.GameObject __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.GameObject.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.GameObject) global::Acid.Sharp.GameObject.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.GameObject.__CreateInstance(@object);
            var __ret = __target.Contains(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[7];
                _AddDelegateInstance += _AddDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AddDelegateInstance).ToPointer();
                _RemoveDelegateInstance += _RemoveDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_RemoveDelegateInstance).ToPointer();
                _MoveDelegateInstance += _MoveDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_MoveDelegateInstance).ToPointer();
                _ClearDelegateInstance += _ClearDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ClearDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _GetSizeDelegateInstance += _GetSizeDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_GetSizeDelegateInstance).ToPointer();
                _ContainsDelegateInstance += _ContainsDelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_ContainsDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                *(void**) (vfptr0 + 16) = _Thunks[0];
                *(void**) (vfptr0 + 24) = _Thunks[1];
                *(void**) (vfptr0 + 32) = _Thunks[2];
                *(void**) (vfptr0 + 40) = _Thunks[3];
                *(void**) (vfptr0 + 48) = _Thunks[4];
                *(void**) (vfptr0 + 56) = _Thunks[5];
                *(void**) (vfptr0 + 64) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 64);
                *(void**) (vfptr0 + 72) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 72);
                *(void**) (vfptr0 + 80) = _Thunks[6];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>A object used to represent a scene.</summary>
    public unsafe abstract partial class IScene : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IScene;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_ICamera___N_std_S_default_delete__S0_ m_camera;

            [FieldOffset(16)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_SelectorJoystick___N_std_S_default_delete__S0_ m_selectorJoystick;

            [FieldOffset(24)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_ScenePhysics___N_std_S_default_delete__S0_ m_physics;

            [FieldOffset(32)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_SceneStructure___N_std_S_default_delete__S0_ m_structure;

            [FieldOffset(40)]
            internal byte m_started;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IScene@acid@@QEAA@PEAVICamera@1@PEAVSelectorJoystick@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr camera, global::System.IntPtr selectorJoystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IScene@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1IScene@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCamera@IScene@acid@@QEBAPEAVICamera@2@XZ")]
            internal static extern global::System.IntPtr GetCamera(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetCamera@IScene@acid@@QEAAXPEAVICamera@2@@Z")]
            internal static extern void SetCamera(global::System.IntPtr instance, global::System.IntPtr camera);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSelectorJoystick@IScene@acid@@QEBAPEAVSelectorJoystick@2@XZ")]
            internal static extern global::System.IntPtr GetSelectorJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSelectorJoystick@IScene@acid@@QEAAXPEAVSelectorJoystick@2@@Z")]
            internal static extern void SetSelectorJoystick(global::System.IntPtr instance, global::System.IntPtr selectorJoystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsStarted@IScene@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetStarted(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStarted@IScene@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetStarted(global::System.IntPtr instance, bool* started);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysics@IScene@acid@@QEBAPEAVScenePhysics@2@XZ")]
            internal static extern global::System.IntPtr GetPhysics(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@IScene@acid@@QEAAPEAVSceneStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IScene> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IScene>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IScene __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ISceneInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IScene __CreateInstance(global::Acid.Sharp.IScene.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ISceneInternal(native, skipVTables);
        }

        protected IScene(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new scene.</summary>
        /// <param name="camera">The scenes camera.</param>
        /// <param name="selectorJoystick">The joystick controlled UI selector.</param>
        protected IScene(global::Acid.Sharp.ICamera camera, global::Acid.Sharp.SelectorJoystick selectorJoystick)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IScene.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(camera, null) ? global::System.IntPtr.Zero : camera.__Instance;
            var __arg1 = ReferenceEquals(selectorJoystick, null) ? global::System.IntPtr.Zero : selectorJoystick.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            SetupVTables(GetType().FullName == "Acid.Sharp.IScene");
        }

        protected IScene(global::Acid.Sharp.IScene _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IScene.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IScene");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IScene __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IScene.__Internal*) __Instance)->vfptr_IScene = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void Start();

        /// <summary>Run when updating the scene.</summary>
        public abstract void Update();

        /// <summary>Gets the current camera object.</summary>
        /// <param name="camera">The new camera.</param>
        /// <remarks>Sets the current camera to a new camera.</remarks>
        public global::Acid.Sharp.ICamera Camera
        {
            get
            {
                var __ret = __Internal.GetCamera((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ICamera __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ICamera.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetCamera((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the joystick controlled UI selector.</summary>
        /// <param name="selectorJoystick">The new joystick selector.</param>
        /// <remarks>Sets the joystick controlled UI selector.</remarks>
        public global::Acid.Sharp.SelectorJoystick SelectorJoystick
        {
            get
            {
                var __ret = __Internal.GetSelectorJoystick((__Instance + __PointerAdjustment));
                global::Acid.Sharp.SelectorJoystick __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.SelectorJoystick.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.SelectorJoystick) global::Acid.Sharp.SelectorJoystick.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.SelectorJoystick.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetSelectorJoystick((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets if this scene has started.</summary>
        /// <param name="started">If the scene has started.</param>
        /// <remarks>Sets if this scene has started.</remarks>
        public bool Started
        {
            get
            {
                var __ret = __Internal.GetStarted((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStarted((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the scene physics system.</summary>
        public global::Acid.Sharp.ScenePhysics Physics
        {
            get
            {
                var __ret = __Internal.GetPhysics((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ScenePhysics __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ScenePhysics.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ScenePhysics) global::Acid.Sharp.ScenePhysics.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ScenePhysics.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the scene object structure.</summary>
        public global::Acid.Sharp.SceneStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::Acid.Sharp.SceneStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.SceneStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.SceneStructure) global::Acid.Sharp.SceneStructure.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.SceneStructure.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets if the scene is paused.</summary>
        public abstract bool Paused
        {
            get;
        }

        #region Virtual table interop

        // void Start() = 0
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() = 0
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // bool IsPaused() const = 0
        private static global::Delegates.Func_bool_IntPtr _GetPausedDelegateInstance;

        private static bool _GetPausedDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IScene) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Paused;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _GetPausedDelegateInstance += _GetPausedDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetPausedDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ISceneInternal : global::Acid.Sharp.IScene, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IScene.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IScene.__Internal));
            *(global::Acid.Sharp.IScene.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ISceneInternal(global::Acid.Sharp.IScene.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ISceneInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Run when updating the scene.</summary>
        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets if the scene is paused.</summary>
        public override bool Paused
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
                var ___GetPausedDelegate = (global::Delegates.Func_bool_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_bool_IntPtr));
                var __ret = ___GetPausedDelegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for managing game scenes on engine updates.</summary>
    public unsafe partial class Scenes : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IScene___N_std_S_default_delete__S0_ m_scene;

            [FieldOffset(16)]
            internal global::Acid.Sharp.ComponentRegister.__Internal m_componentRegister;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scenes@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Scenes@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Scenes@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Scenes@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DeregisterComponent@Scenes@acid@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeregisterComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CreateComponent@Scenes@acid@@QEAAPEAVIComponent@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr CreateComponent(global::System.IntPtr instance, global::System.IntPtr name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetScene@Scenes@acid@@QEBAPEAVIScene@2@XZ")]
            internal static extern global::System.IntPtr GetScene(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetScene@Scenes@acid@@QEAAXPEAVIScene@2@@Z")]
            internal static extern void SetScene(global::System.IntPtr instance, global::System.IntPtr scene);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetCamera@Scenes@acid@@QEBAPEAVICamera@2@XZ")]
            internal static extern global::System.IntPtr GetCamera(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSelectorJoystick@Scenes@acid@@QEBAPEAVSelectorJoystick@2@XZ")]
            internal static extern global::System.IntPtr GetSelectorJoystick(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPhysics@Scenes@acid@@QEBAPEAVScenePhysics@2@XZ")]
            internal static extern global::System.IntPtr GetPhysics(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetStructure@Scenes@acid@@QEBAPEAVSceneStructure@2@XZ")]
            internal static extern global::System.IntPtr GetStructure(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsPaused@Scenes@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetPaused(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Scenes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Scenes(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Scenes __CreateInstance(global::Acid.Sharp.Scenes.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Scenes(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Scenes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Scenes.__Internal));
            global::Acid.Sharp.Scenes.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Scenes(global::Acid.Sharp.Scenes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Scenes(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        /// <summary>Creates a new Scenes module.</summary>
        public Scenes()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Scenes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Scenes");
        }

        public Scenes(global::Acid.Sharp.Scenes _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Scenes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Scenes");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Scenes.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Deregisters a component.</summary>
        /// <param name="name">The components name.</param>
        public bool DeregisterComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.DeregisterComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates a new component from the register.</summary>
        /// <param name="name">The component name to create.</param>
        public global::Acid.Sharp.IComponent CreateComponent(string name)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateComponent((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::Acid.Sharp.IComponent __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.IComponent.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.IComponent) global::Acid.Sharp.IComponent.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.IComponent.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Scenes Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Scenes __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Scenes.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Scenes) global::Acid.Sharp.Scenes.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Scenes.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the current scene.</summary>
        /// <param name="scene">The new scene.</param>
        /// <remarks>Sets the current scene to a new scene.</remarks>
        public global::Acid.Sharp.IScene Scene
        {
            get
            {
                var __ret = __Internal.GetScene((__Instance + __PointerAdjustment));
                global::Acid.Sharp.IScene __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.IScene.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.IScene) global::Acid.Sharp.IScene.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.IScene.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                __Internal.SetScene((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Gets the current camera object.</summary>
        public global::Acid.Sharp.ICamera Camera
        {
            get
            {
                var __ret = __Internal.GetCamera((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ICamera __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ICamera.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the joystick controlled UI selector.</summary>
        public global::Acid.Sharp.SelectorJoystick SelectorJoystick
        {
            get
            {
                var __ret = __Internal.GetSelectorJoystick((__Instance + __PointerAdjustment));
                global::Acid.Sharp.SelectorJoystick __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.SelectorJoystick.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.SelectorJoystick) global::Acid.Sharp.SelectorJoystick.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.SelectorJoystick.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the scene physics system.</summary>
        public global::Acid.Sharp.ScenePhysics Physics
        {
            get
            {
                var __ret = __Internal.GetPhysics((__Instance + __PointerAdjustment));
                global::Acid.Sharp.ScenePhysics __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.ScenePhysics.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.ScenePhysics) global::Acid.Sharp.ScenePhysics.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.ScenePhysics.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the scene object structure.</summary>
        public global::Acid.Sharp.SceneStructure Structure
        {
            get
            {
                var __ret = __Internal.GetStructure((__Instance + __PointerAdjustment));
                global::Acid.Sharp.SceneStructure __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.SceneStructure.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.SceneStructure) global::Acid.Sharp.SceneStructure.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.SceneStructure.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets if the scene is paused.</summary>
        public bool Paused
        {
            get
            {
                var __ret = __Internal.GetPaused((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Scenes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    [Flags]
    public enum EncodeProps
    {
        EncodePropNone = 0,
        EncodePropName = 1,
        EncodePropValue = 2,
        EncodePropChildren = 4,
        EncodePropAttributes = 8
    }

    public unsafe partial class Serialize : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Serialize@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Encode@Serialize@acid@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVMetadata@2@@Z")]
            internal static extern void Encode(global::System.IntPtr @return, global::System.IntPtr metadata);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Decode@Serialize@acid@@SA?AVMetadata@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void Decode(global::System.IntPtr @return, global::System.IntPtr value);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Serialize> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Serialize>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Serialize __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Serialize(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Serialize __CreateInstance(global::Acid.Sharp.Serialize.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Serialize(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Serialize.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Serialize.__Internal));
            *(global::Acid.Sharp.Serialize.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Serialize(global::Acid.Sharp.Serialize.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Serialize(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Serialize()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Serialize.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Serialize(global::Acid.Sharp.Serialize _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Serialize.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.Serialize.__Internal*) __Instance) = *((global::Acid.Sharp.Serialize.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Serialize __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static string Encode(global::Acid.Sharp.Metadata metadata)
        {
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            __Internal.Encode(new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static global::Acid.Sharp.Metadata Decode(string value)
        {
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Acid.Sharp.Metadata.__Internal();
            __Internal.Decode(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return global::Acid.Sharp.Metadata.__CreateInstance(__ret);
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Represents the 3D area of the world in which engine.shadows will be cast (basically represents the orthographic projection area for the shadow render pass). It can be updated each frame to optimise the area, making it as small as possible (to allow for optimal shadow map resolution) while not being too small to avoid objects not having shadows when they should. This class also provides functionality to test whether an object is inside this shadow box. Everything inside the box will be rendered to the shadow map in the shadow render pass.</summary>
    public unsafe partial class ShadowBox : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 392)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Vector3.__Internal m_lightDirection;

            [FieldOffset(12)]
            internal float m_shadowOffset;

            [FieldOffset(16)]
            internal float m_shadowDistance;

            [FieldOffset(20)]
            internal global::Acid.Sharp.Matrix4.__Internal m_projectionMatrix;

            [FieldOffset(84)]
            internal global::Acid.Sharp.Matrix4.__Internal m_lightViewMatrix;

            [FieldOffset(148)]
            internal global::Acid.Sharp.Matrix4.__Internal m_projectionViewMatrix;

            [FieldOffset(212)]
            internal global::Acid.Sharp.Matrix4.__Internal m_shadowMapSpaceMatrix;

            [FieldOffset(276)]
            internal global::Acid.Sharp.Matrix4.__Internal m_offset;

            [FieldOffset(340)]
            internal global::Acid.Sharp.Vector3.__Internal m_centre;

            [FieldOffset(352)]
            internal float m_farHeight;

            [FieldOffset(356)]
            internal float m_farWidth;

            [FieldOffset(360)]
            internal float m_nearHeight;

            [FieldOffset(364)]
            internal float m_nearWidth;

            [FieldOffset(368)]
            internal global::Acid.Sharp.Vector3.__Internal m_minExtents;

            [FieldOffset(380)]
            internal global::Acid.Sharp.Vector3.__Internal m_maxExtents;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowBox@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowBox@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@ShadowBox@acid@@QEAAXAEBVICamera@2@AEBVVector3@2@AEBM2@Z")]
            internal static extern void Update(global::System.IntPtr instance, global::System.IntPtr camera, global::System.IntPtr lightPosition, float* shadowOffset, float* shadowDistance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsInBox@ShadowBox@acid@@QEBA_NAEBVVector3@2@AEBM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetInBox(global::System.IntPtr instance, global::System.IntPtr position, float* radius);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProjectionViewMatrix@ShadowBox@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetProjectionViewMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetToShadowMapSpaceMatrix@ShadowBox@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetToShadowMapSpaceMatrix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLightSpaceTransform@ShadowBox@acid@@QEBA?AVMatrix4@2@XZ")]
            internal static extern void GetLightSpaceTransform(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMinExtents@ShadowBox@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetMinExtents(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetMaxExtents@ShadowBox@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetMaxExtents(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetWidth@ShadowBox@acid@@QEBAMXZ")]
            internal static extern float GetWidth(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetHeight@ShadowBox@acid@@QEBAMXZ")]
            internal static extern float GetHeight(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDepth@ShadowBox@acid@@QEBAMXZ")]
            internal static extern float GetDepth(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ShadowBox> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ShadowBox>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ShadowBox __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ShadowBox(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ShadowBox __CreateInstance(global::Acid.Sharp.ShadowBox.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ShadowBox(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ShadowBox.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShadowBox.__Internal));
            global::Acid.Sharp.ShadowBox.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShadowBox(global::Acid.Sharp.ShadowBox.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShadowBox(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Creates a new shadow box and calculates some initial values relating to the camera's view frustum.</summary>
        public ShadowBox()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShadowBox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public ShadowBox(global::Acid.Sharp.ShadowBox _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShadowBox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ShadowBox __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Updates the bounds of the shadow box based on the light direction and the camera's view frustum. Will make sure that the box covers the smallest area possible while still ensuring that everything. Objects inside the camera's view (and in range) will be shadowed.</summary>
        /// <param name="camera">The camera object to be used when calculating the shadow boxes size.</param>
        /// <param name="lightPosition">The lights position.</param>
        /// <param name="shadowOffset">The shadows offset.</param>
        /// <param name="shadowDistance">The shadows distance.</param>
        public void Update(global::Acid.Sharp.ICamera camera, global::Acid.Sharp.Vector3 lightPosition, float shadowOffset, float shadowDistance)
        {
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = camera.__Instance;
            if (ReferenceEquals(lightPosition, null))
                throw new global::System.ArgumentNullException("lightPosition", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = lightPosition.__Instance;
            var __arg2 = &shadowOffset;
            var __arg3 = &shadowDistance;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Test if a bounding sphere intersects the shadow box. Can be used to decide which engine.entities should be rendered in the shadow render pass.</summary>
        /// <param name="position">The centre of the bounding sphere in world space.</param>
        /// <param name="radius">The radius of the bounding sphere.</param>
        public bool GetInBox(global::Acid.Sharp.Vector3 position, float radius)
        {
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = position.__Instance;
            var __arg1 = &radius;
            var __ret = __Internal.GetInBox((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        public global::Acid.Sharp.Matrix4 ProjectionViewMatrix
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetProjectionViewMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>This biased projection-view matrix is used to convert fragments into &quot;shadow map space&quot; when rendering the main render pass.</summary>
        public global::Acid.Sharp.Matrix4 ToShadowMapSpaceMatrix
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetToShadowMapSpaceMatrix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        /// <summary>Gets the light's &quot;view&quot; matrix</summary>
        public global::Acid.Sharp.Matrix4 LightSpaceTransform
        {
            get
            {
                var __ret = new global::Acid.Sharp.Matrix4.__Internal();
                __Internal.GetLightSpaceTransform((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Matrix4.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector3 MinExtents
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetMinExtents((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public global::Acid.Sharp.Vector3 MaxExtents
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetMaxExtents((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }
        }

        public float Width
        {
            get
            {
                var __ret = __Internal.GetWidth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Height
        {
            get
            {
                var __ret = __Internal.GetHeight((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public float Depth
        {
            get
            {
                var __ret = __Internal.GetDepth((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for managing shadow maps in 3D worlds.</summary>
    public unsafe partial class Shadows : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 440)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Acid.Sharp.Vector3.__Internal m_lightDirection;

            [FieldOffset(20)]
            internal uint m_shadowSize;

            [FieldOffset(24)]
            internal int m_shadowPcf;

            [FieldOffset(28)]
            internal float m_shadowBias;

            [FieldOffset(32)]
            internal float m_shadowDarkness;

            [FieldOffset(36)]
            internal float m_shadowTransition;

            [FieldOffset(40)]
            internal float m_shadowBoxOffset;

            [FieldOffset(44)]
            internal float m_shadowBoxDistance;

            [FieldOffset(48)]
            internal global::Acid.Sharp.ShadowBox.__Internal m_shadowBox;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Shadows@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Shadows@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Shadows@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetLightDirection@Shadows@acid@@QEBA?AVVector3@2@XZ")]
            internal static extern void GetLightDirection(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetLightDirection@Shadows@acid@@QEAAXAEBVVector3@2@@Z")]
            internal static extern void SetLightDirection(global::System.IntPtr instance, global::System.IntPtr lightDirection);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowSize@Shadows@acid@@QEBAIXZ")]
            internal static extern uint GetShadowSize(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowSize@Shadows@acid@@QEAAXAEBI@Z")]
            internal static extern void SetShadowSize(global::System.IntPtr instance, uint* shadowSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowPcf@Shadows@acid@@QEBAHXZ")]
            internal static extern int GetShadowPcf(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowPcf@Shadows@acid@@QEAAXAEBH@Z")]
            internal static extern void SetShadowPcf(global::System.IntPtr instance, int* shadowPcf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBias@Shadows@acid@@QEBAMXZ")]
            internal static extern float GetShadowBias(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowBias@Shadows@acid@@QEAAXAEBM@Z")]
            internal static extern void SetShadowBias(global::System.IntPtr instance, float* shadowBias);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowDarkness@Shadows@acid@@QEBAMXZ")]
            internal static extern float GetShadowDarkness(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowDarkness@Shadows@acid@@QEAAXAEBM@Z")]
            internal static extern void SetShadowDarkness(global::System.IntPtr instance, float* shadowDarkness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowTransition@Shadows@acid@@QEBAMXZ")]
            internal static extern float GetShadowTransition(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowTransition@Shadows@acid@@QEAAXAEBM@Z")]
            internal static extern void SetShadowTransition(global::System.IntPtr instance, float* shadowTransition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBoxOffset@Shadows@acid@@QEBAMXZ")]
            internal static extern float GetShadowBoxOffset(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowBoxOffset@Shadows@acid@@QEAAXAEBM@Z")]
            internal static extern void SetShadowBoxOffset(global::System.IntPtr instance, float* shadowBoxOffset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBoxDistance@Shadows@acid@@QEBAMXZ")]
            internal static extern float GetShadowBoxDistance(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetShadowBoxDistance@Shadows@acid@@QEAAXAEBM@Z")]
            internal static extern void SetShadowBoxDistance(global::System.IntPtr instance, float* shadowBoxDistance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetShadowBox@Shadows@acid@@QEBA?AVShadowBox@2@XZ")]
            internal static extern void GetShadowBox(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        internal static new global::Acid.Sharp.Shadows __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Shadows(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Shadows __CreateInstance(global::Acid.Sharp.Shadows.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Shadows(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Shadows.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Shadows.__Internal));
            global::Acid.Sharp.Shadows.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Shadows(global::Acid.Sharp.Shadows.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Shadows(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Shadows()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Shadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Shadows");
        }

        public Shadows(global::Acid.Sharp.Shadows _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Shadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Shadows");
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Shadows Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Shadows __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Shadows.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Shadows) global::Acid.Sharp.Shadows.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Shadows.__CreateInstance(__ret);
            return __result0;
        }

        public global::Acid.Sharp.Vector3 LightDirection
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector3.__Internal();
                __Internal.GetLightDirection((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector3.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetLightDirection((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public uint ShadowSize
        {
            get
            {
                var __ret = __Internal.GetShadowSize((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetShadowSize((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public int ShadowPcf
        {
            get
            {
                var __ret = __Internal.GetShadowPcf((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetShadowPcf((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ShadowBias
        {
            get
            {
                var __ret = __Internal.GetShadowBias((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetShadowBias((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ShadowDarkness
        {
            get
            {
                var __ret = __Internal.GetShadowDarkness((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetShadowDarkness((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ShadowTransition
        {
            get
            {
                var __ret = __Internal.GetShadowTransition((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetShadowTransition((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ShadowBoxOffset
        {
            get
            {
                var __ret = __Internal.GetShadowBoxOffset((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetShadowBoxOffset((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ShadowBoxDistance
        {
            get
            {
                var __ret = __Internal.GetShadowBoxDistance((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetShadowBoxDistance((__Instance + __PointerAdjustment), __arg0);
            }
        }

        /// <summary>Get the shadow box, so that it can be used by other class to test if engine.entities are inside the box.</summary>
        public global::Acid.Sharp.ShadowBox ShadowBox
        {
            get
            {
                var __ret = new global::Acid.Sharp.ShadowBox.__Internal();
                __Internal.GetShadowBox((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.ShadowBox.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Shadows) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class RendererShadows : global::Acid.Sharp.IRenderer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 728)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IRenderer;

            [FieldOffset(8)]
            internal global::Acid.Sharp.GraphicsStage.__Internal m_graphicsStage;

            [FieldOffset(16)]
            internal byte m_enabled;

            [FieldOffset(24)]
            internal global::Acid.Sharp.Pipeline.__Internal m_pipeline;

            [FieldOffset(688)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformScene;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererShadows@acid@@QEAA@AEBVGraphicsStage@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr graphicsStage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0RendererShadows@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1RendererShadows@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.RendererShadows __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererShadows(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.RendererShadows __CreateInstance(global::Acid.Sharp.RendererShadows.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.RendererShadows(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.RendererShadows.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererShadows.__Internal));
            global::Acid.Sharp.RendererShadows.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private RendererShadows(global::Acid.Sharp.RendererShadows.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererShadows(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public RendererShadows(global::Acid.Sharp.GraphicsStage graphicsStage)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererShadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(graphicsStage, null))
                throw new global::System.ArgumentNullException("graphicsStage", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = graphicsStage.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererShadows");
        }

        public RendererShadows(global::Acid.Sharp.RendererShadows _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.RendererShadows.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.RendererShadows");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IRenderer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.RendererShadows.__Internal*) __Instance)->vfptr_IRenderer = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Render(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Vector4 clipPlane, global::Acid.Sharp.ICamera camera)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___RenderDelegate = (global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(clipPlane, null))
                throw new global::System.ArgumentNullException("clipPlane", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = clipPlane.__Instance;
            if (ReferenceEquals(camera, null))
                throw new global::System.ArgumentNullException("camera", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = camera.__Instance;
            ___RenderDelegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
        }

        public static explicit operator global::Acid.Sharp.RendererShadows(global::Acid.Sharp.GraphicsStage graphicsStage)
        {
            return new global::Acid.Sharp.RendererShadows(graphicsStage);
        }

        public static uint NumCascades
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?NUM_CASCADES@RendererShadows@acid@@2IB");
                return *__ptr;
            }
        }

        public static float DepthBiasConstant
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DEPTH_BIAS_CONSTANT@RendererShadows@acid@@2MB");
                return *__ptr;
            }
        }

        public static float DepthBiasSlope
        {
            get
            {
                var __ptr = (float*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?DEPTH_BIAS_SLOPE@RendererShadows@acid@@2MB");
                return *__ptr;
            }
        }

        #region Virtual table interop

        // void Render(const CommandBuffer &commandBuffer, const Vector4 &clipPlane, const ICamera &camera) override
        private static global::Delegates.Action_IntPtr_IntPtr_IntPtr_IntPtr _RenderDelegateInstance;

        private static void _RenderDelegateHook(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr clipPlane, global::System.IntPtr camera)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.RendererShadows) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.CommandBuffer __result0;
            if (commandBuffer == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.CommandBuffer.NativeToManagedMap.ContainsKey(commandBuffer))
                __result0 = (global::Acid.Sharp.CommandBuffer) global::Acid.Sharp.CommandBuffer.NativeToManagedMap[commandBuffer];
            else __result0 = global::Acid.Sharp.CommandBuffer.__CreateInstance(commandBuffer);
            global::Acid.Sharp.Vector4 __result1;
            if (clipPlane == IntPtr.Zero) __result1 = null;
            else if (global::Acid.Sharp.Vector4.NativeToManagedMap.ContainsKey(clipPlane))
                __result1 = (global::Acid.Sharp.Vector4) global::Acid.Sharp.Vector4.NativeToManagedMap[clipPlane];
            else __result1 = global::Acid.Sharp.Vector4.__CreateInstance(clipPlane);
            global::Acid.Sharp.ICamera __result2;
            if (camera == IntPtr.Zero) __result2 = null;
            else if (global::Acid.Sharp.ICamera.NativeToManagedMap.ContainsKey(camera))
                __result2 = (global::Acid.Sharp.ICamera) global::Acid.Sharp.ICamera.NativeToManagedMap[camera];
            else __result2 = global::Acid.Sharp.ICamera.__CreateInstance(camera);
            __target.Render(__result0, __result1, __result2);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RenderDelegateInstance += _RenderDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RenderDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Class used to render a GameObject as a shadow.</summary>
    public unsafe partial class ShadowRender : global::Acid.Sharp.IComponent, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Acid.Sharp.DescriptorsHandler.__Internal m_descriptorSet;

            [FieldOffset(72)]
            internal global::Acid.Sharp.UniformHandler.__Internal m_uniformObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowRender@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ShadowRender@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ShadowRender@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CmdRender@ShadowRender@acid@@QEAA_NAEBVCommandBuffer@2@AEBVPipeline@2@AEAVUniformHandler@2@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CmdRender(global::System.IntPtr instance, global::System.IntPtr commandBuffer, global::System.IntPtr pipeline, global::System.IntPtr uniformScene);
        }

        internal static new global::Acid.Sharp.ShadowRender __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ShadowRender(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ShadowRender __CreateInstance(global::Acid.Sharp.ShadowRender.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ShadowRender(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ShadowRender.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShadowRender.__Internal));
            global::Acid.Sharp.ShadowRender.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ShadowRender(global::Acid.Sharp.ShadowRender.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ShadowRender(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ShadowRender()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShadowRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.ShadowRender");
        }

        public ShadowRender(global::Acid.Sharp.ShadowRender _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ShadowRender.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.ShadowRender");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.ShadowRender.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            base.Start();
        }

        public override void Update()
        {
            base.Update();
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            base.Decode(metadata);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            base.Encode(metadata);
        }

        public bool CmdRender(global::Acid.Sharp.CommandBuffer commandBuffer, global::Acid.Sharp.Pipeline pipeline, global::Acid.Sharp.UniformHandler uniformScene)
        {
            if (ReferenceEquals(commandBuffer, null))
                throw new global::System.ArgumentNullException("commandBuffer", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = commandBuffer.__Instance;
            if (ReferenceEquals(pipeline, null))
                throw new global::System.ArgumentNullException("pipeline", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = pipeline.__Instance;
            if (ReferenceEquals(uniformScene, null))
                throw new global::System.ArgumentNullException("uniformScene", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = uniformScene.__Instance;
            var __ret = __Internal.CmdRender((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            return __ret;
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.ShadowRender) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    /// <summary>Class that represents a skybox material shader.</summary>
    public unsafe partial class MaterialSkybox : global::Acid.Sharp.IMaterial, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IComponent;

            [FieldOffset(8)]
            internal global::System.IntPtr m_gameObject;

            [FieldOffset(16)]
            internal byte m_started;

            [FieldOffset(17)]
            internal byte m_enabled;

            [FieldOffset(18)]
            internal byte m_removed;

            [FieldOffset(24)]
            internal global::Std.SharedPtr.__Internal m_cubemap;

            [FieldOffset(40)]
            internal global::Acid.Sharp.Colour.__Internal m_skyColour;

            [FieldOffset(56)]
            internal float m_blend;

            [FieldOffset(60)]
            internal global::Acid.Sharp.Colour.__Internal m_fogColour;

            [FieldOffset(76)]
            internal global::Acid.Sharp.Vector2.__Internal m_fogLimits;

            [FieldOffset(88)]
            internal global::Std.SharedPtr.__Internal m_material;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0MaterialSkybox@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1MaterialSkybox@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSkyColour@MaterialSkybox@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetSkyColour(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetSkyColour@MaterialSkybox@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetSkyColour(global::System.IntPtr instance, global::System.IntPtr skyColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetBlend@MaterialSkybox@acid@@QEBAMXZ")]
            internal static extern float GetBlend(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetBlend@MaterialSkybox@acid@@QEAAXAEBM@Z")]
            internal static extern void SetBlend(global::System.IntPtr instance, float* blend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFogColour@MaterialSkybox@acid@@QEBA?AVColour@2@XZ")]
            internal static extern void GetFogColour(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFogColour@MaterialSkybox@acid@@QEAAXAEBVColour@2@@Z")]
            internal static extern void SetFogColour(global::System.IntPtr instance, global::System.IntPtr fogColour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetFogLimits@MaterialSkybox@acid@@QEBA?AVVector2@2@XZ")]
            internal static extern void GetFogLimits(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetFogLimits@MaterialSkybox@acid@@QEAAXAEBVVector2@2@@Z")]
            internal static extern void SetFogLimits(global::System.IntPtr instance, global::System.IntPtr fogLimits);
        }

        internal static new global::Acid.Sharp.MaterialSkybox __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MaterialSkybox(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.MaterialSkybox __CreateInstance(global::Acid.Sharp.MaterialSkybox.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.MaterialSkybox(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.MaterialSkybox.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MaterialSkybox.__Internal));
            global::Acid.Sharp.MaterialSkybox.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MaterialSkybox(global::Acid.Sharp.MaterialSkybox.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MaterialSkybox(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MaterialSkybox(global::Acid.Sharp.MaterialSkybox _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.MaterialSkybox.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.MaterialSkybox");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IComponent __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.MaterialSkybox.__Internal*) __Instance)->vfptr_IComponent = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Start()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___StartDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___StartDelegate((__Instance + __PointerAdjustment));
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        public override void Decode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___DecodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___DecodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Encode(global::Acid.Sharp.Metadata metadata)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___EncodeDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(metadata, null))
                throw new global::System.ArgumentNullException("metadata", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = metadata.__Instance;
            ___EncodeDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushUniforms(global::Acid.Sharp.UniformHandler uniformObject)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___PushUniformsDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(uniformObject, null))
                throw new global::System.ArgumentNullException("uniformObject", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = uniformObject.__Instance;
            ___PushUniformsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void PushDescriptors(global::Acid.Sharp.DescriptorsHandler descriptorSet)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___PushDescriptorsDelegate = (global::Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(descriptorSet, null))
                throw new global::System.ArgumentNullException("descriptorSet", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = descriptorSet.__Instance;
            ___PushDescriptorsDelegate((__Instance + __PointerAdjustment), __arg0);
        }

        public global::Acid.Sharp.Colour SkyColour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetSkyColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetSkyColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Blend
        {
            get
            {
                var __ret = __Internal.GetBlend((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetBlend((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Colour FogColour
        {
            get
            {
                var __ret = new global::Acid.Sharp.Colour.__Internal();
                __Internal.GetFogColour((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Colour.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetFogColour((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::Acid.Sharp.Vector2 FogLimits
        {
            get
            {
                var __ret = new global::Acid.Sharp.Vector2.__Internal();
                __Internal.GetFogLimits((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::Acid.Sharp.Vector2.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetFogLimits((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void Start() override
        private static global::Delegates.Action_IntPtr _StartDelegateInstance;

        private static void _StartDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Start();
        }

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        // void Decode(const Metadata &metadata) override
        private static global::Delegates.Action_IntPtr_IntPtr _DecodeDelegateInstance;

        private static void _DecodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Decode(__result0);
        }

        // void Encode(Metadata &metadata) const override
        private static global::Delegates.Action_IntPtr_IntPtr _EncodeDelegateInstance;

        private static void _EncodeDelegateHook(global::System.IntPtr instance, global::System.IntPtr metadata)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Metadata __result0;
            if (metadata == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Metadata.NativeToManagedMap.ContainsKey(metadata))
                __result0 = (global::Acid.Sharp.Metadata) global::Acid.Sharp.Metadata.NativeToManagedMap[metadata];
            else __result0 = global::Acid.Sharp.Metadata.__CreateInstance(metadata);
            __target.Encode(__result0);
        }

        // void PushUniforms(UniformHandler &uniformObject) override
        private static global::Delegates.Action_IntPtr_IntPtr _PushUniformsDelegateInstance;

        private static void _PushUniformsDelegateHook(global::System.IntPtr instance, global::System.IntPtr uniformObject)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.UniformHandler __result0;
            if (uniformObject == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.UniformHandler.NativeToManagedMap.ContainsKey(uniformObject))
                __result0 = (global::Acid.Sharp.UniformHandler) global::Acid.Sharp.UniformHandler.NativeToManagedMap[uniformObject];
            else __result0 = global::Acid.Sharp.UniformHandler.__CreateInstance(uniformObject);
            __target.PushUniforms(__result0);
        }

        // void PushDescriptors(DescriptorsHandler &descriptorSet) override
        private static global::Delegates.Action_IntPtr_IntPtr _PushDescriptorsDelegateInstance;

        private static void _PushDescriptorsDelegateHook(global::System.IntPtr instance, global::System.IntPtr descriptorSet)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.MaterialSkybox) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.DescriptorsHandler __result0;
            if (descriptorSet == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap.ContainsKey(descriptorSet))
                __result0 = (global::Acid.Sharp.DescriptorsHandler) global::Acid.Sharp.DescriptorsHandler.NativeToManagedMap[descriptorSet];
            else __result0 = global::Acid.Sharp.DescriptorsHandler.__CreateInstance(descriptorSet);
            __target.PushDescriptors(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _StartDelegateInstance += _StartDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_StartDelegateInstance).ToPointer();
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
                _DecodeDelegateInstance += _DecodeDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_DecodeDelegateInstance).ToPointer();
                _EncodeDelegateInstance += _EncodeDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_EncodeDelegateInstance).ToPointer();
                _PushUniformsDelegateInstance += _PushUniformsDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_PushUniformsDelegateInstance).ToPointer();
                _PushDescriptorsDelegateInstance += _PushDescriptorsDelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_PushDescriptorsDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
                *(void**) (vfptr0 + 24) = _Thunks[2];
                *(void**) (vfptr0 + 32) = _Thunks[3];
                *(void**) (vfptr0 + 40) = _Thunks[4];
                *(void**) (vfptr0 + 48) = _Thunks[5];
                *(void**) (vfptr0 + 56) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 56);
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class Thread : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 216)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Thread.__Internal m_worker;

            [FieldOffset(16)]
            internal global::Std.Queue.__Internalc__N_std_S_queue____N_std_S_function__Fv_____N_std_S_deque__S0____N_std_S_allocator__S0_ m_jobQueue;

            [FieldOffset(56)]
            internal global::Std.Mutex.__Internal m_queueMutex;

            [FieldOffset(136)]
            internal global::Std.ConditionVariable.__Internal m_condition;

            [FieldOffset(208)]
            internal byte m_destroying;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Thread@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Thread@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Thread@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Wait@Thread@acid@@QEAAXXZ")]
            internal static extern void Wait(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Thread> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.Thread>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.Thread __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Thread(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Thread __CreateInstance(global::Acid.Sharp.Thread.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Thread(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Thread.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Thread.__Internal));
            global::Acid.Sharp.Thread.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Thread(global::Acid.Sharp.Thread.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Thread(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Thread()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Thread.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Thread(global::Acid.Sharp.Thread _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Thread.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.Thread __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Waits until all jobs have been finished.</summary>
        public void Wait()
        {
            __Internal.Wait((__Instance + __PointerAdjustment));
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A pool of threads.</summary>
    public unsafe partial class ThreadPool : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_Thread___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_threads;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ThreadPool@acid@@QEAA@AEBI@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint* threadCount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ThreadPool@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1ThreadPool@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Wait@ThreadPool@acid@@QEAAXXZ")]
            internal static extern void Wait(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ThreadPool> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.ThreadPool>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.ThreadPool __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ThreadPool(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.ThreadPool __CreateInstance(global::Acid.Sharp.ThreadPool.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.ThreadPool(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.ThreadPool.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ThreadPool.__Internal));
            global::Acid.Sharp.ThreadPool.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ThreadPool(global::Acid.Sharp.ThreadPool.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ThreadPool(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ThreadPool(uint threadCount)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ThreadPool.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = &threadCount;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public ThreadPool(global::Acid.Sharp.ThreadPool _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.ThreadPool.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.ThreadPool __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Waits until all threads are finished.</summary>
        public void Wait()
        {
            __Internal.Wait((__Instance + __PointerAdjustment));
        }

        public static explicit operator global::Acid.Sharp.ThreadPool(uint threadCount)
        {
            return new global::Acid.Sharp.ThreadPool(ref *threadCount);
        }

        public static uint HardwareConcurrency
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("Acid", "?HARDWARE_CONCURRENCY@ThreadPool@acid@@2IB");
                return *__ptr;
            }
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class UiInputButton : global::Acid.Sharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 376)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [FieldOffset(256)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Text___N_std_S_default_delete__S0_ m_text;

            [FieldOffset(264)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Gui___N_std_S_default_delete__S0_ m_background;

            [FieldOffset(272)]
            internal global::Acid.Sharp.Sound.__Internal m_soundClick;

            [FieldOffset(368)]
            internal byte m_mouseOver;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputButton@acid@@QEAA@PEAVUiObject@1@AEBVVector2@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputButton@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiInputButton@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetText@UiInputButton@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetText(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetText@UiInputButton@acid@@QEBAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetText(global::System.IntPtr instance, global::System.IntPtr @string);
        }

        internal static new global::Acid.Sharp.UiInputButton __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputButton(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiInputButton __CreateInstance(global::Acid.Sharp.UiInputButton.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputButton(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiInputButton.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputButton.__Internal));
            global::Acid.Sharp.UiInputButton.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputButton(global::Acid.Sharp.UiInputButton.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputButton(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiInputButton(global::Acid.Sharp.UiObject parent, global::Acid.Sharp.Vector2 position, string @string)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(@string, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputButton");
        }

        public UiInputButton(global::Acid.Sharp.UiInputButton _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputButton.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputButton");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.UiInputButton.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Text
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetText((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetText((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // void UpdateObject() override
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiInputButton) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class UiInputDelay : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.Timer.__Internal m_timerDelay;

            [FieldOffset(16)]
            internal global::Acid.Sharp.Timer.__Internal m_timerRepeat;

            [FieldOffset(32)]
            internal byte m_delayOver;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputDelay@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputDelay@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Update@UiInputDelay@acid@@QEAAXAEB_N@Z")]
            internal static extern void Update(global::System.IntPtr instance, bool* keyIsDown);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?CanInput@UiInputDelay@acid@@QEAA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CanInput(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiInputDelay> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.UiInputDelay>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.UiInputDelay __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputDelay(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiInputDelay __CreateInstance(global::Acid.Sharp.UiInputDelay.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputDelay(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiInputDelay.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputDelay.__Internal));
            *(global::Acid.Sharp.UiInputDelay.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UiInputDelay(global::Acid.Sharp.UiInputDelay.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputDelay(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UiInputDelay()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputDelay.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public UiInputDelay(global::Acid.Sharp.UiInputDelay _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputDelay.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Acid.Sharp.UiInputDelay.__Internal*) __Instance) = *((global::Acid.Sharp.UiInputDelay.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiInputDelay __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Update(bool keyIsDown)
        {
            var __arg0 = &keyIsDown;
            __Internal.Update((__Instance + __PointerAdjustment), __arg0);
        }

        public bool CanInput()
        {
            var __ret = __Internal.CanInput((__Instance + __PointerAdjustment));
            return __ret;
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>A module used for that manages gui textures in a container.</summary>
    public unsafe partial class Uis : global::Acid.Sharp.IModule, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IModule;

            [FieldOffset(8)]
            internal global::Acid.Sharp.UiSelector.__Internal m_selector;

            [FieldOffset(72)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S0_ m_container;

            [FieldOffset(80)]
            internal global::Std.Vector.__Internalc__N_std_S_vector_____N_acid_S_UiObject___N_std_S_allocator__S0_ m_objects;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uis@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Uis@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1Uis@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Get@Uis@acid@@SAPEAV12@XZ")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetContainer@Uis@acid@@QEBAPEAVUiObject@2@XZ")]
            internal static extern global::System.IntPtr GetContainer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetSelector@Uis@acid@@QEAAAEAVUiSelector@2@XZ")]
            internal static extern global::System.IntPtr GetSelector(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.Uis __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Uis(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.Uis __CreateInstance(global::Acid.Sharp.Uis.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.Uis(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.Uis.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Uis.__Internal));
            global::Acid.Sharp.Uis.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Uis(global::Acid.Sharp.Uis.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Uis(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Uis()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Uis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.Uis");
        }

        public Uis(global::Acid.Sharp.Uis _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.Uis.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.Uis");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.Uis.__Internal*) __Instance)->vfptr_IModule = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void Update()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___UpdateDelegate = (global::Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr));
            ___UpdateDelegate((__Instance + __PointerAdjustment));
        }

        /// <summary>Gets this engine instance.</summary>
        public static global::Acid.Sharp.Uis Get()
        {
            var __ret = __Internal.Get();
            global::Acid.Sharp.Uis __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Uis.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::Acid.Sharp.Uis) global::Acid.Sharp.Uis.NativeToManagedMap[__ret];
            else __result0 = global::Acid.Sharp.Uis.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets the screen container.</summary>
        public global::Acid.Sharp.UiObject Container
        {
            get
            {
                var __ret = __Internal.GetContainer((__Instance + __PointerAdjustment));
                global::Acid.Sharp.UiObject __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.UiObject.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.UiObject) global::Acid.Sharp.UiObject.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.UiObject.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the main GUI selector.</summary>
        public global::Acid.Sharp.UiSelector Selector
        {
            get
            {
                var __ret = __Internal.GetSelector((__Instance + __PointerAdjustment));
                global::Acid.Sharp.UiSelector __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::Acid.Sharp.UiSelector.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::Acid.Sharp.UiSelector) global::Acid.Sharp.UiSelector.NativeToManagedMap[__ret];
                else __result0 = global::Acid.Sharp.UiSelector.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // void Update() override
        private static global::Delegates.Action_IntPtr _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.Uis) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Update();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe abstract partial class IUiGrabber : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUiGrabber@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0IUiGrabber@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IUiGrabber> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Acid.Sharp.IUiGrabber>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::Acid.Sharp.IUiGrabber __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IUiGrabberInternal(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.IUiGrabber __CreateInstance(global::Acid.Sharp.IUiGrabber.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.IUiGrabberInternal(native, skipVTables);
        }

        protected IUiGrabber(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected IUiGrabber()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IUiGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.IUiGrabber");
        }

        protected IUiGrabber(global::Acid.Sharp.IUiGrabber _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IUiGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.IUiGrabber");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.IUiGrabber __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.IUiGrabber.__Internal*) __Instance)->vfptr_IUiGrabber = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract int GetCurrent(global::Acid.Sharp.Text @object);

        public abstract string GetValue(int value);

        #region Virtual table interop

        // int32_t GetCurrent(Text *object) = 0
        private static global::Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IUiGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Text __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Text.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.Text) global::Acid.Sharp.Text.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.Text.__CreateInstance(@object);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int32_t &value) = 0
        private static global::Delegates.Action_IntPtr_IntPtr_intPtr _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int* value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.IUiGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class UiGrabberJoystick : global::Acid.Sharp.IUiGrabber, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [FieldOffset(8)]
            internal global::Acid.Sharp.JoystickPort m_joystick;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberJoystick@acid@@QEAA@AEBW4JoystickPort@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::Acid.Sharp.JoystickPort* joystick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberJoystick@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::Acid.Sharp.UiGrabberJoystick __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiGrabberJoystick(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiGrabberJoystick __CreateInstance(global::Acid.Sharp.UiGrabberJoystick.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiGrabberJoystick(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiGrabberJoystick.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberJoystick.__Internal));
            global::Acid.Sharp.UiGrabberJoystick.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiGrabberJoystick(global::Acid.Sharp.UiGrabberJoystick.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiGrabberJoystick(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiGrabberJoystick(global::Acid.Sharp.JoystickPort* joystick)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), joystick);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiGrabberJoystick");
        }

        public UiGrabberJoystick(global::Acid.Sharp.UiGrabberJoystick _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberJoystick.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiGrabberJoystick");
        }

        public override int GetCurrent(global::Acid.Sharp.Text @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___GetCurrentDelegate = (global::Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetValueDelegate = (global::Delegates.Action_IntPtr_IntPtr_intPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_intPtr));
            var __arg0 = &value;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static explicit operator global::Acid.Sharp.UiGrabberJoystick(global::Acid.Sharp.JoystickPort* joystick)
        {
            return new global::Acid.Sharp.UiGrabberJoystick(joystick);
        }

        #region Virtual table interop

        // int32_t GetCurrent(Text *object) override
        private static global::Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiGrabberJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Text __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Text.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.Text) global::Acid.Sharp.Text.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.Text.__CreateInstance(@object);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int32_t &value) override
        private static global::Delegates.Action_IntPtr_IntPtr_intPtr _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int* value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiGrabberJoystick) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class UiGrabberKeyboard : global::Acid.Sharp.IUiGrabber, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberKeyboard@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberKeyboard@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::Acid.Sharp.UiGrabberKeyboard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiGrabberKeyboard(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiGrabberKeyboard __CreateInstance(global::Acid.Sharp.UiGrabberKeyboard.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiGrabberKeyboard(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiGrabberKeyboard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberKeyboard.__Internal));
            global::Acid.Sharp.UiGrabberKeyboard.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiGrabberKeyboard(global::Acid.Sharp.UiGrabberKeyboard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiGrabberKeyboard(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiGrabberKeyboard()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberKeyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.UiGrabberKeyboard");
        }

        public UiGrabberKeyboard(global::Acid.Sharp.UiGrabberKeyboard _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberKeyboard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiGrabberKeyboard");
        }

        public override int GetCurrent(global::Acid.Sharp.Text @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___GetCurrentDelegate = (global::Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetValueDelegate = (global::Delegates.Action_IntPtr_IntPtr_intPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_intPtr));
            var __arg0 = &value;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        #region Virtual table interop

        // int32_t GetCurrent(Text *object) override
        private static global::Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiGrabberKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Text __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Text.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.Text) global::Acid.Sharp.Text.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.Text.__CreateInstance(@object);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int32_t &value) override
        private static global::Delegates.Action_IntPtr_IntPtr_intPtr _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int* value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiGrabberKeyboard) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class UiGrabberMouse : global::Acid.Sharp.IUiGrabber, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_IUiGrabber;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberMouse@acid@@QEAA@XZ")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiGrabberMouse@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::Acid.Sharp.UiGrabberMouse __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiGrabberMouse(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiGrabberMouse __CreateInstance(global::Acid.Sharp.UiGrabberMouse.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiGrabberMouse(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiGrabberMouse.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberMouse.__Internal));
            global::Acid.Sharp.UiGrabberMouse.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiGrabberMouse(global::Acid.Sharp.UiGrabberMouse.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiGrabberMouse(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiGrabberMouse()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "Acid.Sharp.UiGrabberMouse");
        }

        public UiGrabberMouse(global::Acid.Sharp.UiGrabberMouse _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiGrabberMouse.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiGrabberMouse");
        }

        public override int GetCurrent(global::Acid.Sharp.Text @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___GetCurrentDelegate = (global::Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetValueDelegate = (global::Delegates.Action_IntPtr_IntPtr_intPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_intPtr));
            var __arg0 = &value;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        #region Virtual table interop

        // int32_t GetCurrent(Text *object) override
        private static global::Delegates.Func_int_IntPtr_IntPtr _GetCurrentDelegateInstance;

        private static int _GetCurrentDelegateHook(global::System.IntPtr instance, global::System.IntPtr @object)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiGrabberMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::Acid.Sharp.Text __result0;
            if (@object == IntPtr.Zero) __result0 = null;
            else if (global::Acid.Sharp.Text.NativeToManagedMap.ContainsKey(@object))
                __result0 = (global::Acid.Sharp.Text) global::Acid.Sharp.Text.NativeToManagedMap[@object];
            else __result0 = global::Acid.Sharp.Text.__CreateInstance(@object);
            var __ret = __target.GetCurrent(__result0);
            return __ret;
        }

        // std::string GetValue(const int32_t &value) override
        private static global::Delegates.Action_IntPtr_IntPtr_intPtr _GetValueDelegateInstance;

        private static void _GetValueDelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, int* value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiGrabberMouse) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetValue(value);
            var __allocator0 = new global::Std.Allocator<char>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(__ret, __allocator0);
            *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) @return = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _GetCurrentDelegateInstance += _GetCurrentDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetCurrentDelegateInstance).ToPointer();
                _GetValueDelegateInstance += _GetValueDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetValueDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
                *(void**) (vfptr0 + 16) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class UiInputGrabber : global::Acid.Sharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 488)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [FieldOffset(256)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Text___N_std_S_default_delete__S0_ m_text;

            [FieldOffset(264)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Gui___N_std_S_default_delete__S0_ m_background;

            [FieldOffset(272)]
            internal global::Acid.Sharp.Sound.__Internal m_soundClick;

            [FieldOffset(368)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IUiGrabber___N_std_S_default_delete__S0_ m_grabber;

            [FieldOffset(376)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_prefix;

            [FieldOffset(408)]
            internal int m_value;

            [FieldOffset(412)]
            internal int m_lastKey;

            [FieldOffset(416)]
            internal byte m_selected;

            [FieldOffset(417)]
            internal byte m_mouseOver;

            [FieldOffset(424)]
            internal global::Std.Function.__Internal m_actionChange;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputGrabber@acid@@QEAA@PEAVUiObject@1@AEBVVector3@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBHPEAVIUiGrabber@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr prefix, int* value, global::System.IntPtr grabber);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputGrabber@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiInputGrabber@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPrefix@UiInputGrabber@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetPrefix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPrefix@UiInputGrabber@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetPrefix(global::System.IntPtr instance, global::System.IntPtr prefix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@UiInputGrabber@acid@@QEBAHXZ")]
            internal static extern int GetValue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@UiInputGrabber@acid@@QEAAXAEBH@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, int* value);
        }

        internal static new global::Acid.Sharp.UiInputGrabber __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputGrabber(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiInputGrabber __CreateInstance(global::Acid.Sharp.UiInputGrabber.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputGrabber(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiInputGrabber.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputGrabber.__Internal));
            global::Acid.Sharp.UiInputGrabber.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputGrabber(global::Acid.Sharp.UiInputGrabber.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputGrabber(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiInputGrabber(global::Acid.Sharp.UiObject parent, global::Acid.Sharp.Vector3 position, string prefix, int value, global::Acid.Sharp.IUiGrabber grabber)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(prefix, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __arg3 = &value;
            var __arg4 = ReferenceEquals(grabber, null) ? global::System.IntPtr.Zero : grabber.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputGrabber");
        }

        public UiInputGrabber(global::Acid.Sharp.UiInputGrabber _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputGrabber.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputGrabber");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.UiInputGrabber.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Prefix
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetPrefix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetPrefix((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public int Value
        {
            get
            {
                var __ret = __Internal.GetValue((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void UpdateObject() override
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiInputGrabber) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IUiGrabberInternal : global::Acid.Sharp.IUiGrabber, IDisposable
    {
        private static void* __CopyValue(global::Acid.Sharp.IUiGrabber.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.IUiGrabber.__Internal));
            *(global::Acid.Sharp.IUiGrabber.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal IUiGrabberInternal(global::Acid.Sharp.IUiGrabber.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal IUiGrabberInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int GetCurrent(global::Acid.Sharp.Text @object)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 8);
            var ___GetCurrentDelegate = (global::Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Func_int_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __ret = ___GetCurrentDelegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public override string GetValue(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 8);
            var ___GetValueDelegate = (global::Delegates.Action_IntPtr_IntPtr_intPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::Delegates.Action_IntPtr_IntPtr_intPtr));
            var __arg0 = &value;
            var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
            ___GetValueDelegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }
    }
}

namespace Acid.Sharp
{
    public unsafe partial class UiInputSlider : global::Acid.Sharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 512)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [FieldOffset(256)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Text___N_std_S_default_delete__S0_ m_text;

            [FieldOffset(264)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Gui___N_std_S_default_delete__S0_ m_background;

            [FieldOffset(272)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Gui___N_std_S_default_delete__S0_ m_slider;

            [FieldOffset(280)]
            internal global::Acid.Sharp.Sound.__Internal m_soundClick;

            [FieldOffset(376)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_prefix;

            [FieldOffset(408)]
            internal int m_roundTo;

            [FieldOffset(412)]
            internal byte m_updating;

            [FieldOffset(416)]
            internal float m_progressMin;

            [FieldOffset(420)]
            internal float m_progressMax;

            [FieldOffset(424)]
            internal float m_value;

            [FieldOffset(428)]
            internal byte m_mouseOver;

            [FieldOffset(429)]
            internal byte m_hasChange;

            [FieldOffset(432)]
            internal global::Acid.Sharp.Timer.__Internal m_timerChange;

            [FieldOffset(448)]
            internal global::Std.Function.__Internal m_actionChange;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputSlider@acid@@QEAA@PEAVUiObject@1@AEBVVector3@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBHAEBM44@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr prefix, int* roundTo, float* progressMin, float* progressMax, float* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputSlider@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiInputSlider@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPrefix@UiInputSlider@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetPrefix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPrefix@UiInputSlider@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetPrefix(global::System.IntPtr instance, global::System.IntPtr prefix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProgressMin@UiInputSlider@acid@@QEBAMXZ")]
            internal static extern float GetProgressMin(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetProgressMin@UiInputSlider@acid@@QEAAXAEBM@Z")]
            internal static extern void SetProgressMin(global::System.IntPtr instance, float* progressMin);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetProgressMax@UiInputSlider@acid@@QEBAMXZ")]
            internal static extern float GetProgressMax(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetProgressMax@UiInputSlider@acid@@QEAAXAEBM@Z")]
            internal static extern void SetProgressMax(global::System.IntPtr instance, float* progressMax);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@UiInputSlider@acid@@QEBAMXZ")]
            internal static extern float GetValue(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@UiInputSlider@acid@@QEAAXAEBM@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, float* value);
        }

        internal static new global::Acid.Sharp.UiInputSlider __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputSlider(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiInputSlider __CreateInstance(global::Acid.Sharp.UiInputSlider.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputSlider(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiInputSlider.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputSlider.__Internal));
            global::Acid.Sharp.UiInputSlider.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputSlider(global::Acid.Sharp.UiInputSlider.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputSlider(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiInputSlider(global::Acid.Sharp.UiObject parent, global::Acid.Sharp.Vector3 position, string prefix, int roundTo, float progressMin, float progressMax, float value)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputSlider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(prefix, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __arg3 = &roundTo;
            var __arg4 = &progressMin;
            var __arg5 = &progressMax;
            var __arg6 = &value;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputSlider");
        }

        public UiInputSlider(global::Acid.Sharp.UiInputSlider _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputSlider.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputSlider");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.UiInputSlider.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Prefix
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetPrefix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetPrefix((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public float ProgressMin
        {
            get
            {
                var __ret = __Internal.GetProgressMin((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetProgressMin((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float ProgressMax
        {
            get
            {
                var __ret = __Internal.GetProgressMax((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetProgressMax((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public float Value
        {
            get
            {
                var __ret = __Internal.GetValue((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void UpdateObject() override
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiInputSlider) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class UiInputText : global::Acid.Sharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 552)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [FieldOffset(256)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Text___N_std_S_default_delete__S0_ m_text;

            [FieldOffset(264)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Gui___N_std_S_default_delete__S0_ m_background;

            [FieldOffset(272)]
            internal global::Acid.Sharp.Sound.__Internal m_soundClick;

            [FieldOffset(368)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_prefix;

            [FieldOffset(400)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value;

            [FieldOffset(432)]
            internal int m_maxLength;

            [FieldOffset(440)]
            internal global::Acid.Sharp.UiInputDelay.__Internal m_inputDelay;

            [FieldOffset(480)]
            internal int m_lastKey;

            [FieldOffset(484)]
            internal byte m_selected;

            [FieldOffset(485)]
            internal byte m_mouseOver;

            [FieldOffset(488)]
            internal global::Std.Function.__Internal m_actionChange;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputText@acid@@QEAA@PEAVUiObject@1@AEBVVector3@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2AEBH@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent, global::System.IntPtr position, global::System.IntPtr prefix, global::System.IntPtr value, int* maxLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiInputText@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiInputText@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetPrefix@UiInputText@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetPrefix(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetPrefix@UiInputText@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetPrefix(global::System.IntPtr instance, global::System.IntPtr prefix);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetValue@UiInputText@acid@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern void GetValue(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetValue@UiInputText@acid@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern void SetValue(global::System.IntPtr instance, global::System.IntPtr value);
        }

        internal static new global::Acid.Sharp.UiInputText __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputText(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiInputText __CreateInstance(global::Acid.Sharp.UiInputText.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiInputText(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiInputText.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputText.__Internal));
            global::Acid.Sharp.UiInputText.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiInputText(global::Acid.Sharp.UiInputText.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiInputText(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiInputText(global::Acid.Sharp.UiObject parent, global::Acid.Sharp.Vector3 position, string prefix, string value, int maxLength)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputText.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            if (ReferenceEquals(position, null))
                throw new global::System.ArgumentNullException("position", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = position.__Instance;
            var __allocator2 = new global::Std.Allocator<char>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(prefix, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __allocator3 = new global::Std.Allocator<char>();
            var __basicString3 = global::Std.BasicStringExtensions.BasicString(value, __allocator3);
            var __arg3 = __basicString3.__Instance;
            var __arg4 = &maxLength;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            __basicString3.Dispose(false);
            __allocator3.Dispose();
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputText");
        }

        public UiInputText(global::Acid.Sharp.UiInputText _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiInputText.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiInputText");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.UiInputText.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public string Prefix
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetPrefix((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetPrefix((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        public string Value
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetValue((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator<char>();
                var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetValue((__Instance + __PointerAdjustment), __arg0);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
            }
        }

        #region Virtual table interop

        // void UpdateObject() override
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiInputText) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
    public unsafe partial class UiStartLogo : global::Acid.Sharp.UiObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 288)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vfptr_UiObject;

            [FieldOffset(8)]
            internal global::System.IntPtr m_parent;

            [FieldOffset(16)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_UiObject___N_std_S_default_delete__S1____N_std_S_allocator__S0_ m_children;

            [FieldOffset(40)]
            internal byte m_visible;

            [FieldOffset(44)]
            internal global::Acid.Sharp.UiBound.__Internal m_rectangle;

            [FieldOffset(72)]
            internal global::Acid.Sharp.Vector4.__Internal m_scissor;

            [FieldOffset(88)]
            internal global::Acid.Sharp.Vector2.__Internal m_positionOffset;

            [FieldOffset(96)]
            internal global::Acid.Sharp.Vector4.__Internal m_screenTransform;

            [FieldOffset(112)]
            internal byte m_lockRotation;

            [FieldOffset(116)]
            internal global::Std.Optional.__Internal m_worldTransform;

            [FieldOffset(160)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_alphaDriver;

            [FieldOffset(168)]
            internal float m_alpha;

            [FieldOffset(176)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_IDriver___N_std_S_default_delete__S0_ m_scaleDriver;

            [FieldOffset(184)]
            internal float m_scale;

            [FieldOffset(192)]
            internal global::Std.Function.__Internal m_actionClick;

            [FieldOffset(256)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Gui___N_std_S_default_delete__S0_ m_guiBackground;

            [FieldOffset(264)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Gui___N_std_S_default_delete__S0_ m_guiLogoAcid;

            [FieldOffset(272)]
            internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_acid_S_Text___N_std_S_default_delete__S0_ m_textCopyright;

            [FieldOffset(280)]
            internal byte m_starting;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiStartLogo@acid@@QEAA@PEAVUiObject@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0UiStartLogo@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1UiStartLogo@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?IsStarting@UiStartLogo@acid@@QEBA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetStarting(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?SetStarting@UiStartLogo@acid@@QEAAXAEB_N@Z")]
            internal static extern void SetStarting(global::System.IntPtr instance, bool* starting);
        }

        internal static new global::Acid.Sharp.UiStartLogo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiStartLogo(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.UiStartLogo __CreateInstance(global::Acid.Sharp.UiStartLogo.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.UiStartLogo(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.UiStartLogo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiStartLogo.__Internal));
            global::Acid.Sharp.UiStartLogo.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UiStartLogo(global::Acid.Sharp.UiStartLogo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UiStartLogo(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public UiStartLogo(global::Acid.Sharp.UiObject parent)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiStartLogo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(parent, null) ? global::System.IntPtr.Zero : parent.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiStartLogo");
        }

        public UiStartLogo(global::Acid.Sharp.UiStartLogo _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.UiStartLogo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "Acid.Sharp.UiStartLogo");
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.UiObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::Acid.Sharp.UiStartLogo.__Internal*) __Instance)->vfptr_UiObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public override void UpdateObject()
        {
            base.UpdateObject();
        }

        public bool Starting
        {
            get
            {
                var __ret = __Internal.GetStarting((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __arg0 = &value;
                __Internal.SetStarting((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void UpdateObject() override
        private static global::Delegates.Action_IntPtr _UpdateObjectDelegateInstance;

        private static void _UpdateObjectDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::Acid.Sharp.UiStartLogo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.UpdateObject();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _UpdateObjectDelegateInstance += _UpdateObjectDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_UpdateObjectDelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 8) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }
}

namespace Acid.Sharp
{
}

namespace Acid.Sharp
{
    /// <summary>Specialization of FTP response returning a directory.</summary>
    public unsafe partial class FtpResponseDirectory : global::Acid.Sharp.FtpResponse, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.FtpResponseStatus m_status;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_message;

            [FieldOffset(40)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_directory;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpResponseDirectory@acid@@QEAA@AEBVFtpResponse@1@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr response);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpResponseDirectory@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FtpResponseDirectory@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetDirectory@FtpResponseDirectory@acid@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern global::System.IntPtr GetDirectory(global::System.IntPtr instance);
        }

        internal static new global::Acid.Sharp.FtpResponseDirectory __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpResponseDirectory(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FtpResponseDirectory __CreateInstance(global::Acid.Sharp.FtpResponseDirectory.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpResponseDirectory(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FtpResponseDirectory.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponseDirectory.__Internal));
            global::Acid.Sharp.FtpResponseDirectory.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FtpResponseDirectory(global::Acid.Sharp.FtpResponseDirectory.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FtpResponseDirectory(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Default constructor.</summary>
        /// <param name="response">Source response.</param>
        public FtpResponseDirectory(global::Acid.Sharp.FtpResponse response)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponseDirectory.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(response, null))
                throw new global::System.ArgumentNullException("response", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = response.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0);
        }

        public FtpResponseDirectory(global::Acid.Sharp.FtpResponseDirectory _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponseDirectory.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FtpResponse __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Get the directory returned in the response.</summary>
        public string Directory
        {
            get
            {
                var __ret = __Internal.GetDirectory((__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<char, global::Std.CharTraits<char>, global::Std.Allocator<char>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace Acid.Sharp
{
    /// <summary>Specialization of FTP response returning a filename listing.</summary>
    public unsafe partial class FtpResponseListing : global::Acid.Sharp.FtpResponse, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.FtpResponseStatus m_status;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_message;

            [FieldOffset(40)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_listing;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpResponseListing@acid@@QEAA@AEBVFtpResponse@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
            internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr response, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0FtpResponseListing@acid@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Acid", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??1FtpResponseListing@acid@@QEAA@XZ")]
            internal static extern void dtor(global::System.IntPtr instance, int delete);
        }

        internal static new global::Acid.Sharp.FtpResponseListing __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpResponseListing(native.ToPointer(), skipVTables);
        }

        internal static global::Acid.Sharp.FtpResponseListing __CreateInstance(global::Acid.Sharp.FtpResponseListing.__Internal native, bool skipVTables = false)
        {
            return new global::Acid.Sharp.FtpResponseListing(native, skipVTables);
        }

        private static void* __CopyValue(global::Acid.Sharp.FtpResponseListing.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponseListing.__Internal));
            global::Acid.Sharp.FtpResponseListing.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private FtpResponseListing(global::Acid.Sharp.FtpResponseListing.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected FtpResponseListing(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>Default constructor.</summary>
        /// <param name="response">Source response.</param>
        /// <param name="data">Data containing the raw listing.</param>
        public FtpResponseListing(global::Acid.Sharp.FtpResponse response, string data)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponseListing.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(response, null))
                throw new global::System.ArgumentNullException("response", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = response.__Instance;
            var __allocator1 = new global::Std.Allocator<char>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(data, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        public FtpResponseListing(global::Acid.Sharp.FtpResponseListing _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Acid.Sharp.FtpResponseListing.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::Acid.Sharp.FtpResponse __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace Acid.Sharp
{
    namespace Observer
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public unsafe partial struct __Internalc__N_acid_S_Observer__p1___N_acid_S_CollisionObject
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_function__Fv_____N_acid_S_CollisionObject____N_std_S_allocator__S0_ m_subscribed;
        }
    }
}

namespace Delegates
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr(global::System.IntPtr _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr(global::System.IntPtr _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    internal unsafe delegate bool Func_bool_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    internal unsafe delegate bool Func_bool_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1, global::System.IntPtr _2);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate uint Func_uint_IntPtr(global::System.IntPtr _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_IntPtr_uintPtr(global::System.IntPtr _0, global::System.IntPtr _1, uint* _2);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    internal unsafe delegate bool Func_bool_IntPtr(global::System.IntPtr _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_floatPtr(global::System.IntPtr _0, float* _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate float Func_float_IntPtr(global::System.IntPtr _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_IntPtr_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1, global::System.IntPtr _2, global::System.IntPtr _3);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate float Func_float_IntPtr_floatPtr(global::System.IntPtr _0, float* _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_IntPtr_uintPtr_uintPtr(global::System.IntPtr _0, global::System.IntPtr _1, uint* _2, uint* _3);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr _0, int _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_ulongPtr(global::System.IntPtr _0, ulong* _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_IntPtr_ulong(global::System.IntPtr _0, global::System.IntPtr _1, ulong _2);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate int Func_int_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    internal unsafe delegate void Action_IntPtr_IntPtr_intPtr(global::System.IntPtr _0, global::System.IntPtr _1, int* _2);
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_acid_S_GraphicsStage___N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IRenderer___N_std_S_default_delete__S3____N_std_S_allocator__S2_
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.GraphicsStage.__Internal first;

            [FieldOffset(8)]
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_unique_ptr____N_acid_S_IRenderer___N_std_S_default_delete__S1____N_std_S_allocator__S0_ second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 160)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_ComponentCreate
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::Acid.Sharp.ComponentCreate.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_acid_S_IDescriptor
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::System.IntPtr second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public unsafe partial struct __Internalc__N_std_S_pair__1I___N_acid_S_FontCharacter
        {
            [FieldOffset(0)]
            internal int first;

            [FieldOffset(4)]
            internal global::Acid.Sharp.FontCharacter.__Internal second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_acid_E_SoundType_f
        {
            [FieldOffset(0)]
            internal global::Acid.Sharp.SoundType first;

            [FieldOffset(4)]
            internal float second;
        }

        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_acid_S_JointTransform
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(32)]
            internal global::Acid.Sharp.JointTransform.__Internal second;
        }
    }

}
namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IUiGrabber__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Gui__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Text__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Thread__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IScene__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_SceneStructure__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_ScenePhysics__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_SelectorJoystick__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_ICamera__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btDiscreteDynamicsWorld__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btSequentialImpulseConstraintSolver__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCollisionDispatcher__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btBroadphaseInterface__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCollisionConfiguration__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_CommandBuffer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Swapchain__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_RenderStage__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IManagerRender__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IRenderer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Force__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCollisionObject__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCollisionShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btSphereShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btHeightfieldTerrainShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCylinderShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btConvexHullShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btConeShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btCapsuleShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____S_btBoxShape__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_ISpawnParticle__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IFile__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Noise__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Pipeline__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Framebuffers__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_DepthStencil__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Renderpass__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Texture__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IAxis__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IButton__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Model__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IDriver__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_UiObject__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_DescriptorSet__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_StorageBuffer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_UniformBuffer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_ShaderProgram__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_XmlNode__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_JsonSection__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IEvent__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Animation__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Animator__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_GameObject__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IComponent__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_JointData__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_VertexAnimatedData__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IndexBuffer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_VertexBuffer__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_VertexAttribute__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_UniformBlock__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Uniform__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_IModule__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Joint__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_acid_S_Metadata__S1__Vb1
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _Myval2;
        }
    }
}
